(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 67);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(3);

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("./vendor");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DOMException = __webpack_require__(39);
var ERR = DOMException;
var isApiWritable = __webpack_require__(40).isApiWritable;

exports.NAMESPACE = {
  HTML: 'http://www.w3.org/1999/xhtml',
  XML: 'http://www.w3.org/XML/1998/namespace',
  XMLNS: 'http://www.w3.org/2000/xmlns/',
  MATHML: 'http://www.w3.org/1998/Math/MathML',
  SVG: 'http://www.w3.org/2000/svg',
  XLINK: 'http://www.w3.org/1999/xlink'
};

//
// Shortcut functions for throwing errors of various types.
//
exports.IndexSizeError = function() { throw new DOMException(ERR.INDEX_SIZE_ERR); };
exports.HierarchyRequestError = function() { throw new DOMException(ERR.HIERARCHY_REQUEST_ERR); };
exports.WrongDocumentError = function() { throw new DOMException(ERR.WRONG_DOCUMENT_ERR); };
exports.InvalidCharacterError = function() { throw new DOMException(ERR.INVALID_CHARACTER_ERR); };
exports.NoModificationAllowedError = function() { throw new DOMException(ERR.NO_MODIFICATION_ALLOWED_ERR); };
exports.NotFoundError = function() { throw new DOMException(ERR.NOT_FOUND_ERR); };
exports.NotSupportedError = function() { throw new DOMException(ERR.NOT_SUPPORTED_ERR); };
exports.InvalidStateError = function() { throw new DOMException(ERR.INVALID_STATE_ERR); };
exports.SyntaxError = function() { throw new DOMException(ERR.SYNTAX_ERR); };
exports.InvalidModificationError = function() { throw new DOMException(ERR.INVALID_MODIFICATION_ERR); };
exports.NamespaceError = function() { throw new DOMException(ERR.NAMESPACE_ERR); };
exports.InvalidAccessError = function() { throw new DOMException(ERR.INVALID_ACCESS_ERR); };
exports.TypeMismatchError = function() { throw new DOMException(ERR.TYPE_MISMATCH_ERR); };
exports.SecurityError = function() { throw new DOMException(ERR.SECURITY_ERR); };
exports.NetworkError = function() { throw new DOMException(ERR.NETWORK_ERR); };
exports.AbortError = function() { throw new DOMException(ERR.ABORT_ERR); };
exports.UrlMismatchError = function() { throw new DOMException(ERR.URL_MISMATCH_ERR); };
exports.QuotaExceededError = function() { throw new DOMException(ERR.QUOTA_EXCEEDED_ERR); };
exports.TimeoutError = function() { throw new DOMException(ERR.TIMEOUT_ERR); };
exports.InvalidNodeTypeError = function() { throw new DOMException(ERR.INVALID_NODE_TYPE_ERR); };
exports.DataCloneError = function() { throw new DOMException(ERR.DATA_CLONE_ERR); };

exports.nyi = function() {
  throw new Error("NotYetImplemented");
};

exports.assert = function(expr, msg) {
  if (!expr) {
    throw new Error("Assertion failed: " + (msg || "") + "\n" + new Error().stack);
  }
};

exports.expose = function(src, c) {
  for (var n in src) {
    Object.defineProperty(c.prototype, n, { value: src[n], writable: isApiWritable });
  }
};

exports.merge = function(a, b) {
  for (var n in b) {
    a[n] = b[n];
  }
};

// Compare two nodes based on their document order. This function is intended
// to be passed to sort(). Assumes that the array being sorted does not
// contain duplicates.  And that all nodes are connected and comparable.
// Clever code by ppk via jeresig.
exports.documentOrder = function(n,m) {
  /* jshint bitwise: false */
  return 3 - (n.compareDocumentPosition(m) & 6);
};

exports.toASCIILowerCase = function(s) {
  return s.replace(/[A-Z]+/g, function(t) { return t.toLowerCase(); });
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Node;

var EventTarget = __webpack_require__(36);
var utils = __webpack_require__(2);
var NAMESPACE = utils.NAMESPACE;

// All nodes have a nodeType and an ownerDocument.
// Once inserted, they also have a parentNode.
// This is an abstract class; all nodes in a document are instances
// of a subtype, so all the properties are defined by more specific
// constructors.
function Node() {
}

var ELEMENT_NODE                = Node.ELEMENT_NODE = 1;
var ATTRIBUTE_NODE              = Node.ATTRIBUTE_NODE = 2;
var TEXT_NODE                   = Node.TEXT_NODE = 3;
var CDATA_SECTION_NODE          = Node.CDATA_SECTION_NODE = 4;
var ENTITY_REFERENCE_NODE       = Node.ENTITY_REFERENCE_NODE = 5;
var ENTITY_NODE                 = Node.ENTITY_NODE = 6;
var PROCESSING_INSTRUCTION_NODE = Node.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = Node.COMMENT_NODE = 8;
var DOCUMENT_NODE               = Node.DOCUMENT_NODE = 9;
var DOCUMENT_TYPE_NODE          = Node.DOCUMENT_TYPE_NODE = 10;
var DOCUMENT_FRAGMENT_NODE      = Node.DOCUMENT_FRAGMENT_NODE = 11;
var NOTATION_NODE               = Node.NOTATION_NODE = 12;

var DOCUMENT_POSITION_DISCONNECTED            = Node.DOCUMENT_POSITION_DISCONNECTED = 0x01;
var DOCUMENT_POSITION_PRECEDING               = Node.DOCUMENT_POSITION_PRECEDING = 0x02;
var DOCUMENT_POSITION_FOLLOWING               = Node.DOCUMENT_POSITION_FOLLOWING = 0x04;
var DOCUMENT_POSITION_CONTAINS                = Node.DOCUMENT_POSITION_CONTAINS = 0x08;
var DOCUMENT_POSITION_CONTAINED_BY            = Node.DOCUMENT_POSITION_CONTAINED_BY = 0x10;
var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

var hasRawContent = {
  STYLE: true,
  SCRIPT: true,
  XMP: true,
  IFRAME: true,
  NOEMBED: true,
  NOFRAMES: true,
  PLAINTEXT: true
};

var emptyElements = {
  area: true,
  base: true,
  basefont: true,
  bgsound: true,
  br: true,
  col: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

var extraNewLine = {
  /* Removed in https://github.com/whatwg/html/issues/944
  pre: true,
  textarea: true,
  listing: true
  */
};

Node.prototype = Object.create(EventTarget.prototype, {

  // Node that are not inserted into the tree inherit a null parent
  parentNode: { value: null, writable: true },

  // XXX: the baseURI attribute is defined by dom core, but
  // a correct implementation of it requires HTML features, so
  // we'll come back to this later.
  baseURI: { get: utils.nyi },

  parentElement: { get: function() {
    return (this.parentNode && this.parentNode.nodeType===ELEMENT_NODE) ? this.parentNode : null;
  }},

  hasChildNodes: { value: function() {  // Overridden in leaf.js
    return this.childNodes.length > 0;
  }},

  firstChild: { get: function() {
    return this.childNodes.length === 0 ? null : this.childNodes[0];
  }},

  lastChild: { get: function() {
    return this.childNodes.length === 0 ? null : this.childNodes[this.childNodes.length-1];
  }},

  previousSibling: { get: function() {
    if (!this.parentNode) return null;
    var sibs = this.parentNode.childNodes, i = this.index;
    return i === 0 ? null : sibs[i-1];
  }},

  nextSibling: { get: function() {
    if (!this.parentNode) return null;
    var sibs = this.parentNode.childNodes, i = this.index;
    return i+1 === sibs.length ? null : sibs[i+1];
  }},


  _countChildrenOfType: { value: function(type) {
    var sum = 0, nodes = this.childNodes, length = nodes.length, i;
    for (i=0; i<length; i++) {
      if (nodes[i].nodeType === type) sum++;
    }
    return sum;
  }},

  _ensureInsertValid: { value: function _ensureInsertValid(node, child, isPreinsert) {
    var parent = this, i;
    if (!node.nodeType) throw new TypeError('not a node');
    // 1. If parent is not a Document, DocumentFragment, or Element
    // node, throw a HierarchyRequestError.
    switch (parent.nodeType) {
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
    case ELEMENT_NODE:
      break;
    default: utils.HierarchyRequestError();
    }
    // 2. If node is a host-including inclusive ancestor of parent,
    // throw a HierarchyRequestError.
    if (node.isAncestor(parent)) utils.HierarchyRequestError();
    // 3. If child is not null and its parent is not parent, then
    // throw a NotFoundError. (replaceChild omits the 'child is not null'
    // and throws a TypeError here if child is null.)
    if (child !== null || !isPreinsert) {
      if (child.parentNode !== parent) utils.NotFoundError();
    }
    // 4. If node is not a DocumentFragment, DocumentType, Element,
    // Text, ProcessingInstruction, or Comment node, throw a
    // HierarchyRequestError.
    switch (node.nodeType) {
    case DOCUMENT_FRAGMENT_NODE:
    case DOCUMENT_TYPE_NODE:
    case ELEMENT_NODE:
    case TEXT_NODE:
    case PROCESSING_INSTRUCTION_NODE:
    case COMMENT_NODE:
      break;
    default: utils.HierarchyRequestError();
    }
    // 5. If either node is a Text node and parent is a document, or
    // node is a doctype and parent is not a document, throw a
    // HierarchyRequestError.
    // 6. If parent is a document, and any of the statements below, switched
    // on node, are true, throw a HierarchyRequestError.
    if (parent.nodeType === DOCUMENT_NODE) {
      switch (node.nodeType) {
      case TEXT_NODE:
        utils.HierarchyRequestError();
        break;
      case DOCUMENT_FRAGMENT_NODE:
        // 6a1. If node has more than one element child or has a Text
        // node child.
        if (node._countChildrenOfType(TEXT_NODE) > 0)
          utils.HierarchyRequestError();
        switch (node._countChildrenOfType(ELEMENT_NODE)) {
        case 0:
          break;
        case 1:
          // 6a2. Otherwise, if node has one element child and either
          // parent has an element child, child is a doctype, or child
          // is not null and a doctype is following child. [preinsert]
          // 6a2. Otherwise, if node has one element child and either
          // parent has an element child that is not child or a
          // doctype is following child. [replaceWith]
          if (child !== null /* always true here for replaceWith */) {
            if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)
              utils.HierarchyRequestError();
            for (i=parent.childNodes.length-1; i>=0; i--) {
              if (parent.childNodes[i] === child) break;
              if (parent.childNodes[i].nodeType === DOCUMENT_TYPE_NODE)
                utils.HierarchyRequestError();
            }
          }
          i = parent._countChildrenOfType(ELEMENT_NODE);
          if (isPreinsert) {
            // "parent has an element child"
            if (i > 0)
              utils.HierarchyRequestError();
          } else {
            // "parent has an element child that is not child"
            if (i > 1 || (i === 1 && child.nodeType !== ELEMENT_NODE))
              utils.HierarchyRequestError();
          }
          break;
        default: // 6a1, continued. (more than one Element child)
          utils.HierarchyRequestError();
        }
        break;
      case ELEMENT_NODE:
        // 6b. parent has an element child, child is a doctype, or
        // child is not null and a doctype is following child. [preinsert]
        // 6b. parent has an element child that is not child or a
        // doctype is following child. [replaceWith]
        if (child !== null /* always true here for replaceWith */) {
          if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)
            utils.HierarchyRequestError();
          for (i=parent.childNodes.length-1; i>=0; i--) {
            if (parent.childNodes[i] === child) break;
            if (parent.childNodes[i].nodeType === DOCUMENT_TYPE_NODE)
              utils.HierarchyRequestError();
          }
        }
        i = parent._countChildrenOfType(ELEMENT_NODE);
        if (isPreinsert) {
          // "parent has an element child"
          if (i > 0)
            utils.HierarchyRequestError();
        } else {
          // "parent has an element child that is not child"
          if (i > 1 || (i === 1 && child.nodeType !== ELEMENT_NODE))
            utils.HierarchyRequestError();
        }
        break;
      case DOCUMENT_TYPE_NODE:
        // 6c. parent has a doctype child, child is non-null and an
        // element is preceding child, or child is null and parent has
        // an element child. [preinsert]
        // 6c. parent has a doctype child that is not child, or an
        // element is preceding child. [replaceWith]
        if (child === null) {
          if (parent._countChildrenOfType(ELEMENT_NODE))
            utils.HierarchyRequestError();
        } else {
          // child is always non-null for [replaceWith] case
          for (i=0; i<parent.childNodes.length; i++) {
            if (parent.childNodes[i] === child) break;
            if (parent.childNodes[i].nodeType === ELEMENT_NODE)
              utils.HierarchyRequestError();
          }
        }
        i = parent._countChildrenOfType(DOCUMENT_TYPE_NODE);
        if (isPreinsert) {
          // "parent has an doctype child"
          if (i > 0)
            utils.HierarchyRequestError();
        } else {
          // "parent has an doctype child that is not child"
          if (i > 1 || (i === 1 && child.nodeType !== DOCUMENT_TYPE_NODE))
            utils.HierarchyRequestError();
        }
        break;
      }
    } else {
      // 5, continued: (parent is not a document)
      if (node.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
    }
  }},

  insertBefore: { value: function insertBefore(node, child) {
    var parent = this;
    // 1. Ensure pre-insertion validity
    parent._ensureInsertValid(node, child, true);
    // 2. Let reference child be child.
    var refChild = child;
    // 3. If reference child is node, set it to node's next sibling
    if (refChild === node) { refChild = node.nextSibling; }
    // 4. Adopt node into parent's node document.
    parent.doc.adoptNode(node);
    // 5. Insert node into parent before reference child.
    if (refChild === null) {
      parent._appendChild(node);
    } else {
      node.insert(parent, refChild.index);
    }
    // 6. Return node
    return node;
  }},


  appendChild: { value: function(child) {
    // This invokes _appendChild after doing validity checks.
    return this.insertBefore(child, null);
  }},

  _appendChild: { value: function(child) {
    child.insert(this, this.childNodes.length);
    return child;
  }},

  removeChild: { value: function removeChild(child) {
    var parent = this;
    if (!child.nodeType) throw new TypeError('not a node');
    if (child.parentNode !== parent) utils.NotFoundError();
    child.remove();
    return child;
  }},

  // To replace a `child` with `node` within a `parent` (this)
  replaceChild: { value: function replaceChild(node, child) {
    var parent = this;
    // Ensure validity (slight differences from pre-insertion check)
    parent._ensureInsertValid(node, child, false);
    // Adopt node into parent's node document.
    if (node.doc !== parent.doc) {
      // XXX adoptNode has side-effect of removing node from its parent
      // and generating a mutation event, thus causing the _insertOrReplace
      // to generate two deletes and an insert instead of a 'move'
      // event.  It looks like the new MutationObserver stuff avoids
      // this problem, but for now let's only adopt (ie, remove `node`
      // from its parent) here if we need to.
      parent.doc.adoptNode(node);
    }
    // Do the replace.
    node._insertOrReplace(parent, child.index, true);
    return child;
  }},

  // See: http://ejohn.org/blog/comparing-document-position/
  contains: { value: function contains(node) {
    if (node === null) { return false; }
    if (this === node) { return true; /* inclusive descendant */ }
    /* jshint bitwise: false */
    return (this.compareDocumentPosition(node) &
            DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  }},

  compareDocumentPosition: { value: function compareDocumentPosition(that){
    // Basic algorithm for finding the relative position of two nodes.
    // Make a list the ancestors of each node, starting with the
    // document element and proceeding down to the nodes themselves.
    // Then, loop through the lists, looking for the first element
    // that differs.  The order of those two elements give the
    // order of their descendant nodes.  Or, if one list is a prefix
    // of the other one, then that node contains the other.

    if (this === that) return 0;

    // If they're not owned by the same document or if one is rooted
    // and one is not, then they're disconnected.
    if (this.doc !== that.doc ||
      this.rooted !== that.rooted)
      return (DOCUMENT_POSITION_DISCONNECTED +
          DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);

    // Get arrays of ancestors for this and that
    var these = [], those = [];
    for(var n = this; n !== null; n = n.parentNode) these.push(n);
    for(n = that; n !== null; n = n.parentNode) those.push(n);
    these.reverse();  // So we start with the outermost
    those.reverse();

    if (these[0] !== those[0]) // No common ancestor
      return (DOCUMENT_POSITION_DISCONNECTED +
          DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);

    n = Math.min(these.length, those.length);
    for(var i = 1; i < n; i++) {
      if (these[i] !== those[i]) {
        // We found two different ancestors, so compare
        // their positions
        if (these[i].index < those[i].index)
          return DOCUMENT_POSITION_FOLLOWING;
        else
          return DOCUMENT_POSITION_PRECEDING;
      }
    }

    // If we get to here, then one of the nodes (the one with the
    // shorter list of ancestors) contains the other one.
    if (these.length < those.length)
      return (DOCUMENT_POSITION_FOLLOWING +
          DOCUMENT_POSITION_CONTAINED_BY);
    else
      return (DOCUMENT_POSITION_PRECEDING +
          DOCUMENT_POSITION_CONTAINS);
  }},

  isSameNode: {value : function isSameNode(node) {
    return this === node;
  }},


  // This method implements the generic parts of node equality testing
  // and defers to the (non-recursive) type-specific isEqual() method
  // defined by subclasses
  isEqualNode: { value: function isEqualNode(node) {
    if (!node) return false;
    if (node.nodeType !== this.nodeType) return false;

    // Check for same number of children
    // Check for children this way because it is more efficient
    // for childless leaf nodes.
    var n; // number of child nodes
    if (!this.firstChild) {
      n = 0;
      if (node.firstChild) return false;
    }
    else {
      n = this.childNodes.length;
      if (node.childNodes.length !== n) return false;
    }

    // Check type-specific properties for equality
    if (!this.isEqual(node)) return false;

    // Now check children for equality
    for(var i = 0; i < n; i++) {
      var c1 = this.childNodes[i], c2 = node.childNodes[i];
      if (!c1.isEqualNode(c2)) return false;
    }

    return true;
  }},

  // This method delegates shallow cloning to a clone() method
  // that each concrete subclass must implement
  cloneNode: { value: function(deep) {
    // Clone this node
    var clone = this.clone();

    // Handle the recursive case if necessary
    if (deep && this.firstChild) {
      for(var i = 0, n = this.childNodes.length; i < n; i++) {
        clone._appendChild(this.childNodes[i].cloneNode(true));
      }
    }

    return clone;
  }},

  lookupPrefix: { value: function lookupPrefix(ns) {
    var e;
    if (ns === '') return null;
    switch(this.nodeType) {
    case ELEMENT_NODE:
      return this.locateNamespacePrefix(ns);
    case DOCUMENT_NODE:
      e = this.documentElement;
      return e ? e.locateNamespacePrefix(ns) : null;
    case DOCUMENT_TYPE_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      return null;
    default:
      e = this.parentElement;
      return e ? e.locateNamespacePrefix(ns) : null;
    }
  }},


  lookupNamespaceURI: {value: function lookupNamespaceURI(prefix) {
    var e;
    switch(this.nodeType) {
    case ELEMENT_NODE:
      return this.locateNamespace(prefix);
    case DOCUMENT_NODE:
      e = this.documentElement;
      return e ? e.locateNamespace(prefix) : null;
    case DOCUMENT_TYPE_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      return null;
    default:
      e = this.parentElement;
      return e ? e.locateNamespace(prefix) : null;
    }
  }},

  isDefaultNamespace: { value: function isDefaultNamespace(ns) {
    var defaultns = this.lookupNamespaceURI(null);
    if (defaultns === null) defaultns = '';
    return ns === defaultns;
  }},

  // Utility methods for nodes.  Not part of the DOM

  // Return the index of this node in its parent.
  // Throw if no parent, or if this node is not a child of its parent
  index: { get: function() {
    utils.assert(this.parentNode);
    var kids = this.parentNode.childNodes;
    if (this._index === undefined || kids[this._index] !== this) {
      // Ensure that we don't have an O(N^2) blowup if none of the
      // kids have defined indices yet and we're traversing via
      // nextSibling or prevSibling
      for (var i=0; i<kids.length; i++) {
        kids[i]._index = i;
      }
      utils.assert(kids[this._index] === this);
    }
    return this._index;
  }},

  // Return true if this node is equal to or is an ancestor of that node
  // Note that nodes are considered to be ancestors of themselves
  isAncestor: { value: function(that) {
    // If they belong to different documents, then they're unrelated.
    if (this.doc !== that.doc) return false;
    // If one is rooted and one isn't then they're not related
    if (this.rooted !== that.rooted) return false;

    // Otherwise check by traversing the parentNode chain
    for(var e = that; e; e = e.parentNode) {
      if (e === this) return true;
    }
    return false;
  }},

  // DOMINO Changed the behavior to conform with the specs. See:
  // https://groups.google.com/d/topic/mozilla.dev.platform/77sIYcpdDmc/discussion
  ensureSameDoc: { value: function(that) {
    if (that.ownerDocument === null) {
      that.ownerDocument = this.doc;
    }
    else if(that.ownerDocument !== this.doc) {
      utils.WrongDocumentError();
    }
  }},

  // Remove all of this node's children.  This is a minor
  // optimization that only calls modify() once.
  removeChildren: { value: function removeChildren() {
    var n = this.childNodes.length;
    if (n) {
      var root = this.rooted ? this.ownerDocument : null;
      for(var i = 0; i < n; i++) {
        if (root) root.mutateRemove(this.childNodes[i]);
        this.childNodes[i].parentNode = null;
      }
      this.childNodes.length = 0; // Forget all children
      this.modify();              // Update last modified type once only
    }
  }},

  // Insert this node as a child of parent at the specified index,
  // firing mutation events as necessary
  insert: { value: function insert(parent, index) {
    this._insertOrReplace(parent, index, false);
  }},

  // Insert this node as a child of parent at the specified index,
  // or replace the specified child with this node, firing mutation events as
  // necessary
  _insertOrReplace: { value: function _insertOrReplace(parent, index, isReplace) {
    var child = this;
    var kids = parent.childNodes;

    if (child.nodeType === DOCUMENT_FRAGMENT_NODE && child.rooted) {
      utils.HierarchyRequestError();
    }

    // If we are already a child of the specified parent, then
    // the index may have to be adjusted.
    if (child.parentNode === parent) {
      var currentIndex = child.index;
      // If we're not moving the node, we're done now
      // XXX: or do DOM mutation events still have to be fired?
      if (currentIndex === index) return;

      // If the child is before the spot it is to be inserted at,
      // then when it is removed, the index of that spot will be
      // reduced.
      if (currentIndex < index) index--;
    }

    // Delete the old child
    if (isReplace) {
      var oldChild = parent.childNodes[index];
      if (oldChild.rooted) oldChild.doc.mutateRemove(oldChild);
      oldChild.parentNode = null;
    }

    // If both the child and the parent are rooted, then we want to
    // transplant the child without uprooting and rerooting it.
    if (child.rooted && parent.rooted) {
      // Remove the child from its current position in the tree
      // without calling remove(), since we don't want to uproot it.
      var curpar = child.parentNode;
      curpar.childNodes.splice(child.index, 1);
      curpar.modify();

      // And insert it as a child of its new parent
      child.parentNode = parent;
      if (isReplace) {
        kids[index] = child;
      } else {
        kids.splice(index, 0, child);
      }
      child._index = index;
      parent.modify();

      // Generate a move mutation event
      parent.doc.mutateMove(child);
    }
    else {
      if (child.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var spliceArgs = [index, isReplace ? 1 : 0];
        var i;
        for (i = 0; i < child.childNodes.length; i++) {
          var fragChild = child.childNodes[i];
          spliceArgs.push(fragChild);
          fragChild.parentNode = parent;
          fragChild._index = index + i;
        }
        // Remove all nodes from the document fragment
        child.childNodes.length = 0;
        // Add all nodes to the new parent, overwriting the old child
        kids.splice.apply(kids, spliceArgs);
        // Call the mutation handlers
        // Use spliceArgs since the original array has been destroyed. The
        // liveness guarantee requires us to clone the array so that
        // references to the childNodes of the DocumentFragment will be empty
        // when the insertion handlers are called.
        if (parent.rooted) {
          parent.modify();
          for (i = 2; i < spliceArgs.length; i++) {
            parent.doc.mutateInsert(spliceArgs[i]);
          }
        }
      }
      else {
        // If the child already has a parent, it needs to be
        // removed from that parent, which may also uproot it
        if (child.parentNode) child.remove();

        // Now insert the child into the parent's array of children
        child.parentNode = parent;
        if (isReplace) {
          kids[index] = child;
        } else {
          kids.splice(index, 0, child);
        }
        child._index = index;

        // And root the child if necessary
        if (parent.rooted) {
          parent.modify();
          parent.doc.mutateInsert(child);
        }
      }
    }
  }},


  // Return the lastModTime value for this node. (For use as a
  // cache invalidation mechanism. If the node does not already
  // have one, initialize it from the owner document's modclock
  // property. (Note that modclock does not return the actual
  // time; it is simply a counter incremented on each document
  // modification)
  lastModTime: { get: function() {
    if (!this._lastModTime) {
      this._lastModTime = this.doc.modclock;
    }
    return this._lastModTime;
  }},

  // Increment the owner document's modclock and use the new
  // value to update the lastModTime value for this node and
  // all of its ancestors. Nodes that have never had their
  // lastModTime value queried do not need to have a
  // lastModTime property set on them since there is no
  // previously queried value to ever compare the new value
  // against, so only update nodes that already have a
  // _lastModTime property.
  modify: { value: function() {
    if (this.doc.modclock) { // Skip while doc.modclock == 0
      var time = ++this.doc.modclock;
      for(var n = this; n; n = n.parentElement) {
        if (n._lastModTime) {
          n._lastModTime = time;
        }
      }
    }
  }},

  // This attribute is not part of the DOM but is quite helpful.
  // It returns the document with which a node is associated.  Usually
  // this is the ownerDocument. But ownerDocument is null for the
  // document object itself, so this is a handy way to get the document
  // regardless of the node type
  doc: { get: function() {
    return this.ownerDocument || this;
  }},


  // If the node has a nid (node id), then it is rooted in a document
  rooted: { get: function() {
    return !!this._nid;
  }},

  normalize: { value: function() {
    for (var i=0; i < this.childNodes.length; i++) {
      var child = this.childNodes[i];

      if (child.normalize) {
        child.normalize();
      }

      if (child.nodeType !== Node.TEXT_NODE) {
        continue;
      }

      if (child.nodeValue === "") {
        this.removeChild(child);
        i--;
        continue;
      }

      if (i) {
        var prevChild = this.childNodes[i-1];

        if (prevChild.nodeType === Node.TEXT_NODE) {
          // remove the child and decrement i
          prevChild.appendData(child.nodeValue);

          this.removeChild(child);
          i--;
        }
      }
    }
  }},

  // Convert the children of a node to an HTML string.
  // This is used by the innerHTML getter
  // The serialization spec is at:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#serializing-html-fragments
  serialize: { value: function() {
    var s = '';
    for(var i = 0, n = this.childNodes.length; i < n; i++) {
      var kid = this.childNodes[i];
      switch(kid.nodeType) {
      case 1: //ELEMENT_NODE
        var ns = kid.namespaceURI;
        var html = ns === NAMESPACE.HTML;
        var tagname = (html || ns === NAMESPACE.SVG || ns === NAMESPACE.MATHML) ? kid.localName : kid.tagName;

        s += '<' + tagname;

        for(var j = 0, k = kid._numattrs; j < k; j++) {
          var a = kid._attr(j);
          s += ' ' + attrname(a);
          if (a.value !== undefined) s += '="' + escapeAttr(a.value) + '"';
        }
        s += '>';

        if (!(html && emptyElements[tagname])) {
          var ss = kid.serialize();
          if (html && extraNewLine[tagname] && ss.charAt(0)==='\n') s += '\n';
          // Serialize children and add end tag for all others
          s += ss;
          s += '</' + tagname + '>';
        }
        break;
      case 3: //TEXT_NODE
      case 4: //CDATA_SECTION_NODE
        var parenttag;
        if (this.nodeType === ELEMENT_NODE &&
          this.namespaceURI === NAMESPACE.HTML)
          parenttag = this.tagName;
        else
          parenttag = '';

        if (hasRawContent[parenttag] ||
            (parenttag==='NOSCRIPT' && this.ownerDocument._scripting_enabled)) {
          s += kid.data;
        } else {
          s += escape(kid.data);
        }
        break;
      case 8: //COMMENT_NODE
        s += '<!--' + kid.data + '-->';
        break;
      case 7: //PROCESSING_INSTRUCTION_NODE
        s += '<?' + kid.target + ' ' + kid.data + '?>';
        break;
      case 10: //DOCUMENT_TYPE_NODE
        s += '<!DOCTYPE ' + kid.name;

        if (false) {
          // Latest HTML serialization spec omits the public/system ID
          if (kid.publicID) {
            s += ' PUBLIC "' + kid.publicId + '"';
          }

          if (kid.systemId) {
            s += ' "' + kid.systemId + '"';
          }
        }

        s += '>';
        break;
      default:
        utils.InvalidState();
      }
    }

    return s;
  }},

  // mirror node type properties in the prototype, so they are present
  // in instances of Node (and subclasses)
  ELEMENT_NODE:                { value: ELEMENT_NODE },
  ATTRIBUTE_NODE:              { value: ATTRIBUTE_NODE },
  TEXT_NODE:                   { value: TEXT_NODE },
  CDATA_SECTION_NODE:          { value: CDATA_SECTION_NODE },
  ENTITY_REFERENCE_NODE:       { value: ENTITY_REFERENCE_NODE },
  ENTITY_NODE:                 { value: ENTITY_NODE },
  PROCESSING_INSTRUCTION_NODE: { value: PROCESSING_INSTRUCTION_NODE },
  COMMENT_NODE:                { value: COMMENT_NODE },
  DOCUMENT_NODE:               { value: DOCUMENT_NODE },
  DOCUMENT_TYPE_NODE:          { value: DOCUMENT_TYPE_NODE },
  DOCUMENT_FRAGMENT_NODE:      { value: DOCUMENT_FRAGMENT_NODE },
  NOTATION_NODE:               { value: NOTATION_NODE }
});

function escape(s) {
  return s.replace(/[&<>\u00A0]/g, function(c) {
    switch(c) {
    case '&': return '&amp;';
    case '<': return '&lt;';
    case '>': return '&gt;';
    case '\u00A0': return '&nbsp;';
    }
  });
}

function escapeAttr(s) {
  var toEscape = /[&"\u00A0]/g;
  if (!toEscape.test(s)) {
      // nothing to do, fast path
      return s;
  } else {
      return s.replace(toEscape, function(c) {
        switch(c) {
        case '&': return '&amp;';
        case '"': return '&quot;';
        case '\u00A0': return '&nbsp;';
        }
      });
  }
}

function attrname(a) {
  var ns = a.namespaceURI;
  if (!ns)
    return a.localName;
  if (ns === NAMESPACE.XML)
    return 'xml:' + a.localName;
  if (ns === NAMESPACE.XLINK)
    return 'xlink:' + a.localName;

  if (ns === NAMESPACE.XMLNS) {
    if (a.localName === 'xmlns') return 'xmlns';
    else return 'xmlns:' + a.localName;
  }
  return a.name;
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(33);

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PlankCookingService; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_common_http__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var PlankCookingService = /** @class */ (function () {
    function PlankCookingService(httpClient) {
        this.httpClient = httpClient;
        this.products = [];
    }
    PlankCookingService.prototype.getProducts = function () {
        return this.httpClient.get('api/v1/plankcooking');
    };
    PlankCookingService.prototype.getSpiceRubs = function () {
        return this.httpClient.get('api/v1/plankcooking/spicerubs');
    };
    PlankCookingService.prototype.getBakingPlanks = function () {
        return this.httpClient.get('api/v1/plankcooking/bakingplanks');
    };
    PlankCookingService.prototype.getCookBooks = function () {
        return this.httpClient.get('api/v1/plankcooking/cookbooks');
    };
    PlankCookingService.prototype.getBbqPlanks = function () {
        return this.httpClient.get('api/v1/plankcooking/bbqplanks');
    };
    PlankCookingService.prototype.getNutdriver = function () {
        return this.httpClient.get('api/v1/plankcooking/nutdriver');
    };
    PlankCookingService.prototype.addQuantity = function (quantity) {
        console.log(quantity);
        console.log(quantity.orderItemID);
        var httpOptions = {
            headers: new __WEBPACK_IMPORTED_MODULE_1__angular_common_http__["HttpHeaders"]({ 'Content-Type': 'application/json' })
        };
        return this.httpClient.post('api/v1/plankcooking/add/spicerubs', quantity, httpOptions);
    };
    PlankCookingService.prototype.getProduct = function (productID) {
        var product = this.products.find(function (s) { return s.productID == productID; });
        if (product != null) {
            return product;
        }
        else {
            return {
                productID: 0,
                categoryID: 0,
                name: "",
                description: "",
                price: 0,
                priceDescription: "",
                sortOrder: 0,
                active: false,
                ounces: 0,
                imagePath: "",
                handlingCost: 0,
                taxExempt: false,
                sKU: ""
            };
        }
    };
    PlankCookingService = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_common_http__["HttpClient"]])
    ], PlankCookingService);
    return PlankCookingService;
}());



/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Event;

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

function Event(type, dictionary) {
  // Initialize basic event properties
  this.type = '';
  this.target = null;
  this.currentTarget = null;
  this.eventPhase = Event.AT_TARGET;
  this.bubbles = false;
  this.cancelable = false;
  this.isTrusted = false;
  this.defaultPrevented = false;
  this.timeStamp = Date.now();

  // Initialize internal flags
  // XXX: Would it be better to inherit these defaults from the prototype?
  this._propagationStopped = false;
  this._immediatePropagationStopped = false;
  this._initialized = true;
  this._dispatching = false;

  // Now initialize based on the constructor arguments (if any)
  if (type) this.type = type;
  if (dictionary) {
    for(var p in dictionary) {
      this[p] = dictionary[p];
    }
  }
}

Event.prototype = Object.create(Object.prototype, {
  constructor: { value: Event },
  stopPropagation: { value: function stopPropagation() {
    this._propagationStopped = true;
  }},

  stopImmediatePropagation: { value: function stopImmediatePropagation() {
    this._propagationStopped = true;
    this._immediatePropagationStopped = true;
  }},

  preventDefault: { value: function preventDefault() {
    if (this.cancelable) this.defaultPrevented = true;
  }},

  initEvent: { value: function initEvent(type, bubbles, cancelable) {
    this._initialized = true;
    if (this._dispatching) return;

    this._propagationStopped = false;
    this._immediatePropagationStopped = false;
    this.defaultPrevented = false;
    this.isTrusted = false;

    this.target = null;
    this.type = type;
    this.bubbles = bubbles;
    this.cancelable = cancelable;
  }},

});


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Element;

var xml = __webpack_require__(19);
var utils = __webpack_require__(2);
var NAMESPACE = utils.NAMESPACE;
var attributes = __webpack_require__(41);
var Node = __webpack_require__(3);
var NodeList = __webpack_require__(12);
var FilteredElementList = __webpack_require__(81);
var DOMTokenList = __webpack_require__(42);
var select = __webpack_require__(20);
var ChildNode = __webpack_require__(21);
var NonDocumentTypeChildNode = __webpack_require__(43);

function Element(doc, localName, namespaceURI, prefix) {
  this.nodeType = Node.ELEMENT_NODE;
  this.ownerDocument = doc;
  this.localName = localName;
  this.namespaceURI = namespaceURI;
  this.prefix = prefix;

  this.tagName = (prefix !== null) ? prefix + ':' + localName : localName;

  if (namespaceURI !== NAMESPACE.HTML || (!namespaceURI && !doc.isHTML)) this.isHTML = false;

  if (this.isHTML) this.tagName = this.tagName.toUpperCase();

  this.childNodes = new NodeList();

  // These properties maintain the set of attributes
  this._attrsByQName = Object.create(null); // The qname->Attr map
  this._attrsByLName = Object.create(null); // The ns|lname->Attr map
  this._attrKeys = [];     // attr index -> ns|lname

  this._index = undefined;
}

function recursiveGetText(node, a) {
  if (node.nodeType === Node.TEXT_NODE) {
    a.push(node._data);
  }
  else {
    for(var i = 0, n = node.childNodes.length;  i < n; i++)
      recursiveGetText(node.childNodes[i], a);
  }
}

Element.prototype = Object.create(Node.prototype, {
  nodeName: { get: function() { return this.tagName; }},
  nodeValue: {
    get: function() {
      return null;
    },
    set: function() {}
  },
  textContent: {
    get: function() {
      var strings = [];
      recursiveGetText(this, strings);
      return strings.join('');
    },
    set: function(newtext) {
      this.removeChildren();
      if (newtext !== null && newtext !== '') {
        this._appendChild(this.ownerDocument.createTextNode(newtext));
      }
    }
  },
  innerHTML: {
    get: function() {
      return this.serialize();
    },
    set: utils.nyi
  },
  outerHTML: {
    get: function() {
      // "the attribute must return the result of running the HTML fragment
      // serialization algorithm on a fictional node whose only child is
      // the context object"
      var fictional = {
        childNodes: [ this ],
        nodeType: 0
      };
      return Node.prototype.serialize.call(fictional);
    },
    set: utils.nyi
  },

  children: { get: function() {
    if (!this._children) {
      this._children = new ChildrenCollection(this);
    }
    return this._children;
  }},

  attributes: { get: function() {
    if (!this._attributes) {
      this._attributes = new AttributesArray(this);
    }
    return this._attributes;
  }},


  firstElementChild: { get: function() {
    var kids = this.childNodes;
    for(var i = 0, n = kids.length; i < n; i++) {
      if (kids[i].nodeType === Node.ELEMENT_NODE) return kids[i];
    }
    return null;
  }},

  lastElementChild: { get: function() {
    var kids = this.childNodes;
    for(var i = kids.length-1; i >= 0; i--) {
      if (kids[i].nodeType === Node.ELEMENT_NODE) return kids[i];
    }
    return null;
  }},

  childElementCount: { get: function() {
    return this.children.length;
  }},


  // Return the next element, in source order, after this one or
  // null if there are no more.  If root element is specified,
  // then don't traverse beyond its subtree.
  //
  // This is not a DOM method, but is convenient for
  // lazy traversals of the tree.
  nextElement: { value: function(root) {
    if (!root) root = this.ownerDocument.documentElement;
    var next = this.firstElementChild;
    if (!next) {
      // don't use sibling if we're at root
      if (this===root) return null;
      next = this.nextElementSibling;
    }
    if (next) return next;

    // If we can't go down or across, then we have to go up
    // and across to the parent sibling or another ancestor's
    // sibling.  Be careful, though: if we reach the root
    // element, or if we reach the documentElement, then
    // the traversal ends.
    for(var parent = this.parentElement;
      parent && parent !== root;
      parent = parent.parentElement) {

      next = parent.nextElementSibling;
      if (next) return next;
    }

    return null;
  }},

  // XXX:
  // Tests are currently failing for this function.
  // Awaiting resolution of:
  // http://lists.w3.org/Archives/Public/www-dom/2011JulSep/0016.html
  getElementsByTagName: { value: function getElementsByTagName(lname) {
    var filter;
    if (!lname) return new NodeList();
    if (lname === '*')
      filter = function() { return true; };
    else if (this.isHTML)
      filter = htmlLocalNameElementFilter(lname);
    else
      filter = localNameElementFilter(lname);

    return new FilteredElementList(this, filter);
  }},

  getElementsByTagNameNS: { value: function getElementsByTagNameNS(ns, lname){
    var filter;
    if (ns === '*' && lname === '*')
      filter = function() { return true; };
    else if (ns === '*')
      filter = localNameElementFilter(lname);
    else if (lname === '*')
      filter = namespaceElementFilter(ns);
    else
      filter = namespaceLocalNameElementFilter(ns, lname);

    return new FilteredElementList(this, filter);
  }},

  getElementsByClassName: { value: function getElementsByClassName(names){
    names = String(names).trim();
    if (names === '') {
      var result = new NodeList(); // Empty node list
      return result;
    }
    names = names.split(/\s+/);  // Split on spaces
    return new FilteredElementList(this, classNamesElementFilter(names));
  }},

  getElementsByName: { value: function getElementsByName(name) {
    return new FilteredElementList(this, elementNameFilter(String(name)));
  }},

  // Overwritten in the constructor if not in the HTML namespace
  isHTML: { value: true, writable: true },

  // Utility methods used by the public API methods above
  clone: { value: function clone() {
    var e;

    // XXX:
    // Modify this to use the constructor directly or
    // avoid error checking in some other way. In case we try
    // to clone an invalid node that the parser inserted.
    //
    if (this.namespaceURI !== NAMESPACE.HTML || this.prefix)
      e = this.ownerDocument.createElementNS(this.namespaceURI,
                           this.tagName);
    else
      e = this.ownerDocument.createElement(this.localName);

    for(var i = 0, n = this._attrKeys.length; i < n; i++) {
      var lname = this._attrKeys[i];
      var a = this._attrsByLName[lname];
      var b = new Attr(e, a.localName, a.prefix, a.namespaceURI);
      b.data = a.data;
      e._attrsByLName[lname] = b;
      e._addQName(b);
    }
    e._attrKeys = this._attrKeys.concat();

    return e;
  }},

  isEqual: { value: function isEqual(that) {
    if (this.localName !== that.localName ||
      this.namespaceURI !== that.namespaceURI ||
      this.prefix !== that.prefix ||
      this._numattrs !== that._numattrs)
      return false;

    // Compare the sets of attributes, ignoring order
    // and ignoring attribute prefixes.
    for(var i = 0, n = this._numattrs; i < n; i++) {
      var a = this._attr(i);
      if (!that.hasAttributeNS(a.namespaceURI, a.localName))
        return false;
      if (that.getAttributeNS(a.namespaceURI,a.localName) !== a.value)
        return false;
    }

    return true;
  }},

  // This is the 'locate a namespace prefix' algorithm from the
  // DOMCore specification.  It is used by Node.lookupPrefix()
  locateNamespacePrefix: { value: function locateNamespacePrefix(ns) {
    if (this.namespaceURI === ns && this.prefix !== null)
      return this.prefix;

    for(var i = 0, n = this._numattrs; i < n; i++) {
      var a = this._attr(i);
      if (a.prefix === 'xmlns' && a.value === ns)
        return a.localName;
    }

    var parent = this.parentElement;
    return parent ? parent.locateNamespacePrefix(ns) : null;
  }},

  // This is the 'locate a namespace' algorithm for Element nodes
  // from the DOM Core spec.  It is used by Node.lookupNamespaceURI
  locateNamespace: { value: function locateNamespace(prefix) {
    if (this.prefix === prefix && this.namespaceURI !== null)
      return this.namespaceURI;

    for(var i = 0, n = this._numattrs; i < n; i++) {
      var a = this._attr(i);
      if ((a.prefix === 'xmlns' && a.localName === prefix) ||
        (a.prefix === null && a.localName === 'xmlns')) {
        return a.value || null;
      }
    }

    var parent = this.parentElement;
    return parent ? parent.locateNamespace(prefix) : null;
  }},

  //
  // Attribute handling methods and utilities
  //

  /*
   * Attributes in the DOM are tricky:
   *
   * - there are the 8 basic get/set/has/removeAttribute{NS} methods
   *
   * - but many HTML attributes are also 'reflected' through IDL
   *   attributes which means that they can be queried and set through
   *   regular properties of the element.  There is just one attribute
   *   value, but two ways to get and set it.
   *
   * - Different HTML element types have different sets of reflected
     attributes.
   *
   * - attributes can also be queried and set through the .attributes
   *   property of an element.  This property behaves like an array of
   *   Attr objects.  The value property of each Attr is writeable, so
   *   this is a third way to read and write attributes.
   *
   * - for efficiency, we really want to store attributes in some kind
   *   of name->attr map.  But the attributes[] array is an array, not a
   *   map, which is kind of unnatural.
   *
   * - When using namespaces and prefixes, and mixing the NS methods
   *   with the non-NS methods, it is apparently actually possible for
   *   an attributes[] array to have more than one attribute with the
   *   same qualified name.  And certain methods must operate on only
   *   the first attribute with such a name.  So for these methods, an
   *   inefficient array-like data structure would be easier to
   *   implement.
   *
   * - The attributes[] array is live, not a snapshot, so changes to the
   *   attributes must be immediately visible through existing arrays.
   *
   * - When attributes are queried and set through IDL properties
   *   (instead of the get/setAttributes() method or the attributes[]
   *   array) they may be subject to type conversions, URL
   *   normalization, etc., so some extra processing is required in that
   *   case.
   *
   * - But access through IDL properties is probably the most common
   *   case, so we'd like that to be as fast as possible.
   *
   * - We can't just store attribute values in their parsed idl form,
   *   because setAttribute() has to return whatever string is passed to
   *   getAttribute even if it is not a legal, parseable value. So
   *   attribute values must be stored in unparsed string form.
   *
   * - We need to be able to send change notifications or mutation
   *   events of some sort to the renderer whenever an attribute value
   *   changes, regardless of the way in which it changes.
   *
   * - Some attributes, such as id and class affect other parts of the
   *   DOM API, like getElementById and getElementsByClassName and so
   *   for efficiency, we need to specially track changes to these
   *   special attributes.
   *
   * - Some attributes like class have different names (className) when
   *   reflected.
   *
   * - Attributes whose names begin with the string 'data-' are treated
     specially.
   *
   * - Reflected attributes that have a boolean type in IDL have special
   *   behavior: setting them to false (in IDL) is the same as removing
   *   them with removeAttribute()
   *
   * - numeric attributes (like HTMLElement.tabIndex) can have default
   *   values that must be returned by the idl getter even if the
   *   content attribute does not exist. (The default tabIndex value
   *   actually varies based on the type of the element, so that is a
   *   tricky one).
   *
   * See
   * http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#reflect
   * for rules on how attributes are reflected.
   *
   */

  getAttribute: { value: function getAttribute(qname) {
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);
    var attr = this._attrsByQName[qname];
    if (!attr) return null;

    if (Array.isArray(attr))  // If there is more than one
      attr = attr[0];         // use the first

    return attr.value;
  }},

  getAttributeNS: { value: function getAttributeNS(ns, lname) {
    var attr = this._attrsByLName[(ns === null ? '' : ns) + '|' + lname];
    return attr ? attr.value : null;
  }},

  hasAttribute: { value: function hasAttribute(qname) {
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);
    return this._attrsByQName[qname] !== undefined;
  }},

  hasAttributeNS: { value: function hasAttributeNS(ns, lname) {
    var key = (ns === null ? '' : ns) + '|' + lname;
    return this._attrsByLName[key] !== undefined;
  }},

  // Set the attribute without error checking. The parser uses this.
  _setAttribute: { value: function _setAttribute(qname, value) {
    // XXX: the spec says that this next search should be done
    // on the local name, but I think that is an error.
    // email pending on www-dom about it.
    var attr = this._attrsByQName[qname];
    var isnew;
    if (!attr) {
      attr = this._newattr(qname);
      isnew = true;
    }
    else {
      if (Array.isArray(attr)) attr = attr[0];
    }

    // Now set the attribute value on the new or existing Attr object.
    // The Attr.value setter method handles mutation events, etc.
    attr.value = value;
    if (this._attributes) this._attributes[qname] = attr;
    if (isnew && this._newattrhook) this._newattrhook(qname, value);
  }},

  // Check for errors, and then set the attribute
  setAttribute: { value: function setAttribute(qname, value) {
    if (!xml.isValidName(qname)) utils.InvalidCharacterError();
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);
    if (qname.substring(0, 5) === 'xmlns') utils.NamespaceError();
    this._setAttribute(qname, String(value));
  }},


  // The version with no error checking used by the parser
  _setAttributeNS: { value: function _setAttributeNS(ns, qname, value) {
    var pos = qname.indexOf(':'), prefix, lname;
    if (pos === -1) {
      prefix = null;
      lname = qname;
    }
    else {
      prefix = qname.substring(0, pos);
      lname = qname.substring(pos+1);
    }

    var key = (ns === null ? '' : ns) + '|' + lname;
    if (ns === '') ns = null;

    var attr = this._attrsByLName[key];
    var isnew;
    if (!attr) {
      attr = new Attr(this, lname, prefix, ns);
      isnew = true;
      this._attrsByLName[key] = attr;
      this._attrKeys.push(key);

      // We also have to make the attr searchable by qname.
      // But we have to be careful because there may already
      // be an attr with this qname.
      this._addQName(attr);
    }
    else {
      // Calling setAttributeNS() can change the prefix of an
      // existing attribute!
      if (attr.prefix !== prefix) {
        // Unbind the old qname
        this._removeQName(attr);
        // Update the prefix
        attr.prefix = prefix;
        // Bind the new qname
        this._addQName(attr);

      }

    }
    attr.value = value; // Automatically sends mutation event
    if (isnew && this._newattrhook) this._newattrhook(qname, value);
  }},

  // Do error checking then call _setAttributeNS
  setAttributeNS: { value: function setAttributeNS(ns, qname, value) {
    if (!xml.isValidName(qname)) utils.InvalidCharacterError();
    if (!xml.isValidQName(qname)) utils.NamespaceError();

    var pos = qname.indexOf(':');
    var prefix = (pos === -1) ? null : qname.substring(0, pos);
    if (ns === '') ns = null;

    if ((prefix !== null && ns === null) ||
      (prefix === 'xml' && ns !== NAMESPACE.XML) ||
      ((qname === 'xmlns' || prefix === 'xmlns') &&
       (ns !== NAMESPACE.XMLNS)) ||
      (ns === NAMESPACE.XMLNS &&
       !(qname === 'xmlns' || prefix === 'xmlns')))
      utils.NamespaceError();

    this._setAttributeNS(ns, qname, String(value));
  }},

  removeAttribute: { value: function removeAttribute(qname) {
    if (this.isHTML) qname = utils.toASCIILowerCase(qname);

    var attr = this._attrsByQName[qname];
    if (!attr) return;

    // If there is more than one match for this qname
    // so don't delete the qname mapping, just remove the first
    // element from it.
    if (Array.isArray(attr)) {
      if (attr.length > 2) {
        attr = attr.shift();  // remove it from the array
      }
      else {
        this._attrsByQName[qname] = attr[1];
        attr = attr[0];
      }
    }
    else {
      // only a single match, so remove the qname mapping
      this._attrsByQName[qname] = undefined;
    }

    var ns = attr.namespaceURI;
    // Now attr is the removed attribute.  Figure out its
    // ns+lname key and remove it from the other mapping as well.
    var key = (ns === null ? '' : ns) + '|' + attr.localName;
    this._attrsByLName[key] = undefined;

    var i = this._attrKeys.indexOf(key);
    this._attrKeys.splice(i, 1);

    if (this._attributes)
      this._attributes[qname] = undefined;

    // Onchange handler for the attribute
    if (attr.onchange)
      attr.onchange(this, attr.localName, attr.value, null);

    // Mutation event
    if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
  }},

  removeAttributeNS: { value: function removeAttributeNS(ns, lname) {
    var key = (ns === null ? '' : ns) + '|' + lname;
    var attr = this._attrsByLName[key];
    if (!attr) return;

    this._attrsByLName[key] = undefined;

    var i = this._attrKeys.indexOf(key);
    this._attrKeys.splice(i, 1);

    // Now find the same Attr object in the qname mapping and remove it
    // But be careful because there may be more than one match.
    this._removeQName(attr);

    // Onchange handler for the attribute
    if (attr.onchange)
      attr.onchange(this, attr.localName, attr.value, null);
    // Mutation event
    if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
  }},

  // This 'raw' version of getAttribute is used by the getter functions
  // of reflected attributes. It skips some error checking and
  // namespace steps
  _getattr: { value: function _getattr(qname) {
    // Assume that qname is already lowercased, so don't do it here.
    // Also don't check whether attr is an array: a qname with no
    // prefix will never have two matching Attr objects (because
    // setAttributeNS doesn't allow a non-null namespace with a
    // null prefix.
    var attr = this._attrsByQName[qname];
    return attr ? attr.value : null;
  }},

  // The raw version of setAttribute for reflected idl attributes.
  _setattr: { value: function _setattr(qname, value) {
    var attr = this._attrsByQName[qname];
    var isnew;
    if (!attr) {
      attr = this._newattr(qname);
      isnew = true;
    }
    attr.value = String(value);
    if (this._attributes) this._attributes[qname] = attr;
    if (isnew && this._newattrhook) this._newattrhook(qname, value);
  }},

  // Create a new Attr object, insert it, and return it.
  // Used by setAttribute() and by set()
  _newattr: { value: function _newattr(qname) {
    var attr = new Attr(this, qname, null, null);
    var key = '|' + qname;
    this._attrsByQName[qname] = attr;
    this._attrsByLName[key] = attr;
    this._attrKeys.push(key);
    return attr;
  }},

  // Add a qname->Attr mapping to the _attrsByQName object, taking into
  // account that there may be more than one attr object with the
  // same qname
  _addQName: { value: function(attr) {
    var qname = attr.name;
    var existing = this._attrsByQName[qname];
    if (!existing) {
      this._attrsByQName[qname] = attr;
    }
    else if (Array.isArray(existing)) {
      existing.push(attr);
    }
    else {
      this._attrsByQName[qname] = [existing, attr];
    }
    if (this._attributes) this._attributes[qname] = attr;
  }},

  // Remove a qname->Attr mapping to the _attrsByQName object, taking into
  // account that there may be more than one attr object with the
  // same qname
  _removeQName: { value: function(attr) {
    var qname = attr.name;
    var target = this._attrsByQName[qname];

    if (Array.isArray(target)) {
      var idx = target.indexOf(attr);
      utils.assert(idx !== -1); // It must be here somewhere
      if (target.length === 2) {
        this._attrsByQName[qname] = target[1-idx];
      }
      else {
        target.splice(idx, 1);
      }
    }
    else {
      utils.assert(target === attr);  // If only one, it must match
      this._attrsByQName[qname] = undefined;
    }
  }},

  // Return the number of attributes
  _numattrs: { get: function() { return this._attrKeys.length; }},
  // Return the nth Attr object
  _attr: { value: function(n) {
    return this._attrsByLName[this._attrKeys[n]];
  }},

  // Define getters and setters for an 'id' property that reflects
  // the content attribute 'id'.
  id: attributes.property({name: 'id'}),

  // Define getters and setters for a 'className' property that reflects
  // the content attribute 'class'.
  className: attributes.property({name: 'class'}),

  classList: { get: function() {
    var self = this;
    if (this._classList) {
      return this._classList;
    }
    var dtlist = new DOMTokenList(
      function() {
        return self.className || "";
      },
      function(v) {
        self.className = v;
      }
    );
    this._classList = dtlist;
    return dtlist;
  }},

  matches: { value: function(selector) {
    return select.matches(this, selector);
  }},

  closest: { value: function(selector) {
    var el = this;
    while (el.matches && !el.matches(selector)) el = el.parentNode;
    return el.matches ? el : null;
  }},

  querySelector: { value: function(selector) {
    return select(selector, this)[0];
  }},

  querySelectorAll: { value: function(selector) {
    var nodes = select(selector, this);
    return nodes.item ? nodes : new NodeList(nodes);
  }}

});

Object.defineProperties(Element.prototype, ChildNode);
Object.defineProperties(Element.prototype, NonDocumentTypeChildNode);

// Register special handling for the id attribute
attributes.registerChangeHandler(Element, 'id',
 function(element, lname, oldval, newval) {
   if (element.rooted) {
     if (oldval) {
       element.ownerDocument.delId(oldval, element);
     }
     if (newval) {
       element.ownerDocument.addId(newval, element);
     }
   }
 }
);


// The Attr class represents a single attribute.  The values in
// _attrsByQName and _attrsByLName are instances of this class.
function Attr(elt, lname, prefix, namespace) {
  // Always remember what element we're associated with.
  // We need this to property handle mutations
  this.ownerElement = elt;

  if (!namespace && !prefix && elt._attributeChangeHandlers[lname])
    this.onchange = elt._attributeChangeHandlers[lname];

  // localName and namespace are constant for any attr object.
  // But value may change.  And so can prefix, and so, therefore can name.
  this.localName = lname;
  this.prefix = (prefix===null || prefix==='') ? null : ('' + prefix);
  this.namespaceURI = (namespace===null || namespace==='') ? null : ('' + namespace);
}

Attr.prototype = {
  get name() {
    return this.prefix ? this.prefix + ':' + this.localName : this.localName;
  },

  get value() {
    return this.data;
  },

  get specified() {
    // Deprecated
    return true;
  },

  set value(value) {
    var oldval = this.data;
    value = (value === undefined) ? '' : value + '';
    if (value === oldval) return;

    this.data = value;

    // Run the onchange hook for the attribute
    // if there is one.
    if (this.onchange)
      this.onchange(this.ownerElement,this.localName, oldval, value);

    // Generate a mutation event if the element is rooted
    if (this.ownerElement.rooted)
      this.ownerElement.ownerDocument.mutateAttr(this, oldval);
  },

  // Legacy aliases (see gh#70 and https://dom.spec.whatwg.org/#interface-attr)
  get nodeName() { return this.name; },
  get nodeValue() { return this.value; },
  get textContent() { return this.value; },
  set nodeValue(v) { this.value = v; },
  set textContent(v) { this.value = v; },
};


// The attributes property of an Element will be an instance of this class.
// This class is really just a dummy, though. It only defines a length
// property and an item() method. The AttrArrayProxy that
// defines the public API just uses the Element object itself.
function AttributesArray(elt) {
  this.element = elt;
  for (var name in elt._attrsByQName) {
    this[name] = elt._attrsByQName[name];
  }
}
AttributesArray.prototype = {
  get length() {
    return this.element._attrKeys.length;
  },
  item: function(n) {
    return this.element._attrsByLName[this.element._attrKeys[n]];
  }
};


// The children property of an Element will be an instance of this class.
// It defines length, item() and namedItem() and will be wrapped by an
// HTMLCollection when exposed through the DOM.
function ChildrenCollection(e) {
  this.element = e;
  this.updateCache();
}

ChildrenCollection.prototype = {
  get length() {
    this.updateCache();
    return this.childrenByNumber.length;
  },
  item: function item(n) {
    this.updateCache();
    return this.childrenByNumber[n] || null;
  },

  namedItem: function namedItem(name) {
    this.updateCache();
    return this.childrenByName[name] || null;
  },

  // This attribute returns the entire name->element map.
  // It is not part of the HTMLCollection API, but we need it in
  // src/HTMLCollectionProxy
  get namedItems() {
    this.updateCache();
    return this.childrenByName;
  },

  updateCache: function updateCache() {
    var namedElts = /^(a|applet|area|embed|form|frame|frameset|iframe|img|object)$/;
    if (this.lastModTime !== this.element.lastModTime) {
      this.lastModTime = this.element.lastModTime;

      var n = this.childrenByNumber && this.childrenByNumber.length || 0;
      for(var i = 0; i < n; i++) {
        this[i] = undefined;
      }

      this.childrenByNumber = [];
      this.childrenByName = Object.create(null);

      for(i = 0, n = this.element.childNodes.length; i < n; i++) {
        var c = this.element.childNodes[i];
        if (c.nodeType === Node.ELEMENT_NODE) {

          this[this.childrenByNumber.length] = c;
          this.childrenByNumber.push(c);

          // XXX Are there any requirements about the namespace
          // of the id property?
          var id = c.getAttribute('id');

          // If there is an id that is not already in use...
          if (id && !this.childrenByName[id])
            this.childrenByName[id] = c;

          // For certain HTML elements we check the name attribute
          var name = c.getAttribute('name');
          if (name &&
            this.element.namespaceURI === NAMESPACE.HTML &&
            namedElts.test(this.element.localName) &&
            !this.childrenByName[name])
            this.childrenByName[id] = c;
        }
      }
    }
  }
};

// These functions return predicates for filtering elements.
// They're used by the Document and Element classes for methods like
// getElementsByTagName and getElementsByClassName

function localNameElementFilter(lname) {
  return function(e) { return e.localName === lname; };
}

function htmlLocalNameElementFilter(lname) {
  var lclname = utils.toASCIILowerCase(lname);
  if (lclname === lname)
    return localNameElementFilter(lname);

  return function(e) {
    return e.isHTML ? e.localName === lclname : e.localName === lname;
  };
}

function namespaceElementFilter(ns) {
  return function(e) { return e.namespaceURI === ns; };
}

function namespaceLocalNameElementFilter(ns, lname) {
  return function(e) {
    return e.namespaceURI === ns && e.localName === lname;
  };
}

// XXX
// Optimize this when I implement classList.
function classNamesElementFilter(names) {
  return function(e) {
    var classAttr = e.getAttribute('class');
    if (!classAttr) return false;
    var classes = classAttr.trim().split(/\s+/);
    return names.every(function(n) {
      return classes.indexOf(n) !== -1;
    });
  };
}

function elementNameFilter(name) {
  return function(e) {
    return e.getAttribute('name') === name;
  };
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(0);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(7);

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.2.3
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(0), __webpack_require__(71), __webpack_require__(72), __webpack_require__(33), __webpack_require__(73), __webpack_require__(74), __webpack_require__(9), __webpack_require__(8)) :
	typeof define === 'function' && define.amd ? define('@angular/common/http', ['exports', '@angular/core', 'rxjs/observable/of', 'rxjs/operator/concatMap', 'rxjs/operator/filter', 'rxjs/operator/map', 'tslib', '@angular/common', 'rxjs/Observable'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}, global.ng.common.http = {}),global.ng.core,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.tslib,global.ng.common,global.Rx));
}(this, (function (exports,_angular_core,rxjs_observable_of,rxjs_operator_concatMap,rxjs_operator_filter,rxjs_operator_map,tslib,_angular_common,rxjs_Observable) { 'use strict';

/**
 * @license Angular v5.2.3
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a
 * `HttpResponse`.
 *
 * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the
 * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the
 * `HttpBackend`.
 *
 * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.
 *
 * \@stable
 * @abstract
 */
var HttpHandler = /** @class */ (function () {
    function HttpHandler() {
    }
    return HttpHandler;
}());
/**
 * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.
 *
 * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.
 *
 * When injected, `HttpBackend` dispatches requests directly to the backend, without going
 * through the interceptor chain.
 *
 * \@stable
 * @abstract
 */
var HttpBackend = /** @class */ (function () {
    function HttpBackend() {
    }
    return HttpBackend;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @record
 */
/**
 * Immutable set of Http headers, with lazy parsing.
 * \@stable
 */
var HttpHeaders = /** @class */ (function () {
    function HttpHeaders(headers) {
        var _this = this;
        /**
         * Internal map of lowercased header names to the normalized
         * form of the name (the form seen first).
         */
        this.normalizedNames = new Map();
        /**
         * Queued updates to be materialized the next initialization.
         */
        this.lazyUpdate = null;
        if (!headers) {
            this.headers = new Map();
        }
        else if (typeof headers === 'string') {
            this.lazyInit = function () {
                _this.headers = new Map();
                headers.split('\n').forEach(function (line) {
                    var /** @type {?} */ index = line.indexOf(':');
                    if (index > 0) {
                        var /** @type {?} */ name_1 = line.slice(0, index);
                        var /** @type {?} */ key = name_1.toLowerCase();
                        var /** @type {?} */ value = line.slice(index + 1).trim();
                        _this.maybeSetNormalizedName(name_1, key);
                        if (_this.headers.has(key)) {
                            /** @type {?} */ ((_this.headers.get(key))).push(value);
                        }
                        else {
                            _this.headers.set(key, [value]);
                        }
                    }
                });
            };
        }
        else {
            this.lazyInit = function () {
                _this.headers = new Map();
                Object.keys(headers).forEach(function (name) {
                    var /** @type {?} */ values = headers[name];
                    var /** @type {?} */ key = name.toLowerCase();
                    if (typeof values === 'string') {
                        values = [values];
                    }
                    if (values.length > 0) {
                        _this.headers.set(key, values);
                        _this.maybeSetNormalizedName(name, key);
                    }
                });
            };
        }
    }
    /**
     * Checks for existence of header by given name.
     */
    /**
     * Checks for existence of header by given name.
     * @param {?} name
     * @return {?}
     */
    HttpHeaders.prototype.has = /**
     * Checks for existence of header by given name.
     * @param {?} name
     * @return {?}
     */
    function (name) {
        this.init();
        return this.headers.has(name.toLowerCase());
    };
    /**
     * Returns first header that matches given name.
     */
    /**
     * Returns first header that matches given name.
     * @param {?} name
     * @return {?}
     */
    HttpHeaders.prototype.get = /**
     * Returns first header that matches given name.
     * @param {?} name
     * @return {?}
     */
    function (name) {
        this.init();
        var /** @type {?} */ values = this.headers.get(name.toLowerCase());
        return values && values.length > 0 ? values[0] : null;
    };
    /**
     * Returns the names of the headers
     */
    /**
     * Returns the names of the headers
     * @return {?}
     */
    HttpHeaders.prototype.keys = /**
     * Returns the names of the headers
     * @return {?}
     */
    function () {
        this.init();
        return Array.from(this.normalizedNames.values());
    };
    /**
     * Returns list of header values for a given name.
     */
    /**
     * Returns list of header values for a given name.
     * @param {?} name
     * @return {?}
     */
    HttpHeaders.prototype.getAll = /**
     * Returns list of header values for a given name.
     * @param {?} name
     * @return {?}
     */
    function (name) {
        this.init();
        return this.headers.get(name.toLowerCase()) || null;
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    HttpHeaders.prototype.append = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) {
        return this.clone({ name: name, value: value, op: 'a' });
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    HttpHeaders.prototype.set = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) {
        return this.clone({ name: name, value: value, op: 's' });
    };
    /**
     * @param {?} name
     * @param {?=} value
     * @return {?}
     */
    HttpHeaders.prototype.delete = /**
     * @param {?} name
     * @param {?=} value
     * @return {?}
     */
    function (name, value) {
        return this.clone({ name: name, value: value, op: 'd' });
    };
    /**
     * @param {?} name
     * @param {?} lcName
     * @return {?}
     */
    HttpHeaders.prototype.maybeSetNormalizedName = /**
     * @param {?} name
     * @param {?} lcName
     * @return {?}
     */
    function (name, lcName) {
        if (!this.normalizedNames.has(lcName)) {
            this.normalizedNames.set(lcName, name);
        }
    };
    /**
     * @return {?}
     */
    HttpHeaders.prototype.init = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!!this.lazyInit) {
            if (this.lazyInit instanceof HttpHeaders) {
                this.copyFrom(this.lazyInit);
            }
            else {
                this.lazyInit();
            }
            this.lazyInit = null;
            if (!!this.lazyUpdate) {
                this.lazyUpdate.forEach(function (update) { return _this.applyUpdate(update); });
                this.lazyUpdate = null;
            }
        }
    };
    /**
     * @param {?} other
     * @return {?}
     */
    HttpHeaders.prototype.copyFrom = /**
     * @param {?} other
     * @return {?}
     */
    function (other) {
        var _this = this;
        other.init();
        Array.from(other.headers.keys()).forEach(function (key) {
            _this.headers.set(key, /** @type {?} */ ((other.headers.get(key))));
            _this.normalizedNames.set(key, /** @type {?} */ ((other.normalizedNames.get(key))));
        });
    };
    /**
     * @param {?} update
     * @return {?}
     */
    HttpHeaders.prototype.clone = /**
     * @param {?} update
     * @return {?}
     */
    function (update) {
        var /** @type {?} */ clone = new HttpHeaders();
        clone.lazyInit =
            (!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;
        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
        return clone;
    };
    /**
     * @param {?} update
     * @return {?}
     */
    HttpHeaders.prototype.applyUpdate = /**
     * @param {?} update
     * @return {?}
     */
    function (update) {
        var /** @type {?} */ key = update.name.toLowerCase();
        switch (update.op) {
            case 'a':
            case 's':
                var /** @type {?} */ value = /** @type {?} */ ((update.value));
                if (typeof value === 'string') {
                    value = [value];
                }
                if (value.length === 0) {
                    return;
                }
                this.maybeSetNormalizedName(update.name, key);
                var /** @type {?} */ base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];
                base.push.apply(base, value);
                this.headers.set(key, base);
                break;
            case 'd':
                var /** @type {?} */ toDelete_1 = /** @type {?} */ (update.value);
                if (!toDelete_1) {
                    this.headers.delete(key);
                    this.normalizedNames.delete(key);
                }
                else {
                    var /** @type {?} */ existing = this.headers.get(key);
                    if (!existing) {
                        return;
                    }
                    existing = existing.filter(function (value) { return toDelete_1.indexOf(value) === -1; });
                    if (existing.length === 0) {
                        this.headers.delete(key);
                        this.normalizedNames.delete(key);
                    }
                    else {
                        this.headers.set(key, existing);
                    }
                }
                break;
        }
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} fn
     * @return {?}
     */
    HttpHeaders.prototype.forEach = /**
     * \@internal
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        var _this = this;
        this.init();
        Array.from(this.normalizedNames.keys())
            .forEach(function (key) { return fn(/** @type {?} */ ((_this.normalizedNames.get(key))), /** @type {?} */ ((_this.headers.get(key)))); });
    };
    return HttpHeaders;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A codec for encoding and decoding parameters in URLs.
 *
 * Used by `HttpParams`.
 *
 * \@stable
 *
 * @record
 */

/**
 * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to
 * serialize and parse URL parameter keys and values.
 *
 * \@stable
 */
var HttpUrlEncodingCodec = /** @class */ (function () {
    function HttpUrlEncodingCodec() {
    }
    /**
     * @param {?} k
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.encodeKey = /**
     * @param {?} k
     * @return {?}
     */
    function (k) { return standardEncoding(k); };
    /**
     * @param {?} v
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.encodeValue = /**
     * @param {?} v
     * @return {?}
     */
    function (v) { return standardEncoding(v); };
    /**
     * @param {?} k
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.decodeKey = /**
     * @param {?} k
     * @return {?}
     */
    function (k) { return decodeURIComponent(k); };
    /**
     * @param {?} v
     * @return {?}
     */
    HttpUrlEncodingCodec.prototype.decodeValue = /**
     * @param {?} v
     * @return {?}
     */
    function (v) { return decodeURIComponent(v); };
    return HttpUrlEncodingCodec;
}());
/**
 * @param {?} rawParams
 * @param {?} codec
 * @return {?}
 */
function paramParser(rawParams, codec) {
    var /** @type {?} */ map$$1 = new Map();
    if (rawParams.length > 0) {
        var /** @type {?} */ params = rawParams.split('&');
        params.forEach(function (param) {
            var /** @type {?} */ eqIdx = param.indexOf('=');
            var _a = eqIdx == -1 ?
                [codec.decodeKey(param), ''] :
                [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))], key = _a[0], val = _a[1];
            var /** @type {?} */ list = map$$1.get(key) || [];
            list.push(val);
            map$$1.set(key, list);
        });
    }
    return map$$1;
}
/**
 * @param {?} v
 * @return {?}
 */
function standardEncoding(v) {
    return encodeURIComponent(v)
        .replace(/%40/gi, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/gi, '$')
        .replace(/%2C/gi, ',')
        .replace(/%3B/gi, ';')
        .replace(/%2B/gi, '+')
        .replace(/%3D/gi, '=')
        .replace(/%3F/gi, '?')
        .replace(/%2F/gi, '/');
}
/**
 * Options used to construct an `HttpParams` instance.
 * @record
 */

/**
 * An HTTP request/response body that represents serialized parameters,
 * per the MIME type `application/x-www-form-urlencoded`.
 *
 * This class is immutable - all mutation operations return a new instance.
 *
 * \@stable
 */
var HttpParams = /** @class */ (function () {
    function HttpParams(options) {
        if (options === void 0) { options = /** @type {?} */ ({}); }
        var _this = this;
        this.updates = null;
        this.cloneFrom = null;
        this.encoder = options.encoder || new HttpUrlEncodingCodec();
        if (!!options.fromString) {
            if (!!options.fromObject) {
                throw new Error("Cannot specify both fromString and fromObject.");
            }
            this.map = paramParser(options.fromString, this.encoder);
        }
        else if (!!options.fromObject) {
            this.map = new Map();
            Object.keys(options.fromObject).forEach(function (key) {
                var /** @type {?} */ value = (/** @type {?} */ (options.fromObject))[key]; /** @type {?} */
                ((_this.map)).set(key, Array.isArray(value) ? value : [value]);
            });
        }
        else {
            this.map = null;
        }
    }
    /**
     * Check whether the body has one or more values for the given parameter name.
     */
    /**
     * Check whether the body has one or more values for the given parameter name.
     * @param {?} param
     * @return {?}
     */
    HttpParams.prototype.has = /**
     * Check whether the body has one or more values for the given parameter name.
     * @param {?} param
     * @return {?}
     */
    function (param) {
        this.init();
        return /** @type {?} */ ((this.map)).has(param);
    };
    /**
     * Get the first value for the given parameter name, or `null` if it's not present.
     */
    /**
     * Get the first value for the given parameter name, or `null` if it's not present.
     * @param {?} param
     * @return {?}
     */
    HttpParams.prototype.get = /**
     * Get the first value for the given parameter name, or `null` if it's not present.
     * @param {?} param
     * @return {?}
     */
    function (param) {
        this.init();
        var /** @type {?} */ res = /** @type {?} */ ((this.map)).get(param);
        return !!res ? res[0] : null;
    };
    /**
     * Get all values for the given parameter name, or `null` if it's not present.
     */
    /**
     * Get all values for the given parameter name, or `null` if it's not present.
     * @param {?} param
     * @return {?}
     */
    HttpParams.prototype.getAll = /**
     * Get all values for the given parameter name, or `null` if it's not present.
     * @param {?} param
     * @return {?}
     */
    function (param) {
        this.init();
        return /** @type {?} */ ((this.map)).get(param) || null;
    };
    /**
     * Get all the parameter names for this body.
     */
    /**
     * Get all the parameter names for this body.
     * @return {?}
     */
    HttpParams.prototype.keys = /**
     * Get all the parameter names for this body.
     * @return {?}
     */
    function () {
        this.init();
        return Array.from(/** @type {?} */ ((this.map)).keys());
    };
    /**
     * Construct a new body with an appended value for the given parameter name.
     */
    /**
     * Construct a new body with an appended value for the given parameter name.
     * @param {?} param
     * @param {?} value
     * @return {?}
     */
    HttpParams.prototype.append = /**
     * Construct a new body with an appended value for the given parameter name.
     * @param {?} param
     * @param {?} value
     * @return {?}
     */
    function (param, value) { return this.clone({ param: param, value: value, op: 'a' }); };
    /**
     * Construct a new body with a new value for the given parameter name.
     */
    /**
     * Construct a new body with a new value for the given parameter name.
     * @param {?} param
     * @param {?} value
     * @return {?}
     */
    HttpParams.prototype.set = /**
     * Construct a new body with a new value for the given parameter name.
     * @param {?} param
     * @param {?} value
     * @return {?}
     */
    function (param, value) { return this.clone({ param: param, value: value, op: 's' }); };
    /**
     * Construct a new body with either the given value for the given parameter
     * removed, if a value is given, or all values for the given parameter removed
     * if not.
     */
    /**
     * Construct a new body with either the given value for the given parameter
     * removed, if a value is given, or all values for the given parameter removed
     * if not.
     * @param {?} param
     * @param {?=} value
     * @return {?}
     */
    HttpParams.prototype.delete = /**
     * Construct a new body with either the given value for the given parameter
     * removed, if a value is given, or all values for the given parameter removed
     * if not.
     * @param {?} param
     * @param {?=} value
     * @return {?}
     */
    function (param, value) { return this.clone({ param: param, value: value, op: 'd' }); };
    /**
     * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are
     * separated by `&`s.
     */
    /**
     * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are
     * separated by `&`s.
     * @return {?}
     */
    HttpParams.prototype.toString = /**
     * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are
     * separated by `&`s.
     * @return {?}
     */
    function () {
        var _this = this;
        this.init();
        return this.keys()
            .map(function (key) {
            var /** @type {?} */ eKey = _this.encoder.encodeKey(key);
            return /** @type {?} */ ((/** @type {?} */ ((_this.map)).get(key))).map(function (value) { return eKey + '=' + _this.encoder.encodeValue(value); }).join('&');
        })
            .join('&');
    };
    /**
     * @param {?} update
     * @return {?}
     */
    HttpParams.prototype.clone = /**
     * @param {?} update
     * @return {?}
     */
    function (update) {
        var /** @type {?} */ clone = new HttpParams(/** @type {?} */ ({ encoder: this.encoder }));
        clone.cloneFrom = this.cloneFrom || this;
        clone.updates = (this.updates || []).concat([update]);
        return clone;
    };
    /**
     * @return {?}
     */
    HttpParams.prototype.init = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.map === null) {
            this.map = new Map();
        }
        if (this.cloneFrom !== null) {
            this.cloneFrom.init();
            this.cloneFrom.keys().forEach(function (key) { return ((_this.map)).set(key, /** @type {?} */ ((/** @type {?} */ ((/** @type {?} */ ((_this.cloneFrom)).map)).get(key)))); }); /** @type {?} */
            ((this.updates)).forEach(function (update) {
                switch (update.op) {
                    case 'a':
                    case 's':
                        var /** @type {?} */ base = (update.op === 'a' ? /** @type {?} */ ((_this.map)).get(update.param) : undefined) || [];
                        base.push(/** @type {?} */ ((update.value))); /** @type {?} */
                        ((_this.map)).set(update.param, base);
                        break;
                    case 'd':
                        if (update.value !== undefined) {
                            var /** @type {?} */ base_1 = /** @type {?} */ ((_this.map)).get(update.param) || [];
                            var /** @type {?} */ idx = base_1.indexOf(update.value);
                            if (idx !== -1) {
                                base_1.splice(idx, 1);
                            }
                            if (base_1.length > 0) {
                                /** @type {?} */ ((_this.map)).set(update.param, base_1);
                            }
                            else {
                                /** @type {?} */ ((_this.map)).delete(update.param);
                            }
                        }
                        else {
                            /** @type {?} */ ((_this.map)).delete(update.param);
                            break;
                        }
                }
            });
            this.cloneFrom = null;
        }
    };
    return HttpParams;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Determine whether the given HTTP method may include a body.
 * @param {?} method
 * @return {?}
 */
function mightHaveBody(method) {
    switch (method) {
        case 'DELETE':
        case 'GET':
        case 'HEAD':
        case 'OPTIONS':
        case 'JSONP':
            return false;
        default:
            return true;
    }
}
/**
 * Safely assert whether the given value is an ArrayBuffer.
 *
 * In some execution environments ArrayBuffer is not defined.
 * @param {?} value
 * @return {?}
 */
function isArrayBuffer(value) {
    return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;
}
/**
 * Safely assert whether the given value is a Blob.
 *
 * In some execution environments Blob is not defined.
 * @param {?} value
 * @return {?}
 */
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
/**
 * Safely assert whether the given value is a FormData instance.
 *
 * In some execution environments FormData is not defined.
 * @param {?} value
 * @return {?}
 */
function isFormData(value) {
    return typeof FormData !== 'undefined' && value instanceof FormData;
}
/**
 * An outgoing HTTP request with an optional typed body.
 *
 * `HttpRequest` represents an outgoing request, including URL, method,
 * headers, body, and other request configuration options. Instances should be
 * assumed to be immutable. To modify a `HttpRequest`, the `clone`
 * method should be used.
 *
 * \@stable
 */
var HttpRequest = /** @class */ (function () {
    function HttpRequest(method, url, third, fourth) {
        this.url = url;
        /**
         * The request body, or `null` if one isn't set.
         *
         * Bodies are not enforced to be immutable, as they can include a reference to any
         * user-defined data type. However, interceptors should take care to preserve
         * idempotence by treating them as such.
         */
        this.body = null;
        /**
         * Whether this request should be made in a way that exposes progress events.
         *
         * Progress events are expensive (change detection runs on each event) and so
         * they should only be requested if the consumer intends to monitor them.
         */
        this.reportProgress = false;
        /**
         * Whether this request should be sent with outgoing credentials (cookies).
         */
        this.withCredentials = false;
        /**
         * The expected response type of the server.
         *
         * This is used to parse the response appropriately before returning it to
         * the requestee.
         */
        this.responseType = 'json';
        this.method = method.toUpperCase();
        // Next, need to figure out which argument holds the HttpRequestInit
        // options, if any.
        var /** @type {?} */ options;
        // Check whether a body argument is expected. The only valid way to omit
        // the body argument is to use a known no-body method like GET.
        if (mightHaveBody(this.method) || !!fourth) {
            // Body is the third argument, options are the fourth.
            this.body = (third !== undefined) ? /** @type {?} */ (third) : null;
            options = fourth;
        }
        else {
            // No body required, options are the third argument. The body stays null.
            options = /** @type {?} */ (third);
        }
        // If options have been passed, interpret them.
        if (options) {
            // Normalize reportProgress and withCredentials.
            this.reportProgress = !!options.reportProgress;
            this.withCredentials = !!options.withCredentials;
            // Override default response type of 'json' if one is provided.
            if (!!options.responseType) {
                this.responseType = options.responseType;
            }
            // Override headers if they're provided.
            if (!!options.headers) {
                this.headers = options.headers;
            }
            if (!!options.params) {
                this.params = options.params;
            }
        }
        // If no headers have been passed in, construct a new HttpHeaders instance.
        if (!this.headers) {
            this.headers = new HttpHeaders();
        }
        // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.
        if (!this.params) {
            this.params = new HttpParams();
            this.urlWithParams = url;
        }
        else {
            // Encode the parameters to a string in preparation for inclusion in the URL.
            var /** @type {?} */ params = this.params.toString();
            if (params.length === 0) {
                // No parameters, the visible URL is just the URL given at creation time.
                this.urlWithParams = url;
            }
            else {
                // Does the URL already have query parameters? Look for '?'.
                var /** @type {?} */ qIdx = url.indexOf('?');
                // There are 3 cases to handle:
                // 1) No existing parameters -> append '?' followed by params.
                // 2) '?' exists and is followed by existing query string ->
                //    append '&' followed by params.
                // 3) '?' exists at the end of the url -> append params directly.
                // This basically amounts to determining the character, if any, with
                // which to join the URL and parameters.
                var /** @type {?} */ sep = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');
                this.urlWithParams = url + sep + params;
            }
        }
    }
    /**
     * Transform the free-form body into a serialized format suitable for
     * transmission to the server.
     */
    /**
     * Transform the free-form body into a serialized format suitable for
     * transmission to the server.
     * @return {?}
     */
    HttpRequest.prototype.serializeBody = /**
     * Transform the free-form body into a serialized format suitable for
     * transmission to the server.
     * @return {?}
     */
    function () {
        // If no body is present, no need to serialize it.
        if (this.body === null) {
            return null;
        }
        // Check whether the body is already in a serialized form. If so,
        // it can just be returned directly.
        if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||
            typeof this.body === 'string') {
            return this.body;
        }
        // Check whether the body is an instance of HttpUrlEncodedParams.
        if (this.body instanceof HttpParams) {
            return this.body.toString();
        }
        // Check whether the body is an object or array, and serialize with JSON if so.
        if (typeof this.body === 'object' || typeof this.body === 'boolean' ||
            Array.isArray(this.body)) {
            return JSON.stringify(this.body);
        }
        // Fall back on toString() for everything else.
        return (/** @type {?} */ (this.body)).toString();
    };
    /**
     * Examine the body and attempt to infer an appropriate MIME type
     * for it.
     *
     * If no such type can be inferred, this method will return `null`.
     */
    /**
     * Examine the body and attempt to infer an appropriate MIME type
     * for it.
     *
     * If no such type can be inferred, this method will return `null`.
     * @return {?}
     */
    HttpRequest.prototype.detectContentTypeHeader = /**
     * Examine the body and attempt to infer an appropriate MIME type
     * for it.
     *
     * If no such type can be inferred, this method will return `null`.
     * @return {?}
     */
    function () {
        // An empty body has no content type.
        if (this.body === null) {
            return null;
        }
        // FormData bodies rely on the browser's content type assignment.
        if (isFormData(this.body)) {
            return null;
        }
        // Blobs usually have their own content type. If it doesn't, then
        // no type can be inferred.
        if (isBlob(this.body)) {
            return this.body.type || null;
        }
        // Array buffers have unknown contents and thus no type can be inferred.
        if (isArrayBuffer(this.body)) {
            return null;
        }
        // Technically, strings could be a form of JSON data, but it's safe enough
        // to assume they're plain strings.
        if (typeof this.body === 'string') {
            return 'text/plain';
        }
        // `HttpUrlEncodedParams` has its own content-type.
        if (this.body instanceof HttpParams) {
            return 'application/x-www-form-urlencoded;charset=UTF-8';
        }
        // Arrays, objects, and numbers will be encoded as JSON.
        if (typeof this.body === 'object' || typeof this.body === 'number' ||
            Array.isArray(this.body)) {
            return 'application/json';
        }
        // No type could be inferred.
        return null;
    };
    /**
     * @param {?=} update
     * @return {?}
     */
    HttpRequest.prototype.clone = /**
     * @param {?=} update
     * @return {?}
     */
    function (update) {
        if (update === void 0) { update = {}; }
        // For method, url, and responseType, take the current value unless
        // it is overridden in the update hash.
        var /** @type {?} */ method = update.method || this.method;
        var /** @type {?} */ url = update.url || this.url;
        var /** @type {?} */ responseType = update.responseType || this.responseType;
        // The body is somewhat special - a `null` value in update.body means
        // whatever current body is present is being overridden with an empty
        // body, whereas an `undefined` value in update.body implies no
        // override.
        var /** @type {?} */ body = (update.body !== undefined) ? update.body : this.body;
        // Carefully handle the boolean options to differentiate between
        // `false` and `undefined` in the update args.
        var /** @type {?} */ withCredentials = (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;
        var /** @type {?} */ reportProgress = (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;
        // Headers and params may be appended to if `setHeaders` or
        // `setParams` are used.
        var /** @type {?} */ headers = update.headers || this.headers;
        var /** @type {?} */ params = update.params || this.params;
        // Check whether the caller has asked to add headers.
        if (update.setHeaders !== undefined) {
            // Set every requested header.
            headers =
                Object.keys(update.setHeaders)
                    .reduce(function (headers, name) { return headers.set(name, /** @type {?} */ ((update.setHeaders))[name]); }, headers);
        }
        // Check whether the caller has asked to set params.
        if (update.setParams) {
            // Set every requested param.
            params = Object.keys(update.setParams)
                .reduce(function (params, param) { return params.set(param, /** @type {?} */ ((update.setParams))[param]); }, params);
        }
        // Finally, construct the new HttpRequest using the pieces from above.
        return new HttpRequest(method, url, body, {
            params: params, headers: headers, reportProgress: reportProgress, responseType: responseType, withCredentials: withCredentials,
        });
    };
    return HttpRequest;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** @enum {number} */
var HttpEventType = {
    /**
       * The request was sent out over the wire.
       */
    Sent: 0,
    /**
       * An upload progress event was received.
       */
    UploadProgress: 1,
    /**
       * The response status code and headers were received.
       */
    ResponseHeader: 2,
    /**
       * A download progress event was received.
       */
    DownloadProgress: 3,
    /**
       * The full response including the body was received.
       */
    Response: 4,
    /**
       * A custom event from an interceptor or a backend.
       */
    User: 5,
};
HttpEventType[HttpEventType.Sent] = "Sent";
HttpEventType[HttpEventType.UploadProgress] = "UploadProgress";
HttpEventType[HttpEventType.ResponseHeader] = "ResponseHeader";
HttpEventType[HttpEventType.DownloadProgress] = "DownloadProgress";
HttpEventType[HttpEventType.Response] = "Response";
HttpEventType[HttpEventType.User] = "User";
/**
 * Base interface for progress events.
 *
 * \@stable
 * @record
 */

/**
 * A download progress event.
 *
 * \@stable
 * @record
 */

/**
 * An upload progress event.
 *
 * \@stable
 * @record
 */

/**
 * An event indicating that the request was sent to the server. Useful
 * when a request may be retried multiple times, to distinguish between
 * retries on the final event stream.
 *
 * \@stable
 * @record
 */

/**
 * A user-defined event.
 *
 * Grouping all custom events under this type ensures they will be handled
 * and forwarded by all implementations of interceptors.
 *
 * \@stable
 * @record
 */

/**
 * An error that represents a failed attempt to JSON.parse text coming back
 * from the server.
 *
 * It bundles the Error object with the actual response body that failed to parse.
 *
 * \@stable
 * @record
 */

/**
 * Base class for both `HttpResponse` and `HttpHeaderResponse`.
 *
 * \@stable
 * @abstract
 */
var HttpResponseBase = /** @class */ (function () {
    /**
     * Super-constructor for all responses.
     *
     * The single parameter accepted is an initialization hash. Any properties
     * of the response passed there will override the default values.
     */
    function HttpResponseBase(init, defaultStatus, defaultStatusText) {
        if (defaultStatus === void 0) { defaultStatus = 200; }
        if (defaultStatusText === void 0) { defaultStatusText = 'OK'; }
        // If the hash has values passed, use them to initialize the response.
        // Otherwise use the default values.
        this.headers = init.headers || new HttpHeaders();
        this.status = init.status !== undefined ? init.status : defaultStatus;
        this.statusText = init.statusText || defaultStatusText;
        this.url = init.url || null;
        // Cache the ok value to avoid defining a getter.
        this.ok = this.status >= 200 && this.status < 300;
    }
    return HttpResponseBase;
}());
/**
 * A partial HTTP response which only includes the status and header data,
 * but no response body.
 *
 * `HttpHeaderResponse` is a `HttpEvent` available on the response
 * event stream, only when progress events are requested.
 *
 * \@stable
 */
var HttpHeaderResponse = /** @class */ (function (_super) {
    tslib.__extends(HttpHeaderResponse, _super);
    /**
     * Create a new `HttpHeaderResponse` with the given parameters.
     */
    function HttpHeaderResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.ResponseHeader;
        return _this;
    }
    /**
     * Copy this `HttpHeaderResponse`, overriding its contents with the
     * given parameter hash.
     */
    /**
     * Copy this `HttpHeaderResponse`, overriding its contents with the
     * given parameter hash.
     * @param {?=} update
     * @return {?}
     */
    HttpHeaderResponse.prototype.clone = /**
     * Copy this `HttpHeaderResponse`, overriding its contents with the
     * given parameter hash.
     * @param {?=} update
     * @return {?}
     */
    function (update) {
        if (update === void 0) { update = {}; }
        // Perform a straightforward initialization of the new HttpHeaderResponse,
        // overriding the current parameters with new ones if given.
        return new HttpHeaderResponse({
            headers: update.headers || this.headers,
            status: update.status !== undefined ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpHeaderResponse;
}(HttpResponseBase));
/**
 * A full HTTP response, including a typed response body (which may be `null`
 * if one was not returned).
 *
 * `HttpResponse` is a `HttpEvent` available on the response event
 * stream.
 *
 * \@stable
 */
var HttpResponse = /** @class */ (function (_super) {
    tslib.__extends(HttpResponse, _super);
    /**
     * Construct a new `HttpResponse`.
     */
    function HttpResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.Response;
        _this.body = init.body !== undefined ? init.body : null;
        return _this;
    }
    /**
     * @param {?=} update
     * @return {?}
     */
    HttpResponse.prototype.clone = /**
     * @param {?=} update
     * @return {?}
     */
    function (update) {
        if (update === void 0) { update = {}; }
        return new HttpResponse({
            body: (update.body !== undefined) ? update.body : this.body,
            headers: update.headers || this.headers,
            status: (update.status !== undefined) ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpResponse;
}(HttpResponseBase));
/**
 * A response that represents an error or failure, either from a
 * non-successful HTTP status, an error while executing the request,
 * or some other failure which occurred during the parsing of the response.
 *
 * Any error returned on the `Observable` response stream will be
 * wrapped in an `HttpErrorResponse` to provide additional context about
 * the state of the HTTP layer when the error occurred. The error property
 * will contain either a wrapped Error object or the error response returned
 * from the server.
 *
 * \@stable
 */
var HttpErrorResponse = /** @class */ (function (_super) {
    tslib.__extends(HttpErrorResponse, _super);
    function HttpErrorResponse(init) {
        var _this = 
        // Initialize with a default status of 0 / Unknown Error.
        _super.call(this, init, 0, 'Unknown Error') || this;
        _this.name = 'HttpErrorResponse';
        /**
         * Errors are never okay, even when the status code is in the 2xx success range.
         */
        _this.ok = false;
        // If the response was successful, then this was a parse error. Otherwise, it was
        // a protocol-level failure of some sort. Either the request failed in transit
        // or the server returned an unsuccessful status code.
        if (_this.status >= 200 && _this.status < 300) {
            _this.message = "Http failure during parsing for " + (init.url || '(unknown url)');
        }
        else {
            _this.message =
                "Http failure response for " + (init.url || '(unknown url)') + ": " + init.status + " " + init.statusText;
        }
        _this.error = init.error || null;
        return _this;
    }
    return HttpErrorResponse;
}(HttpResponseBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Construct an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and
 * the given `body`. Basically, this clones the object and adds the body.
 * @template T
 * @param {?} options
 * @param {?} body
 * @return {?}
 */
function addBody(options, body) {
    return {
        body: body,
        headers: options.headers,
        observe: options.observe,
        params: options.params,
        reportProgress: options.reportProgress,
        responseType: options.responseType,
        withCredentials: options.withCredentials,
    };
}
/**
 * Perform HTTP requests.
 *
 * `HttpClient` is available as an injectable class, with methods to perform HTTP requests.
 * Each request method has multiple signatures, and the return type varies according to which
 * signature is called (mainly the values of `observe` and `responseType`).
 *
 * \@stable
 */
var HttpClient = /** @class */ (function () {
    function HttpClient(handler) {
        this.handler = handler;
    }
    /**
     * Constructs an `Observable` for a particular HTTP request that, when subscribed,
     * fires the request through the chain of registered interceptors and on to the
     * server.
     *
     * This method can be called in one of two ways. Either an `HttpRequest`
     * instance can be passed directly as the only parameter, or a method can be
     * passed as the first parameter, a string URL as the second, and an
     * options hash as the third.
     *
     * If a `HttpRequest` object is passed directly, an `Observable` of the
     * raw `HttpEvent` stream will be returned.
     *
     * If a request is instead built by providing a URL, the options object
     * determines the return type of `request()`. In addition to configuring
     * request parameters such as the outgoing headers and/or the body, the options
     * hash specifies two key pieces of information about the request: the
     * `responseType` and what to `observe`.
     *
     * The `responseType` value determines how a successful response body will be
     * parsed. If `responseType` is the default `json`, a type interface for the
     * resulting object may be passed as a type parameter to `request()`.
     *
     * The `observe` value determines the return type of `request()`, based on what
     * the consumer is interested in observing. A value of `events` will return an
     * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,
     * including progress events by default. A value of `response` will return an
     * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`
     * depends on the `responseType` and any optionally provided type parameter.
     * A value of `body` will return an `Observable<T>` with the same `T` body type.
     */
    /**
     * Constructs an `Observable` for a particular HTTP request that, when subscribed,
     * fires the request through the chain of registered interceptors and on to the
     * server.
     *
     * This method can be called in one of two ways. Either an `HttpRequest`
     * instance can be passed directly as the only parameter, or a method can be
     * passed as the first parameter, a string URL as the second, and an
     * options hash as the third.
     *
     * If a `HttpRequest` object is passed directly, an `Observable` of the
     * raw `HttpEvent` stream will be returned.
     *
     * If a request is instead built by providing a URL, the options object
     * determines the return type of `request()`. In addition to configuring
     * request parameters such as the outgoing headers and/or the body, the options
     * hash specifies two key pieces of information about the request: the
     * `responseType` and what to `observe`.
     *
     * The `responseType` value determines how a successful response body will be
     * parsed. If `responseType` is the default `json`, a type interface for the
     * resulting object may be passed as a type parameter to `request()`.
     *
     * The `observe` value determines the return type of `request()`, based on what
     * the consumer is interested in observing. A value of `events` will return an
     * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,
     * including progress events by default. A value of `response` will return an
     * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`
     * depends on the `responseType` and any optionally provided type parameter.
     * A value of `body` will return an `Observable<T>` with the same `T` body type.
     * @param {?} first
     * @param {?=} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.request = /**
     * Constructs an `Observable` for a particular HTTP request that, when subscribed,
     * fires the request through the chain of registered interceptors and on to the
     * server.
     *
     * This method can be called in one of two ways. Either an `HttpRequest`
     * instance can be passed directly as the only parameter, or a method can be
     * passed as the first parameter, a string URL as the second, and an
     * options hash as the third.
     *
     * If a `HttpRequest` object is passed directly, an `Observable` of the
     * raw `HttpEvent` stream will be returned.
     *
     * If a request is instead built by providing a URL, the options object
     * determines the return type of `request()`. In addition to configuring
     * request parameters such as the outgoing headers and/or the body, the options
     * hash specifies two key pieces of information about the request: the
     * `responseType` and what to `observe`.
     *
     * The `responseType` value determines how a successful response body will be
     * parsed. If `responseType` is the default `json`, a type interface for the
     * resulting object may be passed as a type parameter to `request()`.
     *
     * The `observe` value determines the return type of `request()`, based on what
     * the consumer is interested in observing. A value of `events` will return an
     * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,
     * including progress events by default. A value of `response` will return an
     * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`
     * depends on the `responseType` and any optionally provided type parameter.
     * A value of `body` will return an `Observable<T>` with the same `T` body type.
     * @param {?} first
     * @param {?=} url
     * @param {?=} options
     * @return {?}
     */
    function (first, url, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var /** @type {?} */ req;
        // Firstly, check whether the primary argument is an instance of `HttpRequest`.
        if (first instanceof HttpRequest) {
            // It is. The other arguments must be undefined (per the signatures) and can be
            // ignored.
            req = /** @type {?} */ (first);
        }
        else {
            // It's a string, so it represents a URL. Construct a request based on it,
            // and incorporate the remaining arguments (assuming GET unless a method is
            // provided.
            // Figure out the headers.
            var /** @type {?} */ headers = undefined;
            if (options.headers instanceof HttpHeaders) {
                headers = options.headers;
            }
            else {
                headers = new HttpHeaders(options.headers);
            }
            // Sort out parameters.
            var /** @type {?} */ params = undefined;
            if (!!options.params) {
                if (options.params instanceof HttpParams) {
                    params = options.params;
                }
                else {
                    params = new HttpParams(/** @type {?} */ ({ fromObject: options.params }));
                }
            }
            // Construct the request.
            req = new HttpRequest(first, /** @type {?} */ ((url)), (options.body !== undefined ? options.body : null), {
                headers: headers,
                params: params,
                reportProgress: options.reportProgress,
                // By default, JSON is assumed to be returned for all calls.
                responseType: options.responseType || 'json',
                withCredentials: options.withCredentials,
            });
        }
        // Start with an Observable.of() the initial request, and run the handler (which
        // includes all interceptors) inside a concatMap(). This way, the handler runs
        // inside an Observable chain, which causes interceptors to be re-run on every
        // subscription (this also makes retries re-run the handler, including interceptors).
        var /** @type {?} */ events$ = rxjs_operator_concatMap.concatMap.call(rxjs_observable_of.of(req), function (req) { return _this.handler.handle(req); });
        // If coming via the API signature which accepts a previously constructed HttpRequest,
        // the only option is to get the event stream. Otherwise, return the event stream if
        // that is what was requested.
        if (first instanceof HttpRequest || options.observe === 'events') {
            return events$;
        }
        // The requested stream contains either the full response or the body. In either
        // case, the first step is to filter the event stream to extract a stream of
        // responses(s).
        var /** @type {?} */ res$ = rxjs_operator_filter.filter.call(events$, function (event) { return event instanceof HttpResponse; });
        // Decide which stream to return.
        switch (options.observe || 'body') {
            case 'body':
                // The requested stream is the body. Map the response stream to the response
                // body. This could be done more simply, but a misbehaving interceptor might
                // transform the response body into a different format and ignore the requested
                // responseType. Guard against this by validating that the response is of the
                // requested type.
                switch (req.responseType) {
                    case 'arraybuffer':
                        return rxjs_operator_map.map.call(res$, function (res) {
                            // Validate that the body is an ArrayBuffer.
                            if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                                throw new Error('Response is not an ArrayBuffer.');
                            }
                            return res.body;
                        });
                    case 'blob':
                        return rxjs_operator_map.map.call(res$, function (res) {
                            // Validate that the body is a Blob.
                            if (res.body !== null && !(res.body instanceof Blob)) {
                                throw new Error('Response is not a Blob.');
                            }
                            return res.body;
                        });
                    case 'text':
                        return rxjs_operator_map.map.call(res$, function (res) {
                            // Validate that the body is a string.
                            if (res.body !== null && typeof res.body !== 'string') {
                                throw new Error('Response is not a string.');
                            }
                            return res.body;
                        });
                    case 'json':
                    default:
                        // No validation needed for JSON responses, as they can be of any type.
                        return rxjs_operator_map.map.call(res$, function (res) { return res.body; });
                }
            case 'response':
                // The response stream was requested directly, so return it.
                return res$;
            default:
                // Guard against new future observe types being added.
                throw new Error("Unreachable: unhandled observe type " + options.observe + "}");
        }
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * DELETE request to be executed on the server. See the individual overloads for
     * details of `delete()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * DELETE request to be executed on the server. See the individual overloads for
     * details of `delete()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.delete = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * DELETE request to be executed on the server. See the individual overloads for
     * details of `delete()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('DELETE', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * GET request to be executed on the server. See the individual overloads for
     * details of `get()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * GET request to be executed on the server. See the individual overloads for
     * details of `get()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.get = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * GET request to be executed on the server. See the individual overloads for
     * details of `get()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('GET', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * HEAD request to be executed on the server. See the individual overloads for
     * details of `head()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * HEAD request to be executed on the server. See the individual overloads for
     * details of `head()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.head = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * HEAD request to be executed on the server. See the individual overloads for
     * details of `head()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('HEAD', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause a request
     * with the special method `JSONP` to be dispatched via the interceptor pipeline.
     *
     * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).
     * If no such interceptor is reached, then the `JSONP` request will likely be
     * rejected by the configured backend.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause a request
     * with the special method `JSONP` to be dispatched via the interceptor pipeline.
     *
     * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).
     * If no such interceptor is reached, then the `JSONP` request will likely be
     * rejected by the configured backend.
     * @template T
     * @param {?} url
     * @param {?} callbackParam
     * @return {?}
     */
    HttpClient.prototype.jsonp = /**
     * Constructs an `Observable` which, when subscribed, will cause a request
     * with the special method `JSONP` to be dispatched via the interceptor pipeline.
     *
     * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).
     * If no such interceptor is reached, then the `JSONP` request will likely be
     * rejected by the configured backend.
     * @template T
     * @param {?} url
     * @param {?} callbackParam
     * @return {?}
     */
    function (url, callbackParam) {
        return this.request('JSONP', url, {
            params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),
            observe: 'body',
            responseType: 'json',
        });
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * OPTIONS request to be executed on the server. See the individual overloads for
     * details of `options()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * OPTIONS request to be executed on the server. See the individual overloads for
     * details of `options()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.options = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * OPTIONS request to be executed on the server. See the individual overloads for
     * details of `options()`'s return type based on the provided options.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('OPTIONS', url, /** @type {?} */ (options));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * PATCH request to be executed on the server. See the individual overloads for
     * details of `patch()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * PATCH request to be executed on the server. See the individual overloads for
     * details of `patch()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.patch = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * PATCH request to be executed on the server. See the individual overloads for
     * details of `patch()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PATCH', url, addBody(options, body));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.post = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('POST', url, addBody(options, body));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     */
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    HttpClient.prototype.put = /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PUT', url, addBody(options, body));
    };
    HttpClient.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    HttpClient.ctorParameters = function () { return [
        { type: HttpHandler, },
    ]; };
    return HttpClient;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Intercepts `HttpRequest` and handles them.
 *
 * Most interceptors will transform the outgoing request before passing it to the
 * next interceptor in the chain, by calling `next.handle(transformedReq)`.
 *
 * In rare cases, interceptors may wish to completely handle a request themselves,
 * and not delegate to the remainder of the chain. This behavior is allowed.
 *
 * \@stable
 * @record
 */

/**
 * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.
 *
 * \@stable
 */
var HttpInterceptorHandler = /** @class */ (function () {
    function HttpInterceptorHandler(next, interceptor) {
        this.next = next;
        this.interceptor = interceptor;
    }
    /**
     * @param {?} req
     * @return {?}
     */
    HttpInterceptorHandler.prototype.handle = /**
     * @param {?} req
     * @return {?}
     */
    function (req) {
        return this.interceptor.intercept(req, this.next);
    };
    return HttpInterceptorHandler;
}());
/**
 * A multi-provider token which represents the array of `HttpInterceptor`s that
 * are registered.
 *
 * \@stable
 */
var HTTP_INTERCEPTORS = new _angular_core.InjectionToken('HTTP_INTERCEPTORS');
var NoopInterceptor = /** @class */ (function () {
    function NoopInterceptor() {
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    NoopInterceptor.prototype.intercept = /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    function (req, next) {
        return next.handle(req);
    };
    NoopInterceptor.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    NoopInterceptor.ctorParameters = function () { return []; };
    return NoopInterceptor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Every request made through JSONP needs a callback name that's unique across the
// whole page. Each request is assigned an id and the callback name is constructed
// from that. The next id to be assigned is tracked in a global variable here that
// is shared among all applications on the page.
var nextRequestId = 0;
// Error text given when a JSONP script is injected, but doesn't invoke the callback
// passed in its URL.
var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
// Error text given when a request is passed to the JsonpClientBackend that doesn't
// have a request method JSONP.
var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';
var JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';
/**
 * DI token/abstract type representing a map of JSONP callbacks.
 *
 * In the browser, this should always be the `window` object.
 *
 * \@stable
 * @abstract
 */
var JsonpCallbackContext = /** @class */ (function () {
    function JsonpCallbackContext() {
    }
    return JsonpCallbackContext;
}());
/**
 * `HttpBackend` that only processes `HttpRequest` with the JSONP method,
 * by performing JSONP style requests.
 *
 * \@stable
 */
var JsonpClientBackend = /** @class */ (function () {
    function JsonpClientBackend(callbackMap, document) {
        this.callbackMap = callbackMap;
        this.document = document;
    }
    /**
     * Get the name of the next callback method, by incrementing the global `nextRequestId`.
     * @return {?}
     */
    JsonpClientBackend.prototype.nextCallback = /**
     * Get the name of the next callback method, by incrementing the global `nextRequestId`.
     * @return {?}
     */
    function () { return "ng_jsonp_callback_" + nextRequestId++; };
    /**
     * Process a JSONP request and return an event stream of the results.
     */
    /**
     * Process a JSONP request and return an event stream of the results.
     * @param {?} req
     * @return {?}
     */
    JsonpClientBackend.prototype.handle = /**
     * Process a JSONP request and return an event stream of the results.
     * @param {?} req
     * @return {?}
     */
    function (req) {
        var _this = this;
        // Firstly, check both the method and response type. If either doesn't match
        // then the request was improperly routed here and cannot be handled.
        if (req.method !== 'JSONP') {
            throw new Error(JSONP_ERR_WRONG_METHOD);
        }
        else if (req.responseType !== 'json') {
            throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
        }
        // Everything else happens inside the Observable boundary.
        return new rxjs_Observable.Observable(function (observer) {
            // The first step to make a request is to generate the callback name, and replace the
            // callback placeholder in the URL with the name. Care has to be taken here to ensure
            // a trailing &, if matched, gets inserted back into the URL in the correct place.
            var /** @type {?} */ callback = _this.nextCallback();
            var /** @type {?} */ url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, "=" + callback + "$1");
            // Construct the <script> tag and point it at the URL.
            var /** @type {?} */ node = _this.document.createElement('script');
            node.src = url;
            // A JSONP request requires waiting for multiple callbacks. These variables
            // are closed over and track state across those callbacks.
            // The response object, if one has been received, or null otherwise.
            var /** @type {?} */ body = null;
            // Whether the response callback has been called.
            var /** @type {?} */ finished = false;
            // Whether the request has been cancelled (and thus any other callbacks)
            // should be ignored.
            var /** @type {?} */ cancelled = false;
            // Set the response callback in this.callbackMap (which will be the window
            // object in the browser. The script being loaded via the <script> tag will
            // eventually call this callback.
            // Set the response callback in this.callbackMap (which will be the window
            // object in the browser. The script being loaded via the <script> tag will
            // eventually call this callback.
            _this.callbackMap[callback] = function (data) {
                // Data has been received from the JSONP script. Firstly, delete this callback.
                delete _this.callbackMap[callback];
                // Next, make sure the request wasn't cancelled in the meantime.
                if (cancelled) {
                    return;
                }
                // Set state to indicate data was received.
                body = data;
                finished = true;
            };
            // cleanup() is a utility closure that removes the <script> from the page and
            // the response callback from the window. This logic is used in both the
            // success, error, and cancellation paths, so it's extracted out for convenience.
            var /** @type {?} */ cleanup = function () {
                // Remove the <script> tag if it's still on the page.
                if (node.parentNode) {
                    node.parentNode.removeChild(node);
                }
                // Remove the response callback from the callbackMap (window object in the
                // browser).
                delete _this.callbackMap[callback];
            };
            // onLoad() is the success callback which runs after the response callback
            // if the JSONP script loads successfully. The event itself is unimportant.
            // If something went wrong, onLoad() may run without the response callback
            // having been invoked.
            var /** @type {?} */ onLoad = function (event) {
                // Do nothing if the request has been cancelled.
                if (cancelled) {
                    return;
                }
                // Cleanup the page.
                cleanup();
                // Check whether the response callback has run.
                if (!finished) {
                    // It hasn't, something went wrong with the request. Return an error via
                    // the Observable error path. All JSONP errors have status 0.
                    observer.error(new HttpErrorResponse({
                        url: url,
                        status: 0,
                        statusText: 'JSONP Error',
                        error: new Error(JSONP_ERR_NO_CALLBACK),
                    }));
                    return;
                }
                // Success. body either contains the response body or null if none was
                // returned.
                observer.next(new HttpResponse({
                    body: body,
                    status: 200,
                    statusText: 'OK', url: url,
                }));
                // Complete the stream, the resposne is over.
                observer.complete();
            };
            // onError() is the error callback, which runs if the script returned generates
            // a Javascript error. It emits the error via the Observable error channel as
            // a HttpErrorResponse.
            var /** @type {?} */ onError = function (error) {
                // If the request was already cancelled, no need to emit anything.
                if (cancelled) {
                    return;
                }
                cleanup();
                // Wrap the error in a HttpErrorResponse.
                observer.error(new HttpErrorResponse({
                    error: error,
                    status: 0,
                    statusText: 'JSONP Error', url: url,
                }));
            };
            // Subscribe to both the success (load) and error events on the <script> tag,
            // and add it to the page.
            node.addEventListener('load', onLoad);
            node.addEventListener('error', onError);
            _this.document.body.appendChild(node);
            // The request has now been successfully sent.
            observer.next({ type: HttpEventType.Sent });
            // Cancellation handler.
            return function () {
                // Track the cancellation so event listeners won't do anything even if already scheduled.
                cancelled = true;
                // Remove the event listeners so they won't run if the events later fire.
                node.removeEventListener('load', onLoad);
                node.removeEventListener('error', onError);
                // And finally, clean up the page.
                cleanup();
            };
        });
    };
    JsonpClientBackend.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    JsonpClientBackend.ctorParameters = function () { return [
        { type: JsonpCallbackContext, },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_common.DOCUMENT,] },] },
    ]; };
    return JsonpClientBackend;
}());
/**
 * An `HttpInterceptor` which identifies requests with the method JSONP and
 * shifts them to the `JsonpClientBackend`.
 *
 * \@stable
 */
var JsonpInterceptor = /** @class */ (function () {
    function JsonpInterceptor(jsonp) {
        this.jsonp = jsonp;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    JsonpInterceptor.prototype.intercept = /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    function (req, next) {
        if (req.method === 'JSONP') {
            return this.jsonp.handle(/** @type {?} */ (req));
        }
        // Fall through for normal HTTP requests.
        return next.handle(req);
    };
    JsonpInterceptor.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    JsonpInterceptor.ctorParameters = function () { return [
        { type: JsonpClientBackend, },
    ]; };
    return JsonpInterceptor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSSI_PREFIX = /^\)\]\}',?\n/;
/**
 * Determine an appropriate URL for the response, by checking either
 * XMLHttpRequest.responseURL or the X-Request-URL header.
 * @param {?} xhr
 * @return {?}
 */
function getResponseUrl(xhr) {
    if ('responseURL' in xhr && xhr.responseURL) {
        return xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
        return xhr.getResponseHeader('X-Request-URL');
    }
    return null;
}
/**
 * A wrapper around the `XMLHttpRequest` constructor.
 *
 * \@stable
 * @abstract
 */
var XhrFactory = /** @class */ (function () {
    function XhrFactory() {
    }
    return XhrFactory;
}());
/**
 * A factory for \@{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.
 *
 * \@stable
 */
var BrowserXhr = /** @class */ (function () {
    function BrowserXhr() {
    }
    /**
     * @return {?}
     */
    BrowserXhr.prototype.build = /**
     * @return {?}
     */
    function () { return /** @type {?} */ ((new XMLHttpRequest())); };
    BrowserXhr.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    BrowserXhr.ctorParameters = function () { return []; };
    return BrowserXhr;
}());
/**
 * An `HttpBackend` which uses the XMLHttpRequest API to send
 * requests to a backend server.
 *
 * \@stable
 */
var HttpXhrBackend = /** @class */ (function () {
    function HttpXhrBackend(xhrFactory) {
        this.xhrFactory = xhrFactory;
    }
    /**
     * Process a request and return a stream of response events.
     */
    /**
     * Process a request and return a stream of response events.
     * @param {?} req
     * @return {?}
     */
    HttpXhrBackend.prototype.handle = /**
     * Process a request and return a stream of response events.
     * @param {?} req
     * @return {?}
     */
    function (req) {
        var _this = this;
        // Quick check to give a better error message when a user attempts to use
        // HttpClient.jsonp() without installing the JsonpClientModule
        if (req.method === 'JSONP') {
            throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed.");
        }
        // Everything happens on Observable subscription.
        return new rxjs_Observable.Observable(function (observer) {
            // Start by setting up the XHR object with request method, URL, and withCredentials flag.
            var /** @type {?} */ xhr = _this.xhrFactory.build();
            xhr.open(req.method, req.urlWithParams);
            if (!!req.withCredentials) {
                xhr.withCredentials = true;
            }
            // Add all the requested headers.
            req.headers.forEach(function (name, values) { return xhr.setRequestHeader(name, values.join(',')); });
            // Add an Accept header if one isn't present already.
            if (!req.headers.has('Accept')) {
                xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');
            }
            // Auto-detect the Content-Type header if one isn't present already.
            if (!req.headers.has('Content-Type')) {
                var /** @type {?} */ detectedType = req.detectContentTypeHeader();
                // Sometimes Content-Type detection fails.
                if (detectedType !== null) {
                    xhr.setRequestHeader('Content-Type', detectedType);
                }
            }
            // Set the responseType if one was requested.
            if (req.responseType) {
                var /** @type {?} */ responseType = req.responseType.toLowerCase();
                // JSON responses need to be processed as text. This is because if the server
                // returns an XSSI-prefixed JSON response, the browser will fail to parse it,
                // xhr.response will be null, and xhr.responseText cannot be accessed to
                // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON
                // is parsed by first requesting text and then applying JSON.parse.
                xhr.responseType = /** @type {?} */ (((responseType !== 'json') ? responseType : 'text'));
            }
            // Serialize the request body if one is present. If not, this will be set to null.
            var /** @type {?} */ reqBody = req.serializeBody();
            // If progress events are enabled, response headers will be delivered
            // in two events - the HttpHeaderResponse event and the full HttpResponse
            // event. However, since response headers don't change in between these
            // two events, it doesn't make sense to parse them twice. So headerResponse
            // caches the data extracted from the response whenever it's first parsed,
            // to ensure parsing isn't duplicated.
            var /** @type {?} */ headerResponse = null;
            // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest
            // state, and memoizes it into headerResponse.
            var /** @type {?} */ partialFromXhr = function () {
                if (headerResponse !== null) {
                    return headerResponse;
                }
                // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).
                var /** @type {?} */ status = xhr.status === 1223 ? 204 : xhr.status;
                var /** @type {?} */ statusText = xhr.statusText || 'OK';
                // Parse headers from XMLHttpRequest - this step is lazy.
                var /** @type {?} */ headers = new HttpHeaders(xhr.getAllResponseHeaders());
                // Read the response URL from the XMLHttpResponse instance and fall back on the
                // request URL.
                var /** @type {?} */ url = getResponseUrl(xhr) || req.url;
                // Construct the HttpHeaderResponse and memoize it.
                headerResponse = new HttpHeaderResponse({ headers: headers, status: status, statusText: statusText, url: url });
                return headerResponse;
            };
            // Next, a few closures are defined for the various events which XMLHttpRequest can
            // emit. This allows them to be unregistered as event listeners later.
            // First up is the load event, which represents a response being fully available.
            var /** @type {?} */ onLoad = function () {
                // Read response state from the memoized partial data.
                var _a = partialFromXhr(), headers = _a.headers, status = _a.status, statusText = _a.statusText, url = _a.url;
                // The body will be read out if present.
                var /** @type {?} */ body = null;
                if (status !== 204) {
                    // Use XMLHttpRequest.response if set, responseText otherwise.
                    body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;
                }
                // Normalize another potential bug (this one comes from CORS).
                if (status === 0) {
                    status = !!body ? 200 : 0;
                }
                // ok determines whether the response will be transmitted on the event or
                // error channel. Unsuccessful status codes (not 2xx) will always be errors,
                // but a successful status code can still result in an error if the user
                // asked for JSON data and the body cannot be parsed as such.
                var /** @type {?} */ ok = status >= 200 && status < 300;
                // Check whether the body needs to be parsed as JSON (in many cases the browser
                // will have done that already).
                if (req.responseType === 'json' && typeof body === 'string') {
                    // Save the original body, before attempting XSSI prefix stripping.
                    var /** @type {?} */ originalBody = body;
                    body = body.replace(XSSI_PREFIX, '');
                    try {
                        // Attempt the parse. If it fails, a parse error should be delivered to the user.
                        body = body !== '' ? JSON.parse(body) : null;
                    }
                    catch (/** @type {?} */ error) {
                        // Since the JSON.parse failed, it's reasonable to assume this might not have been a
                        // JSON response. Restore the original body (including any XSSI prefix) to deliver
                        // a better error response.
                        body = originalBody;
                        // If this was an error request to begin with, leave it as a string, it probably
                        // just isn't JSON. Otherwise, deliver the parsing error to the user.
                        if (ok) {
                            // Even though the response status was 2xx, this is still an error.
                            ok = false;
                            // The parse error contains the text of the body that failed to parse.
                            body = /** @type {?} */ ({ error: error, text: body });
                        }
                    }
                }
                if (ok) {
                    // A successful response is delivered on the event stream.
                    observer.next(new HttpResponse({
                        body: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                    // The full body has been received and delivered, no further events
                    // are possible. This request is complete.
                    observer.complete();
                }
                else {
                    // An unsuccessful request is delivered on the error channel.
                    observer.error(new HttpErrorResponse({
                        // The error in this case is the response body (error from the server).
                        error: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                }
            };
            // The onError callback is called when something goes wrong at the network level.
            // Connection timeout, DNS error, offline, etc. These are actual errors, and are
            // transmitted on the error channel.
            var /** @type {?} */ onError = function (error) {
                var /** @type {?} */ res = new HttpErrorResponse({
                    error: error,
                    status: xhr.status || 0,
                    statusText: xhr.statusText || 'Unknown Error',
                });
                observer.error(res);
            };
            // The sentHeaders flag tracks whether the HttpResponseHeaders event
            // has been sent on the stream. This is necessary to track if progress
            // is enabled since the event will be sent on only the first download
            // progerss event.
            var /** @type {?} */ sentHeaders = false;
            // The download progress event handler, which is only registered if
            // progress events are enabled.
            var /** @type {?} */ onDownProgress = function (event) {
                // Send the HttpResponseHeaders event if it hasn't been sent already.
                if (!sentHeaders) {
                    observer.next(partialFromXhr());
                    sentHeaders = true;
                }
                // Start building the download progress event to deliver on the response
                // event stream.
                var /** @type {?} */ progressEvent = {
                    type: HttpEventType.DownloadProgress,
                    loaded: event.loaded,
                };
                // Set the total number of bytes in the event if it's available.
                if (event.lengthComputable) {
                    progressEvent.total = event.total;
                }
                // If the request was for text content and a partial response is
                // available on XMLHttpRequest, include it in the progress event
                // to allow for streaming reads.
                if (req.responseType === 'text' && !!xhr.responseText) {
                    progressEvent.partialText = xhr.responseText;
                }
                // Finally, fire the event.
                observer.next(progressEvent);
            };
            // The upload progress event handler, which is only registered if
            // progress events are enabled.
            var /** @type {?} */ onUpProgress = function (event) {
                // Upload progress events are simpler. Begin building the progress
                // event.
                var /** @type {?} */ progress = {
                    type: HttpEventType.UploadProgress,
                    loaded: event.loaded,
                };
                // If the total number of bytes being uploaded is available, include
                // it.
                if (event.lengthComputable) {
                    progress.total = event.total;
                }
                // Send the event.
                observer.next(progress);
            };
            // By default, register for load and error events.
            xhr.addEventListener('load', onLoad);
            xhr.addEventListener('error', onError);
            // Progress events are only enabled if requested.
            if (req.reportProgress) {
                // Download progress is always enabled if requested.
                xhr.addEventListener('progress', onDownProgress);
                // Upload progress depends on whether there is a body to upload.
                if (reqBody !== null && xhr.upload) {
                    xhr.upload.addEventListener('progress', onUpProgress);
                }
            }
            // Fire the request, and notify the event stream that it was fired.
            xhr.send(reqBody);
            observer.next({ type: HttpEventType.Sent });
            // This is the return from the Observable function, which is the
            // request cancellation handler.
            return function () {
                // On a cancellation, remove all registered event listeners.
                xhr.removeEventListener('error', onError);
                xhr.removeEventListener('load', onLoad);
                if (req.reportProgress) {
                    xhr.removeEventListener('progress', onDownProgress);
                    if (reqBody !== null && xhr.upload) {
                        xhr.upload.removeEventListener('progress', onUpProgress);
                    }
                }
                // Finally, abort the in-flight request.
                xhr.abort();
            };
        });
    };
    HttpXhrBackend.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    HttpXhrBackend.ctorParameters = function () { return [
        { type: XhrFactory, },
    ]; };
    return HttpXhrBackend;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSRF_COOKIE_NAME = new _angular_core.InjectionToken('XSRF_COOKIE_NAME');
var XSRF_HEADER_NAME = new _angular_core.InjectionToken('XSRF_HEADER_NAME');
/**
 * Retrieves the current XSRF token to use with the next outgoing request.
 *
 * \@stable
 * @abstract
 */
var HttpXsrfTokenExtractor = /** @class */ (function () {
    function HttpXsrfTokenExtractor() {
    }
    return HttpXsrfTokenExtractor;
}());
/**
 * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.
 */
var HttpXsrfCookieExtractor = /** @class */ (function () {
    function HttpXsrfCookieExtractor(doc, platform, cookieName) {
        this.doc = doc;
        this.platform = platform;
        this.cookieName = cookieName;
        this.lastCookieString = '';
        this.lastToken = null;
        /**
         * \@internal for testing
         */
        this.parseCount = 0;
    }
    /**
     * @return {?}
     */
    HttpXsrfCookieExtractor.prototype.getToken = /**
     * @return {?}
     */
    function () {
        if (this.platform === 'server') {
            return null;
        }
        var /** @type {?} */ cookieString = this.doc.cookie || '';
        if (cookieString !== this.lastCookieString) {
            this.parseCount++;
            this.lastToken = _angular_common.ɵparseCookieValue(cookieString, this.cookieName);
            this.lastCookieString = cookieString;
        }
        return this.lastToken;
    };
    HttpXsrfCookieExtractor.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    HttpXsrfCookieExtractor.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_common.DOCUMENT,] },] },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.PLATFORM_ID,] },] },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [XSRF_COOKIE_NAME,] },] },
    ]; };
    return HttpXsrfCookieExtractor;
}());
/**
 * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.
 */
var HttpXsrfInterceptor = /** @class */ (function () {
    function HttpXsrfInterceptor(tokenService, headerName) {
        this.tokenService = tokenService;
        this.headerName = headerName;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    HttpXsrfInterceptor.prototype.intercept = /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    function (req, next) {
        var /** @type {?} */ lcUrl = req.url.toLowerCase();
        // Skip both non-mutating requests and absolute URLs.
        // Non-mutating requests don't require a token, and absolute URLs require special handling
        // anyway as the cookie set
        // on our origin is not the same as the token expected by another origin.
        if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||
            lcUrl.startsWith('https://')) {
            return next.handle(req);
        }
        var /** @type {?} */ token = this.tokenService.getToken();
        // Be careful not to overwrite an existing header of the same name.
        if (token !== null && !req.headers.has(this.headerName)) {
            req = req.clone({ headers: req.headers.set(this.headerName, token) });
        }
        return next.handle(req);
    };
    HttpXsrfInterceptor.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    HttpXsrfInterceptor.ctorParameters = function () { return [
        { type: HttpXsrfTokenExtractor, },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [XSRF_HEADER_NAME,] },] },
    ]; };
    return HttpXsrfInterceptor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An `HttpHandler` that applies a bunch of `HttpInterceptor`s
 * to a request before passing it to the given `HttpBackend`.
 *
 * The interceptors are loaded lazily from the injector, to allow
 * interceptors to themselves inject classes depending indirectly
 * on `HttpInterceptingHandler` itself.
 */
var HttpInterceptingHandler = /** @class */ (function () {
    function HttpInterceptingHandler(backend, injector) {
        this.backend = backend;
        this.injector = injector;
        this.chain = null;
    }
    /**
     * @param {?} req
     * @return {?}
     */
    HttpInterceptingHandler.prototype.handle = /**
     * @param {?} req
     * @return {?}
     */
    function (req) {
        if (this.chain === null) {
            var /** @type {?} */ interceptors = this.injector.get(HTTP_INTERCEPTORS, []);
            this.chain = interceptors.reduceRight(function (next, interceptor) { return new HttpInterceptorHandler(next, interceptor); }, this.backend);
        }
        return this.chain.handle(req);
    };
    HttpInterceptingHandler.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    HttpInterceptingHandler.ctorParameters = function () { return [
        { type: HttpBackend, },
        { type: _angular_core.Injector, },
    ]; };
    return HttpInterceptingHandler;
}());
/**
 * Constructs an `HttpHandler` that applies a bunch of `HttpInterceptor`s
 * to a request before passing it to the given `HttpBackend`.
 *
 * Meant to be used as a factory function within `HttpClientModule`.
 *
 * \@stable
 * @param {?} backend
 * @param {?=} interceptors
 * @return {?}
 */
function interceptingHandler(backend, interceptors) {
    if (interceptors === void 0) { interceptors = []; }
    if (!interceptors) {
        return backend;
    }
    return interceptors.reduceRight(function (next, interceptor) { return new HttpInterceptorHandler(next, interceptor); }, backend);
}
/**
 * Factory function that determines where to store JSONP callbacks.
 *
 * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist
 * in test environments. In that case, callbacks are stored on an anonymous object instead.
 *
 * \@stable
 * @return {?}
 */
function jsonpCallbackContext() {
    if (typeof window === 'object') {
        return window;
    }
    return {};
}
/**
 * `NgModule` which adds XSRF protection support to outgoing requests.
 *
 * Provided the server supports a cookie-based XSRF protection system, this
 * module can be used directly to configure XSRF protection with the correct
 * cookie and header names.
 *
 * If no such names are provided, the default is to use `X-XSRF-TOKEN` for
 * the header name and `XSRF-TOKEN` for the cookie name.
 *
 * \@stable
 */
var HttpClientXsrfModule = /** @class */ (function () {
    function HttpClientXsrfModule() {
    }
    /**
     * Disable the default XSRF protection.
     */
    /**
     * Disable the default XSRF protection.
     * @return {?}
     */
    HttpClientXsrfModule.disable = /**
     * Disable the default XSRF protection.
     * @return {?}
     */
    function () {
        return {
            ngModule: HttpClientXsrfModule,
            providers: [
                { provide: HttpXsrfInterceptor, useClass: NoopInterceptor },
            ],
        };
    };
    /**
     * Configure XSRF protection to use the given cookie name or header name,
     * or the default names (as described above) if not provided.
     */
    /**
     * Configure XSRF protection to use the given cookie name or header name,
     * or the default names (as described above) if not provided.
     * @param {?=} options
     * @return {?}
     */
    HttpClientXsrfModule.withOptions = /**
     * Configure XSRF protection to use the given cookie name or header name,
     * or the default names (as described above) if not provided.
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = {}; }
        return {
            ngModule: HttpClientXsrfModule,
            providers: [
                options.cookieName ? { provide: XSRF_COOKIE_NAME, useValue: options.cookieName } : [],
                options.headerName ? { provide: XSRF_HEADER_NAME, useValue: options.headerName } : [],
            ],
        };
    };
    HttpClientXsrfModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    providers: [
                        HttpXsrfInterceptor,
                        { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },
                        { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },
                        { provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN' },
                        { provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN' },
                    ],
                },] },
    ];
    /** @nocollapse */
    HttpClientXsrfModule.ctorParameters = function () { return []; };
    return HttpClientXsrfModule;
}());
/**
 * `NgModule` which provides the `HttpClient` and associated services.
 *
 * Interceptors can be added to the chain behind `HttpClient` by binding them
 * to the multiprovider for `HTTP_INTERCEPTORS`.
 *
 * \@stable
 */
var HttpClientModule = /** @class */ (function () {
    function HttpClientModule() {
    }
    HttpClientModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    imports: [
                        HttpClientXsrfModule.withOptions({
                            cookieName: 'XSRF-TOKEN',
                            headerName: 'X-XSRF-TOKEN',
                        }),
                    ],
                    providers: [
                        HttpClient,
                        { provide: HttpHandler, useClass: HttpInterceptingHandler },
                        HttpXhrBackend,
                        { provide: HttpBackend, useExisting: HttpXhrBackend },
                        BrowserXhr,
                        { provide: XhrFactory, useExisting: BrowserXhr },
                    ],
                },] },
    ];
    /** @nocollapse */
    HttpClientModule.ctorParameters = function () { return []; };
    return HttpClientModule;
}());
/**
 * `NgModule` which enables JSONP support in `HttpClient`.
 *
 * Without this module, Jsonp requests will reach the backend
 * with method JSONP, where they'll be rejected.
 *
 * \@stable
 */
var HttpClientJsonpModule = /** @class */ (function () {
    function HttpClientJsonpModule() {
    }
    HttpClientJsonpModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    providers: [
                        JsonpClientBackend,
                        { provide: JsonpCallbackContext, useFactory: jsonpCallbackContext },
                        { provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true },
                    ],
                },] },
    ];
    /** @nocollapse */
    HttpClientJsonpModule.ctorParameters = function () { return []; };
    return HttpClientJsonpModule;
}());

exports.HttpBackend = HttpBackend;
exports.HttpHandler = HttpHandler;
exports.HttpClient = HttpClient;
exports.HttpHeaders = HttpHeaders;
exports.HTTP_INTERCEPTORS = HTTP_INTERCEPTORS;
exports.JsonpClientBackend = JsonpClientBackend;
exports.JsonpInterceptor = JsonpInterceptor;
exports.HttpClientJsonpModule = HttpClientJsonpModule;
exports.HttpClientModule = HttpClientModule;
exports.HttpClientXsrfModule = HttpClientXsrfModule;
exports.ɵinterceptingHandler = interceptingHandler;
exports.HttpParams = HttpParams;
exports.HttpUrlEncodingCodec = HttpUrlEncodingCodec;
exports.HttpRequest = HttpRequest;
exports.HttpErrorResponse = HttpErrorResponse;
exports.HttpEventType = HttpEventType;
exports.HttpHeaderResponse = HttpHeaderResponse;
exports.HttpResponse = HttpResponse;
exports.HttpResponseBase = HttpResponseBase;
exports.HttpXhrBackend = HttpXhrBackend;
exports.XhrFactory = XhrFactory;
exports.HttpXsrfTokenExtractor = HttpXsrfTokenExtractor;
exports.ɵa = NoopInterceptor;
exports.ɵb = JsonpCallbackContext;
exports.ɵc = HttpInterceptingHandler;
exports.ɵd = jsonpCallbackContext;
exports.ɵe = BrowserXhr;
exports.ɵh = HttpXsrfCookieExtractor;
exports.ɵi = HttpXsrfInterceptor;
exports.ɵf = XSRF_COOKIE_NAME;
exports.ɵg = XSRF_HEADER_NAME;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=common-http.umd.js.map


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = DOMImplementation;

var Document = __webpack_require__(18);
var DocumentType = __webpack_require__(26);
var HTMLParser = __webpack_require__(27);
var utils = __webpack_require__(2);
var xml = __webpack_require__(19);

// Each document must have its own instance of the domimplementation object
// Even though these objects have no state
function DOMImplementation() {}


// Feature/version pairs that DOMImplementation.hasFeature() returns
// true for.  It returns false for anything else.
var supportedFeatures = {
  'xml': { '': true, '1.0': true, '2.0': true },   // DOM Core
  'core': { '': true, '2.0': true },               // DOM Core
  'html': { '': true, '1.0': true, '2.0': true} ,  // HTML
  'xhtml': { '': true, '1.0': true, '2.0': true} , // HTML
};

DOMImplementation.prototype = {
  hasFeature: function hasFeature(feature, version) {
    var f = supportedFeatures[(feature || '').toLowerCase()];
    return (f && f[version || '']) || false;
  },

  createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {
    if (!xml.isValidName(qualifiedName)) utils.InvalidCharacterError();
    if (!xml.isValidQName(qualifiedName)) utils.NamespaceError();

    return new DocumentType(qualifiedName, publicId, systemId);
  },

  createDocument: function createDocument(namespace, qualifiedName, doctype) {
    //
    // Note that the current DOMCore spec makes it impossible to
    // create an HTML document with this function, even if the
    // namespace and doctype are propertly set.  See this thread:
    // http://lists.w3.org/Archives/Public/www-dom/2011AprJun/0132.html
    //
    var d = new Document(false, null);
    var e;

    if (qualifiedName)
      e = d.createElementNS(namespace, qualifiedName);
    else
      e = null;

    if (doctype) {
      if (doctype.ownerDocument) utils.WrongDocumentError();
      d.appendChild(doctype);
    }

    if (e) d.appendChild(e);

    return d;
  },

  createHTMLDocument: function createHTMLDocument(titleText) {
    var d = new Document(true, null);
    d.appendChild(new DocumentType('html'));
    var html = d.createElement('html');
    d.appendChild(html);
    var head = d.createElement('head');
    html.appendChild(head);
    var title = d.createElement('title');
    head.appendChild(title);
    title.appendChild(d.createTextNode(titleText));
    html.appendChild(d.createElement('body'));
    d.modclock = 1; // Start tracking modifications
    return d;
  },

  mozSetOutputMutationHandler: function(doc, handler) {
    doc.mutationHandler = handler;
  },

  mozGetInputMutationHandler: function(doc) {
    utils.nyi();
  },

  mozHTMLParser: HTMLParser,
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = NodeList;

function item(i) {
  /* jshint validthis: true */
  return this[i];
}

function NodeList(a) {
  if (!a) a = [];
  a.item = item;
  return a;
}


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = CharacterData;

var Leaf = __webpack_require__(45);
var utils = __webpack_require__(2);
var ChildNode = __webpack_require__(21);
var NonDocumentTypeChildNode = __webpack_require__(43);

function CharacterData() {
}

CharacterData.prototype = Object.create(Leaf.prototype, {
  // DOMString substringData(unsigned long offset,
  //               unsigned long count);
  // The substringData(offset, count) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     If offset+count is greater than the context
  //     object's length, return a DOMString whose value is
  //     the UTF-16 code units from the offsetth UTF-16 code
  //     unit to the end of data.
  //
  //     Return a DOMString whose value is the UTF-16 code
  //     units from the offsetth UTF-16 code unit to the
  //     offset+countth UTF-16 code unit in data.
  substringData: { value: function substringData(offset, count) {
    if (offset > this.data.length || offset < 0 || count < 0) 
      utils.IndexSizeError();
    return this.data.substring(offset, offset+count);
  }},

  // void appendData(DOMString data);
  // The appendData(data) method must append data to the context
  // object's data.
  appendData: { value: function appendData(data) {
    this.data = this.data + data;
  }},

  // void insertData(unsigned long offset, DOMString data);
  // The insertData(offset, data) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     Insert data into the context object's data after
  //     offset UTF-16 code units.
  //
  insertData: { value: function insertData(offset, data) {
    var curtext = this.data;
    if (offset > curtext.length || offset < 0) utils.IndexSizeError();
    var prefix = curtext.substring(0, offset),
    suffix = curtext.substring(offset);
    this.data = prefix + data + suffix;
  }},


  // void deleteData(unsigned long offset, unsigned long count);
  // The deleteData(offset, count) method must run these steps:
  //
  //     If offset is greater than the context object's
  //     length, throw an INDEX_SIZE_ERR exception and
  //     terminate these steps.
  //
  //     If offset+count is greater than the context
  //     object's length var count be length-offset.
  //
  //     Starting from offset UTF-16 code units remove count
  //     UTF-16 code units from the context object's data.
  deleteData: { value: function deleteData(offset, count) {
    var curtext = this.data, len = curtext.length;

    if (offset > len || offset < 0) utils.IndexSizeError();

    if (offset+count > len)
      count = len - offset;

    var prefix = curtext.substring(0, offset),
    suffix = curtext.substring(offset+count);

    this.data = prefix + suffix;
  }},


  // void replaceData(unsigned long offset, unsigned long count,
  //          DOMString data);
  //
  // The replaceData(offset, count, data) method must act as
  // if the deleteData() method is invoked with offset and
  // count as arguments followed by the insertData() method
  // with offset and data as arguments and re-throw any
  // exceptions these methods might have thrown.
  replaceData: { value: function replaceData(offset, count, data) {
    var curtext = this.data, len = curtext.length;

    if (offset > len || offset < 0) utils.IndexSizeError();

    if (offset+count > len)
      count = len - offset;

    var prefix = curtext.substring(0, offset),
    suffix = curtext.substring(offset+count);

    this.data = prefix + data + suffix;
  }},

  // Utility method that Node.isEqualNode() calls to test Text and
  // Comment nodes for equality.  It is okay to put it here, since
  // Node will have already verified that nodeType is equal
  isEqual: { value: function isEqual(n) {
    return this._data === n._data;
  }},

  length: { get: function() { return this.data.length; }}

});

Object.defineProperties(CharacterData.prototype, ChildNode);
Object.defineProperties(CharacterData.prototype, NonDocumentTypeChildNode);


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NodeFilter = {
  // Constants for acceptNode()
  FILTER_ACCEPT: 1,
  FILTER_REJECT: 2,
  FILTER_SKIP: 3,

  // Constants for whatToShow
  SHOW_ALL: 0xFFFFFFFF,
  SHOW_ELEMENT: 0x1,
  SHOW_ATTRIBUTE: 0x2, // historical
  SHOW_TEXT: 0x4,
  SHOW_CDATA_SECTION: 0x8, // historical
  SHOW_ENTITY_REFERENCE: 0x10, // historical
  SHOW_ENTITY: 0x20, // historical
  SHOW_PROCESSING_INSTRUCTION: 0x40,
  SHOW_COMMENT: 0x80,
  SHOW_DOCUMENT: 0x100,
  SHOW_DOCUMENT_TYPE: 0x200,
  SHOW_DOCUMENT_FRAGMENT: 0x400,
  SHOW_NOTATION: 0x800 // historical
};

module.exports = (NodeFilter.constructor = NodeFilter.prototype = NodeFilter);


/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF4AAAAbCAMAAADCmciDAAABRFBMVEU2KhtENSJGNiRIOCRENCJCMiBKOCRAMiA/MCBDNCJINiRCMiFKNyRENCFAMCBKOSbj28FMOiZMOyhQPCdOPChSQClSPilQPihLOSRYQyxPPik2KRtQPSq7sZfOxavPx61TQCpOOidOPCZ2ZlBQPCheSC9UQSpWQipTPypWQivZ0beJfGRZRCyThm7Fu6KVh29kUjynnINUQCpYRCxcRi5+cFpgTzpcRi2IemNWRjFWRi90ZU54aFGThW5WRTBkVD28spltXEawpY2LfGVcRy5UQClaSDNbRi5uXUd0ZlCpnYXEu6HPx6uViHBpWkR0ZVCnm4NaRC5KOSSBcVtKOCVrW0ZVQCqlmoKekXpUPiheTjpiUTtiUTxaRjKnm4Szp4+RhW6ViG+Ke2SckHidkXqUhW7FvaFVRC6JemRaRjCBcluom4MptArBAAAEB0lEQVR4AWROSW7DMAzkJ9iC9UUXawF8kgT4AzZy7qX/f0qHolgZzYThLEMFof3qF7DbmOz92vehwTCXLhBC0Nnt8IRCfEIiUfQdBcx8CksvR1+rgxb+R1OuYLm3iI4X/WHzcW28ymVc+tEq1Mzv90GtkUiT1tpx6DYjCtUG8LHkMOIfsVBW1Ga4iZCUrQBSkhQxgDXBGpzK7JKI82hU643FSdmhj4RKsYnFAWkuPbJn++7i5BTTs0z6vylGqjUqmCFM2napqZLCKzhr+YZgd0qGH/zwXSlnyiGEmmsIOUPeEDVAwbMSBmkYB89crzCgcI8UkyuPIw6YLQdiJv5g5i/+VFpQP7NfqqZrN24YCPITZpcrUlCRQElPOujKgw++4g4Y7jaQBOm9J///nqUOMOKRMFtmdqjkfJK8Hovb2aKo6lM8SpFczPbOZInLdHI+UnIF4LNbAMkWOHM1FLVz82OtF0fAbQYcu6MpMJ0nDpi5EnWBEVfOFU7jvOZlWe6c8d50hVcoKbpX/UXx8dae45nP/paZ/EFWbCvfTafn7+ut/1YXR9MTn9Wln1fHUsz6zqu36+dn8LMPPiuKwnfeW9sVeeeNSG7/Rz8oibVobbMorW2ho9gTbEWFZqjbch63J42d4bedVDZ6lSYY7yKaXcnFGmv1hbgW3Qb7Fu3Og4gxXovosTCraQZUWs5go9TypJZGxhuN3wWx3cVZE8QIG2ISCUGCCL/DpbBw0BMODyVzCyZVJtCdCt+rVT9w2IcE1vig8Sy41+AvGA3a7QJCMCwmcM5MTE2jzLzCAXGjG9wzLzR+A47YwwtdBx5qHvrDceRfWIVJRURo9WIfrA4FqW/MMo2+QIYewURltaTTT7TGHtFpSbQHoruKDvuSD28u6WtPVC1offNjvawXUd7QgJXeHmBNT5HH7FT/dBzT+L25BrCfPgC00YYqKK7TdBOb5RI4SLWjuylw+vN5mr7811UV7boOwrBAWFkp3cTbpOn8FOr/f8txbZ1cdE1wHMfiFcY/A5ufMQffQuHi4WHzAs/rmnPignAG2tDwme+JMFzOI9bwYDGF9oaG8bfVe3ZN27avX31znLkJmHqnApyK+E/5LUABFwXMu7l/3Vtr/XL0W4KpCIhNg3fZ8piJ6m2j33xBs+bm2dyz4/J4zhkhCSe0DRJrjHCTJbSmoGVUtpwYTIkihUiJ5roUaxdYU8wRfNhSsZJSSTfhEuqB1ZdUPBS7FOMShW/vVsp+ln0v97lx4kJxhI1asOvAlFZJAcyKi6GOk387aP35yQtiuzooHc3BgfOw+gCOB/lgX1G5RElWDcSS1RtVHg0KGFafz2cl8cYIxoQCHlUjVxLwmH/9i70wopgFaP8C95v9Y7WqpOcAAAAASUVORK5CYII="

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "ff1c82f32a41bbdf02e52b6c7b818c51.png";

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Document;

var Node = __webpack_require__(3);
var NodeList = __webpack_require__(12);
var Element = __webpack_require__(7);
var Text = __webpack_require__(44);
var Comment = __webpack_require__(46);
var Event = __webpack_require__(6);
var DocumentFragment = __webpack_require__(47);
var ProcessingInstruction = __webpack_require__(48);
var DOMImplementation = __webpack_require__(11);
var TreeWalker = __webpack_require__(82);
var NodeIterator = __webpack_require__(83);
var NodeFilter = __webpack_require__(14);
var URL = __webpack_require__(22);
var select = __webpack_require__(20);
var events = __webpack_require__(50);
var xml = __webpack_require__(19);
var html = __webpack_require__(23);
var svg = __webpack_require__(55);
var utils = __webpack_require__(2);
var MUTATE = __webpack_require__(89);
var NAMESPACE = utils.NAMESPACE;
var isApiWritable = __webpack_require__(40).isApiWritable;

function Document(isHTML, address) {
  this.nodeType = Node.DOCUMENT_NODE;
  this.isHTML = isHTML;
  this._address = address || 'about:blank';
  this.readyState = 'loading';
  this.implementation = new DOMImplementation();

  // DOMCore says that documents are always associated with themselves
  this.ownerDocument = null; // ... but W3C tests expect null

  // These will be initialized by our custom versions of
  // appendChild and insertBefore that override the inherited
  // Node methods.
  // XXX: override those methods!
  this.doctype = null;
  this.documentElement = null;
  this.childNodes = new NodeList();

  // "Associated inert template document"
  this._templateDocCache = null;

  // Documents are always rooted, by definition
  this._nid = 1;
  this._nextnid = 2; // For numbering children of the document
  this._nodes = [null, this];  // nid to node map

  // This maintains the mapping from element ids to element nodes.
  // We may need to update this mapping every time a node is rooted
  // or uprooted, and any time an attribute is added, removed or changed
  // on a rooted element.
  this.byId = Object.create(null);

  // This property holds a monotonically increasing value akin to
  // a timestamp used to record the last modification time of nodes
  // and their subtrees. See the lastModTime attribute and modify()
  // method of the Node class. And see FilteredElementList for an example
  // of the use of lastModTime
  this.modclock = 0;
}

// Map from lowercase event category names (used as arguments to
// createEvent()) to the property name in the impl object of the
// event constructor.
var supportedEvents = {
  event: 'Event',
  customevent: 'CustomEvent',
  uievent: 'UIEvent',
  mouseevent: 'MouseEvent'
};

// Certain arguments to document.createEvent() must be treated specially
var replacementEvent = {
  events: 'event',
  htmlevents: 'event',
  mouseevents: 'mouseevent',
  mutationevents: 'mutationevent',
  uievents: 'uievent'
};

var mirrorAttr = function(f, name, defaultValue) {
  return {
    get: function() {
      var o = f.call(this);
      if (o) { return o[name]; }
      return defaultValue;
    },
    set: function(value) {
      var o = f.call(this);
      if (o) { o[name] = value; }
    },
  };
};

Document.prototype = Object.create(Node.prototype, {
  // This method allows dom.js to communicate with a renderer
  // that displays the document in some way
  // XXX: I should probably move this to the window object
  _setMutationHandler: { value: function(handler) {
    this.mutationHandler = handler;
  }},

  // This method allows dom.js to receive event notifications
  // from the renderer.
  // XXX: I should probably move this to the window object
  _dispatchRendererEvent: { value: function(targetNid, type, details) {
    var target = this._nodes[targetNid];
    if (!target) return;
    target._dispatchEvent(new Event(type, details), true);
  }},

  nodeName: { value: '#document'},
  nodeValue: {
    get: function() {
      return null;
    },
    set: function() {}
  },

  // XXX: DOMCore may remove documentURI, so it is NYI for now
  documentURI: { get: utils.nyi, set: utils.nyi },
  compatMode: { get: function() {
    // The _quirks property is set by the HTML parser
    return this._quirks ? 'BackCompat' : 'CSS1Compat';
  }},
  parentNode: { value: null },

  createTextNode: { value: function(data) {
    return new Text(this, '' + data);
  }},
  createComment: { value: function(data) {
    return new Comment(this, data);
  }},
  createDocumentFragment: { value: function() {
    return new DocumentFragment(this);
  }},
  createProcessingInstruction: { value: function(target, data) {
    if (!xml.isValidName(target) || data.indexOf('?>') !== -1)
      utils.InvalidCharacterError();
    return new ProcessingInstruction(this, target, data);
  }},

  createElement: { value: function(localName) {
    if (!xml.isValidName(localName)) utils.InvalidCharacterError();
    if (this.isHTML) localName = utils.toASCIILowerCase(localName);
    return html.createElement(this, localName, null);
  }, writable: isApiWritable },

  createElementNS: { value: function(namespace, qualifiedName) {
    if (!xml.isValidName(qualifiedName)) utils.InvalidCharacterError();
    if (!xml.isValidQName(qualifiedName)) utils.NamespaceError();

    var pos, prefix, localName;
    if ((pos = qualifiedName.indexOf(':')) !== -1) {
      prefix = qualifiedName.substring(0, pos);
      localName = qualifiedName.substring(pos+1);

      if (namespace === '' ||
        (prefix === 'xml' && namespace !== NAMESPACE.XML))
        utils.NamespaceError();
    }
    else {
      prefix = null;
      localName = qualifiedName;
    }

    if (((qualifiedName === 'xmlns' || prefix === 'xmlns') &&
       namespace !== NAMESPACE.XMLNS) ||
      (namespace === NAMESPACE.XMLNS &&
       qualifiedName !== 'xmlns' &&
       prefix !== 'xmlns'))
      utils.NamespaceError();

    if (namespace === NAMESPACE.HTML) {
      return html.createElement(this, localName, prefix);
    }
    else if (namespace === NAMESPACE.SVG) {
      return svg.createElement(this, localName, prefix);
    }

    return new Element(this, localName, namespace, prefix);
  }, writable: isApiWritable },

  createEvent: { value: function createEvent(interfaceName) {
    interfaceName = interfaceName.toLowerCase();
    var name = replacementEvent[interfaceName] || interfaceName;
    var constructor = events[supportedEvents[name]];

    if (constructor) {
      var e = new constructor();
      e._initialized = false;
      return e;
    }
    else {
      utils.NotSupportedError();
    }
  }},

  // See: http://www.w3.org/TR/dom/#dom-document-createtreewalker
  createTreeWalker: {value: function (root, whatToShow, filter) {
    whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : whatToShow;

    if (filter && typeof filter === 'object' &&
        typeof filter.acceptNode === 'function') {
      filter = filter.acceptNode.bind(filter);
      // Support filter being a function
      // https://developer.mozilla.org/en-US/docs/DOM/document.createTreeWalker
    }
    else if (typeof filter !== 'function') {
      filter = null;
    }
    return new TreeWalker(root, whatToShow, filter);
  }},

  // See: http://www.w3.org/TR/dom/#dom-document-createnodeiterator
  createNodeIterator: {value: function (root, whatToShow, filter) {
    whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : whatToShow;

    if (filter && typeof filter === 'object' &&
        typeof filter.acceptNode === 'function') {
      filter = filter.acceptNode.bind(filter);
      // Support filter being a function
      // https://developer.mozilla.org/en-US/docs/DOM/document.createNodeIterator
    }
    else if (typeof filter !== 'function') {
      filter = null;
    }
    return new NodeIterator(root, whatToShow, filter);
  }},

  // Maintain the documentElement and
  // doctype properties of the document.  Each of the following
  // methods chains to the Node implementation of the method
  // to do the actual inserting, removal or replacement.

  _updateDocTypeElement: { value: function _updateDocTypeElement() {
    var i, n, nodes = this.childNodes, length = nodes.length;
    this.doctype = this.documentElement = null;
    for (i=0; i<length; i++) {
      n = nodes[i];
      if (n.nodeType === Node.DOCUMENT_TYPE_NODE)
        this.doctype = n;
      else if (n.nodeType === Node.ELEMENT_NODE)
        this.documentElement = n;
    }
  }},

  insertBefore: { value: function insertBefore(child, refChild) {
    Node.prototype.insertBefore.call(this, child, refChild);
    this._updateDocTypeElement();
    return child;
  }},

  replaceChild: { value: function replaceChild(node, child) {
    Node.prototype.replaceChild.call(this, node, child);
    this._updateDocTypeElement();
    return child;
  }},

  removeChild: { value: function removeChild(child) {
    Node.prototype.removeChild.call(this, child);
    this._updateDocTypeElement();
    return child;
  }},

  getElementById: { value: function(id) {
    var n = this.byId[id];
    if (!n) return null;
    if (n instanceof MultiId) { // there was more than one element with this id
      return n.getFirst();
    }
    return n;
  }},

  _hasMultipleElementsWithId: { value: function(id) {
    // Used internally by querySelectorAll optimization
    return (this.byId[id] instanceof MultiId);
  }},

  // Just copy this method from the Element prototype
  getElementsByName: { value: Element.prototype.getElementsByName },
  getElementsByTagName: { value: Element.prototype.getElementsByTagName },
  getElementsByTagNameNS: { value: Element.prototype.getElementsByTagNameNS },
  getElementsByClassName: { value: Element.prototype.getElementsByClassName },

  adoptNode: { value: function adoptNode(node) {
    if (node.nodeType === Node.DOCUMENT_NODE) utils.NotSupportedError();

    if (node.parentNode) node.parentNode.removeChild(node);

    if (node.ownerDocument !== this)
      recursivelySetOwner(node, this);

    return node;
  }},

  importNode: { value: function importNode(node, deep) {
    return this.adoptNode(node.cloneNode(deep));
  }, writable: isApiWritable },

  // The following attributes and methods are from the HTML spec
  URL: { get: utils.nyi },
  domain: { get: utils.nyi, set: utils.nyi },
  referrer: { get: utils.nyi },
  cookie: { get: utils.nyi, set: utils.nyi },
  lastModified: { get: utils.nyi },
  location: {
	get: function() {
	  return this.defaultView ? this.defaultView.location : null; // gh #75
	},
	set: utils.nyi
  },
  _titleElement: {
    get: function() {
      // The title element of a document is the first title element in the
      // document in tree order, if there is one, or null otherwise.
      return this.getElementsByTagName('title').item(0) || null;
    }
  },
  title: {
    get: function() {
      var elt = this._titleElement;
      // The child text content of the title element, or '' if null.
      var value = elt ? elt.textContent : '';
      // Strip and collapse whitespace in value
      return value.replace(/[ \t\n\r\f]+/g, ' ').trim();
    },
    set: function(value) {
      var elt = this._titleElement;
      var head = this.head;
      if (!elt && !head) { return; /* according to spec */ }
      if (!elt) {
        elt = this.createElement('title');
        head.appendChild(elt);
      }
      elt.textContent = value;
    }
  },
  dir: mirrorAttr(function() {
    var htmlElement = this.documentElement;
    if (htmlElement && htmlElement.tagName === 'HTML') { return htmlElement; }
  }, 'dir', ''),
  fgColor: mirrorAttr(function() { return this.body; }, 'text', ''),
  linkColor: mirrorAttr(function() { return this.body; }, 'link', ''),
  vlinkColor: mirrorAttr(function() { return this.body; }, 'vLink', ''),
  alinkColor: mirrorAttr(function() { return this.body; }, 'aLink', ''),
  bgColor: mirrorAttr(function() { return this.body; }, 'bgColor', ''),

  // Return the first <body> child of the document element.
  // XXX For now, setting this attribute is not implemented.
  body: {
    get: function() {
      return namedHTMLChild(this.documentElement, 'body');
    },
    set: utils.nyi
  },
  // Return the first <head> child of the document element.
  head: { get: function() {
    return namedHTMLChild(this.documentElement, 'head');
  }},
  images: { get: utils.nyi },
  embeds: { get: utils.nyi },
  plugins: { get: utils.nyi },
  links: { get: utils.nyi },
  forms: { get: utils.nyi },
  scripts: { get: utils.nyi },
  innerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },
  outerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },

  write: { value: function(args) {
    if (!this.isHTML) utils.InvalidStateError();

    // XXX: still have to implement the ignore part
    if (!this._parser /* && this._ignore_destructive_writes > 0 */ )
      return;

    if (!this._parser) {
      // XXX call document.open, etc.
    }

    var s = arguments.join('');

    // If the Document object's reload override flag is set, then
    // append the string consisting of the concatenation of all the
    // arguments to the method to the Document's reload override
    // buffer.
    // XXX: don't know what this is about.  Still have to do it

    // If there is no pending parsing-blocking script, have the
    // tokenizer process the characters that were inserted, one at a
    // time, processing resulting tokens as they are emitted, and
    // stopping when the tokenizer reaches the insertion point or when
    // the processing of the tokenizer is aborted by the tree
    // construction stage (this can happen if a script end tag token is
    // emitted by the tokenizer).

    // XXX: still have to do the above. Sounds as if we don't
    // always call parse() here.  If we're blocked, then we just
    // insert the text into the stream but don't parse it reentrantly...

    // Invoke the parser reentrantly
    this._parser.parse(s);
  }},

  writeln: { value: function writeln(args) {
    this.write(Array.prototype.join.call(arguments, '') + '\n');
  }},

  open: { value: function() {
    this.documentElement = null;
  }},

  close: { value: function() {
    this.readyState = 'complete';
    var ev = new Event('DOMContentLoaded');
    this._dispatchEvent(ev, true);
    if (this.defaultView) {
      ev = new Event('load');
      this.defaultView._dispatchEvent(ev, true);
    }
  }},

  // Utility methods
  clone: { value: function clone() {
    // Can't clone an entire document
    utils.DataCloneError();
  }},

  isEqual: { value: function isEqual(n) {
    // Any two documents are shallowly equal.
    // Node.isEqualNode will also test the children
    return true;
  }},

  // Implementation-specific function.  Called when a text, comment,
  // or pi value changes.
  mutateValue: { value: function(node) {
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.VALUE,
        target: node,
        data: node.data
      });
    }
  }},

  // Invoked when an attribute's value changes. Attr holds the new
  // value.  oldval is the old value.  Attribute mutations can also
  // involve changes to the prefix (and therefore the qualified name)
  mutateAttr: { value: function(attr, oldval) {
    // Manage id->element mapping for getElementsById()
    // XXX: this special case id handling should not go here,
    // but in the attribute declaration for the id attribute
    /*
    if (attr.localName === 'id' && attr.namespaceURI === null) {
      if (oldval) delId(oldval, attr.ownerElement);
      addId(attr.value, attr.ownerElement);
    }
    */
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.ATTR,
        target: attr.ownerElement,
        attr: attr
      });
    }
  }},

  // Used by removeAttribute and removeAttributeNS for attributes.
  mutateRemoveAttr: { value: function(attr) {
/*
* This is now handled in Attributes.js
    // Manage id to element mapping
    if (attr.localName === 'id' && attr.namespaceURI === null) {
      this.delId(attr.value, attr.ownerElement);
    }
*/
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.REMOVE_ATTR,
        target: attr.ownerElement,
        attr: attr
      });
    }
  }},

  // Called by Node.removeChild, etc. to remove a rooted element from
  // the tree. Only needs to generate a single mutation event when a
  // node is removed, but must recursively mark all descendants as not
  // rooted.
  mutateRemove: { value: function(node) {
    // Send a single mutation event
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.REMOVE,
        target: node.parentNode,
        node: node
      });
    }

    // Mark this and all descendants as not rooted
    recursivelyUproot(node);
  }},

  // Called when a new element becomes rooted.  It must recursively
  // generate mutation events for each of the children, and mark them all
  // as rooted.
  mutateInsert: { value: function(node) {
    // Mark node and its descendants as rooted
    recursivelyRoot(node);

    // Send a single mutation event
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.INSERT,
        target: node.parentNode,
        node: node
      });
    }
  }},

  // Called when a rooted element is moved within the document
  mutateMove: { value: function(node) {
    if (this.mutationHandler) {
      this.mutationHandler({
        type: MUTATE.MOVE,
        target: node
      });
    }
  }},


  // Add a mapping from  id to n for n.ownerDocument
  addId: { value: function addId(id, n) {
    var val = this.byId[id];
    if (!val) {
      this.byId[id] = n;
    }
    else {
      // TODO: Add a way to opt-out console warnings
      //console.warn('Duplicate element id ' + id);
      if (!(val instanceof MultiId)) {
        val = new MultiId(val);
        this.byId[id] = val;
      }
      val.add(n);
    }
  }},

  // Delete the mapping from id to n for n.ownerDocument
  delId: { value: function delId(id, n) {
    var val = this.byId[id];
    utils.assert(val);

    if (val instanceof MultiId) {
      val.del(n);
      if (val.length === 1) { // convert back to a single node
        this.byId[id] = val.downgrade();
      }
    }
    else {
      this.byId[id] = undefined;
    }
  }},

  _resolve: { value: function(href) {
    //XXX: Cache the URL
    return new URL(this._documentBaseURL).resolve(href);
  }},

  _documentBaseURL: { get: function() {
    // XXX: This is not implemented correctly yet
    var url = this._address;
    if (url === 'about:blank') url = '/';

    var base = this.querySelector('base[href]');
    if (base) {
      return new URL(url).resolve(base.getAttribute('href'));
    }
    return url;

    // The document base URL of a Document object is the
    // absolute URL obtained by running these substeps:

    //     Let fallback base url be the document's address.

    //     If fallback base url is about:blank, and the
    //     Document's browsing context has a creator browsing
    //     context, then let fallback base url be the document
    //     base URL of the creator Document instead.

    //     If the Document is an iframe srcdoc document, then
    //     let fallback base url be the document base URL of
    //     the Document's browsing context's browsing context
    //     container's Document instead.

    //     If there is no base element that has an href
    //     attribute, then the document base URL is fallback
    //     base url; abort these steps. Otherwise, let url be
    //     the value of the href attribute of the first such
    //     element.

    //     Resolve url relative to fallback base url (thus,
    //     the base href attribute isn't affected by xml:base
    //     attributes).

    //     The document base URL is the result of the previous
    //     step if it was successful; otherwise it is fallback
    //     base url.
  }},

  _templateDoc: { get: function() {
    if (!this._templateDocCache) {
      // "associated inert template document"
      var newDoc = new Document(this.isHTML, this._address);
      this._templateDocCache = newDoc._templateDocCache = newDoc;
    }
    return this._templateDocCache;
  }},

  querySelector: { value: function(selector) {
    return select(selector, this)[0];
  }},

  querySelectorAll: { value: function(selector) {
    var nodes = select(selector, this);
    return nodes.item ? nodes : new NodeList(nodes);
  }}

});


var eventHandlerTypes = [
  'abort', 'canplay', 'canplaythrough', 'change', 'click', 'contextmenu',
  'cuechange', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragleave',
  'dragover', 'dragstart', 'drop', 'durationchange', 'emptied', 'ended',
  'input', 'invalid', 'keydown', 'keypress', 'keyup', 'loadeddata',
  'loadedmetadata', 'loadstart', 'mousedown', 'mousemove', 'mouseout',
  'mouseover', 'mouseup', 'mousewheel', 'pause', 'play', 'playing',
  'progress', 'ratechange', 'readystatechange', 'reset', 'seeked',
  'seeking', 'select', 'show', 'stalled', 'submit', 'suspend',
  'timeupdate', 'volumechange', 'waiting',

  'blur', 'error', 'focus', 'load', 'scroll'
];

// Add event handler idl attribute getters and setters to Document
eventHandlerTypes.forEach(function(type) {
  // Define the event handler registration IDL attribute for this type
  Object.defineProperty(Document.prototype, 'on' + type, {
    get: function() {
      return this._getEventHandler(type);
    },
    set: function(v) {
      this._setEventHandler(type, v);
    }
  });
});

function namedHTMLChild(parent, name) {
  if (parent && parent.isHTML) {
    var kids = parent.childNodes;
    for(var i = 0, n = kids.length; i < n; i++) {
      if (kids[i].nodeType === Node.ELEMENT_NODE &&
        kids[i].localName === name &&
        kids[i].namespaceURI === NAMESPACE.HTML) {
        return kids[i];
      }
    }
  }
  return null;
}

function root(n) {
  n._nid = n.ownerDocument._nextnid++;
  n.ownerDocument._nodes[n._nid] = n;
  // Manage id to element mapping
  if (n.nodeType === Node.ELEMENT_NODE) {
    var id = n.getAttribute('id');
    if (id) n.ownerDocument.addId(id, n);

    // Script elements need to know when they're inserted
    // into the document
    if (n._roothook) n._roothook();
  }
}

function uproot(n) {
  // Manage id to element mapping
  if (n.nodeType === Node.ELEMENT_NODE) {
    var id = n.getAttribute('id');
    if (id) n.ownerDocument.delId(id, n);
  }
  n.ownerDocument._nodes[n._nid] = undefined;
  n._nid = undefined;
}

function recursivelyRoot(node) {
  root(node);
  // XXX:
  // accessing childNodes on a leaf node creates a new array the
  // first time, so be careful to write this loop so that it
  // doesn't do that. node is polymorphic, so maybe this is hard to
  // optimize?  Try switching on nodeType?
/*
  if (node.hasChildNodes()) {
    var kids = node.childNodes;
    for(var i = 0, n = kids.length;  i < n; i++)
      recursivelyRoot(kids[i]);
  }
*/
  if (node.nodeType === Node.ELEMENT_NODE) {
    var kids = node.childNodes;
    for(var i = 0, n = kids.length; i < n; i++)
      recursivelyRoot(kids[i]);
  }
}

function recursivelyUproot(node) {
  uproot(node);
  for(var i = 0, n = node.childNodes.length; i < n; i++)
    recursivelyUproot(node.childNodes[i]);
}

function recursivelySetOwner(node, owner) {
  node.ownerDocument = owner;
  node._lastModTime = undefined; // mod times are document-based
  var kids = node.childNodes;
  for(var i = 0, n = kids.length; i < n; i++)
    recursivelySetOwner(kids[i], owner);
}

// A class for storing multiple nodes with the same ID
function MultiId(node) {
  this.nodes = Object.create(null);
  this.nodes[node._nid] = node;
  this.length = 1;
  this.firstNode = undefined;
}

// Add a node to the list, with O(1) time
MultiId.prototype.add = function(node) {
  if (!this.nodes[node._nid]) {
    this.nodes[node._nid] = node;
    this.length++;
    this.firstNode = undefined;
  }
};

// Remove a node from the list, with O(1) time
MultiId.prototype.del = function(node) {
  if (this.nodes[node._nid]) {
    delete this.nodes[node._nid];
    this.length--;
    this.firstNode = undefined;
  }
};

// Get the first node from the list, in the document order
// Takes O(N) time in the size of the list, with a cache that is invalidated
// when the list is modified.
MultiId.prototype.getFirst = function() {
  /* jshint bitwise: false */
  if (!this.firstNode) {
    var nid;
    for (nid in this.nodes) {
      if (this.firstNode === undefined ||
        this.firstNode.compareDocumentPosition(this.nodes[nid]) & Node.DOCUMENT_POSITION_PRECEDING) {
        this.firstNode = this.nodes[nid];
      }
    }
  }
  return this.firstNode;
};

// If there is only one node left, return it. Otherwise return "this".
MultiId.prototype.downgrade = function() {
  if (this.length === 1) {
    var nid;
    for (nid in this.nodes) {
      return this.nodes[nid];
    }
  }
  return this;
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// This grammar is from the XML and XML Namespace specs. It specifies whether
// a string (such as an element or attribute name) is a valid Name or QName.
//
// Name           ::= NameStartChar (NameChar)*
// NameStartChar  ::= ":" | [A-Z] | "_" | [a-z] |
//                    [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
//                    [#x370-#x37D] | [#x37F-#x1FFF] |
//                    [#x200C-#x200D] | [#x2070-#x218F] |
//                    [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
//                    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |
//                    [#x10000-#xEFFFF]
//
// NameChar       ::= NameStartChar | "-" | "." | [0-9] |
//                    #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//
// QName          ::= PrefixedName| UnprefixedName
// PrefixedName   ::= Prefix ':' LocalPart
// UnprefixedName ::= LocalPart
// Prefix         ::= NCName
// LocalPart      ::= NCName
// NCName         ::= Name - (Char* ':' Char*)
//                    # An XML Name, minus the ":"
//

exports.isValidName = isValidName;
exports.isValidQName = isValidQName;

// Most names will be ASCII only. Try matching against simple regexps first
var simplename = /^[_:A-Za-z][-.:\w]+$/;
var simpleqname = /^([_A-Za-z][-.\w]+|[_A-Za-z][-.\w]+:[_A-Za-z][-.\w]+)$/;

// If the regular expressions above fail, try more complex ones that work
// for any identifiers using codepoints from the Unicode BMP
var ncnamestartchars = "_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02ff\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
var ncnamechars = "-._A-Za-z0-9\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02ff\u0300-\u037D\u037F-\u1FFF\u200C\u200D\u203f\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";

var ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
var namestartchars = ncnamestartchars + ":";
var namechars = ncnamechars + ":";
var name = new RegExp("^[" + namestartchars + "]" + "[" + namechars + "]*$");
var qname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");

// XML says that these characters are also legal:
// [#x10000-#xEFFFF].  So if the patterns above fail, and the
// target string includes surrogates, then try the following
// patterns that allow surrogates and then run an extra validation
// step to make sure that the surrogates are in valid pairs and in
// the right range.  Note that since the characters \uf0000 to \u1f0000
// are not allowed, it means that the high surrogate can only go up to
// \uDB7f instead of \uDBFF.
var hassurrogates = /[\uD800-\uDB7F\uDC00-\uDFFF]/;
var surrogatechars = /[\uD800-\uDB7F\uDC00-\uDFFF]/g;
var surrogatepairs = /[\uD800-\uDB7F][\uDC00-\uDFFF]/g;

// Modify the variables above to allow surrogates
ncnamestartchars += "\uD800-\uDB7F\uDC00-\uDFFF";
ncnamechars += "\uD800-\uDB7F\uDC00-\uDFFF";
ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
namestartchars = ncnamestartchars + ":";
namechars = ncnamechars + ":";

// Build another set of regexps that include surrogates
var surrogatename = new RegExp("^[" + namestartchars + "]" + "[" + namechars + "]*$");
var surrogateqname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");

function isValidName(s) {
  if (simplename.test(s)) return true; // Plain ASCII
  if (name.test(s)) return true; // Unicode BMP

  // Maybe the tests above failed because s includes surrogate pairs
  // Most likely, though, they failed for some more basic syntax problem
  if (!hassurrogates.test(s)) return false;

  // Is the string a valid name if we allow surrogates?
  if (!surrogatename.test(s)) return false;

  // Finally, are the surrogates all correctly paired up?
  var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);
  return pairs !== null && 2*pairs.length === chars.length;
}

function isValidQName(s) {
  if (simpleqname.test(s)) return true; // Plain ASCII
  if (qname.test(s)) return true; // Unicode BMP

  if (!hassurrogates.test(s)) return false;
  if (!surrogateqname.test(s)) return false;
  var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);
  return pairs !== null && 2*pairs.length === chars.length;
}


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* jshint eqnull: true */
/**
 * Zest (https://github.com/chjj/zest)
 * A css selector engine.
 * Copyright (c) 2011-2012, Christopher Jeffrey. (MIT Licensed)
 */

/**
 * Helpers
 */

var window = Object.create(null, {
  location: { get: function() {
    throw new Error('window.location is not supported.');
  } }
});

var compareDocumentPosition = function(a, b) {
      return a.compareDocumentPosition(b);
};

var order = function(a, b) {
  /* jshint bitwise: false */
  return compareDocumentPosition(a, b) & 2 ? 1 : -1;
};

var next = function(el) {
  while ((el = el.nextSibling)
         && el.nodeType !== 1);
  return el;
};

var prev = function(el) {
  while ((el = el.previousSibling)
         && el.nodeType !== 1);
  return el;
};

var child = function(el) {
  /*jshint -W084 */
  if (el = el.firstChild) {
    while (el.nodeType !== 1
           && (el = el.nextSibling));
  }
  return el;
};

var lastChild = function(el) {
  /*jshint -W084 */
  if (el = el.lastChild) {
    while (el.nodeType !== 1
           && (el = el.previousSibling));
  }
  return el;
};

var unquote = function(str) {
  if (!str) return str;
  var ch = str[0];
  if (ch === '"' || ch === '\'') {
    if (str[str.length-1] === ch) {
      str = str.slice(1, -1);
    } else {
      // bad string.
      str = str.slice(1);
    }
    return str.replace(rules.str_escape, function(s) {
      var m = /^\\(?:([0-9A-Fa-f]+)|([\r\n\f]+))/.exec(s);
      if (!m) { return s.slice(1); }
      if (m[2]) { return ''; /* escaped newlines are ignored in strings. */ }
      var cp = parseInt(m[1], 16);
      return String.fromCodePoint ? String.fromCodePoint(cp) :
        // Not all JavaScript implementations have String.fromCodePoint yet.
        String.fromCharCode(cp);
    });
  } else if (rules.ident.test(str)) {
    return decodeid(str);
  } else {
    // NUMBER, PERCENTAGE, DIMENSION, etc
    return str;
  }
};

var decodeid = function(str) {
  return str.replace(rules.escape, function(s) {
    var m = /^\\([0-9A-Fa-f]+)/.exec(s);
    if (!m) { return s[1]; }
    var cp = parseInt(m[1], 16);
    return String.fromCodePoint ? String.fromCodePoint(cp) :
      // Not all JavaScript implementations have String.fromCodePoint yet.
      String.fromCharCode(cp);
  });
};

var indexOf = (function() {
  if (Array.prototype.indexOf) {
    return Array.prototype.indexOf;
  }
  return function(obj, item) {
    var i = this.length;
    while (i--) {
      if (this[i] === item) return i;
    }
    return -1;
  };
})();

var makeInside = function(start, end) {
  var regex = rules.inside.source
    .replace(/</g, start)
    .replace(/>/g, end);

  return new RegExp(regex);
};

var replace = function(regex, name, val) {
  regex = regex.source;
  regex = regex.replace(name, val.source || val);
  return new RegExp(regex);
};

var truncateUrl = function(url, num) {
  return url
    .replace(/^(?:\w+:\/\/|\/+)/, '')
    .replace(/(?:\/+|\/*#.*?)$/, '')
    .split('/', num)
    .join('/');
};

/**
 * Handle `nth` Selectors
 */

var parseNth = function(param_, test) {
  var param = param_.replace(/\s+/g, '')
    , cap;

  if (param === 'even') {
    param = '2n+0';
  } else if (param === 'odd') {
    param = '2n+1';
  } else if (param.indexOf('n') === -1) {
    param = '0n' + param;
  }

  cap = /^([+-])?(\d+)?n([+-])?(\d+)?$/.exec(param);

  return {
    group: cap[1] === '-'
      ? -(cap[2] || 1)
      : +(cap[2] || 1),
    offset: cap[4]
      ? (cap[3] === '-' ? -cap[4] : +cap[4])
      : 0
  };
};

var nth = function(param_, test, last) {
  var param = parseNth(param_)
    , group = param.group
    , offset = param.offset
    , find = !last ? child : lastChild
    , advance = !last ? next : prev;

  return function(el) {
    if (el.parentNode.nodeType !== 1) return;

    var rel = find(el.parentNode)
      , pos = 0;

    while (rel) {
      if (test(rel, el)) pos++;
      if (rel === el) {
        pos -= offset;
        return group && pos
          ? (pos % group) === 0 && (pos < 0 === group < 0)
          : !pos;
      }
      rel = advance(rel);
    }
  };
};

/**
 * Simple Selectors
 */

var selectors = {
  '*': (function() {
    if (false/*function() {
      var el = document.createElement('div');
      el.appendChild(document.createComment(''));
      return !!el.getElementsByTagName('*')[0];
    }()*/) {
      return function(el) {
        if (el.nodeType === 1) return true;
      };
    }
    return function() {
      return true;
    };
  })(),
  'type': function(type) {
    type = type.toLowerCase();
    return function(el) {
      return el.nodeName.toLowerCase() === type;
    };
  },
  'attr': function(key, op, val, i) {
    op = operators[op];
    return function(el) {
      var attr;
      switch (key) {
        case 'for':
          attr = el.htmlFor;
          break;
        case 'class':
          // className is '' when non-existent
          // getAttribute('class') is null
          attr = el.className;
          if (attr === '' && el.getAttribute('class') == null) {
            attr = null;
          }
          break;
        case 'href':
          attr = el.getAttribute('href', 2);
          break;
        case 'title':
          // getAttribute('title') can be '' when non-existent sometimes?
          attr = el.getAttribute('title') || null;
          break;
        // careful with attributes with special getter functions
        case 'id':
        case 'lang':
        case 'dir':
        case 'accessKey':
        case 'hidden':
        case 'tabIndex':
        case 'style':
          if (el.getAttribute) {
            attr = el.getAttribute(key);
            break;
          }
        /* falls through */
        default:
          if (el.hasAttribute && !el.hasAttribute(key)) {
            break;
          }
          attr = el[key] != null
            ? el[key]
            : el.getAttribute && el.getAttribute(key);
          break;
      }
      if (attr == null) return;
      attr = attr + '';
      if (i) {
        attr = attr.toLowerCase();
        val = val.toLowerCase();
      }
      return op(attr, val);
    };
  },
  ':first-child': function(el) {
    return !prev(el) && el.parentNode.nodeType === 1;
  },
  ':last-child': function(el) {
    return !next(el) && el.parentNode.nodeType === 1;
  },
  ':only-child': function(el) {
    return !prev(el) && !next(el)
      && el.parentNode.nodeType === 1;
  },
  ':nth-child': function(param, last) {
    return nth(param, function() {
      return true;
    }, last);
  },
  ':nth-last-child': function(param) {
    return selectors[':nth-child'](param, true);
  },
  ':root': function(el) {
    return el.ownerDocument.documentElement === el;
  },
  ':empty': function(el) {
    return !el.firstChild;
  },
  ':not': function(sel) {
    var test = compileGroup(sel);
    return function(el) {
      return !test(el);
    };
  },
  ':first-of-type': function(el) {
    if (el.parentNode.nodeType !== 1) return;
    var type = el.nodeName;
    /*jshint -W084 */
    while (el = prev(el)) {
      if (el.nodeName === type) return;
    }
    return true;
  },
  ':last-of-type': function(el) {
    if (el.parentNode.nodeType !== 1) return;
    var type = el.nodeName;
    /*jshint -W084 */
    while (el = next(el)) {
      if (el.nodeName === type) return;
    }
    return true;
  },
  ':only-of-type': function(el) {
    return selectors[':first-of-type'](el)
        && selectors[':last-of-type'](el);
  },
  ':nth-of-type': function(param, last) {
    return nth(param, function(rel, el) {
      return rel.nodeName === el.nodeName;
    }, last);
  },
  ':nth-last-of-type': function(param) {
    return selectors[':nth-of-type'](param, true);
  },
  ':checked': function(el) {
    return !!(el.checked || el.selected);
  },
  ':indeterminate': function(el) {
    return !selectors[':checked'](el);
  },
  ':enabled': function(el) {
    return !el.disabled && el.type !== 'hidden';
  },
  ':disabled': function(el) {
    return !!el.disabled;
  },
  ':target': function(el) {
    return el.id === window.location.hash.substring(1);
  },
  ':focus': function(el) {
    return el === el.ownerDocument.activeElement;
  },
  ':matches': function(sel) {
    return compileGroup(sel);
  },
  ':nth-match': function(param, last) {
    var args = param.split(/\s*,\s*/)
      , arg = args.shift()
      , test = compileGroup(args.join(','));

    return nth(arg, test, last);
  },
  ':nth-last-match': function(param) {
    return selectors[':nth-match'](param, true);
  },
  ':links-here': function(el) {
    return el + '' === window.location + '';
  },
  ':lang': function(param) {
    return function(el) {
      while (el) {
        if (el.lang) return el.lang.indexOf(param) === 0;
        el = el.parentNode;
      }
    };
  },
  ':dir': function(param) {
    return function(el) {
      while (el) {
        if (el.dir) return el.dir === param;
        el = el.parentNode;
      }
    };
  },
  ':scope': function(el, con) {
    var context = con || el.ownerDocument;
    if (context.nodeType === 9) {
      return el === context.documentElement;
    }
    return el === context;
  },
  ':any-link': function(el) {
    return typeof el.href === 'string';
  },
  ':local-link': function(el) {
    if (el.nodeName) {
      return el.href && el.host === window.location.host;
    }
    var param = +el + 1;
    return function(el) {
      if (!el.href) return;

      var url = window.location + ''
        , href = el + '';

      return truncateUrl(url, param) === truncateUrl(href, param);
    };
  },
  ':default': function(el) {
    return !!el.defaultSelected;
  },
  ':valid': function(el) {
    return el.willValidate || (el.validity && el.validity.valid);
  },
  ':invalid': function(el) {
    return !selectors[':valid'](el);
  },
  ':in-range': function(el) {
    return el.value > el.min && el.value <= el.max;
  },
  ':out-of-range': function(el) {
    return !selectors[':in-range'](el);
  },
  ':required': function(el) {
    return !!el.required;
  },
  ':optional': function(el) {
    return !el.required;
  },
  ':read-only': function(el) {
    if (el.readOnly) return true;

    var attr = el.getAttribute('contenteditable')
      , prop = el.contentEditable
      , name = el.nodeName.toLowerCase();

    name = name !== 'input' && name !== 'textarea';

    return (name || el.disabled) && attr == null && prop !== 'true';
  },
  ':read-write': function(el) {
    return !selectors[':read-only'](el);
  },
  ':hover': function() {
    throw new Error(':hover is not supported.');
  },
  ':active': function() {
    throw new Error(':active is not supported.');
  },
  ':link': function() {
    throw new Error(':link is not supported.');
  },
  ':visited': function() {
    throw new Error(':visited is not supported.');
  },
  ':column': function() {
    throw new Error(':column is not supported.');
  },
  ':nth-column': function() {
    throw new Error(':nth-column is not supported.');
  },
  ':nth-last-column': function() {
    throw new Error(':nth-last-column is not supported.');
  },
  ':current': function() {
    throw new Error(':current is not supported.');
  },
  ':past': function() {
    throw new Error(':past is not supported.');
  },
  ':future': function() {
    throw new Error(':future is not supported.');
  },
  // Non-standard, for compatibility purposes.
  ':contains': function(param) {
    return function(el) {
      var text = el.innerText || el.textContent || el.value || '';
      return text.indexOf(param) !== -1;
    };
  },
  ':has': function(param) {
    return function(el) {
      return find(param, el).length > 0;
    };
  }
  // Potentially add more pseudo selectors for
  // compatibility with sizzle and most other
  // selector engines (?).
};

/**
 * Attribute Operators
 */

var operators = {
  '-': function() {
    return true;
  },
  '=': function(attr, val) {
    return attr === val;
  },
  '*=': function(attr, val) {
    return attr.indexOf(val) !== -1;
  },
  '~=': function(attr, val) {
    var i = attr.indexOf(val)
      , f
      , l;

    if (i === -1) return;
    f = attr[i - 1];
    l = attr[i + val.length];

    return (!f || f === ' ') && (!l || l === ' ');
  },
  '|=': function(attr, val) {
    var i = attr.indexOf(val)
      , l;

    if (i !== 0) return;
    l = attr[i + val.length];

    return l === '-' || !l;
  },
  '^=': function(attr, val) {
    return attr.indexOf(val) === 0;
  },
  '$=': function(attr, val) {
    return attr.indexOf(val) + val.length === attr.length;
  },
  // non-standard
  '!=': function(attr, val) {
    return attr !== val;
  }
};

/**
 * Combinator Logic
 */

var combinators = {
  ' ': function(test) {
    return function(el) {
      /*jshint -W084 */
      while (el = el.parentNode) {
        if (test(el)) return el;
      }
    };
  },
  '>': function(test) {
    return function(el) {
      /*jshint -W084 */
      if (el = el.parentNode) {
        return test(el) && el;
      }
    };
  },
  '+': function(test) {
    return function(el) {
      /*jshint -W084 */
      if (el = prev(el)) {
        return test(el) && el;
      }
    };
  },
  '~': function(test) {
    return function(el) {
      /*jshint -W084 */
      while (el = prev(el)) {
        if (test(el)) return el;
      }
    };
  },
  'noop': function(test) {
    return function(el) {
      return test(el) && el;
    };
  },
  'ref': function(test, name) {
    var node;

    function ref(el) {
      var doc = el.ownerDocument
        , nodes = doc.getElementsByTagName('*')
        , i = nodes.length;

      while (i--) {
        node = nodes[i];
        if (ref.test(el)) {
          node = null;
          return true;
        }
      }

      node = null;
    }

    ref.combinator = function(el) {
      if (!node || !node.getAttribute) return;

      var attr = node.getAttribute(name) || '';
      if (attr[0] === '#') attr = attr.substring(1);

      if (attr === el.id && test(node)) {
        return node;
      }
    };

    return ref;
  }
};

/**
 * Grammar
 */

var rules = {
  escape: /\\(?:[^0-9A-Fa-f\r\n]|[0-9A-Fa-f]{1,6}[\r\n\t ]?)/g,
  str_escape: /(escape)|\\(\n|\r\n?|\f)/g,
  nonascii: /[\u00A0-\uFFFF]/,
  cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,
  qname: /^ *(cssid|\*)/,
  simple: /^(?:([.#]cssid)|pseudo|attr)/,
  ref: /^ *\/(cssid)\/ */,
  combinator: /^(?: +([^ \w*.#\\]) +|( )+|([^ \w*.#\\]))(?! *$)/,
  attr: /^\[(cssid)(?:([^\w]?=)(inside))?\]/,
  pseudo: /^(:cssid)(?:\((inside)\))?/,
  inside: /(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|<[^"'>]*>|\\["'>]|[^"'>])*/,
  ident: /^(cssid)$/
};

rules.cssid = replace(rules.cssid, 'nonascii', rules.nonascii);
rules.cssid = replace(rules.cssid, 'escape', rules.escape);
rules.qname = replace(rules.qname, 'cssid', rules.cssid);
rules.simple = replace(rules.simple, 'cssid', rules.cssid);
rules.ref = replace(rules.ref, 'cssid', rules.cssid);
rules.attr = replace(rules.attr, 'cssid', rules.cssid);
rules.pseudo = replace(rules.pseudo, 'cssid', rules.cssid);
rules.inside = replace(rules.inside, '[^"\'>]*', rules.inside);
rules.attr = replace(rules.attr, 'inside', makeInside('\\[', '\\]'));
rules.pseudo = replace(rules.pseudo, 'inside', makeInside('\\(', '\\)'));
rules.simple = replace(rules.simple, 'pseudo', rules.pseudo);
rules.simple = replace(rules.simple, 'attr', rules.attr);
rules.ident = replace(rules.ident, 'cssid', rules.cssid);
rules.str_escape = replace(rules.str_escape, 'escape', rules.escape);

/**
 * Compiling
 */

var compile = function(sel_) {
  var sel = sel_.replace(/^\s+|\s+$/g, '')
    , test
    , filter = []
    , buff = []
    , subject
    , qname
    , cap
    , op
    , ref;

  /*jshint -W084 */
  while (sel) {
    if (cap = rules.qname.exec(sel)) {
      sel = sel.substring(cap[0].length);
      qname = cap[1];
      buff.push(tok(qname, true));
    } else if (cap = rules.simple.exec(sel)) {
      sel = sel.substring(cap[0].length);
      qname = '*';
      buff.push(tok(qname, true));
      buff.push(tok(cap));
    } else {
      throw new SyntaxError('Invalid selector.');
    }

    while (cap = rules.simple.exec(sel)) {
      sel = sel.substring(cap[0].length);
      buff.push(tok(cap));
    }

    if (sel[0] === '!') {
      sel = sel.substring(1);
      subject = makeSubject();
      subject.qname = qname;
      buff.push(subject.simple);
    }

    if (cap = rules.ref.exec(sel)) {
      sel = sel.substring(cap[0].length);
      ref = combinators.ref(makeSimple(buff), decodeid(cap[1]));
      filter.push(ref.combinator);
      buff = [];
      continue;
    }

    if (cap = rules.combinator.exec(sel)) {
      sel = sel.substring(cap[0].length);
      op = cap[1] || cap[2] || cap[3];
      if (op === ',') {
        filter.push(combinators.noop(makeSimple(buff)));
        break;
      }
    } else {
      op = 'noop';
    }

    if (!combinators[op]) { throw new SyntaxError('Bad combinator.'); }
    filter.push(combinators[op](makeSimple(buff)));
    buff = [];
  }

  test = makeTest(filter);
  test.qname = qname;
  test.sel = sel;

  if (subject) {
    subject.lname = test.qname;

    subject.test = test;
    subject.qname = subject.qname;
    subject.sel = test.sel;
    test = subject;
  }

  if (ref) {
    ref.test = test;
    ref.qname = test.qname;
    ref.sel = test.sel;
    test = ref;
  }

  return test;
};

var tok = function(cap, qname) {
  // qname
  if (qname) {
    return cap === '*'
      ? selectors['*']
      : selectors.type(decodeid(cap));
  }

  // class/id
  if (cap[1]) {
    return cap[1][0] === '.'
	  // XXX unescape here?  or in attr?
      ? selectors.attr('class', '~=', decodeid(cap[1].substring(1)))
      : selectors.attr('id', '=', decodeid(cap[1].substring(1)));
  }

  // pseudo-name
  // inside-pseudo
  if (cap[2]) {
    return cap[3]
      ? selectors[decodeid(cap[2])](unquote(cap[3]))
      : selectors[decodeid(cap[2])];
  }

  // attr name
  // attr op
  // attr value
  if (cap[4]) {
    return selectors.attr(decodeid(cap[4]), cap[5] || '-', unquote(cap[6]), false);
  }

  throw new SyntaxError('Unknown Selector.');
};

var makeSimple = function(func) {
  var l = func.length
    , i;

  // Potentially make sure
  // `el` is truthy.
  if (l < 2) return func[0];

  return function(el) {
    if (!el) return;
    for (i = 0; i < l; i++) {
      if (!func[i](el)) return;
    }
    return true;
  };
};

var makeTest = function(func) {
  if (func.length < 2) {
    return function(el) {
      return !!func[0](el);
    };
  }
  return function(el) {
    var i = func.length;
    while (i--) {
      if (!(el = func[i](el))) return;
    }
    return true;
  };
};

var makeSubject = function() {
  var target;

  function subject(el) {
    var node = el.ownerDocument
      , scope = node.getElementsByTagName(subject.lname)
      , i = scope.length;

    while (i--) {
      if (subject.test(scope[i]) && target === el) {
        target = null;
        return true;
      }
    }

    target = null;
  }

  subject.simple = function(el) {
    target = el;
    return true;
  };

  return subject;
};

var compileGroup = function(sel) {
  var test = compile(sel)
    , tests = [ test ];

  while (test.sel) {
    test = compile(test.sel);
    tests.push(test);
  }

  if (tests.length < 2) return test;

  return function(el) {
    var l = tests.length
      , i = 0;

    for (; i < l; i++) {
      if (tests[i](el)) return true;
    }
  };
};

/**
 * Selection
 */

var find = function(sel, node) {
  var results = []
    , test = compile(sel)
    , scope = node.getElementsByTagName(test.qname)
    , i = 0
    , el;

  /*jshint -W084 */
  while (el = scope[i++]) {
    if (test(el)) results.push(el);
  }

  if (test.sel) {
    while (test.sel) {
      test = compile(test.sel);
      scope = node.getElementsByTagName(test.qname);
      i = 0;
      /*jshint -W084 */
      while (el = scope[i++]) {
        if (test(el) && indexOf.call(results, el) === -1) {
          results.push(el);
        }
      }
    }
    results.sort(order);
  }

  return results;
};

/**
 * Expose
 */

module.exports = exports = function(sel, context) {
  /* when context isn't a DocumentFragment and the selector is simple: */
  var id, r;
  if (context.nodeType !== 11 && sel.indexOf(' ') === -1) {
    if (sel[0] === '#' && context.rooted && /^#[A-Z_][-A-Z0-9_]*$/i.test(sel)) {
      if (context.doc._hasMultipleElementsWithId) {
        id = sel.substring(1);
        if (!context.doc._hasMultipleElementsWithId(id)) {
          r = context.doc.getElementById(id);
          return r ? [r] : [];
        }
      }
    }
    if (sel[0] === '.' && /^\.\w+$/.test(sel)) {
      return context.getElementsByClassName(sel.substring(1));
    }
    if (/^\w+$/.test(sel)) {
      return context.getElementsByTagName(sel);
    }
  }
  /* do things the hard/slow way */
  return find(sel, context);
};

exports.selectors = selectors;
exports.operators = operators;
exports.combinators = combinators;

exports.matches = function(el, sel) {
  var test = { sel: sel };
  do {
    test = compile(test.sel);
    if (test(el)) { return true; }
  } while (test.sel);
  return false;
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Node = __webpack_require__(3);

var createDocumentFragmentFromArguments = function(document, args) {
  var docFrag = document.createDocumentFragment();

  for (var i=0; i<args.length; i++) {
    var argItem = args[i];
    var isNode = argItem instanceof Node;
    docFrag.appendChild(isNode ? argItem :
                        document.createTextNode(String(argItem)));
  }

  return docFrag;
};

// The ChildNode interface contains methods that are particular to `Node`
// objects that can have a parent.  It is implemented by `Element`,
// `DocumentType`, and `CharacterData` objects.
var ChildNode = {

  // Inserts a set of Node or String objects in the children list of this
  // ChildNode's parent, just after this ChildNode.  String objects are
  // inserted as the equivalent Text nodes.
  after: { value: function after() {
    var argArr = Array.prototype.slice.call(arguments);
    var parentNode = this.parentNode, nextSibling = this.nextSibling;
    if (parentNode === null) { return; }
    // Find "viable next sibling"; that is, next one not in argArr
    while (nextSibling && argArr.some(function(v) { return v===nextSibling; }))
      nextSibling = nextSibling.nextSibling;
    // ok, parent and sibling are saved away since this node could itself
    // appear in argArr and we're about to move argArr to a document fragment.
    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);

    parentNode.insertBefore(docFrag, nextSibling);
  }},

  // Inserts a set of Node or String objects in the children list of this
  // ChildNode's parent, just before this ChildNode.  String objects are
  // inserted as the equivalent Text nodes.
  before: { value: function before() {
    var argArr = Array.prototype.slice.call(arguments);
    var parentNode = this.parentNode, prevSibling = this.previousSibling;
    if (parentNode === null) { return; }
    // Find "viable prev sibling"; that is, prev one not in argArr
    while (prevSibling && argArr.some(function(v) { return v===prevSibling; }))
      prevSibling = prevSibling.previousSibling;
    // ok, parent and sibling are saved away since this node could itself
    // appear in argArr and we're about to move argArr to a document fragment.
    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);

    var nextSibling =
        prevSibling ? prevSibling.nextSibling : parentNode.firstChild;
    parentNode.insertBefore(docFrag, nextSibling);
  }},

  // Remove this node from its parent
  remove: { value: function remove() {
    if (this.parentNode === null) return;

    // Send mutation events if necessary
    if (this.rooted && this.doc) this.doc.mutateRemove(this);

    // Remove this node from its parents array of children
    this.parentNode.childNodes.splice(this.index, 1);

    // Update the structure id for all ancestors
    this.parentNode.modify();

    // Forget this node's parent
    this.parentNode = null;
  }},

  // Replace this node with the nodes or strings provided as arguments.
  replaceWith: { value: function replaceWith() {
    var argArr = Array.prototype.slice.call(arguments);
    var parentNode = this.parentNode, nextSibling = this.nextSibling;
    if (parentNode === null) { return; }
    // Find "viable next sibling"; that is, next one not in argArr
    while (nextSibling && argArr.some(function(v) { return v===nextSibling; }))
      nextSibling = nextSibling.nextSibling;
    // ok, parent and sibling are saved away since this node could itself
    // appear in argArr and we're about to move argArr to a document fragment.
    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
    if (this.parentNode === parentNode) {
      parentNode.replaceChild(docFrag, this);
    } else {
      // `this` was inserted into docFrag
      parentNode.insertBefore(docFrag, nextSibling);
    }
  }},

};

module.exports = ChildNode;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = URL;

function URL(url) {
  if (!url) return Object.create(URL.prototype);
  // Can't use String.trim() since it defines whitespace differently than HTML
  this.url = url.replace(/^[ \t\n\r\f]+|[ \t\n\r\f]+$/g, "");

  // See http://tools.ietf.org/html/rfc3986#appendix-B
  // and https://url.spec.whatwg.org/#parsing
  var match = URL.pattern.exec(this.url);
  if (match) {
    if (match[2]) this.scheme = match[2];
    if (match[4]) {
      // parse username/password
      var userinfo = match[4].match(URL.userinfoPattern);
      if (userinfo) {
        this.username = userinfo[1];
        this.password = userinfo[3];
        match[4] = match[4].substring(userinfo[0].length);
      }
      if (match[4].match(URL.portPattern)) {
        var pos = match[4].lastIndexOf(':');
        this.host = match[4].substring(0, pos);
        this.port = match[4].substring(pos+1);
      }
      else {
        this.host = match[4];
      }
    }
    if (match[5]) this.path = match[5];
    if (match[6]) this.query = match[7];
    if (match[8]) this.fragment = match[9];
  }
}

URL.pattern = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/;
URL.userinfoPattern = /^([^@:]*)(:([^@]*))?@/;
URL.portPattern = /:\d+$/;
URL.authorityPattern = /^[^:\/?#]+:\/\//;
URL.hierarchyPattern = /^[^:\/?#]+:\//;

// Return a percentEncoded version of s.
// S should be a single-character string
// XXX: needs to do utf-8 encoding?
URL.percentEncode = function percentEncode(s) {
  var c = s.charCodeAt(0);
  if (c < 256) return "%" + c.toString(16);
  else throw Error("can't percent-encode codepoints > 255 yet");
};

URL.prototype = {
  constructor: URL,

  // XXX: not sure if this is the precise definition of absolute
  isAbsolute: function() { return !!this.scheme; },
  isAuthorityBased: function() {
    return URL.authorityPattern.test(this.url);
  },
  isHierarchical: function() {
    return URL.hierarchyPattern.test(this.url);
  },

  toString: function() {
    var s = "";
    if (this.scheme !== undefined) s += this.scheme + ":";
    if (this.isAbsolute()) {
      s += '//';
      if (this.username || this.password) {
        s += this.username || '';
        if (this.password) {
          s += ':' + this.password;
        }
        s += '@';
      }
      s += this.host;
    }
    if (this.port !== undefined) s += ":" + this.port;
    if (this.path !== undefined) s += this.path;
    if (this.query !== undefined) s += "?" + this.query;
    if (this.fragment !== undefined) s += "#" + this.fragment;
    return s;
  },

  // See: http://tools.ietf.org/html/rfc3986#section-5.2
  // and https://url.spec.whatwg.org/#constructors
  resolve: function(relative) {
    var base = this;           // The base url we're resolving against
    var r = new URL(relative); // The relative reference url to resolve
    var t = new URL();         // The absolute target url we will return

    if (r.scheme !== undefined) {
      t.scheme = r.scheme;
      t.username = r.username;
      t.password = r.password;
      t.host = r.host;
      t.port = r.port;
      t.path = remove_dot_segments(r.path);
      t.query = r.query;
    }
    else {
      t.scheme = base.scheme;
      if (r.host !== undefined) {
        t.username = r.username;
        t.password = r.password;
        t.host = r.host;
        t.port = r.port;
        t.path = remove_dot_segments(r.path);
        t.query = r.query;
      }
      else {
        t.username = base.username;
        t.password = base.password;
        t.host = base.host;
        t.port = base.port;
        if (!r.path) { // undefined or empty
          t.path = base.path;
          if (r.query !== undefined)
            t.query = r.query;
          else
            t.query = base.query;
        }
        else {
          if (r.path.charAt(0) === "/") {
            t.path = remove_dot_segments(r.path);
          }
          else {
            t.path = merge(base.path, r.path);
            t.path = remove_dot_segments(t.path);
          }
          t.query = r.query;
        }
      }
    }
    t.fragment = r.fragment;

    return t.toString();


    function merge(basepath, refpath) {
      if (base.host !== undefined && !base.path)
        return "/" + refpath;

      var lastslash = basepath.lastIndexOf("/");
      if (lastslash === -1)
        return refpath;
      else
        return basepath.substring(0, lastslash+1) + refpath;
    }

    function remove_dot_segments(path) {
      if (!path) return path; // For "" or undefined

      var output = "";
      while(path.length > 0) {
        if (path === "." || path === "..") {
          path = "";
          break;
        }

        var twochars = path.substring(0,2);
        var threechars = path.substring(0,3);
        var fourchars = path.substring(0,4);
        if (threechars === "../") {
          path = path.substring(3);
        }
        else if (twochars === "./") {
          path = path.substring(2);
        }
        else if (threechars === "/./") {
          path = "/" + path.substring(3);
        }
        else if (twochars === "/." && path.length === 2) {
          path = "/";
        }
        else if (fourchars === "/../" ||
             (threechars === "/.." && path.length === 3)) {
          path = "/" + path.substring(4);

          output = output.replace(/\/?[^\/]*$/, "");
        }
        else {
          var segment = path.match(/(\/?([^\/]*))/)[0];
          output += segment;
          path = path.substring(segment.length);
        }
      }

      return output;
    }
  },
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Node = __webpack_require__(3);
var Element = __webpack_require__(7);
var CSSStyleDeclaration = __webpack_require__(24);
var utils = __webpack_require__(2);
var URLUtils = __webpack_require__(51);
var defineElement = __webpack_require__(52);

var htmlElements = exports.elements = {};
var htmlNameToImpl = Object.create(null);

exports.createElement = function(doc, localName, prefix) {
  var impl = htmlNameToImpl[localName] || HTMLUnknownElement;
  return new impl(doc, localName, prefix);
};

function define(spec) {
  return defineElement(spec, HTMLElement, htmlElements, htmlNameToImpl);
}

function URL(attr) {
  return {
    get: function() {
      var v = this._getattr(attr);
      if (v === null) { return ''; }
      var url = this.doc._resolve(v);
      return (url === null) ? v : url;
    },
    set: function(value) {
      this._setattr(attr, value);
    }
  };
}

function CORS(attr) {
  return {
    get: function() {
      var v = this._getattr(attr);
      if (v === null) { return null; }
      if (v.toLowerCase() === 'use-credentials') { return 'use-credentials'; }
      return 'anonymous';
    },
    set: function(value) {
      if (value===null || value===undefined) {
        this.removeAttribute(attr);
      } else {
        this._setattr(attr, value);
      }
    }
  };
}

var REFERRER = {
  type: ["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"],
  missing: '',
};


// XXX: the default value for tabIndex should be 0 if the element is
// focusable and -1 if it is not.  But the full definition of focusable
// is actually hard to compute, so for now, I'll follow Firefox and
// just base the default value on the type of the element.
var focusableElements = {
  "A":true, "LINK":true, "BUTTON":true, "INPUT":true,
  "SELECT":true, "TEXTAREA":true, "COMMAND":true
};

var HTMLFormElement = function(doc, localName, prefix) {
  HTMLElement.call(this, doc, localName, prefix);
  this._form = null; // Prevent later deoptimization
};

var HTMLElement = exports.HTMLElement = define({
  superclass: Element,
  ctor: function HTMLElement(doc, localName, prefix) {
    Element.call(this, doc, localName, utils.NAMESPACE.HTML, prefix);
  },
  props: {
    innerHTML: {
      get: function() {
        return this.serialize();
      },
      set: function(v) {
        var parser = this.ownerDocument.implementation.mozHTMLParser(
          this.ownerDocument._address,
          this);
        parser.parse(v, true);
        var tmpdoc = parser.document();
        var root = tmpdoc.firstChild;
        var target = (this instanceof htmlNameToImpl.template) ?
            this.content : this;

        // Remove any existing children of this node
        while(target.hasChildNodes())
          target.removeChild(target.firstChild);

        // Now copy newly parsed children from the root to this node
        target.doc.adoptNode(root);
        while(root.hasChildNodes()) {
          target.appendChild(root.firstChild);
        }
      }
    },
    style: { get: function() {
      if (!this._style)
        this._style = new CSSStyleDeclaration(this);
      return this._style;
    }},

    click: { value: function() {
      if (this._click_in_progress) return;
      this._click_in_progress = true;
      try {
        if (this._pre_click_activation_steps)
          this._pre_click_activation_steps();

        var event = this.ownerDocument.createEvent("MouseEvent");
        event.initMouseEvent("click", true, true,
          this.ownerDocument.defaultView, 1,
          0, 0, 0, 0,
          // These 4 should be initialized with
          // the actually current keyboard state
          // somehow...
          false, false, false, false,
          0, null
        );

        // Dispatch this as an untrusted event since it is synthetic
        var success = this.dispatchEvent(event);

        if (success) {
          if (this._post_click_activation_steps)
            this._post_click_activation_steps(event);
        }
        else {
          if (this._cancelled_activation_steps)
            this._cancelled_activation_steps();
        }
      }
      finally {
        this._click_in_progress = false;
      }
    }}
  },
  attributes: {
    title: String,
    lang: String,
    dir: {type: ["ltr", "rtl", "auto"], missing: ''},
    accessKey: String,
    hidden: Boolean,
    tabIndex: {type: "long", default: function() {
      if (this.tagName in focusableElements ||
        this.contentEditable)
        return 0;
      else
        return -1;
    }}
  },
  events: [
    "abort", "canplay", "canplaythrough", "change", "click", "contextmenu",
    "cuechange", "dblclick", "drag", "dragend", "dragenter", "dragleave",
    "dragover", "dragstart", "drop", "durationchange", "emptied", "ended",
    "input", "invalid", "keydown", "keypress", "keyup", "loadeddata",
    "loadedmetadata", "loadstart", "mousedown", "mousemove", "mouseout",
    "mouseover", "mouseup", "mousewheel", "pause", "play", "playing",
    "progress", "ratechange", "readystatechange", "reset", "seeked",
    "seeking", "select", "show", "stalled", "submit", "suspend",
    "timeupdate", "volumechange", "waiting",

    // These last 5 event types will be overriden by HTMLBodyElement
    "blur", "error", "focus", "load", "scroll"
  ]
});


// XXX: reflect contextmenu as contextMenu, with element type


// style: the spec doesn't call this a reflected attribute.
//   may want to handle it manually.

// contentEditable: enumerated, not clear if it is actually
// reflected or requires custom getter/setter. Not listed as
// "limited to known values".  Raises syntax_err on bad setting,
// so I think this is custom.

// contextmenu: content is element id, idl type is an element
// draggable: boolean, but not a reflected attribute
// dropzone: reflected SettableTokenList, experimental, so don't
//   implement it right away.

// data-* attributes: need special handling in setAttribute?
// Or maybe that isn't necessary. Can I just scan the attribute list
// when building the dataset?  Liveness and caching issues?

// microdata attributes: many are simple reflected attributes, but
// I'm not going to implement this now.


var HTMLUnknownElement = define({
  ctor: function HTMLUnknownElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});


var formAssociatedProps = {
  // See http://www.w3.org/TR/html5/association-of-controls-and-forms.html#form-owner
  form: { get: function() {
    return this._form;
  }}
};

define({
  tag: 'a',
  ctor: function HTMLAnchorElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    _post_click_activation_steps: { value: function(e) {
      if (this.href) {
        // Follow the link
        // XXX: this is just a quick hack
        // XXX: the HTML spec probably requires more than this
        this.ownerDocument.defaultView.location = this.href;
      }
    }},
    blur: { value: function() {}},
    focus: { value: function() {}}
  },
  attributes: {
    href: URL,
    ping: String,
    download: String,
    target: String,
    rel: String,
    media: String,
    hreflang: String,
    type: String,
    referrerPolicy: REFERRER,
    // Obsolete
    coords: String,
    charset: String,
    name: String,
    rev: String,
    shape: String,
  }
});
URLUtils._inherit(htmlNameToImpl.a.prototype);

define({
  tag: 'area',
  ctor: function HTMLAreaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    alt: String,
    target: String,
    download: String,
    rel: String,
    media: String,
    href: URL,
    hreflang: String,
    type: String,
    shape: String,
    coords: String,
    ping: String,
    // XXX: also reflect relList
    referrerPolicy: REFERRER,
    // Obsolete
    noHref: Boolean,
  }
});

define({
  tag: 'br',
  ctor: function HTMLBRElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    clear: String
  },
});

define({
  tag: 'base',
  ctor: function HTMLBaseElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    "target": String
  }
});


define({
  tag: 'body',
  ctor: function HTMLBodyElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  // Certain event handler attributes on a <body> tag actually set
  // handlers for the window rather than just that element.  Define
  // getters and setters for those here.  Note that some of these override
  // properties on HTMLElement.prototype.
  // XXX: If I add support for <frameset>, these have to go there, too
  // XXX
  // When the Window object is implemented, these attribute will have
  // to work with the same-named attributes on the Window.
  events: [
    "afterprint", "beforeprint", "beforeunload", "blur", "error",
    "focus","hashchange", "load", "message", "offline", "online",
    "pagehide", "pageshow","popstate","resize","scroll","storage","unload",
  ],
  attributes: {
    // Obsolete
    text: { type: String, treatNullAsEmptyString: true },
    link: { type: String, treatNullAsEmptyString: true },
    vLink: { type: String, treatNullAsEmptyString: true },
    aLink: { type: String, treatNullAsEmptyString: true },
    bgColor: { type: String, treatNullAsEmptyString: true },
    background: String,
  }
});

define({
  tag: 'button',
  ctor: function HTMLButtonElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    name: String,
    value: String,
    disabled: Boolean,
    autofocus: Boolean,
    type: { type:["submit", "reset", "button", "menu"], missing: 'submit' },
    formTarget: String,
    formNoValidate: Boolean,
    formMethod: { type: ["get", "post", "dialog"], invalid: 'get', missing: '' },
    formEnctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: '' },
  }
});

define({
  tag: 'dl',
  ctor: function HTMLDListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    compact: Boolean,
  }
});

define({
  tag: 'data',
  ctor: function HTMLDataElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    value: String,
  }
});

define({
  tag: 'datalist',
  ctor: function HTMLDataListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'details',
  ctor: function HTMLDetailsElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    "open": Boolean
  }
});

define({
  tag: 'div',
  ctor: function HTMLDivElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  }
});

define({
  tag: 'embed',
  ctor: function HTMLEmbedElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    type: String,
    width: String,
    height: String,
    // Obsolete
    align: String,
    name: String,
  }
});

define({
  tag: 'fieldset',
  ctor: function HTMLFieldSetElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    disabled: Boolean,
    name: String
  }
});

define({
  tag: 'form',
  ctor: function HTMLFormElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    action: String,
    autocomplete: {type:['on', 'off'], missing: 'on'},
    name: String,
    acceptCharset: {name: "accept-charset"},
    target: String,
    noValidate: Boolean,
    method: { type: ["get", "post", "dialog"], invalid: 'get', missing: 'get' },
    // Both enctype and encoding reflect the enctype content attribute
    enctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded" },
    encoding: {name: 'enctype', type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded" },
  }
});

define({
  tag: 'hr',
  ctor: function HTMLHRElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String,
    color: String,
    noShade: Boolean,
    size: String,
    width: String,
  },
});

define({
  tag: 'head',
  ctor: function HTMLHeadElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tags: ['h1','h2','h3','h4','h5','h6'],
  ctor: function HTMLHeadingElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String,
  },
});

define({
  tag: 'html',
  ctor: function HTMLHtmlElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    version: String
  }
});

define({
  tag: 'iframe',
  ctor: function HTMLIFrameElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
    var Window = __webpack_require__(25); // Avoid circular dependencies.
    this._contentWindow = new Window();
  },
  props: {
    contentWindow: { get: function() {
      return this._contentWindow;
    } },
    contentDocument: { get: function() {
      return this.contentWindow.document;
    } },
  },
  attributes: {
    src: URL,
    srcdoc: String,
    name: String,
    width: String,
    height: String,
    // XXX: sandbox is a reflected settable token list
    seamless: Boolean,
    allowFullscreen: Boolean,
    allowUserMedia: Boolean,
    allowPaymentRequest: Boolean,
    referrerPolicy: REFERRER,
    // Obsolete
    align: String,
    scrolling: String,
    frameBorder: String,
    longDesc: URL,
    marginHeight: { type: String, treatNullAsEmptyString: true },
    marginWidth: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'img',
  ctor: function HTMLImageElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    alt: String,
    src: URL,
    srcset: String,
    crossOrigin: CORS,
    useMap: String,
    isMap: Boolean,
    height: { type: "unsigned long", default: 0 },
    width: { type: "unsigned long", default: 0 },
    referrerPolicy: REFERRER,
    // Obsolete:
    name: String,
    lowsrc: URL,
    align: String,
    hspace: { type: "unsigned long", default: 0 },
    vspace: { type: "unsigned long", default: 0 },
    longDesc: URL,
    border: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'input',
  ctor: function HTMLInputElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: {
    form: formAssociatedProps.form,
    _post_click_activation_steps: { value: function(e) {
      if (this.type === 'checkbox') {
        this.checked = !this.checked;
      }
      else if (this.type === 'radio') {
        var group = this.form.getElementsByName(this.name);
        for (var i=group.length-1; i >= 0; i--) {
          var el = group[i];
          el.checked = (el === this);
        }
      }
    }},
  },
  attributes: {
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    accept: String,
    alt: String,
    max: String,
    min: String,
    pattern: String,
    placeholder: String,
    step: String,
    dirName: String,
    defaultValue: {name: 'value'},
    multiple: Boolean,
    required: Boolean,
    readOnly: Boolean,
    checked: Boolean,
    value: String,
    src: URL,
    defaultChecked: {name: 'checked', type: Boolean},
    size: {type: 'unsigned long', default: 20, min: 1, setmin: 1},
    maxLength: {type: 'unsigned long', min: 0, setmin: 0, default: -1},
    autocomplete: String, // It's complicated
    type: { type:
            ["text", "hidden", "search", "tel", "url", "email", "password",
             "datetime", "date", "month", "week", "time", "datetime-local",
             "number", "range", "color", "checkbox", "radio", "file", "submit",
             "image", "reset", "button"],
            missing: 'text' },
    formTarget: String,
    formNoValidate: Boolean,
    formMethod: { type: ["get", "post"], invalid: 'get', missing: '' },
    formEnctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: '' },
    inputMode: { type: [ "verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url" ], missing: '' },
    // Obsolete
    align: String,
    useMap: String,
  }
});

define({
  tag: 'keygen',
  ctor: function HTMLKeygenElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    challenge: String,
    keytype: { type:["rsa"], missing: '' },
  }
});

define({
  tag: 'li',
  ctor: function HTMLLIElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    value: {type: "long", default: 0},
    // Obsolete
    type: String,
  }
});

define({
  tag: 'label',
  ctor: function HTMLLabelElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    htmlFor: {name: 'for', type: String}
  }
});

define({
  tag: 'legend',
  ctor: function HTMLLegendElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  },
});

define({
  tag: 'link',
  ctor: function HTMLLinkElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // XXX Reflect DOMSettableTokenList sizes also DOMTokenList relList
    href: URL,
    rel: String,
    media: String,
    hreflang: String,
    type: String,
    crossOrigin: CORS,
    nonce: String,
    integrity: String,
    referrerPolicy: REFERRER,
    // Obsolete
    charset: String,
    rev: String,
    target: String,
  }
});

define({
  tag: 'map',
  ctor: function HTMLMapElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String
  }
});

define({
  tag: 'menu',
  ctor: function HTMLMenuElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // XXX: not quite right, default should be popup if parent element is
    // popup.
    type: { type: [ 'context', 'popup', 'toolbar' ], missing: 'toolbar' },
    label: String,
    // Obsolete
    compact: Boolean,
  }
});

define({
  tag: 'meta',
  ctor: function HTMLMetaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String,
    content: String,
    httpEquiv: {name: 'http-equiv', type: String},
    // Obsolete
    scheme: String,
  }
});

define({
  tag: 'meter',
  ctor: function HTMLMeterElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps
});

define({
  tags: ['ins', 'del'],
  ctor: function HTMLModElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    cite: URL,
    dateTime: String
  }
});

define({
  tag: 'ol',
  ctor: function HTMLOListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    // Utility function (see the start attribute default value). Returns
    // the number of <li> children of this element
    _numitems: { get: function() {
      var items = 0;
      this.childNodes.forEach(function(n) {
        if (n.nodeType === Node.ELEMENT_NODE && n.tagName === "LI")
          items++;
      });
      return items;
    }}
  },
  attributes: {
    type: String,
    reversed: Boolean,
    start: {
      type: "long",
      default: function() {
       // The default value of the start attribute is 1 unless the list is
       // reversed. Then it is the # of li children
       if (this.reversed)
         return this._numitems;
       else
         return 1;
      }
    },
    // Obsolete
    compact: Boolean,
  }
});

define({
  tag: 'object',
  ctor: function HTMLObjectElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    data: URL,
    type: String,
    name: String,
    useMap: String,
    typeMustMatch: Boolean,
    width: String,
    height: String,
    // Obsolete
    align: String,
    archive: String,
    code: String,
    declare: Boolean,
    hspace: { type: "unsigned long", default: 0 },
    standby: String,
    vspace: { type: "unsigned long", default: 0 },
    codeBase: URL,
    codeType: String,
    border: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'optgroup',
  ctor: function HTMLOptGroupElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    disabled: Boolean,
    label: String
  }
});

define({
  tag: 'option',
  ctor: function HTMLOptionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    form: { get: function() {
      var p = this.parentNode;
      while (p && p.nodeType === Node.ELEMENT_NODE) {
        if (p.localName === 'select') return p.form;
        p = p.parentNode;
      }
    }}
  },
  attributes: {
    disabled: Boolean,
    defaultSelected: {name: 'selected', type: Boolean},
    label: String,
    value: String,
  }
});

define({
  tag: 'output',
  ctor: function HTMLOutputElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    // XXX Reflect for/htmlFor as a settable token list
    name: String
  }
});

define({
  tag: 'p',
  ctor: function HTMLParagraphElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String
  }
});

define({
  tag: 'param',
  ctor: function HTMLParamElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    name: String,
    value: String,
    // Obsolete
    type: String,
    valueType: String,
  }
});

define({
  tags: ['pre',/*legacy elements:*/'listing','xmp'],
  ctor: function HTMLPreElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    width: { type: "long", default: 0 },
  }
});

define({
  tag: 'progress',
  ctor: function HTMLProgressElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    max: {type: Number, float: true, default: 1.0, min: 0}
  }
});

define({
  tags: ['q', 'blockquote'],
  ctor: function HTMLQuoteElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    cite: URL
  }
});

define({
  tag: 'script',
  ctor: function HTMLScriptElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    text: {
      get: function() {
        var s = "";
        for(var i = 0, n = this.childNodes.length; i < n; i++) {
          var child = this.childNodes[i];
          if (child.nodeType === Node.TEXT_NODE)
            s += child._data;
        }
        return s;
      },
      set: function(value) {
        this.removeChildren();
        if (value !== null && value !== "") {
          this.appendChild(this.ownerDocument.createTextNode(value));
        }
      }
    }
  },
  attributes: {
    src: URL,
    type: String,
    charset: String,
    defer: Boolean,
    async: Boolean,
    crossOrigin: CORS,
    nonce: String,
    integrity: String,
  }
});

define({
  tag: 'select',
  ctor: function HTMLSelectElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: {
    form: formAssociatedProps.form,
    options: { get: function() {
      return this.getElementsByTagName('option');
    }}
  },
  attributes: {
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    multiple: Boolean,
    required: Boolean,
    size: {type: "unsigned long", default: 0}
  }
});

define({
  tag: 'source',
  ctor: function HTMLSourceElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    type: String,
    media: String
  }
});

define({
  tag: 'span',
  ctor: function HTMLSpanElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'style',
  ctor: function HTMLStyleElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    media: String,
    type: String,
    scoped: Boolean
  }
});

define({
  tag: 'caption',
  ctor: function HTMLTableCaptionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    // Obsolete
    align: String,
  }
});


define({
  ctor: function HTMLTableCellElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    colSpan: {type: "unsigned long", default: 1},
    rowSpan: {type: "unsigned long", default: 1},
    //XXX Also reflect settable token list headers
    scope: { type: ['row','col','rowgroup','colgroup'], missing: '' },
    abbr: String,
    // Obsolete
    align: String,
    axis: String,
    height: String,
    width: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    noWrap: Boolean,
    vAlign: String,
    bgColor: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tags: ['col', 'colgroup'],
  ctor: function HTMLTableColElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    span: {type: 'limited unsigned long with fallback', default: 1, min: 1},
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String,
    width: String,
  }
});

define({
  tag: 'table',
  ctor: function HTMLTableElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    rows: { get: function() {
      return this.getElementsByTagName('tr');
    }}
  },
  attributes: {
    // Obsolete
    align: String,
    border: String,
    frame: String,
    rules: String,
    summary: String,
    width: String,
    bgColor: { type: String, treatNullAsEmptyString: true },
    cellPadding: { type: String, treatNullAsEmptyString: true },
    cellSpacing: { type: String, treatNullAsEmptyString: true },
  }
});

define({
  tag: 'template',
  ctor: function HTMLTemplateElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
    this._contentFragment = doc._templateDoc.createDocumentFragment();
  },
  props: {
    content: { get: function() { return this._contentFragment; } },
    serialize: { value: function() { return this.content.serialize(); } }
  }
});

define({
  tag: 'tr',
  ctor: function HTMLTableRowElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    cells: { get: function() {
      return this.querySelectorAll('td,th');
    }}
  },
  attributes: {
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String,
    bgColor: { type: String, treatNullAsEmptyString: true },
  },
});

define({
  tags: ['thead', 'tfoot', 'tbody'],
  ctor: function HTMLTableSectionElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    rows: { get: function() {
      return this.getElementsByTagName('tr');
    }}
  },
  attributes: {
    // Obsolete
    align: String,
    ch: { name: 'char', type: String },
    chOff: { name: 'charoff', type: String },
    vAlign: String,
  }
});

define({
  tag: 'textarea',
  ctor: function HTMLTextAreaElement(doc, localName, prefix) {
    HTMLFormElement.call(this, doc, localName, prefix);
  },
  props: formAssociatedProps,
  attributes: {
    autocomplete: String, // It's complicated
    name: String,
    disabled: Boolean,
    autofocus: Boolean,
    placeholder: String,
    wrap: String,
    dirName: String,
    required: Boolean,
    readOnly: Boolean,
    rows: {type: 'limited unsigned long with fallback', default: 2 },
    cols: {type: 'limited unsigned long with fallback', default: 20 },
    maxLength: {type: 'unsigned long', min: 0, setmin: 0, default: -1},
    inputMode: { type: [ "verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url" ], missing: '' },
  }
});

define({
  tag: 'time',
  ctor: function HTMLTimeElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    dateTime: String,
    pubDate: Boolean
  }
});

define({
  tag: 'title',
  ctor: function HTMLTitleElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    text: { get: function() {
      return this.textContent;
    }}
  }
});

define({
  tag: 'ul',
  ctor: function HTMLUListElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    type: String,
    // Obsolete
    compact: Boolean,
  }
});

define({
  ctor: function HTMLMediaElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    crossOrigin: CORS,
    preload: { type:["metadata", "none", "auto", {value: "", alias: "auto"}], missing: 'auto' },
    loop: Boolean,
    autoplay: Boolean,
    mediaGroup: String,
    controls: Boolean,
    defaultMuted: {name: "muted", type: Boolean}
  }
});

define({
  tag: 'audio',
  superclass: htmlElements.HTMLMediaElement,
  ctor: function HTMLAudioElement(doc, localName, prefix) {
    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'video',
  superclass: htmlElements.HTMLMediaElement,
  ctor: function HTMLVideoElement(doc, localName, prefix) {
    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);
  },
  attributes: {
    poster: URL,
    width: {type: "unsigned long", min: 0, default: 0 },
    height: {type: "unsigned long", min: 0, default: 0 }
  }
});

define({
  tag: 'td',
  superclass: htmlElements.HTMLTableCellElement,
  ctor: function HTMLTableDataCellElement(doc, localName, prefix) {
    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'th',
  superclass: htmlElements.HTMLTableCellElement,
  ctor: function HTMLTableHeaderCellElement(doc, localName, prefix) {
    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);
  },
});

define({
  tag: 'frameset',
  ctor: function HTMLFrameSetElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'frame',
  ctor: function HTMLFrameElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  }
});

define({
  tag: 'canvas',
  ctor: function HTMLCanvasElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    getContext: { value: utils.nyi },
    probablySupportsContext: { value: utils.nyi },
    setContext: { value: utils.nyi },
    transferControlToProxy: { value: utils.nyi },
    toDataURL: { value: utils.nyi },
    toBlob: { value: utils.nyi }
  },
  attributes: {
    width: { type: "unsigned long", default: 300},
    height: { type: "unsigned long", default: 150}
  }
});

define({
  tag: 'dialog',
  ctor: function HTMLDialogElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    show: { value: utils.nyi },
    showModal: { value: utils.nyi },
    close: { value: utils.nyi }
  },
  attributes: {
    open: Boolean,
    returnValue: String
  }
});

define({
  tag: 'menuitem',
  ctor: function HTMLMenuItemElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  props: {
    // The menuitem's label
    _label: {
      get: function() {
        var val = this._getattr('label');
        if (val !== null && val !== '') { return val; }
        val = this.textContent;
        // Strip and collapse whitespace
        return val.replace(/[ \t\n\f\r]+/g, ' ').trim();
      }
    },
    // The menuitem label IDL attribute
    label: {
      get: function() {
        var val = this._getattr('label');
        if (val !== null) { return val; }
        return this._label;
      },
      set: function(v) {
        this._setattr('label', v);
      },
    }
  },
  attributes: {
    type: { type: ["command","checkbox","radio"], missing: 'command' },
    icon: URL,
    disabled: Boolean,
    checked: Boolean,
    radiogroup: String,
    default: Boolean
  }
});

define({
  tag: 'source',
  ctor: function HTMLSourceElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    srcset: String,
    sizes: String,
    media: String,
    src: URL,
    type: String
  }
});

define({
  tag: 'track',
  ctor: function HTMLTrackElement(doc, localName, prefix) {
    HTMLElement.call(this, doc, localName, prefix);
  },
  attributes: {
    src: URL,
    srclang: String,
    label: String,
    default: Boolean,
    kind: { type: ["subtitles", "captions", "descriptions", "chapters", "metadata"], missing: 'subtitles', invalid: 'metadata' },
  },
  props: {
    NONE: { get: function() { return 0; } },
    LOADING: { get: function() { return 1; } },
    LOADED: { get: function() { return 2; } },
    ERROR: { get: function() { return 3; } },
    readyState: { get: utils.nyi },
    track: { get: utils.nyi }
  }
});

define({
  tags: [
    "abbr", "address", "article", "aside", "b", "bdi", "bdo",
    "cite", "code", "dd", "dfn", "dt", "em", "figcaption", "figure",
    "footer", "header", "hgroup", "i", "kbd", "main", "mark", "nav", "noscript",
    "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "section", "small", "strong",
    "sub", "summary", "sup", "u", "var", "wbr",
    // Legacy elements
    "acronym", "basefont", "big", "center", "nobr", "noembed", "noframes",
    "plaintext", "strike", "tt"
  ]
});


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var parserlib = __webpack_require__(85);

module.exports = CSSStyleDeclaration;

function CSSStyleDeclaration(elt) {
  this._element = elt;
}

// Utility function for parsing style declarations
// Pass in a string like "margin-left: 5px; border-style: solid"
// and this function returns an object like
// {"margin-left":"5px", "border-style":"solid"}
function parseStyles(s) {
  var parser = new parserlib.css.Parser();
  var result = { property: Object.create(null), priority: Object.create(null) };
  parser.addListener("property", function(e) {
    if (e.invalid) return; // Skip errors
    result.property[e.property.text] = e.value.text;
    if (e.important) result.priority[e.property.text] = 'important';
  });
  s = (''+s).replace(/^;/, '');
  parser.parseStyleAttribute(s);
  return result;
}

var NO_CHANGE = {}; // Private marker object

CSSStyleDeclaration.prototype = Object.create(Object.prototype, {

  // Return the parsed form of the element's style attribute.
  // If the element's style attribute has never been parsed
  // or if it has changed since the last parse, then reparse it
  // Note that the styles don't get parsed until they're actually needed
  _parsed: { get: function() {
    if (!this._parsedStyles || this.cssText !== this._lastParsedText) {
      var text = this.cssText;
      this._parsedStyles = parseStyles(text);
      this._lastParsedText = text;
      delete this._names;
    }
    return this._parsedStyles;
  }},

  // Call this method any time the parsed representation of the
  // style changes.  It converts the style properties to a string and
  // sets cssText and the element's style attribute
  _serialize: { value: function() {
    var styles = this._parsed;
    var s = "";

    for(var name in styles.property) {
      if (s) s += " ";
      s += name + ": " + styles.property[name];
      if (styles.priority[name]) {
        s += " !" + styles.priority[name];
      }
      s += ";";
    }

    this.cssText = s;      // also sets the style attribute
    this._lastParsedText = s;  // so we don't reparse
    delete this._names;
  }},

  cssText: {
    get: function() {
      // XXX: this is a CSSStyleDeclaration for an element.
      // A different impl might be necessary for a set of styles
      // associated returned by getComputedStyle(), e.g.
      return this._element.getAttribute("style");
    },
    set: function(value) {
      // XXX: I should parse and serialize the value to
      // normalize it and remove errors. FF and chrome do that.
      this._element.setAttribute("style", value);
    }
  },

  length: { get: function() {
    if (!this._names)
      this._names = Object.getOwnPropertyNames(this._parsed.property);
    return this._names.length;
  }},

  item: { value: function(n) {
    if (!this._names)
      this._names = Object.getOwnPropertyNames(this._parsed.property);
    return this._names[n];
  }},

  getPropertyValue: { value: function(property) {
    property = property.toLowerCase();
    return this._parsed.property[property] || "";
  }},

  getPropertyPriority: { value: function(property) {
    property = property.toLowerCase();
    return this._parsed.priority[property] || "";
  }},

  setProperty: { value: function(property, value, priority) {
    property = property.toLowerCase();
    if (value === null || value === undefined) {
      value = "";
    }
    if (priority === null || priority === undefined) {
      priority = "";
    }

    // String coercion
    if (value !== NO_CHANGE) {
      value = "" + value;
    }

    if (value === "") {
      this.removeProperty(property);
      return;
    }

    if (priority !== "" && priority !== NO_CHANGE &&
        !/^important$/i.test(priority)) {
      return;
    }

    var styles = this._parsed;
    if (value === NO_CHANGE) {
      if (!styles.property[property]) {
        return; // Not a valid property name.
      }
      if (priority !== "") {
        styles.priority[property] = "important";
      } else {
        delete styles.priority[property];
      }
    } else {
      // We don't just accept the property value.  Instead
      // we parse it to ensure that it is something valid.
      // If it contains a semicolon it is invalid
      if (value.indexOf(";") !== -1) return;

      var newprops = parseStyles(property + ":" + value);
      if (Object.getOwnPropertyNames(newprops.property).length === 0) {
        return; // no valid property found
      }
      if (Object.getOwnPropertyNames(newprops.priority).length !== 0) {
        return; // if the value included '!important' it wasn't valid.
      }

      // XXX handle shorthand properties

      for (var p in newprops.property) {
        styles.property[p] = newprops.property[p];
        if (priority === NO_CHANGE) {
          continue;
        } else if (priority !== "") {
          styles.priority[p] = "important";
        } else if (styles.priority[p]) {
          delete styles.priority[p];
        }
      }
    }

    // Serialize and update cssText and element.style!
    this._serialize();
  }},

  setPropertyValue: { value: function(property, value) {
    return this.setProperty(property, value, NO_CHANGE);
  }},

  setPropertyPriority: { value: function(property, priority) {
    return this.setProperty(property, NO_CHANGE, priority);
  }},

  removeProperty: { value: function(property) {
    property = property.toLowerCase();
    var styles = this._parsed;
    if (property in styles.property) {
      delete styles.property[property];
      delete styles.priority[property];

      // Serialize and update cssText and element.style!
      this._serialize();
    }
  }},
});

var cssProperties = {
  background: "background",
  backgroundAttachment: "background-attachment",
  backgroundColor: "background-color",
  backgroundImage: "background-image",
  backgroundPosition: "background-position",
  backgroundRepeat: "background-repeat",
  border: "border",
  borderCollapse: "border-collapse",
  borderColor: "border-color",
  borderSpacing: "border-spacing",
  borderStyle: "border-style",
  borderTop: "border-top",
  borderRight: "border-right",
  borderBottom: "border-bottom",
  borderLeft: "border-left",
  borderTopColor: "border-top-color",
  borderRightColor: "border-right-color",
  borderBottomColor: "border-bottom-color",
  borderLeftColor: "border-left-color",
  borderTopStyle: "border-top-style",
  borderRightStyle: "border-right-style",
  borderBottomStyle: "border-bottom-style",
  borderLeftStyle: "border-left-style",
  borderTopWidth: "border-top-width",
  borderRightWidth: "border-right-width",
  borderBottomWidth: "border-bottom-width",
  borderLeftWidth: "border-left-width",
  borderWidth: "border-width",
  bottom: "bottom",
  captionSide: "caption-side",
  clear: "clear",
  clip: "clip",
  color: "color",
  content: "content",
  counterIncrement: "counter-increment",
  counterReset: "counter-reset",
  cursor: "cursor",
  direction: "direction",
  display: "display",
  emptyCells: "empty-cells",
  cssFloat: "float",
  font: "font",
  fontFamily: "font-family",
  fontSize: "font-size",
  fontSizeAdjust: "font-size-adjust",
  fontStretch: "font-stretch",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  height: "height",
  left: "left",
  letterSpacing: "letter-spacing",
  lineHeight: "line-height",
  listStyle: "list-style",
  listStyleImage: "list-style-image",
  listStylePosition: "list-style-position",
  listStyleType: "list-style-type",
  margin: "margin",
  marginTop: "margin-top",
  marginRight: "margin-right",
  marginBottom: "margin-bottom",
  marginLeft: "margin-left",
  markerOffset: "marker-offset",
  marks: "marks",
  maxHeight: "max-height",
  maxWidth: "max-width",
  minHeight: "min-height",
  minWidth: "min-width",
  opacity: "opacity",
  orphans: "orphans",
  outline: "outline",
  outlineColor: "outline-color",
  outlineStyle: "outline-style",
  outlineWidth: "outline-width",
  overflow: "overflow",
  padding: "padding",
  paddingTop: "padding-top",
  paddingRight: "padding-right",
  paddingBottom: "padding-bottom",
  paddingLeft: "padding-left",
  page: "page",
  pageBreakAfter: "page-break-after",
  pageBreakBefore: "page-break-before",
  pageBreakInside: "page-break-inside",
  position: "position",
  quotes: "quotes",
  right: "right",
  size: "size",
  tableLayout: "table-layout",
  textAlign: "text-align",
  textDecoration: "text-decoration",
  textIndent: "text-indent",
  textShadow: "text-shadow",
  textTransform: "text-transform",
  top: "top",
  unicodeBidi: "unicode-bidi",
  verticalAlign: "vertical-align",
  visibility: "visibility",
  whiteSpace: "white-space",
  widows: "widows",
  width: "width",
  wordSpacing: "word-spacing",
  zIndex: "z-index",
};

for(var prop in cssProperties) defineStyleProperty(prop);

function defineStyleProperty(jsname) {
  var cssname = cssProperties[jsname];
  Object.defineProperty(CSSStyleDeclaration.prototype, jsname, {
    get: function() {
      return this.getPropertyValue(cssname);
    },
    set: function(value) {
      this.setProperty(cssname, value);
    }
  });
}


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DOMImplementation = __webpack_require__(11);
var EventTarget = __webpack_require__(36);
var Location = __webpack_require__(86);
var sloppy = __webpack_require__(53);
var utils = __webpack_require__(2);

module.exports = Window;

function Window(document) {
  this.document = document || new DOMImplementation().createHTMLDocument("");
  this.document._scripting_enabled = true;
  this.document.defaultView = this;
  this.location = new Location(this, this.document._address || 'about:blank');
}

Window.prototype = Object.create(EventTarget.prototype, {
  _run: { value: sloppy.Window_run },
  console: { value: console },
  history: { value: {
    back: utils.nyi,
    forward: utils.nyi,
    go: utils.nyi
  }},
  navigator: { value: __webpack_require__(87) },

  // Self-referential properties
  window: { get: function() { return this; }},
  self: { get: function() { return this; }},
  frames: { get: function() { return this; }},

  // Self-referential properties for a top-level window
  parent: { get: function() { return this; }},
  top: { get: function() { return this; }},

  // We don't support any other windows for now
  length: { value: 0 },           // no frames
  frameElement: { value: null },  // not part of a frame
  opener: { value: null },        // not opened by another window

  // The onload event handler.
  // XXX: need to support a bunch of other event types, too,
  // and have them interoperate with document.body.

  onload: {
    get: function() {
      return this._getEventHandler("load");
    },
    set: function(v) {
      this._setEventHandler("load", v);
    }
  },

  // XXX This is a completely broken implementation
  getComputedStyle: { value: function getComputedStyle(elt) {
    return elt.style;
  }}

});

utils.expose(__webpack_require__(88), Window);
utils.expose(__webpack_require__(54), Window);


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = DocumentType;

var Node = __webpack_require__(3);
var Leaf = __webpack_require__(45);
var utils = __webpack_require__(2);
var ChildNode = __webpack_require__(21);

function DocumentType(name, publicId, systemId) {
  // Unlike other nodes, doctype nodes always start off unowned
  // until inserted
  this.nodeType = Node.DOCUMENT_TYPE_NODE;
  this.ownerDocument = null;
  this.name = name;
  this.publicId = publicId || "";
  this.systemId = systemId || "";
}

DocumentType.prototype = Object.create(Leaf.prototype, {
  nodeName: { get: function() { return this.name; }},
  nodeValue: {
    get: function() { return null; },
    set: function() {}
  },

  // Utility methods
  clone: { value: function clone() {
    utils.DataCloneError();
  }},

  isEqual: { value: function isEqual(n) {
    return this.name === n.name &&
      this.publicId === n.publicId &&
      this.systemId === n.systemId;
  }}
});

Object.defineProperties(DocumentType.prototype, ChildNode);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = HTMLParser;

var Document = __webpack_require__(18);
var DocumentType = __webpack_require__(26);
var Node = __webpack_require__(3);
var NAMESPACE = __webpack_require__(2).NAMESPACE;
var html = __webpack_require__(23);
var impl = html.elements;

var pushAll = Function.prototype.apply.bind(Array.prototype.push);

/*
 * This file contains an implementation of the HTML parsing algorithm.
 * The algorithm and the implementation are complex because HTML
 * explicitly defines how the parser should behave for all possible
 * valid and invalid inputs.
 *
 * Usage:
 *
 * The file defines a single HTMLParser() function, which dom.js exposes
 * publicly as document.implementation.mozHTMLParser(). This is a
 * factory function, not a constructor.
 *
 * When you call document.implementation.mozHTMLParser(), it returns
 * an object that has parse() and document() methods. To parse HTML text,
 * pass the text (in one or more chunks) to the parse() method.  When
 * you've passed all the text (on the last chunk, or afterward) pass
 * true as the second argument to parse() to tell the parser that there
 * is no more coming. Call document() to get the document object that
 * the parser is parsing into.  You can call this at any time, before
 * or after calling parse().
 *
 * The first argument to mozHTMLParser is the absolute URL of the document.
 *
 * The second argument is optional and is for internal use only.  Pass an
 * element as the fragmentContext to do innerHTML parsing for the
 * element.  To do innerHTML parsing on a document, pass null. Otherwise,
 * omit the 2nd argument. See HTMLElement.innerHTML for an example.  Note
 * that if you pass a context element, the end() method will return an
 * unwrapped document instead of a wrapped one.
 *
 * Implementation details:
 *
 * This is a long file of almost 7000 lines. It is structured as one
 * big function nested within another big function.  The outer
 * function defines a bunch of constant data, utility functions
 * that use that data, and a couple of classes used by the parser.
 * The outer function also defines and returns the
 * inner function. This inner function is the HTMLParser factory
 * function that implements the parser and holds all the parser state
 * as local variables.  The HTMLParser function is quite big because
 * it defines many nested functions that use those local variables.
 *
 * There are three tightly coupled parser stages: a scanner, a
 * tokenizer and a tree builder. In a (possibly misguided) attempt at
 * efficiency, the stages are not implemented as separate classes:
 * everything shares state and is (mostly) implemented in imperative
 * (rather than OO) style.
 *
 * The stages of the parser work like this: When the client code calls
 * the parser's parse() method, the specified string is passed to
 * scanChars(). The scanner loops through that string and passes characters
 * (sometimes one at a time, sometimes in chunks) to the tokenizer stage.
 * The tokenizer groups the characters into tokens: tags, endtags, runs
 * of text, comments, doctype declarations, and the end-of-file (EOF)
 * token.  These tokens are then passed to the tree building stage via
 * the insertToken() function.  The tree building stage builds up the
 * document tree.
 *
 * The tokenizer stage is a finite state machine.  Each state is
 * implemented as a function with a name that ends in "_state".  The
 * initial state is data_state(). The current tokenizer state is stored
 * in the variable 'tokenizer'.  Most state functions expect a single
 * integer argument which represents a single UTF-16 codepoint.  Some
 * states want more characters and set a lookahead property on
 * themselves.  The scanChars() function in the scanner checks for this
 * lookahead property.  If it doesn't exist, then scanChars() just passes
 * the next input character to the current tokenizer state function.
 * Otherwise, scanChars() looks ahead (a given # of characters, or for a
 * matching string, or for a matching regexp) and passes a string of
 * characters to the current tokenizer state function.
 *
 * As a shortcut, certain states of the tokenizer use regular expressions
 * to look ahead in the scanner's input buffer for runs of text, simple
 * tags and attributes.  For well-formed input, these shortcuts skip a
 * lot of state transitions and speed things up a bit.
 *
 * When a tokenizer state function has consumed a complete token, it
 * emits that token, by calling insertToken(), or by calling a utility
 * function that itself calls insertToken().  These tokens are passed to
 * the tree building stage, which is also a state machine.  Like the
 * tokenizer, the tree building states are implemented as functions, and
 * these functions have names that end with _mode (because the HTML spec
 * refers to them as insertion modes). The current insertion mode is held
 * by the 'parser' variable.  Each insertion mode function takes up to 4
 * arguments.  The first is a token type, represented by the constants
 * TAG, ENDTAG, TEXT, COMMENT, DOCTYPE and EOF.  The second argument is
 * the value of the token: the text or comment data, or tagname or
 * doctype.  For tags, the 3rd argument is an array of attributes.  For
 * DOCTYPES it is the optional public id.  For tags, the 4th argument is
 * true if the tag is self-closing. For doctypes, the 4th argument is the
 * optional system id.
 *
 * Search for "***" to find the major sub-divisions in the code.
 */


/***
 * Data prolog.  Lots of constants declared here, including some
 * very large objects.  They're used throughout the code that follows
 */
// Token types for the tree builder.
var EOF = -1;
var TEXT = 1;
var TAG = 2;
var ENDTAG = 3;
var COMMENT = 4;
var DOCTYPE = 5;

// A re-usable empty array
var NOATTRS = [];

// These DTD public ids put the browser in quirks mode
var quirkyPublicIds = /^HTML$|^-\/\/W3O\/\/DTD W3 HTML Strict 3\.0\/\/EN\/\/$|^-\/W3C\/DTD HTML 4\.0 Transitional\/EN$|^\+\/\/Silmaril\/\/dtd html Pro v0r11 19970101\/\/|^-\/\/AdvaSoft Ltd\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/AS\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict\/\/|^-\/\/IETF\/\/DTD HTML 2\.0\/\/|^-\/\/IETF\/\/DTD HTML 2\.1E\/\/|^-\/\/IETF\/\/DTD HTML 3\.0\/\/|^-\/\/IETF\/\/DTD HTML 3\.2 Final\/\/|^-\/\/IETF\/\/DTD HTML 3\.2\/\/|^-\/\/IETF\/\/DTD HTML 3\/\/|^-\/\/IETF\/\/DTD HTML Level 0\/\/|^-\/\/IETF\/\/DTD HTML Level 1\/\/|^-\/\/IETF\/\/DTD HTML Level 2\/\/|^-\/\/IETF\/\/DTD HTML Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 0\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict\/\/|^-\/\/IETF\/\/DTD HTML\/\/|^-\/\/Metrius\/\/DTD Metrius Presentational\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 Tables\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 Tables\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD HTML\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD Strict HTML\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML 2\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended 1\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended Relaxed 1\.0\/\/|^-\/\/SoftQuad Software\/\/DTD HoTMetaL PRO 6\.0::19990601::extensions to HTML 4\.0\/\/|^-\/\/SoftQuad\/\/DTD HoTMetaL PRO 4\.0::19971010::extensions to HTML 4\.0\/\/|^-\/\/Spyglass\/\/DTD HTML 2\.0 Extended\/\/|^-\/\/SQ\/\/DTD HTML 2\.0 HoTMetaL \+ extensions\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava HTML\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava Strict HTML\/\/|^-\/\/W3C\/\/DTD HTML 3 1995-03-24\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Draft\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Final\/\/|^-\/\/W3C\/\/DTD HTML 3\.2\/\/|^-\/\/W3C\/\/DTD HTML 3\.2S Draft\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Transitional\/\/|^-\/\/W3C\/\/DTD HTML Experimental 19960712\/\/|^-\/\/W3C\/\/DTD HTML Experimental 970421\/\/|^-\/\/W3C\/\/DTD W3 HTML\/\/|^-\/\/W3O\/\/DTD W3 HTML 3\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML 2\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML\/\//i;

var quirkySystemId = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";

var conditionallyQuirkyPublicIds = /^-\/\/W3C\/\/DTD HTML 4\.01 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.01 Transitional\/\//i;

// These DTD public ids put the browser in limited quirks mode
var limitedQuirkyPublicIds = /^-\/\/W3C\/\/DTD XHTML 1\.0 Frameset\/\/|^-\/\/W3C\/\/DTD XHTML 1\.0 Transitional\/\//i;


// Element sets below. See the isA() function for a way to test
// whether an element is a member of a set
var specialSet = Object.create(null);
specialSet[NAMESPACE.HTML] = {
  __proto__: null,
  "address":true, "applet":true, "area":true, "article":true,
  "aside":true, "base":true, "basefont":true, "bgsound":true,
  "blockquote":true, "body":true, "br":true, "button":true,
  "caption":true, "center":true, "col":true, "colgroup":true,
  "dd":true, "details":true, "dir":true,
  "div":true, "dl":true, "dt":true, "embed":true,
  "fieldset":true, "figcaption":true, "figure":true, "footer":true,
  "form":true, "frame":true, "frameset":true, "h1":true,
  "h2":true, "h3":true, "h4":true, "h5":true,
  "h6":true, "head":true, "header":true, "hgroup":true,
  "hr":true, "html":true, "iframe":true, "img":true,
  "input":true, "li":true, "link":true,
  "listing":true, "main":true, "marquee":true, "menu":true, "meta":true,
  "nav":true, "noembed":true, "noframes":true, "noscript":true,
  "object":true, "ol":true, "p":true, "param":true,
  "plaintext":true, "pre":true, "script":true, "section":true,
  "select":true, "source":true, "style":true, "summary":true, "table":true,
  "tbody":true, "td":true, "template":true, "textarea":true, "tfoot":true,
  "th":true, "thead":true, "title":true, "tr":true, "track":true,
  // Note that "xmp" was removed from the "special" set in the latest
  // spec, apparently by accident; see
  // https://github.com/whatwg/html/pull/1919
  "ul":true, "wbr":true, "xmp":true
};
specialSet[NAMESPACE.SVG] = {
  __proto__: null,
  "foreignObject": true, "desc": true, "title": true
};
specialSet[NAMESPACE.MATHML] = {
  __proto__: null,
  "mi":true, "mo":true, "mn":true, "ms":true,
  "mtext":true, "annotation-xml":true
};

// The set of address, div, and p HTML tags
var addressdivpSet = Object.create(null);
addressdivpSet[NAMESPACE.HTML] = {
  __proto__: null,
  "address":true, "div":true, "p":true
};

var dddtSet = Object.create(null);
dddtSet[NAMESPACE.HTML] = {
  __proto__: null,
  "dd":true, "dt":true
};

var tablesectionrowSet = Object.create(null);
tablesectionrowSet[NAMESPACE.HTML] = {
  __proto__: null,
  "table":true, "thead":true, "tbody":true, "tfoot":true, "tr":true
};

var impliedEndTagsSet = Object.create(null);
impliedEndTagsSet[NAMESPACE.HTML] = {
  __proto__: null,
  "dd": true, "dt": true, "li": true, "menuitem": true, "optgroup": true,
  "option": true, "p": true, "rb": true, "rp": true, "rt": true, "rtc": true
};

var thoroughImpliedEndTagsSet = Object.create(null);
thoroughImpliedEndTagsSet[NAMESPACE.HTML] = {
  __proto__: null,
  "caption": true, "colgroup": true, "dd": true, "dt": true, "li": true,
  "optgroup": true, "option": true, "p": true, "rb": true, "rp": true,
  "rt": true, "rtc": true, "tbody": true, "td": true, "tfoot": true,
  "th": true, "thead": true, "tr": true
};

var tableContextSet = Object.create(null);
tableContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "table": true, "template": true, "html": true
};

var tableBodyContextSet = Object.create(null);
tableBodyContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "tbody": true, "tfoot": true, "thead": true, "template": true, "html": true
};

var tableRowContextSet = Object.create(null);
tableRowContextSet[NAMESPACE.HTML] = {
  __proto__: null,
  "tr": true, "template": true, "html": true
};

// See http://www.w3.org/TR/html5/forms.html#form-associated-element
var formassociatedSet = Object.create(null);
formassociatedSet[NAMESPACE.HTML] = {
  __proto__: null,
  "button": true, "fieldset": true, "input": true, "keygen": true,
  "object": true, "output": true, "select": true, "textarea": true,
  "img": true
};

var inScopeSet = Object.create(null);
inScopeSet[NAMESPACE.HTML]= {
  __proto__: null,
  "applet":true, "caption":true, "html":true, "table":true,
  "td":true, "th":true, "marquee":true, "object":true,
  "template":true
};
inScopeSet[NAMESPACE.MATHML] = {
  __proto__: null,
  "mi":true, "mo":true, "mn":true, "ms":true,
  "mtext":true, "annotation-xml":true
};
inScopeSet[NAMESPACE.SVG] = {
  __proto__: null,
  "foreignObject":true, "desc":true, "title":true
};

var inListItemScopeSet = Object.create(inScopeSet);
inListItemScopeSet[NAMESPACE.HTML] =
  Object.create(inScopeSet[NAMESPACE.HTML]);
inListItemScopeSet[NAMESPACE.HTML].ol = true;
inListItemScopeSet[NAMESPACE.HTML].ul = true;

var inButtonScopeSet = Object.create(inScopeSet);
inButtonScopeSet[NAMESPACE.HTML] =
  Object.create(inScopeSet[NAMESPACE.HTML]);
inButtonScopeSet[NAMESPACE.HTML].button = true;

var inTableScopeSet = Object.create(null);
inTableScopeSet[NAMESPACE.HTML] = {
  __proto__: null,
  "html":true, "table":true, "template":true
};

// The set of elements for select scope is the everything *except* these
var invertedSelectScopeSet = Object.create(null);
invertedSelectScopeSet[NAMESPACE.HTML] = {
  __proto__: null,
  "optgroup":true, "option":true
};

var mathmlTextIntegrationPointSet = Object.create(null);
mathmlTextIntegrationPointSet[NAMESPACE.MATHML] = {
  __proto__: null,
  mi: true,
  mo: true,
  mn: true,
  ms: true,
  mtext: true
};

var htmlIntegrationPointSet = Object.create(null);
htmlIntegrationPointSet[NAMESPACE.SVG] = {
  __proto__: null,
  foreignObject: true,
  desc: true,
  title: true
};

var foreignAttributes = {
  __proto__: null,
  "xlink:actuate": NAMESPACE.XLINK, "xlink:arcrole": NAMESPACE.XLINK,
  "xlink:href":   NAMESPACE.XLINK,  "xlink:role":    NAMESPACE.XLINK,
  "xlink:show":   NAMESPACE.XLINK,  "xlink:title":   NAMESPACE.XLINK,
  "xlink:type":   NAMESPACE.XLINK,  "xml:base":      NAMESPACE.XML,
  "xml:lang":     NAMESPACE.XML,    "xml:space":     NAMESPACE.XML,
  "xmlns":        NAMESPACE.XMLNS,  "xmlns:xlink":   NAMESPACE.XMLNS
};


// Lowercase to mixed case mapping for SVG attributes and tagnames
var svgAttrAdjustments = {
  __proto__: null,
  attributename: "attributeName", attributetype: "attributeType",
  basefrequency: "baseFrequency", baseprofile: "baseProfile",
  calcmode: "calcMode", clippathunits: "clipPathUnits",
  diffuseconstant: "diffuseConstant",
  edgemode: "edgeMode",
  filterunits: "filterUnits",
  glyphref: "glyphRef", gradienttransform: "gradientTransform",
  gradientunits: "gradientUnits", kernelmatrix: "kernelMatrix",
  kernelunitlength: "kernelUnitLength", keypoints: "keyPoints",
  keysplines: "keySplines", keytimes: "keyTimes",
  lengthadjust: "lengthAdjust", limitingconeangle: "limitingConeAngle",
  markerheight: "markerHeight", markerunits: "markerUnits",
  markerwidth: "markerWidth", maskcontentunits: "maskContentUnits",
  maskunits: "maskUnits", numoctaves: "numOctaves",
  pathlength: "pathLength", patterncontentunits: "patternContentUnits",
  patterntransform: "patternTransform", patternunits: "patternUnits",
  pointsatx: "pointsAtX", pointsaty: "pointsAtY",
  pointsatz: "pointsAtZ", preservealpha: "preserveAlpha",
  preserveaspectratio: "preserveAspectRatio",
  primitiveunits: "primitiveUnits", refx: "refX",
  refy: "refY", repeatcount: "repeatCount",
  repeatdur: "repeatDur", requiredextensions: "requiredExtensions",
  requiredfeatures: "requiredFeatures",
  specularconstant: "specularConstant",
  specularexponent: "specularExponent", spreadmethod: "spreadMethod",
  startoffset: "startOffset", stddeviation: "stdDeviation",
  stitchtiles: "stitchTiles", surfacescale: "surfaceScale",
  systemlanguage: "systemLanguage", tablevalues: "tableValues",
  targetx: "targetX", targety: "targetY",
  textlength: "textLength", viewbox: "viewBox",
  viewtarget: "viewTarget", xchannelselector: "xChannelSelector",
  ychannelselector: "yChannelSelector", zoomandpan: "zoomAndPan"
};

var svgTagNameAdjustments = {
  __proto__: null,
  altglyph: "altGlyph", altglyphdef: "altGlyphDef",
  altglyphitem: "altGlyphItem", animatecolor: "animateColor",
  animatemotion: "animateMotion", animatetransform: "animateTransform",
  clippath: "clipPath", feblend: "feBlend",
  fecolormatrix: "feColorMatrix",
  fecomponenttransfer: "feComponentTransfer", fecomposite: "feComposite",
  feconvolvematrix: "feConvolveMatrix",
  fediffuselighting: "feDiffuseLighting",
  fedisplacementmap: "feDisplacementMap",
  fedistantlight: "feDistantLight", feflood: "feFlood",
  fefunca: "feFuncA", fefuncb: "feFuncB",
  fefuncg: "feFuncG", fefuncr: "feFuncR",
  fegaussianblur: "feGaussianBlur", feimage: "feImage",
  femerge: "feMerge", femergenode: "feMergeNode",
  femorphology: "feMorphology", feoffset: "feOffset",
  fepointlight: "fePointLight", fespecularlighting: "feSpecularLighting",
  fespotlight: "feSpotLight", fetile: "feTile",
  feturbulence: "feTurbulence", foreignobject: "foreignObject",
  glyphref: "glyphRef", lineargradient: "linearGradient",
  radialgradient: "radialGradient", textpath: "textPath"
};


// Data for parsing numeric and named character references
// These next 3 objects are direct translations of tables
// in the HTML spec into JavaScript object format
var numericCharRefReplacements = {
  __proto__: null,
  0x00:0xFFFD, 0x80:0x20AC, 0x82:0x201A, 0x83:0x0192, 0x84:0x201E,
  0x85:0x2026, 0x86:0x2020, 0x87:0x2021, 0x88:0x02C6, 0x89:0x2030,
  0x8A:0x0160, 0x8B:0x2039, 0x8C:0x0152, 0x8E:0x017D, 0x91:0x2018,
  0x92:0x2019, 0x93:0x201C, 0x94:0x201D, 0x95:0x2022, 0x96:0x2013,
  0x97:0x2014, 0x98:0x02DC, 0x99:0x2122, 0x9A:0x0161, 0x9B:0x203A,
  0x9C:0x0153, 0x9E:0x017E, 0x9F:0x0178
};

/*
 * This table is generated with test/tools/update-entities.js
 */
var namedCharRefs = {
  __proto__: null,
  "AElig":0xc6, "AElig;":0xc6,
  "AMP":0x26, "AMP;":0x26,
  "Aacute":0xc1, "Aacute;":0xc1,
  "Abreve;":0x102, "Acirc":0xc2,
  "Acirc;":0xc2, "Acy;":0x410,
  "Afr;":[0xd835,0xdd04], "Agrave":0xc0,
  "Agrave;":0xc0, "Alpha;":0x391,
  "Amacr;":0x100, "And;":0x2a53,
  "Aogon;":0x104, "Aopf;":[0xd835,0xdd38],
  "ApplyFunction;":0x2061, "Aring":0xc5,
  "Aring;":0xc5, "Ascr;":[0xd835,0xdc9c],
  "Assign;":0x2254, "Atilde":0xc3,
  "Atilde;":0xc3, "Auml":0xc4,
  "Auml;":0xc4, "Backslash;":0x2216,
  "Barv;":0x2ae7, "Barwed;":0x2306,
  "Bcy;":0x411, "Because;":0x2235,
  "Bernoullis;":0x212c, "Beta;":0x392,
  "Bfr;":[0xd835,0xdd05], "Bopf;":[0xd835,0xdd39],
  "Breve;":0x2d8, "Bscr;":0x212c,
  "Bumpeq;":0x224e, "CHcy;":0x427,
  "COPY":0xa9, "COPY;":0xa9,
  "Cacute;":0x106, "Cap;":0x22d2,
  "CapitalDifferentialD;":0x2145, "Cayleys;":0x212d,
  "Ccaron;":0x10c, "Ccedil":0xc7,
  "Ccedil;":0xc7, "Ccirc;":0x108,
  "Cconint;":0x2230, "Cdot;":0x10a,
  "Cedilla;":0xb8, "CenterDot;":0xb7,
  "Cfr;":0x212d, "Chi;":0x3a7,
  "CircleDot;":0x2299, "CircleMinus;":0x2296,
  "CirclePlus;":0x2295, "CircleTimes;":0x2297,
  "ClockwiseContourIntegral;":0x2232, "CloseCurlyDoubleQuote;":0x201d,
  "CloseCurlyQuote;":0x2019, "Colon;":0x2237,
  "Colone;":0x2a74, "Congruent;":0x2261,
  "Conint;":0x222f, "ContourIntegral;":0x222e,
  "Copf;":0x2102, "Coproduct;":0x2210,
  "CounterClockwiseContourIntegral;":0x2233, "Cross;":0x2a2f,
  "Cscr;":[0xd835,0xdc9e], "Cup;":0x22d3,
  "CupCap;":0x224d, "DD;":0x2145,
  "DDotrahd;":0x2911, "DJcy;":0x402,
  "DScy;":0x405, "DZcy;":0x40f,
  "Dagger;":0x2021, "Darr;":0x21a1,
  "Dashv;":0x2ae4, "Dcaron;":0x10e,
  "Dcy;":0x414, "Del;":0x2207,
  "Delta;":0x394, "Dfr;":[0xd835,0xdd07],
  "DiacriticalAcute;":0xb4, "DiacriticalDot;":0x2d9,
  "DiacriticalDoubleAcute;":0x2dd, "DiacriticalGrave;":0x60,
  "DiacriticalTilde;":0x2dc, "Diamond;":0x22c4,
  "DifferentialD;":0x2146, "Dopf;":[0xd835,0xdd3b],
  "Dot;":0xa8, "DotDot;":0x20dc,
  "DotEqual;":0x2250, "DoubleContourIntegral;":0x222f,
  "DoubleDot;":0xa8, "DoubleDownArrow;":0x21d3,
  "DoubleLeftArrow;":0x21d0, "DoubleLeftRightArrow;":0x21d4,
  "DoubleLeftTee;":0x2ae4, "DoubleLongLeftArrow;":0x27f8,
  "DoubleLongLeftRightArrow;":0x27fa, "DoubleLongRightArrow;":0x27f9,
  "DoubleRightArrow;":0x21d2, "DoubleRightTee;":0x22a8,
  "DoubleUpArrow;":0x21d1, "DoubleUpDownArrow;":0x21d5,
  "DoubleVerticalBar;":0x2225, "DownArrow;":0x2193,
  "DownArrowBar;":0x2913, "DownArrowUpArrow;":0x21f5,
  "DownBreve;":0x311, "DownLeftRightVector;":0x2950,
  "DownLeftTeeVector;":0x295e, "DownLeftVector;":0x21bd,
  "DownLeftVectorBar;":0x2956, "DownRightTeeVector;":0x295f,
  "DownRightVector;":0x21c1, "DownRightVectorBar;":0x2957,
  "DownTee;":0x22a4, "DownTeeArrow;":0x21a7,
  "Downarrow;":0x21d3, "Dscr;":[0xd835,0xdc9f],
  "Dstrok;":0x110, "ENG;":0x14a,
  "ETH":0xd0, "ETH;":0xd0,
  "Eacute":0xc9, "Eacute;":0xc9,
  "Ecaron;":0x11a, "Ecirc":0xca,
  "Ecirc;":0xca, "Ecy;":0x42d,
  "Edot;":0x116, "Efr;":[0xd835,0xdd08],
  "Egrave":0xc8, "Egrave;":0xc8,
  "Element;":0x2208, "Emacr;":0x112,
  "EmptySmallSquare;":0x25fb, "EmptyVerySmallSquare;":0x25ab,
  "Eogon;":0x118, "Eopf;":[0xd835,0xdd3c],
  "Epsilon;":0x395, "Equal;":0x2a75,
  "EqualTilde;":0x2242, "Equilibrium;":0x21cc,
  "Escr;":0x2130, "Esim;":0x2a73,
  "Eta;":0x397, "Euml":0xcb,
  "Euml;":0xcb, "Exists;":0x2203,
  "ExponentialE;":0x2147, "Fcy;":0x424,
  "Ffr;":[0xd835,0xdd09], "FilledSmallSquare;":0x25fc,
  "FilledVerySmallSquare;":0x25aa, "Fopf;":[0xd835,0xdd3d],
  "ForAll;":0x2200, "Fouriertrf;":0x2131,
  "Fscr;":0x2131, "GJcy;":0x403,
  "GT":0x3e, "GT;":0x3e,
  "Gamma;":0x393, "Gammad;":0x3dc,
  "Gbreve;":0x11e, "Gcedil;":0x122,
  "Gcirc;":0x11c, "Gcy;":0x413,
  "Gdot;":0x120, "Gfr;":[0xd835,0xdd0a],
  "Gg;":0x22d9, "Gopf;":[0xd835,0xdd3e],
  "GreaterEqual;":0x2265, "GreaterEqualLess;":0x22db,
  "GreaterFullEqual;":0x2267, "GreaterGreater;":0x2aa2,
  "GreaterLess;":0x2277, "GreaterSlantEqual;":0x2a7e,
  "GreaterTilde;":0x2273, "Gscr;":[0xd835,0xdca2],
  "Gt;":0x226b, "HARDcy;":0x42a,
  "Hacek;":0x2c7, "Hat;":0x5e,
  "Hcirc;":0x124, "Hfr;":0x210c,
  "HilbertSpace;":0x210b, "Hopf;":0x210d,
  "HorizontalLine;":0x2500, "Hscr;":0x210b,
  "Hstrok;":0x126, "HumpDownHump;":0x224e,
  "HumpEqual;":0x224f, "IEcy;":0x415,
  "IJlig;":0x132, "IOcy;":0x401,
  "Iacute":0xcd, "Iacute;":0xcd,
  "Icirc":0xce, "Icirc;":0xce,
  "Icy;":0x418, "Idot;":0x130,
  "Ifr;":0x2111, "Igrave":0xcc,
  "Igrave;":0xcc, "Im;":0x2111,
  "Imacr;":0x12a, "ImaginaryI;":0x2148,
  "Implies;":0x21d2, "Int;":0x222c,
  "Integral;":0x222b, "Intersection;":0x22c2,
  "InvisibleComma;":0x2063, "InvisibleTimes;":0x2062,
  "Iogon;":0x12e, "Iopf;":[0xd835,0xdd40],
  "Iota;":0x399, "Iscr;":0x2110,
  "Itilde;":0x128, "Iukcy;":0x406,
  "Iuml":0xcf, "Iuml;":0xcf,
  "Jcirc;":0x134, "Jcy;":0x419,
  "Jfr;":[0xd835,0xdd0d], "Jopf;":[0xd835,0xdd41],
  "Jscr;":[0xd835,0xdca5], "Jsercy;":0x408,
  "Jukcy;":0x404, "KHcy;":0x425,
  "KJcy;":0x40c, "Kappa;":0x39a,
  "Kcedil;":0x136, "Kcy;":0x41a,
  "Kfr;":[0xd835,0xdd0e], "Kopf;":[0xd835,0xdd42],
  "Kscr;":[0xd835,0xdca6], "LJcy;":0x409,
  "LT":0x3c, "LT;":0x3c,
  "Lacute;":0x139, "Lambda;":0x39b,
  "Lang;":0x27ea, "Laplacetrf;":0x2112,
  "Larr;":0x219e, "Lcaron;":0x13d,
  "Lcedil;":0x13b, "Lcy;":0x41b,
  "LeftAngleBracket;":0x27e8, "LeftArrow;":0x2190,
  "LeftArrowBar;":0x21e4, "LeftArrowRightArrow;":0x21c6,
  "LeftCeiling;":0x2308, "LeftDoubleBracket;":0x27e6,
  "LeftDownTeeVector;":0x2961, "LeftDownVector;":0x21c3,
  "LeftDownVectorBar;":0x2959, "LeftFloor;":0x230a,
  "LeftRightArrow;":0x2194, "LeftRightVector;":0x294e,
  "LeftTee;":0x22a3, "LeftTeeArrow;":0x21a4,
  "LeftTeeVector;":0x295a, "LeftTriangle;":0x22b2,
  "LeftTriangleBar;":0x29cf, "LeftTriangleEqual;":0x22b4,
  "LeftUpDownVector;":0x2951, "LeftUpTeeVector;":0x2960,
  "LeftUpVector;":0x21bf, "LeftUpVectorBar;":0x2958,
  "LeftVector;":0x21bc, "LeftVectorBar;":0x2952,
  "Leftarrow;":0x21d0, "Leftrightarrow;":0x21d4,
  "LessEqualGreater;":0x22da, "LessFullEqual;":0x2266,
  "LessGreater;":0x2276, "LessLess;":0x2aa1,
  "LessSlantEqual;":0x2a7d, "LessTilde;":0x2272,
  "Lfr;":[0xd835,0xdd0f], "Ll;":0x22d8,
  "Lleftarrow;":0x21da, "Lmidot;":0x13f,
  "LongLeftArrow;":0x27f5, "LongLeftRightArrow;":0x27f7,
  "LongRightArrow;":0x27f6, "Longleftarrow;":0x27f8,
  "Longleftrightarrow;":0x27fa, "Longrightarrow;":0x27f9,
  "Lopf;":[0xd835,0xdd43], "LowerLeftArrow;":0x2199,
  "LowerRightArrow;":0x2198, "Lscr;":0x2112,
  "Lsh;":0x21b0, "Lstrok;":0x141,
  "Lt;":0x226a, "Map;":0x2905,
  "Mcy;":0x41c, "MediumSpace;":0x205f,
  "Mellintrf;":0x2133, "Mfr;":[0xd835,0xdd10],
  "MinusPlus;":0x2213, "Mopf;":[0xd835,0xdd44],
  "Mscr;":0x2133, "Mu;":0x39c,
  "NJcy;":0x40a, "Nacute;":0x143,
  "Ncaron;":0x147, "Ncedil;":0x145,
  "Ncy;":0x41d, "NegativeMediumSpace;":0x200b,
  "NegativeThickSpace;":0x200b, "NegativeThinSpace;":0x200b,
  "NegativeVeryThinSpace;":0x200b, "NestedGreaterGreater;":0x226b,
  "NestedLessLess;":0x226a, "NewLine;":0xa,
  "Nfr;":[0xd835,0xdd11], "NoBreak;":0x2060,
  "NonBreakingSpace;":0xa0, "Nopf;":0x2115,
  "Not;":0x2aec, "NotCongruent;":0x2262,
  "NotCupCap;":0x226d, "NotDoubleVerticalBar;":0x2226,
  "NotElement;":0x2209, "NotEqual;":0x2260,
  "NotEqualTilde;":[0x2242,0x338], "NotExists;":0x2204,
  "NotGreater;":0x226f, "NotGreaterEqual;":0x2271,
  "NotGreaterFullEqual;":[0x2267,0x338], "NotGreaterGreater;":[0x226b,0x338],
  "NotGreaterLess;":0x2279, "NotGreaterSlantEqual;":[0x2a7e,0x338],
  "NotGreaterTilde;":0x2275, "NotHumpDownHump;":[0x224e,0x338],
  "NotHumpEqual;":[0x224f,0x338], "NotLeftTriangle;":0x22ea,
  "NotLeftTriangleBar;":[0x29cf,0x338], "NotLeftTriangleEqual;":0x22ec,
  "NotLess;":0x226e, "NotLessEqual;":0x2270,
  "NotLessGreater;":0x2278, "NotLessLess;":[0x226a,0x338],
  "NotLessSlantEqual;":[0x2a7d,0x338], "NotLessTilde;":0x2274,
  "NotNestedGreaterGreater;":[0x2aa2,0x338], "NotNestedLessLess;":[0x2aa1,0x338],
  "NotPrecedes;":0x2280, "NotPrecedesEqual;":[0x2aaf,0x338],
  "NotPrecedesSlantEqual;":0x22e0, "NotReverseElement;":0x220c,
  "NotRightTriangle;":0x22eb, "NotRightTriangleBar;":[0x29d0,0x338],
  "NotRightTriangleEqual;":0x22ed, "NotSquareSubset;":[0x228f,0x338],
  "NotSquareSubsetEqual;":0x22e2, "NotSquareSuperset;":[0x2290,0x338],
  "NotSquareSupersetEqual;":0x22e3, "NotSubset;":[0x2282,0x20d2],
  "NotSubsetEqual;":0x2288, "NotSucceeds;":0x2281,
  "NotSucceedsEqual;":[0x2ab0,0x338], "NotSucceedsSlantEqual;":0x22e1,
  "NotSucceedsTilde;":[0x227f,0x338], "NotSuperset;":[0x2283,0x20d2],
  "NotSupersetEqual;":0x2289, "NotTilde;":0x2241,
  "NotTildeEqual;":0x2244, "NotTildeFullEqual;":0x2247,
  "NotTildeTilde;":0x2249, "NotVerticalBar;":0x2224,
  "Nscr;":[0xd835,0xdca9], "Ntilde":0xd1,
  "Ntilde;":0xd1, "Nu;":0x39d,
  "OElig;":0x152, "Oacute":0xd3,
  "Oacute;":0xd3, "Ocirc":0xd4,
  "Ocirc;":0xd4, "Ocy;":0x41e,
  "Odblac;":0x150, "Ofr;":[0xd835,0xdd12],
  "Ograve":0xd2, "Ograve;":0xd2,
  "Omacr;":0x14c, "Omega;":0x3a9,
  "Omicron;":0x39f, "Oopf;":[0xd835,0xdd46],
  "OpenCurlyDoubleQuote;":0x201c, "OpenCurlyQuote;":0x2018,
  "Or;":0x2a54, "Oscr;":[0xd835,0xdcaa],
  "Oslash":0xd8, "Oslash;":0xd8,
  "Otilde":0xd5, "Otilde;":0xd5,
  "Otimes;":0x2a37, "Ouml":0xd6,
  "Ouml;":0xd6, "OverBar;":0x203e,
  "OverBrace;":0x23de, "OverBracket;":0x23b4,
  "OverParenthesis;":0x23dc, "PartialD;":0x2202,
  "Pcy;":0x41f, "Pfr;":[0xd835,0xdd13],
  "Phi;":0x3a6, "Pi;":0x3a0,
  "PlusMinus;":0xb1, "Poincareplane;":0x210c,
  "Popf;":0x2119, "Pr;":0x2abb,
  "Precedes;":0x227a, "PrecedesEqual;":0x2aaf,
  "PrecedesSlantEqual;":0x227c, "PrecedesTilde;":0x227e,
  "Prime;":0x2033, "Product;":0x220f,
  "Proportion;":0x2237, "Proportional;":0x221d,
  "Pscr;":[0xd835,0xdcab], "Psi;":0x3a8,
  "QUOT":0x22, "QUOT;":0x22,
  "Qfr;":[0xd835,0xdd14], "Qopf;":0x211a,
  "Qscr;":[0xd835,0xdcac], "RBarr;":0x2910,
  "REG":0xae, "REG;":0xae,
  "Racute;":0x154, "Rang;":0x27eb,
  "Rarr;":0x21a0, "Rarrtl;":0x2916,
  "Rcaron;":0x158, "Rcedil;":0x156,
  "Rcy;":0x420, "Re;":0x211c,
  "ReverseElement;":0x220b, "ReverseEquilibrium;":0x21cb,
  "ReverseUpEquilibrium;":0x296f, "Rfr;":0x211c,
  "Rho;":0x3a1, "RightAngleBracket;":0x27e9,
  "RightArrow;":0x2192, "RightArrowBar;":0x21e5,
  "RightArrowLeftArrow;":0x21c4, "RightCeiling;":0x2309,
  "RightDoubleBracket;":0x27e7, "RightDownTeeVector;":0x295d,
  "RightDownVector;":0x21c2, "RightDownVectorBar;":0x2955,
  "RightFloor;":0x230b, "RightTee;":0x22a2,
  "RightTeeArrow;":0x21a6, "RightTeeVector;":0x295b,
  "RightTriangle;":0x22b3, "RightTriangleBar;":0x29d0,
  "RightTriangleEqual;":0x22b5, "RightUpDownVector;":0x294f,
  "RightUpTeeVector;":0x295c, "RightUpVector;":0x21be,
  "RightUpVectorBar;":0x2954, "RightVector;":0x21c0,
  "RightVectorBar;":0x2953, "Rightarrow;":0x21d2,
  "Ropf;":0x211d, "RoundImplies;":0x2970,
  "Rrightarrow;":0x21db, "Rscr;":0x211b,
  "Rsh;":0x21b1, "RuleDelayed;":0x29f4,
  "SHCHcy;":0x429, "SHcy;":0x428,
  "SOFTcy;":0x42c, "Sacute;":0x15a,
  "Sc;":0x2abc, "Scaron;":0x160,
  "Scedil;":0x15e, "Scirc;":0x15c,
  "Scy;":0x421, "Sfr;":[0xd835,0xdd16],
  "ShortDownArrow;":0x2193, "ShortLeftArrow;":0x2190,
  "ShortRightArrow;":0x2192, "ShortUpArrow;":0x2191,
  "Sigma;":0x3a3, "SmallCircle;":0x2218,
  "Sopf;":[0xd835,0xdd4a], "Sqrt;":0x221a,
  "Square;":0x25a1, "SquareIntersection;":0x2293,
  "SquareSubset;":0x228f, "SquareSubsetEqual;":0x2291,
  "SquareSuperset;":0x2290, "SquareSupersetEqual;":0x2292,
  "SquareUnion;":0x2294, "Sscr;":[0xd835,0xdcae],
  "Star;":0x22c6, "Sub;":0x22d0,
  "Subset;":0x22d0, "SubsetEqual;":0x2286,
  "Succeeds;":0x227b, "SucceedsEqual;":0x2ab0,
  "SucceedsSlantEqual;":0x227d, "SucceedsTilde;":0x227f,
  "SuchThat;":0x220b, "Sum;":0x2211,
  "Sup;":0x22d1, "Superset;":0x2283,
  "SupersetEqual;":0x2287, "Supset;":0x22d1,
  "THORN":0xde, "THORN;":0xde,
  "TRADE;":0x2122, "TSHcy;":0x40b,
  "TScy;":0x426, "Tab;":0x9,
  "Tau;":0x3a4, "Tcaron;":0x164,
  "Tcedil;":0x162, "Tcy;":0x422,
  "Tfr;":[0xd835,0xdd17], "Therefore;":0x2234,
  "Theta;":0x398, "ThickSpace;":[0x205f,0x200a],
  "ThinSpace;":0x2009, "Tilde;":0x223c,
  "TildeEqual;":0x2243, "TildeFullEqual;":0x2245,
  "TildeTilde;":0x2248, "Topf;":[0xd835,0xdd4b],
  "TripleDot;":0x20db, "Tscr;":[0xd835,0xdcaf],
  "Tstrok;":0x166, "Uacute":0xda,
  "Uacute;":0xda, "Uarr;":0x219f,
  "Uarrocir;":0x2949, "Ubrcy;":0x40e,
  "Ubreve;":0x16c, "Ucirc":0xdb,
  "Ucirc;":0xdb, "Ucy;":0x423,
  "Udblac;":0x170, "Ufr;":[0xd835,0xdd18],
  "Ugrave":0xd9, "Ugrave;":0xd9,
  "Umacr;":0x16a, "UnderBar;":0x5f,
  "UnderBrace;":0x23df, "UnderBracket;":0x23b5,
  "UnderParenthesis;":0x23dd, "Union;":0x22c3,
  "UnionPlus;":0x228e, "Uogon;":0x172,
  "Uopf;":[0xd835,0xdd4c], "UpArrow;":0x2191,
  "UpArrowBar;":0x2912, "UpArrowDownArrow;":0x21c5,
  "UpDownArrow;":0x2195, "UpEquilibrium;":0x296e,
  "UpTee;":0x22a5, "UpTeeArrow;":0x21a5,
  "Uparrow;":0x21d1, "Updownarrow;":0x21d5,
  "UpperLeftArrow;":0x2196, "UpperRightArrow;":0x2197,
  "Upsi;":0x3d2, "Upsilon;":0x3a5,
  "Uring;":0x16e, "Uscr;":[0xd835,0xdcb0],
  "Utilde;":0x168, "Uuml":0xdc,
  "Uuml;":0xdc, "VDash;":0x22ab,
  "Vbar;":0x2aeb, "Vcy;":0x412,
  "Vdash;":0x22a9, "Vdashl;":0x2ae6,
  "Vee;":0x22c1, "Verbar;":0x2016,
  "Vert;":0x2016, "VerticalBar;":0x2223,
  "VerticalLine;":0x7c, "VerticalSeparator;":0x2758,
  "VerticalTilde;":0x2240, "VeryThinSpace;":0x200a,
  "Vfr;":[0xd835,0xdd19], "Vopf;":[0xd835,0xdd4d],
  "Vscr;":[0xd835,0xdcb1], "Vvdash;":0x22aa,
  "Wcirc;":0x174, "Wedge;":0x22c0,
  "Wfr;":[0xd835,0xdd1a], "Wopf;":[0xd835,0xdd4e],
  "Wscr;":[0xd835,0xdcb2], "Xfr;":[0xd835,0xdd1b],
  "Xi;":0x39e, "Xopf;":[0xd835,0xdd4f],
  "Xscr;":[0xd835,0xdcb3], "YAcy;":0x42f,
  "YIcy;":0x407, "YUcy;":0x42e,
  "Yacute":0xdd, "Yacute;":0xdd,
  "Ycirc;":0x176, "Ycy;":0x42b,
  "Yfr;":[0xd835,0xdd1c], "Yopf;":[0xd835,0xdd50],
  "Yscr;":[0xd835,0xdcb4], "Yuml;":0x178,
  "ZHcy;":0x416, "Zacute;":0x179,
  "Zcaron;":0x17d, "Zcy;":0x417,
  "Zdot;":0x17b, "ZeroWidthSpace;":0x200b,
  "Zeta;":0x396, "Zfr;":0x2128,
  "Zopf;":0x2124, "Zscr;":[0xd835,0xdcb5],
  "aacute":0xe1, "aacute;":0xe1,
  "abreve;":0x103, "ac;":0x223e,
  "acE;":[0x223e,0x333], "acd;":0x223f,
  "acirc":0xe2, "acirc;":0xe2,
  "acute":0xb4, "acute;":0xb4,
  "acy;":0x430, "aelig":0xe6,
  "aelig;":0xe6, "af;":0x2061,
  "afr;":[0xd835,0xdd1e], "agrave":0xe0,
  "agrave;":0xe0, "alefsym;":0x2135,
  "aleph;":0x2135, "alpha;":0x3b1,
  "amacr;":0x101, "amalg;":0x2a3f,
  "amp":0x26, "amp;":0x26,
  "and;":0x2227, "andand;":0x2a55,
  "andd;":0x2a5c, "andslope;":0x2a58,
  "andv;":0x2a5a, "ang;":0x2220,
  "ange;":0x29a4, "angle;":0x2220,
  "angmsd;":0x2221, "angmsdaa;":0x29a8,
  "angmsdab;":0x29a9, "angmsdac;":0x29aa,
  "angmsdad;":0x29ab, "angmsdae;":0x29ac,
  "angmsdaf;":0x29ad, "angmsdag;":0x29ae,
  "angmsdah;":0x29af, "angrt;":0x221f,
  "angrtvb;":0x22be, "angrtvbd;":0x299d,
  "angsph;":0x2222, "angst;":0xc5,
  "angzarr;":0x237c, "aogon;":0x105,
  "aopf;":[0xd835,0xdd52], "ap;":0x2248,
  "apE;":0x2a70, "apacir;":0x2a6f,
  "ape;":0x224a, "apid;":0x224b,
  "apos;":0x27, "approx;":0x2248,
  "approxeq;":0x224a, "aring":0xe5,
  "aring;":0xe5, "ascr;":[0xd835,0xdcb6],
  "ast;":0x2a, "asymp;":0x2248,
  "asympeq;":0x224d, "atilde":0xe3,
  "atilde;":0xe3, "auml":0xe4,
  "auml;":0xe4, "awconint;":0x2233,
  "awint;":0x2a11, "bNot;":0x2aed,
  "backcong;":0x224c, "backepsilon;":0x3f6,
  "backprime;":0x2035, "backsim;":0x223d,
  "backsimeq;":0x22cd, "barvee;":0x22bd,
  "barwed;":0x2305, "barwedge;":0x2305,
  "bbrk;":0x23b5, "bbrktbrk;":0x23b6,
  "bcong;":0x224c, "bcy;":0x431,
  "bdquo;":0x201e, "becaus;":0x2235,
  "because;":0x2235, "bemptyv;":0x29b0,
  "bepsi;":0x3f6, "bernou;":0x212c,
  "beta;":0x3b2, "beth;":0x2136,
  "between;":0x226c, "bfr;":[0xd835,0xdd1f],
  "bigcap;":0x22c2, "bigcirc;":0x25ef,
  "bigcup;":0x22c3, "bigodot;":0x2a00,
  "bigoplus;":0x2a01, "bigotimes;":0x2a02,
  "bigsqcup;":0x2a06, "bigstar;":0x2605,
  "bigtriangledown;":0x25bd, "bigtriangleup;":0x25b3,
  "biguplus;":0x2a04, "bigvee;":0x22c1,
  "bigwedge;":0x22c0, "bkarow;":0x290d,
  "blacklozenge;":0x29eb, "blacksquare;":0x25aa,
  "blacktriangle;":0x25b4, "blacktriangledown;":0x25be,
  "blacktriangleleft;":0x25c2, "blacktriangleright;":0x25b8,
  "blank;":0x2423, "blk12;":0x2592,
  "blk14;":0x2591, "blk34;":0x2593,
  "block;":0x2588, "bne;":[0x3d,0x20e5],
  "bnequiv;":[0x2261,0x20e5], "bnot;":0x2310,
  "bopf;":[0xd835,0xdd53], "bot;":0x22a5,
  "bottom;":0x22a5, "bowtie;":0x22c8,
  "boxDL;":0x2557, "boxDR;":0x2554,
  "boxDl;":0x2556, "boxDr;":0x2553,
  "boxH;":0x2550, "boxHD;":0x2566,
  "boxHU;":0x2569, "boxHd;":0x2564,
  "boxHu;":0x2567, "boxUL;":0x255d,
  "boxUR;":0x255a, "boxUl;":0x255c,
  "boxUr;":0x2559, "boxV;":0x2551,
  "boxVH;":0x256c, "boxVL;":0x2563,
  "boxVR;":0x2560, "boxVh;":0x256b,
  "boxVl;":0x2562, "boxVr;":0x255f,
  "boxbox;":0x29c9, "boxdL;":0x2555,
  "boxdR;":0x2552, "boxdl;":0x2510,
  "boxdr;":0x250c, "boxh;":0x2500,
  "boxhD;":0x2565, "boxhU;":0x2568,
  "boxhd;":0x252c, "boxhu;":0x2534,
  "boxminus;":0x229f, "boxplus;":0x229e,
  "boxtimes;":0x22a0, "boxuL;":0x255b,
  "boxuR;":0x2558, "boxul;":0x2518,
  "boxur;":0x2514, "boxv;":0x2502,
  "boxvH;":0x256a, "boxvL;":0x2561,
  "boxvR;":0x255e, "boxvh;":0x253c,
  "boxvl;":0x2524, "boxvr;":0x251c,
  "bprime;":0x2035, "breve;":0x2d8,
  "brvbar":0xa6, "brvbar;":0xa6,
  "bscr;":[0xd835,0xdcb7], "bsemi;":0x204f,
  "bsim;":0x223d, "bsime;":0x22cd,
  "bsol;":0x5c, "bsolb;":0x29c5,
  "bsolhsub;":0x27c8, "bull;":0x2022,
  "bullet;":0x2022, "bump;":0x224e,
  "bumpE;":0x2aae, "bumpe;":0x224f,
  "bumpeq;":0x224f, "cacute;":0x107,
  "cap;":0x2229, "capand;":0x2a44,
  "capbrcup;":0x2a49, "capcap;":0x2a4b,
  "capcup;":0x2a47, "capdot;":0x2a40,
  "caps;":[0x2229,0xfe00], "caret;":0x2041,
  "caron;":0x2c7, "ccaps;":0x2a4d,
  "ccaron;":0x10d, "ccedil":0xe7,
  "ccedil;":0xe7, "ccirc;":0x109,
  "ccups;":0x2a4c, "ccupssm;":0x2a50,
  "cdot;":0x10b, "cedil":0xb8,
  "cedil;":0xb8, "cemptyv;":0x29b2,
  "cent":0xa2, "cent;":0xa2,
  "centerdot;":0xb7, "cfr;":[0xd835,0xdd20],
  "chcy;":0x447, "check;":0x2713,
  "checkmark;":0x2713, "chi;":0x3c7,
  "cir;":0x25cb, "cirE;":0x29c3,
  "circ;":0x2c6, "circeq;":0x2257,
  "circlearrowleft;":0x21ba, "circlearrowright;":0x21bb,
  "circledR;":0xae, "circledS;":0x24c8,
  "circledast;":0x229b, "circledcirc;":0x229a,
  "circleddash;":0x229d, "cire;":0x2257,
  "cirfnint;":0x2a10, "cirmid;":0x2aef,
  "cirscir;":0x29c2, "clubs;":0x2663,
  "clubsuit;":0x2663, "colon;":0x3a,
  "colone;":0x2254, "coloneq;":0x2254,
  "comma;":0x2c, "commat;":0x40,
  "comp;":0x2201, "compfn;":0x2218,
  "complement;":0x2201, "complexes;":0x2102,
  "cong;":0x2245, "congdot;":0x2a6d,
  "conint;":0x222e, "copf;":[0xd835,0xdd54],
  "coprod;":0x2210, "copy":0xa9,
  "copy;":0xa9, "copysr;":0x2117,
  "crarr;":0x21b5, "cross;":0x2717,
  "cscr;":[0xd835,0xdcb8], "csub;":0x2acf,
  "csube;":0x2ad1, "csup;":0x2ad0,
  "csupe;":0x2ad2, "ctdot;":0x22ef,
  "cudarrl;":0x2938, "cudarrr;":0x2935,
  "cuepr;":0x22de, "cuesc;":0x22df,
  "cularr;":0x21b6, "cularrp;":0x293d,
  "cup;":0x222a, "cupbrcap;":0x2a48,
  "cupcap;":0x2a46, "cupcup;":0x2a4a,
  "cupdot;":0x228d, "cupor;":0x2a45,
  "cups;":[0x222a,0xfe00], "curarr;":0x21b7,
  "curarrm;":0x293c, "curlyeqprec;":0x22de,
  "curlyeqsucc;":0x22df, "curlyvee;":0x22ce,
  "curlywedge;":0x22cf, "curren":0xa4,
  "curren;":0xa4, "curvearrowleft;":0x21b6,
  "curvearrowright;":0x21b7, "cuvee;":0x22ce,
  "cuwed;":0x22cf, "cwconint;":0x2232,
  "cwint;":0x2231, "cylcty;":0x232d,
  "dArr;":0x21d3, "dHar;":0x2965,
  "dagger;":0x2020, "daleth;":0x2138,
  "darr;":0x2193, "dash;":0x2010,
  "dashv;":0x22a3, "dbkarow;":0x290f,
  "dblac;":0x2dd, "dcaron;":0x10f,
  "dcy;":0x434, "dd;":0x2146,
  "ddagger;":0x2021, "ddarr;":0x21ca,
  "ddotseq;":0x2a77, "deg":0xb0,
  "deg;":0xb0, "delta;":0x3b4,
  "demptyv;":0x29b1, "dfisht;":0x297f,
  "dfr;":[0xd835,0xdd21], "dharl;":0x21c3,
  "dharr;":0x21c2, "diam;":0x22c4,
  "diamond;":0x22c4, "diamondsuit;":0x2666,
  "diams;":0x2666, "die;":0xa8,
  "digamma;":0x3dd, "disin;":0x22f2,
  "div;":0xf7, "divide":0xf7,
  "divide;":0xf7, "divideontimes;":0x22c7,
  "divonx;":0x22c7, "djcy;":0x452,
  "dlcorn;":0x231e, "dlcrop;":0x230d,
  "dollar;":0x24, "dopf;":[0xd835,0xdd55],
  "dot;":0x2d9, "doteq;":0x2250,
  "doteqdot;":0x2251, "dotminus;":0x2238,
  "dotplus;":0x2214, "dotsquare;":0x22a1,
  "doublebarwedge;":0x2306, "downarrow;":0x2193,
  "downdownarrows;":0x21ca, "downharpoonleft;":0x21c3,
  "downharpoonright;":0x21c2, "drbkarow;":0x2910,
  "drcorn;":0x231f, "drcrop;":0x230c,
  "dscr;":[0xd835,0xdcb9], "dscy;":0x455,
  "dsol;":0x29f6, "dstrok;":0x111,
  "dtdot;":0x22f1, "dtri;":0x25bf,
  "dtrif;":0x25be, "duarr;":0x21f5,
  "duhar;":0x296f, "dwangle;":0x29a6,
  "dzcy;":0x45f, "dzigrarr;":0x27ff,
  "eDDot;":0x2a77, "eDot;":0x2251,
  "eacute":0xe9, "eacute;":0xe9,
  "easter;":0x2a6e, "ecaron;":0x11b,
  "ecir;":0x2256, "ecirc":0xea,
  "ecirc;":0xea, "ecolon;":0x2255,
  "ecy;":0x44d, "edot;":0x117,
  "ee;":0x2147, "efDot;":0x2252,
  "efr;":[0xd835,0xdd22], "eg;":0x2a9a,
  "egrave":0xe8, "egrave;":0xe8,
  "egs;":0x2a96, "egsdot;":0x2a98,
  "el;":0x2a99, "elinters;":0x23e7,
  "ell;":0x2113, "els;":0x2a95,
  "elsdot;":0x2a97, "emacr;":0x113,
  "empty;":0x2205, "emptyset;":0x2205,
  "emptyv;":0x2205, "emsp13;":0x2004,
  "emsp14;":0x2005, "emsp;":0x2003,
  "eng;":0x14b, "ensp;":0x2002,
  "eogon;":0x119, "eopf;":[0xd835,0xdd56],
  "epar;":0x22d5, "eparsl;":0x29e3,
  "eplus;":0x2a71, "epsi;":0x3b5,
  "epsilon;":0x3b5, "epsiv;":0x3f5,
  "eqcirc;":0x2256, "eqcolon;":0x2255,
  "eqsim;":0x2242, "eqslantgtr;":0x2a96,
  "eqslantless;":0x2a95, "equals;":0x3d,
  "equest;":0x225f, "equiv;":0x2261,
  "equivDD;":0x2a78, "eqvparsl;":0x29e5,
  "erDot;":0x2253, "erarr;":0x2971,
  "escr;":0x212f, "esdot;":0x2250,
  "esim;":0x2242, "eta;":0x3b7,
  "eth":0xf0, "eth;":0xf0,
  "euml":0xeb, "euml;":0xeb,
  "euro;":0x20ac, "excl;":0x21,
  "exist;":0x2203, "expectation;":0x2130,
  "exponentiale;":0x2147, "fallingdotseq;":0x2252,
  "fcy;":0x444, "female;":0x2640,
  "ffilig;":0xfb03, "fflig;":0xfb00,
  "ffllig;":0xfb04, "ffr;":[0xd835,0xdd23],
  "filig;":0xfb01, "fjlig;":[0x66,0x6a],
  "flat;":0x266d, "fllig;":0xfb02,
  "fltns;":0x25b1, "fnof;":0x192,
  "fopf;":[0xd835,0xdd57], "forall;":0x2200,
  "fork;":0x22d4, "forkv;":0x2ad9,
  "fpartint;":0x2a0d, "frac12":0xbd,
  "frac12;":0xbd, "frac13;":0x2153,
  "frac14":0xbc, "frac14;":0xbc,
  "frac15;":0x2155, "frac16;":0x2159,
  "frac18;":0x215b, "frac23;":0x2154,
  "frac25;":0x2156, "frac34":0xbe,
  "frac34;":0xbe, "frac35;":0x2157,
  "frac38;":0x215c, "frac45;":0x2158,
  "frac56;":0x215a, "frac58;":0x215d,
  "frac78;":0x215e, "frasl;":0x2044,
  "frown;":0x2322, "fscr;":[0xd835,0xdcbb],
  "gE;":0x2267, "gEl;":0x2a8c,
  "gacute;":0x1f5, "gamma;":0x3b3,
  "gammad;":0x3dd, "gap;":0x2a86,
  "gbreve;":0x11f, "gcirc;":0x11d,
  "gcy;":0x433, "gdot;":0x121,
  "ge;":0x2265, "gel;":0x22db,
  "geq;":0x2265, "geqq;":0x2267,
  "geqslant;":0x2a7e, "ges;":0x2a7e,
  "gescc;":0x2aa9, "gesdot;":0x2a80,
  "gesdoto;":0x2a82, "gesdotol;":0x2a84,
  "gesl;":[0x22db,0xfe00], "gesles;":0x2a94,
  "gfr;":[0xd835,0xdd24], "gg;":0x226b,
  "ggg;":0x22d9, "gimel;":0x2137,
  "gjcy;":0x453, "gl;":0x2277,
  "glE;":0x2a92, "gla;":0x2aa5,
  "glj;":0x2aa4, "gnE;":0x2269,
  "gnap;":0x2a8a, "gnapprox;":0x2a8a,
  "gne;":0x2a88, "gneq;":0x2a88,
  "gneqq;":0x2269, "gnsim;":0x22e7,
  "gopf;":[0xd835,0xdd58], "grave;":0x60,
  "gscr;":0x210a, "gsim;":0x2273,
  "gsime;":0x2a8e, "gsiml;":0x2a90,
  "gt":0x3e, "gt;":0x3e,
  "gtcc;":0x2aa7, "gtcir;":0x2a7a,
  "gtdot;":0x22d7, "gtlPar;":0x2995,
  "gtquest;":0x2a7c, "gtrapprox;":0x2a86,
  "gtrarr;":0x2978, "gtrdot;":0x22d7,
  "gtreqless;":0x22db, "gtreqqless;":0x2a8c,
  "gtrless;":0x2277, "gtrsim;":0x2273,
  "gvertneqq;":[0x2269,0xfe00], "gvnE;":[0x2269,0xfe00],
  "hArr;":0x21d4, "hairsp;":0x200a,
  "half;":0xbd, "hamilt;":0x210b,
  "hardcy;":0x44a, "harr;":0x2194,
  "harrcir;":0x2948, "harrw;":0x21ad,
  "hbar;":0x210f, "hcirc;":0x125,
  "hearts;":0x2665, "heartsuit;":0x2665,
  "hellip;":0x2026, "hercon;":0x22b9,
  "hfr;":[0xd835,0xdd25], "hksearow;":0x2925,
  "hkswarow;":0x2926, "hoarr;":0x21ff,
  "homtht;":0x223b, "hookleftarrow;":0x21a9,
  "hookrightarrow;":0x21aa, "hopf;":[0xd835,0xdd59],
  "horbar;":0x2015, "hscr;":[0xd835,0xdcbd],
  "hslash;":0x210f, "hstrok;":0x127,
  "hybull;":0x2043, "hyphen;":0x2010,
  "iacute":0xed, "iacute;":0xed,
  "ic;":0x2063, "icirc":0xee,
  "icirc;":0xee, "icy;":0x438,
  "iecy;":0x435, "iexcl":0xa1,
  "iexcl;":0xa1, "iff;":0x21d4,
  "ifr;":[0xd835,0xdd26], "igrave":0xec,
  "igrave;":0xec, "ii;":0x2148,
  "iiiint;":0x2a0c, "iiint;":0x222d,
  "iinfin;":0x29dc, "iiota;":0x2129,
  "ijlig;":0x133, "imacr;":0x12b,
  "image;":0x2111, "imagline;":0x2110,
  "imagpart;":0x2111, "imath;":0x131,
  "imof;":0x22b7, "imped;":0x1b5,
  "in;":0x2208, "incare;":0x2105,
  "infin;":0x221e, "infintie;":0x29dd,
  "inodot;":0x131, "int;":0x222b,
  "intcal;":0x22ba, "integers;":0x2124,
  "intercal;":0x22ba, "intlarhk;":0x2a17,
  "intprod;":0x2a3c, "iocy;":0x451,
  "iogon;":0x12f, "iopf;":[0xd835,0xdd5a],
  "iota;":0x3b9, "iprod;":0x2a3c,
  "iquest":0xbf, "iquest;":0xbf,
  "iscr;":[0xd835,0xdcbe], "isin;":0x2208,
  "isinE;":0x22f9, "isindot;":0x22f5,
  "isins;":0x22f4, "isinsv;":0x22f3,
  "isinv;":0x2208, "it;":0x2062,
  "itilde;":0x129, "iukcy;":0x456,
  "iuml":0xef, "iuml;":0xef,
  "jcirc;":0x135, "jcy;":0x439,
  "jfr;":[0xd835,0xdd27], "jmath;":0x237,
  "jopf;":[0xd835,0xdd5b], "jscr;":[0xd835,0xdcbf],
  "jsercy;":0x458, "jukcy;":0x454,
  "kappa;":0x3ba, "kappav;":0x3f0,
  "kcedil;":0x137, "kcy;":0x43a,
  "kfr;":[0xd835,0xdd28], "kgreen;":0x138,
  "khcy;":0x445, "kjcy;":0x45c,
  "kopf;":[0xd835,0xdd5c], "kscr;":[0xd835,0xdcc0],
  "lAarr;":0x21da, "lArr;":0x21d0,
  "lAtail;":0x291b, "lBarr;":0x290e,
  "lE;":0x2266, "lEg;":0x2a8b,
  "lHar;":0x2962, "lacute;":0x13a,
  "laemptyv;":0x29b4, "lagran;":0x2112,
  "lambda;":0x3bb, "lang;":0x27e8,
  "langd;":0x2991, "langle;":0x27e8,
  "lap;":0x2a85, "laquo":0xab,
  "laquo;":0xab, "larr;":0x2190,
  "larrb;":0x21e4, "larrbfs;":0x291f,
  "larrfs;":0x291d, "larrhk;":0x21a9,
  "larrlp;":0x21ab, "larrpl;":0x2939,
  "larrsim;":0x2973, "larrtl;":0x21a2,
  "lat;":0x2aab, "latail;":0x2919,
  "late;":0x2aad, "lates;":[0x2aad,0xfe00],
  "lbarr;":0x290c, "lbbrk;":0x2772,
  "lbrace;":0x7b, "lbrack;":0x5b,
  "lbrke;":0x298b, "lbrksld;":0x298f,
  "lbrkslu;":0x298d, "lcaron;":0x13e,
  "lcedil;":0x13c, "lceil;":0x2308,
  "lcub;":0x7b, "lcy;":0x43b,
  "ldca;":0x2936, "ldquo;":0x201c,
  "ldquor;":0x201e, "ldrdhar;":0x2967,
  "ldrushar;":0x294b, "ldsh;":0x21b2,
  "le;":0x2264, "leftarrow;":0x2190,
  "leftarrowtail;":0x21a2, "leftharpoondown;":0x21bd,
  "leftharpoonup;":0x21bc, "leftleftarrows;":0x21c7,
  "leftrightarrow;":0x2194, "leftrightarrows;":0x21c6,
  "leftrightharpoons;":0x21cb, "leftrightsquigarrow;":0x21ad,
  "leftthreetimes;":0x22cb, "leg;":0x22da,
  "leq;":0x2264, "leqq;":0x2266,
  "leqslant;":0x2a7d, "les;":0x2a7d,
  "lescc;":0x2aa8, "lesdot;":0x2a7f,
  "lesdoto;":0x2a81, "lesdotor;":0x2a83,
  "lesg;":[0x22da,0xfe00], "lesges;":0x2a93,
  "lessapprox;":0x2a85, "lessdot;":0x22d6,
  "lesseqgtr;":0x22da, "lesseqqgtr;":0x2a8b,
  "lessgtr;":0x2276, "lesssim;":0x2272,
  "lfisht;":0x297c, "lfloor;":0x230a,
  "lfr;":[0xd835,0xdd29], "lg;":0x2276,
  "lgE;":0x2a91, "lhard;":0x21bd,
  "lharu;":0x21bc, "lharul;":0x296a,
  "lhblk;":0x2584, "ljcy;":0x459,
  "ll;":0x226a, "llarr;":0x21c7,
  "llcorner;":0x231e, "llhard;":0x296b,
  "lltri;":0x25fa, "lmidot;":0x140,
  "lmoust;":0x23b0, "lmoustache;":0x23b0,
  "lnE;":0x2268, "lnap;":0x2a89,
  "lnapprox;":0x2a89, "lne;":0x2a87,
  "lneq;":0x2a87, "lneqq;":0x2268,
  "lnsim;":0x22e6, "loang;":0x27ec,
  "loarr;":0x21fd, "lobrk;":0x27e6,
  "longleftarrow;":0x27f5, "longleftrightarrow;":0x27f7,
  "longmapsto;":0x27fc, "longrightarrow;":0x27f6,
  "looparrowleft;":0x21ab, "looparrowright;":0x21ac,
  "lopar;":0x2985, "lopf;":[0xd835,0xdd5d],
  "loplus;":0x2a2d, "lotimes;":0x2a34,
  "lowast;":0x2217, "lowbar;":0x5f,
  "loz;":0x25ca, "lozenge;":0x25ca,
  "lozf;":0x29eb, "lpar;":0x28,
  "lparlt;":0x2993, "lrarr;":0x21c6,
  "lrcorner;":0x231f, "lrhar;":0x21cb,
  "lrhard;":0x296d, "lrm;":0x200e,
  "lrtri;":0x22bf, "lsaquo;":0x2039,
  "lscr;":[0xd835,0xdcc1], "lsh;":0x21b0,
  "lsim;":0x2272, "lsime;":0x2a8d,
  "lsimg;":0x2a8f, "lsqb;":0x5b,
  "lsquo;":0x2018, "lsquor;":0x201a,
  "lstrok;":0x142, "lt":0x3c,
  "lt;":0x3c, "ltcc;":0x2aa6,
  "ltcir;":0x2a79, "ltdot;":0x22d6,
  "lthree;":0x22cb, "ltimes;":0x22c9,
  "ltlarr;":0x2976, "ltquest;":0x2a7b,
  "ltrPar;":0x2996, "ltri;":0x25c3,
  "ltrie;":0x22b4, "ltrif;":0x25c2,
  "lurdshar;":0x294a, "luruhar;":0x2966,
  "lvertneqq;":[0x2268,0xfe00], "lvnE;":[0x2268,0xfe00],
  "mDDot;":0x223a, "macr":0xaf,
  "macr;":0xaf, "male;":0x2642,
  "malt;":0x2720, "maltese;":0x2720,
  "map;":0x21a6, "mapsto;":0x21a6,
  "mapstodown;":0x21a7, "mapstoleft;":0x21a4,
  "mapstoup;":0x21a5, "marker;":0x25ae,
  "mcomma;":0x2a29, "mcy;":0x43c,
  "mdash;":0x2014, "measuredangle;":0x2221,
  "mfr;":[0xd835,0xdd2a], "mho;":0x2127,
  "micro":0xb5, "micro;":0xb5,
  "mid;":0x2223, "midast;":0x2a,
  "midcir;":0x2af0, "middot":0xb7,
  "middot;":0xb7, "minus;":0x2212,
  "minusb;":0x229f, "minusd;":0x2238,
  "minusdu;":0x2a2a, "mlcp;":0x2adb,
  "mldr;":0x2026, "mnplus;":0x2213,
  "models;":0x22a7, "mopf;":[0xd835,0xdd5e],
  "mp;":0x2213, "mscr;":[0xd835,0xdcc2],
  "mstpos;":0x223e, "mu;":0x3bc,
  "multimap;":0x22b8, "mumap;":0x22b8,
  "nGg;":[0x22d9,0x338], "nGt;":[0x226b,0x20d2],
  "nGtv;":[0x226b,0x338], "nLeftarrow;":0x21cd,
  "nLeftrightarrow;":0x21ce, "nLl;":[0x22d8,0x338],
  "nLt;":[0x226a,0x20d2], "nLtv;":[0x226a,0x338],
  "nRightarrow;":0x21cf, "nVDash;":0x22af,
  "nVdash;":0x22ae, "nabla;":0x2207,
  "nacute;":0x144, "nang;":[0x2220,0x20d2],
  "nap;":0x2249, "napE;":[0x2a70,0x338],
  "napid;":[0x224b,0x338], "napos;":0x149,
  "napprox;":0x2249, "natur;":0x266e,
  "natural;":0x266e, "naturals;":0x2115,
  "nbsp":0xa0, "nbsp;":0xa0,
  "nbump;":[0x224e,0x338], "nbumpe;":[0x224f,0x338],
  "ncap;":0x2a43, "ncaron;":0x148,
  "ncedil;":0x146, "ncong;":0x2247,
  "ncongdot;":[0x2a6d,0x338], "ncup;":0x2a42,
  "ncy;":0x43d, "ndash;":0x2013,
  "ne;":0x2260, "neArr;":0x21d7,
  "nearhk;":0x2924, "nearr;":0x2197,
  "nearrow;":0x2197, "nedot;":[0x2250,0x338],
  "nequiv;":0x2262, "nesear;":0x2928,
  "nesim;":[0x2242,0x338], "nexist;":0x2204,
  "nexists;":0x2204, "nfr;":[0xd835,0xdd2b],
  "ngE;":[0x2267,0x338], "nge;":0x2271,
  "ngeq;":0x2271, "ngeqq;":[0x2267,0x338],
  "ngeqslant;":[0x2a7e,0x338], "nges;":[0x2a7e,0x338],
  "ngsim;":0x2275, "ngt;":0x226f,
  "ngtr;":0x226f, "nhArr;":0x21ce,
  "nharr;":0x21ae, "nhpar;":0x2af2,
  "ni;":0x220b, "nis;":0x22fc,
  "nisd;":0x22fa, "niv;":0x220b,
  "njcy;":0x45a, "nlArr;":0x21cd,
  "nlE;":[0x2266,0x338], "nlarr;":0x219a,
  "nldr;":0x2025, "nle;":0x2270,
  "nleftarrow;":0x219a, "nleftrightarrow;":0x21ae,
  "nleq;":0x2270, "nleqq;":[0x2266,0x338],
  "nleqslant;":[0x2a7d,0x338], "nles;":[0x2a7d,0x338],
  "nless;":0x226e, "nlsim;":0x2274,
  "nlt;":0x226e, "nltri;":0x22ea,
  "nltrie;":0x22ec, "nmid;":0x2224,
  "nopf;":[0xd835,0xdd5f], "not":0xac,
  "not;":0xac, "notin;":0x2209,
  "notinE;":[0x22f9,0x338], "notindot;":[0x22f5,0x338],
  "notinva;":0x2209, "notinvb;":0x22f7,
  "notinvc;":0x22f6, "notni;":0x220c,
  "notniva;":0x220c, "notnivb;":0x22fe,
  "notnivc;":0x22fd, "npar;":0x2226,
  "nparallel;":0x2226, "nparsl;":[0x2afd,0x20e5],
  "npart;":[0x2202,0x338], "npolint;":0x2a14,
  "npr;":0x2280, "nprcue;":0x22e0,
  "npre;":[0x2aaf,0x338], "nprec;":0x2280,
  "npreceq;":[0x2aaf,0x338], "nrArr;":0x21cf,
  "nrarr;":0x219b, "nrarrc;":[0x2933,0x338],
  "nrarrw;":[0x219d,0x338], "nrightarrow;":0x219b,
  "nrtri;":0x22eb, "nrtrie;":0x22ed,
  "nsc;":0x2281, "nsccue;":0x22e1,
  "nsce;":[0x2ab0,0x338], "nscr;":[0xd835,0xdcc3],
  "nshortmid;":0x2224, "nshortparallel;":0x2226,
  "nsim;":0x2241, "nsime;":0x2244,
  "nsimeq;":0x2244, "nsmid;":0x2224,
  "nspar;":0x2226, "nsqsube;":0x22e2,
  "nsqsupe;":0x22e3, "nsub;":0x2284,
  "nsubE;":[0x2ac5,0x338], "nsube;":0x2288,
  "nsubset;":[0x2282,0x20d2], "nsubseteq;":0x2288,
  "nsubseteqq;":[0x2ac5,0x338], "nsucc;":0x2281,
  "nsucceq;":[0x2ab0,0x338], "nsup;":0x2285,
  "nsupE;":[0x2ac6,0x338], "nsupe;":0x2289,
  "nsupset;":[0x2283,0x20d2], "nsupseteq;":0x2289,
  "nsupseteqq;":[0x2ac6,0x338], "ntgl;":0x2279,
  "ntilde":0xf1, "ntilde;":0xf1,
  "ntlg;":0x2278, "ntriangleleft;":0x22ea,
  "ntrianglelefteq;":0x22ec, "ntriangleright;":0x22eb,
  "ntrianglerighteq;":0x22ed, "nu;":0x3bd,
  "num;":0x23, "numero;":0x2116,
  "numsp;":0x2007, "nvDash;":0x22ad,
  "nvHarr;":0x2904, "nvap;":[0x224d,0x20d2],
  "nvdash;":0x22ac, "nvge;":[0x2265,0x20d2],
  "nvgt;":[0x3e,0x20d2], "nvinfin;":0x29de,
  "nvlArr;":0x2902, "nvle;":[0x2264,0x20d2],
  "nvlt;":[0x3c,0x20d2], "nvltrie;":[0x22b4,0x20d2],
  "nvrArr;":0x2903, "nvrtrie;":[0x22b5,0x20d2],
  "nvsim;":[0x223c,0x20d2], "nwArr;":0x21d6,
  "nwarhk;":0x2923, "nwarr;":0x2196,
  "nwarrow;":0x2196, "nwnear;":0x2927,
  "oS;":0x24c8, "oacute":0xf3,
  "oacute;":0xf3, "oast;":0x229b,
  "ocir;":0x229a, "ocirc":0xf4,
  "ocirc;":0xf4, "ocy;":0x43e,
  "odash;":0x229d, "odblac;":0x151,
  "odiv;":0x2a38, "odot;":0x2299,
  "odsold;":0x29bc, "oelig;":0x153,
  "ofcir;":0x29bf, "ofr;":[0xd835,0xdd2c],
  "ogon;":0x2db, "ograve":0xf2,
  "ograve;":0xf2, "ogt;":0x29c1,
  "ohbar;":0x29b5, "ohm;":0x3a9,
  "oint;":0x222e, "olarr;":0x21ba,
  "olcir;":0x29be, "olcross;":0x29bb,
  "oline;":0x203e, "olt;":0x29c0,
  "omacr;":0x14d, "omega;":0x3c9,
  "omicron;":0x3bf, "omid;":0x29b6,
  "ominus;":0x2296, "oopf;":[0xd835,0xdd60],
  "opar;":0x29b7, "operp;":0x29b9,
  "oplus;":0x2295, "or;":0x2228,
  "orarr;":0x21bb, "ord;":0x2a5d,
  "order;":0x2134, "orderof;":0x2134,
  "ordf":0xaa, "ordf;":0xaa,
  "ordm":0xba, "ordm;":0xba,
  "origof;":0x22b6, "oror;":0x2a56,
  "orslope;":0x2a57, "orv;":0x2a5b,
  "oscr;":0x2134, "oslash":0xf8,
  "oslash;":0xf8, "osol;":0x2298,
  "otilde":0xf5, "otilde;":0xf5,
  "otimes;":0x2297, "otimesas;":0x2a36,
  "ouml":0xf6, "ouml;":0xf6,
  "ovbar;":0x233d, "par;":0x2225,
  "para":0xb6, "para;":0xb6,
  "parallel;":0x2225, "parsim;":0x2af3,
  "parsl;":0x2afd, "part;":0x2202,
  "pcy;":0x43f, "percnt;":0x25,
  "period;":0x2e, "permil;":0x2030,
  "perp;":0x22a5, "pertenk;":0x2031,
  "pfr;":[0xd835,0xdd2d], "phi;":0x3c6,
  "phiv;":0x3d5, "phmmat;":0x2133,
  "phone;":0x260e, "pi;":0x3c0,
  "pitchfork;":0x22d4, "piv;":0x3d6,
  "planck;":0x210f, "planckh;":0x210e,
  "plankv;":0x210f, "plus;":0x2b,
  "plusacir;":0x2a23, "plusb;":0x229e,
  "pluscir;":0x2a22, "plusdo;":0x2214,
  "plusdu;":0x2a25, "pluse;":0x2a72,
  "plusmn":0xb1, "plusmn;":0xb1,
  "plussim;":0x2a26, "plustwo;":0x2a27,
  "pm;":0xb1, "pointint;":0x2a15,
  "popf;":[0xd835,0xdd61], "pound":0xa3,
  "pound;":0xa3, "pr;":0x227a,
  "prE;":0x2ab3, "prap;":0x2ab7,
  "prcue;":0x227c, "pre;":0x2aaf,
  "prec;":0x227a, "precapprox;":0x2ab7,
  "preccurlyeq;":0x227c, "preceq;":0x2aaf,
  "precnapprox;":0x2ab9, "precneqq;":0x2ab5,
  "precnsim;":0x22e8, "precsim;":0x227e,
  "prime;":0x2032, "primes;":0x2119,
  "prnE;":0x2ab5, "prnap;":0x2ab9,
  "prnsim;":0x22e8, "prod;":0x220f,
  "profalar;":0x232e, "profline;":0x2312,
  "profsurf;":0x2313, "prop;":0x221d,
  "propto;":0x221d, "prsim;":0x227e,
  "prurel;":0x22b0, "pscr;":[0xd835,0xdcc5],
  "psi;":0x3c8, "puncsp;":0x2008,
  "qfr;":[0xd835,0xdd2e], "qint;":0x2a0c,
  "qopf;":[0xd835,0xdd62], "qprime;":0x2057,
  "qscr;":[0xd835,0xdcc6], "quaternions;":0x210d,
  "quatint;":0x2a16, "quest;":0x3f,
  "questeq;":0x225f, "quot":0x22,
  "quot;":0x22, "rAarr;":0x21db,
  "rArr;":0x21d2, "rAtail;":0x291c,
  "rBarr;":0x290f, "rHar;":0x2964,
  "race;":[0x223d,0x331], "racute;":0x155,
  "radic;":0x221a, "raemptyv;":0x29b3,
  "rang;":0x27e9, "rangd;":0x2992,
  "range;":0x29a5, "rangle;":0x27e9,
  "raquo":0xbb, "raquo;":0xbb,
  "rarr;":0x2192, "rarrap;":0x2975,
  "rarrb;":0x21e5, "rarrbfs;":0x2920,
  "rarrc;":0x2933, "rarrfs;":0x291e,
  "rarrhk;":0x21aa, "rarrlp;":0x21ac,
  "rarrpl;":0x2945, "rarrsim;":0x2974,
  "rarrtl;":0x21a3, "rarrw;":0x219d,
  "ratail;":0x291a, "ratio;":0x2236,
  "rationals;":0x211a, "rbarr;":0x290d,
  "rbbrk;":0x2773, "rbrace;":0x7d,
  "rbrack;":0x5d, "rbrke;":0x298c,
  "rbrksld;":0x298e, "rbrkslu;":0x2990,
  "rcaron;":0x159, "rcedil;":0x157,
  "rceil;":0x2309, "rcub;":0x7d,
  "rcy;":0x440, "rdca;":0x2937,
  "rdldhar;":0x2969, "rdquo;":0x201d,
  "rdquor;":0x201d, "rdsh;":0x21b3,
  "real;":0x211c, "realine;":0x211b,
  "realpart;":0x211c, "reals;":0x211d,
  "rect;":0x25ad, "reg":0xae,
  "reg;":0xae, "rfisht;":0x297d,
  "rfloor;":0x230b, "rfr;":[0xd835,0xdd2f],
  "rhard;":0x21c1, "rharu;":0x21c0,
  "rharul;":0x296c, "rho;":0x3c1,
  "rhov;":0x3f1, "rightarrow;":0x2192,
  "rightarrowtail;":0x21a3, "rightharpoondown;":0x21c1,
  "rightharpoonup;":0x21c0, "rightleftarrows;":0x21c4,
  "rightleftharpoons;":0x21cc, "rightrightarrows;":0x21c9,
  "rightsquigarrow;":0x219d, "rightthreetimes;":0x22cc,
  "ring;":0x2da, "risingdotseq;":0x2253,
  "rlarr;":0x21c4, "rlhar;":0x21cc,
  "rlm;":0x200f, "rmoust;":0x23b1,
  "rmoustache;":0x23b1, "rnmid;":0x2aee,
  "roang;":0x27ed, "roarr;":0x21fe,
  "robrk;":0x27e7, "ropar;":0x2986,
  "ropf;":[0xd835,0xdd63], "roplus;":0x2a2e,
  "rotimes;":0x2a35, "rpar;":0x29,
  "rpargt;":0x2994, "rppolint;":0x2a12,
  "rrarr;":0x21c9, "rsaquo;":0x203a,
  "rscr;":[0xd835,0xdcc7], "rsh;":0x21b1,
  "rsqb;":0x5d, "rsquo;":0x2019,
  "rsquor;":0x2019, "rthree;":0x22cc,
  "rtimes;":0x22ca, "rtri;":0x25b9,
  "rtrie;":0x22b5, "rtrif;":0x25b8,
  "rtriltri;":0x29ce, "ruluhar;":0x2968,
  "rx;":0x211e, "sacute;":0x15b,
  "sbquo;":0x201a, "sc;":0x227b,
  "scE;":0x2ab4, "scap;":0x2ab8,
  "scaron;":0x161, "sccue;":0x227d,
  "sce;":0x2ab0, "scedil;":0x15f,
  "scirc;":0x15d, "scnE;":0x2ab6,
  "scnap;":0x2aba, "scnsim;":0x22e9,
  "scpolint;":0x2a13, "scsim;":0x227f,
  "scy;":0x441, "sdot;":0x22c5,
  "sdotb;":0x22a1, "sdote;":0x2a66,
  "seArr;":0x21d8, "searhk;":0x2925,
  "searr;":0x2198, "searrow;":0x2198,
  "sect":0xa7, "sect;":0xa7,
  "semi;":0x3b, "seswar;":0x2929,
  "setminus;":0x2216, "setmn;":0x2216,
  "sext;":0x2736, "sfr;":[0xd835,0xdd30],
  "sfrown;":0x2322, "sharp;":0x266f,
  "shchcy;":0x449, "shcy;":0x448,
  "shortmid;":0x2223, "shortparallel;":0x2225,
  "shy":0xad, "shy;":0xad,
  "sigma;":0x3c3, "sigmaf;":0x3c2,
  "sigmav;":0x3c2, "sim;":0x223c,
  "simdot;":0x2a6a, "sime;":0x2243,
  "simeq;":0x2243, "simg;":0x2a9e,
  "simgE;":0x2aa0, "siml;":0x2a9d,
  "simlE;":0x2a9f, "simne;":0x2246,
  "simplus;":0x2a24, "simrarr;":0x2972,
  "slarr;":0x2190, "smallsetminus;":0x2216,
  "smashp;":0x2a33, "smeparsl;":0x29e4,
  "smid;":0x2223, "smile;":0x2323,
  "smt;":0x2aaa, "smte;":0x2aac,
  "smtes;":[0x2aac,0xfe00], "softcy;":0x44c,
  "sol;":0x2f, "solb;":0x29c4,
  "solbar;":0x233f, "sopf;":[0xd835,0xdd64],
  "spades;":0x2660, "spadesuit;":0x2660,
  "spar;":0x2225, "sqcap;":0x2293,
  "sqcaps;":[0x2293,0xfe00], "sqcup;":0x2294,
  "sqcups;":[0x2294,0xfe00], "sqsub;":0x228f,
  "sqsube;":0x2291, "sqsubset;":0x228f,
  "sqsubseteq;":0x2291, "sqsup;":0x2290,
  "sqsupe;":0x2292, "sqsupset;":0x2290,
  "sqsupseteq;":0x2292, "squ;":0x25a1,
  "square;":0x25a1, "squarf;":0x25aa,
  "squf;":0x25aa, "srarr;":0x2192,
  "sscr;":[0xd835,0xdcc8], "ssetmn;":0x2216,
  "ssmile;":0x2323, "sstarf;":0x22c6,
  "star;":0x2606, "starf;":0x2605,
  "straightepsilon;":0x3f5, "straightphi;":0x3d5,
  "strns;":0xaf, "sub;":0x2282,
  "subE;":0x2ac5, "subdot;":0x2abd,
  "sube;":0x2286, "subedot;":0x2ac3,
  "submult;":0x2ac1, "subnE;":0x2acb,
  "subne;":0x228a, "subplus;":0x2abf,
  "subrarr;":0x2979, "subset;":0x2282,
  "subseteq;":0x2286, "subseteqq;":0x2ac5,
  "subsetneq;":0x228a, "subsetneqq;":0x2acb,
  "subsim;":0x2ac7, "subsub;":0x2ad5,
  "subsup;":0x2ad3, "succ;":0x227b,
  "succapprox;":0x2ab8, "succcurlyeq;":0x227d,
  "succeq;":0x2ab0, "succnapprox;":0x2aba,
  "succneqq;":0x2ab6, "succnsim;":0x22e9,
  "succsim;":0x227f, "sum;":0x2211,
  "sung;":0x266a, "sup1":0xb9,
  "sup1;":0xb9, "sup2":0xb2,
  "sup2;":0xb2, "sup3":0xb3,
  "sup3;":0xb3, "sup;":0x2283,
  "supE;":0x2ac6, "supdot;":0x2abe,
  "supdsub;":0x2ad8, "supe;":0x2287,
  "supedot;":0x2ac4, "suphsol;":0x27c9,
  "suphsub;":0x2ad7, "suplarr;":0x297b,
  "supmult;":0x2ac2, "supnE;":0x2acc,
  "supne;":0x228b, "supplus;":0x2ac0,
  "supset;":0x2283, "supseteq;":0x2287,
  "supseteqq;":0x2ac6, "supsetneq;":0x228b,
  "supsetneqq;":0x2acc, "supsim;":0x2ac8,
  "supsub;":0x2ad4, "supsup;":0x2ad6,
  "swArr;":0x21d9, "swarhk;":0x2926,
  "swarr;":0x2199, "swarrow;":0x2199,
  "swnwar;":0x292a, "szlig":0xdf,
  "szlig;":0xdf, "target;":0x2316,
  "tau;":0x3c4, "tbrk;":0x23b4,
  "tcaron;":0x165, "tcedil;":0x163,
  "tcy;":0x442, "tdot;":0x20db,
  "telrec;":0x2315, "tfr;":[0xd835,0xdd31],
  "there4;":0x2234, "therefore;":0x2234,
  "theta;":0x3b8, "thetasym;":0x3d1,
  "thetav;":0x3d1, "thickapprox;":0x2248,
  "thicksim;":0x223c, "thinsp;":0x2009,
  "thkap;":0x2248, "thksim;":0x223c,
  "thorn":0xfe, "thorn;":0xfe,
  "tilde;":0x2dc, "times":0xd7,
  "times;":0xd7, "timesb;":0x22a0,
  "timesbar;":0x2a31, "timesd;":0x2a30,
  "tint;":0x222d, "toea;":0x2928,
  "top;":0x22a4, "topbot;":0x2336,
  "topcir;":0x2af1, "topf;":[0xd835,0xdd65],
  "topfork;":0x2ada, "tosa;":0x2929,
  "tprime;":0x2034, "trade;":0x2122,
  "triangle;":0x25b5, "triangledown;":0x25bf,
  "triangleleft;":0x25c3, "trianglelefteq;":0x22b4,
  "triangleq;":0x225c, "triangleright;":0x25b9,
  "trianglerighteq;":0x22b5, "tridot;":0x25ec,
  "trie;":0x225c, "triminus;":0x2a3a,
  "triplus;":0x2a39, "trisb;":0x29cd,
  "tritime;":0x2a3b, "trpezium;":0x23e2,
  "tscr;":[0xd835,0xdcc9], "tscy;":0x446,
  "tshcy;":0x45b, "tstrok;":0x167,
  "twixt;":0x226c, "twoheadleftarrow;":0x219e,
  "twoheadrightarrow;":0x21a0, "uArr;":0x21d1,
  "uHar;":0x2963, "uacute":0xfa,
  "uacute;":0xfa, "uarr;":0x2191,
  "ubrcy;":0x45e, "ubreve;":0x16d,
  "ucirc":0xfb, "ucirc;":0xfb,
  "ucy;":0x443, "udarr;":0x21c5,
  "udblac;":0x171, "udhar;":0x296e,
  "ufisht;":0x297e, "ufr;":[0xd835,0xdd32],
  "ugrave":0xf9, "ugrave;":0xf9,
  "uharl;":0x21bf, "uharr;":0x21be,
  "uhblk;":0x2580, "ulcorn;":0x231c,
  "ulcorner;":0x231c, "ulcrop;":0x230f,
  "ultri;":0x25f8, "umacr;":0x16b,
  "uml":0xa8, "uml;":0xa8,
  "uogon;":0x173, "uopf;":[0xd835,0xdd66],
  "uparrow;":0x2191, "updownarrow;":0x2195,
  "upharpoonleft;":0x21bf, "upharpoonright;":0x21be,
  "uplus;":0x228e, "upsi;":0x3c5,
  "upsih;":0x3d2, "upsilon;":0x3c5,
  "upuparrows;":0x21c8, "urcorn;":0x231d,
  "urcorner;":0x231d, "urcrop;":0x230e,
  "uring;":0x16f, "urtri;":0x25f9,
  "uscr;":[0xd835,0xdcca], "utdot;":0x22f0,
  "utilde;":0x169, "utri;":0x25b5,
  "utrif;":0x25b4, "uuarr;":0x21c8,
  "uuml":0xfc, "uuml;":0xfc,
  "uwangle;":0x29a7, "vArr;":0x21d5,
  "vBar;":0x2ae8, "vBarv;":0x2ae9,
  "vDash;":0x22a8, "vangrt;":0x299c,
  "varepsilon;":0x3f5, "varkappa;":0x3f0,
  "varnothing;":0x2205, "varphi;":0x3d5,
  "varpi;":0x3d6, "varpropto;":0x221d,
  "varr;":0x2195, "varrho;":0x3f1,
  "varsigma;":0x3c2, "varsubsetneq;":[0x228a,0xfe00],
  "varsubsetneqq;":[0x2acb,0xfe00], "varsupsetneq;":[0x228b,0xfe00],
  "varsupsetneqq;":[0x2acc,0xfe00], "vartheta;":0x3d1,
  "vartriangleleft;":0x22b2, "vartriangleright;":0x22b3,
  "vcy;":0x432, "vdash;":0x22a2,
  "vee;":0x2228, "veebar;":0x22bb,
  "veeeq;":0x225a, "vellip;":0x22ee,
  "verbar;":0x7c, "vert;":0x7c,
  "vfr;":[0xd835,0xdd33], "vltri;":0x22b2,
  "vnsub;":[0x2282,0x20d2], "vnsup;":[0x2283,0x20d2],
  "vopf;":[0xd835,0xdd67], "vprop;":0x221d,
  "vrtri;":0x22b3, "vscr;":[0xd835,0xdccb],
  "vsubnE;":[0x2acb,0xfe00], "vsubne;":[0x228a,0xfe00],
  "vsupnE;":[0x2acc,0xfe00], "vsupne;":[0x228b,0xfe00],
  "vzigzag;":0x299a, "wcirc;":0x175,
  "wedbar;":0x2a5f, "wedge;":0x2227,
  "wedgeq;":0x2259, "weierp;":0x2118,
  "wfr;":[0xd835,0xdd34], "wopf;":[0xd835,0xdd68],
  "wp;":0x2118, "wr;":0x2240,
  "wreath;":0x2240, "wscr;":[0xd835,0xdccc],
  "xcap;":0x22c2, "xcirc;":0x25ef,
  "xcup;":0x22c3, "xdtri;":0x25bd,
  "xfr;":[0xd835,0xdd35], "xhArr;":0x27fa,
  "xharr;":0x27f7, "xi;":0x3be,
  "xlArr;":0x27f8, "xlarr;":0x27f5,
  "xmap;":0x27fc, "xnis;":0x22fb,
  "xodot;":0x2a00, "xopf;":[0xd835,0xdd69],
  "xoplus;":0x2a01, "xotime;":0x2a02,
  "xrArr;":0x27f9, "xrarr;":0x27f6,
  "xscr;":[0xd835,0xdccd], "xsqcup;":0x2a06,
  "xuplus;":0x2a04, "xutri;":0x25b3,
  "xvee;":0x22c1, "xwedge;":0x22c0,
  "yacute":0xfd, "yacute;":0xfd,
  "yacy;":0x44f, "ycirc;":0x177,
  "ycy;":0x44b, "yen":0xa5,
  "yen;":0xa5, "yfr;":[0xd835,0xdd36],
  "yicy;":0x457, "yopf;":[0xd835,0xdd6a],
  "yscr;":[0xd835,0xdcce], "yucy;":0x44e,
  "yuml":0xff, "yuml;":0xff,
  "zacute;":0x17a, "zcaron;":0x17e,
  "zcy;":0x437, "zdot;":0x17c,
  "zeetrf;":0x2128, "zeta;":0x3b6,
  "zfr;":[0xd835,0xdd37], "zhcy;":0x436,
  "zigrarr;":0x21dd, "zopf;":[0xd835,0xdd6b],
  "zscr;":[0xd835,0xdccf], "zwj;":0x200d,
  "zwnj;":0x200c,
};
/*
 * This regexp is generated with test/tools/update-entities.js
 * It will always match at least one character -- but note that there
 * are no entities whose names are a single character long.
 */
var NAMEDCHARREF = /(A(?:Elig;?|MP;?|acute;?|breve;|c(?:irc;?|y;)|fr;|grave;?|lpha;|macr;|nd;|o(?:gon;|pf;)|pplyFunction;|ring;?|s(?:cr;|sign;)|tilde;?|uml;?)|B(?:a(?:ckslash;|r(?:v;|wed;))|cy;|e(?:cause;|rnoullis;|ta;)|fr;|opf;|reve;|scr;|umpeq;)|C(?:Hcy;|OPY;?|a(?:cute;|p(?:;|italDifferentialD;)|yleys;)|c(?:aron;|edil;?|irc;|onint;)|dot;|e(?:dilla;|nterDot;)|fr;|hi;|ircle(?:Dot;|Minus;|Plus;|Times;)|lo(?:ckwiseContourIntegral;|seCurly(?:DoubleQuote;|Quote;))|o(?:lon(?:;|e;)|n(?:gruent;|int;|tourIntegral;)|p(?:f;|roduct;)|unterClockwiseContourIntegral;)|ross;|scr;|up(?:;|Cap;))|D(?:D(?:;|otrahd;)|Jcy;|Scy;|Zcy;|a(?:gger;|rr;|shv;)|c(?:aron;|y;)|el(?:;|ta;)|fr;|i(?:a(?:critical(?:Acute;|Do(?:t;|ubleAcute;)|Grave;|Tilde;)|mond;)|fferentialD;)|o(?:pf;|t(?:;|Dot;|Equal;)|uble(?:ContourIntegral;|Do(?:t;|wnArrow;)|L(?:eft(?:Arrow;|RightArrow;|Tee;)|ong(?:Left(?:Arrow;|RightArrow;)|RightArrow;))|Right(?:Arrow;|Tee;)|Up(?:Arrow;|DownArrow;)|VerticalBar;)|wn(?:Arrow(?:;|Bar;|UpArrow;)|Breve;|Left(?:RightVector;|TeeVector;|Vector(?:;|Bar;))|Right(?:TeeVector;|Vector(?:;|Bar;))|Tee(?:;|Arrow;)|arrow;))|s(?:cr;|trok;))|E(?:NG;|TH;?|acute;?|c(?:aron;|irc;?|y;)|dot;|fr;|grave;?|lement;|m(?:acr;|pty(?:SmallSquare;|VerySmallSquare;))|o(?:gon;|pf;)|psilon;|qu(?:al(?:;|Tilde;)|ilibrium;)|s(?:cr;|im;)|ta;|uml;?|x(?:ists;|ponentialE;))|F(?:cy;|fr;|illed(?:SmallSquare;|VerySmallSquare;)|o(?:pf;|rAll;|uriertrf;)|scr;)|G(?:Jcy;|T;?|amma(?:;|d;)|breve;|c(?:edil;|irc;|y;)|dot;|fr;|g;|opf;|reater(?:Equal(?:;|Less;)|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|scr;|t;)|H(?:ARDcy;|a(?:cek;|t;)|circ;|fr;|ilbertSpace;|o(?:pf;|rizontalLine;)|s(?:cr;|trok;)|ump(?:DownHump;|Equal;))|I(?:Ecy;|Jlig;|Ocy;|acute;?|c(?:irc;?|y;)|dot;|fr;|grave;?|m(?:;|a(?:cr;|ginaryI;)|plies;)|n(?:t(?:;|e(?:gral;|rsection;))|visible(?:Comma;|Times;))|o(?:gon;|pf;|ta;)|scr;|tilde;|u(?:kcy;|ml;?))|J(?:c(?:irc;|y;)|fr;|opf;|s(?:cr;|ercy;)|ukcy;)|K(?:Hcy;|Jcy;|appa;|c(?:edil;|y;)|fr;|opf;|scr;)|L(?:Jcy;|T;?|a(?:cute;|mbda;|ng;|placetrf;|rr;)|c(?:aron;|edil;|y;)|e(?:ft(?:A(?:ngleBracket;|rrow(?:;|Bar;|RightArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|Right(?:Arrow;|Vector;)|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;|rightarrow;)|ss(?:EqualGreater;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;))|fr;|l(?:;|eftarrow;)|midot;|o(?:ng(?:Left(?:Arrow;|RightArrow;)|RightArrow;|left(?:arrow;|rightarrow;)|rightarrow;)|pf;|wer(?:LeftArrow;|RightArrow;))|s(?:cr;|h;|trok;)|t;)|M(?:ap;|cy;|e(?:diumSpace;|llintrf;)|fr;|inusPlus;|opf;|scr;|u;)|N(?:Jcy;|acute;|c(?:aron;|edil;|y;)|e(?:gative(?:MediumSpace;|Thi(?:ckSpace;|nSpace;)|VeryThinSpace;)|sted(?:GreaterGreater;|LessLess;)|wLine;)|fr;|o(?:Break;|nBreakingSpace;|pf;|t(?:;|C(?:ongruent;|upCap;)|DoubleVerticalBar;|E(?:lement;|qual(?:;|Tilde;)|xists;)|Greater(?:;|Equal;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|Hump(?:DownHump;|Equal;)|Le(?:ftTriangle(?:;|Bar;|Equal;)|ss(?:;|Equal;|Greater;|Less;|SlantEqual;|Tilde;))|Nested(?:GreaterGreater;|LessLess;)|Precedes(?:;|Equal;|SlantEqual;)|R(?:everseElement;|ightTriangle(?:;|Bar;|Equal;))|S(?:quareSu(?:bset(?:;|Equal;)|perset(?:;|Equal;))|u(?:bset(?:;|Equal;)|cceeds(?:;|Equal;|SlantEqual;|Tilde;)|perset(?:;|Equal;)))|Tilde(?:;|Equal;|FullEqual;|Tilde;)|VerticalBar;))|scr;|tilde;?|u;)|O(?:Elig;|acute;?|c(?:irc;?|y;)|dblac;|fr;|grave;?|m(?:acr;|ega;|icron;)|opf;|penCurly(?:DoubleQuote;|Quote;)|r;|s(?:cr;|lash;?)|ti(?:lde;?|mes;)|uml;?|ver(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;))|P(?:artialD;|cy;|fr;|hi;|i;|lusMinus;|o(?:incareplane;|pf;)|r(?:;|ecedes(?:;|Equal;|SlantEqual;|Tilde;)|ime;|o(?:duct;|portion(?:;|al;)))|s(?:cr;|i;))|Q(?:UOT;?|fr;|opf;|scr;)|R(?:Barr;|EG;?|a(?:cute;|ng;|rr(?:;|tl;))|c(?:aron;|edil;|y;)|e(?:;|verse(?:E(?:lement;|quilibrium;)|UpEquilibrium;))|fr;|ho;|ight(?:A(?:ngleBracket;|rrow(?:;|Bar;|LeftArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;)|o(?:pf;|undImplies;)|rightarrow;|s(?:cr;|h;)|uleDelayed;)|S(?:H(?:CHcy;|cy;)|OFTcy;|acute;|c(?:;|aron;|edil;|irc;|y;)|fr;|hort(?:DownArrow;|LeftArrow;|RightArrow;|UpArrow;)|igma;|mallCircle;|opf;|q(?:rt;|uare(?:;|Intersection;|Su(?:bset(?:;|Equal;)|perset(?:;|Equal;))|Union;))|scr;|tar;|u(?:b(?:;|set(?:;|Equal;))|c(?:ceeds(?:;|Equal;|SlantEqual;|Tilde;)|hThat;)|m;|p(?:;|erset(?:;|Equal;)|set;)))|T(?:HORN;?|RADE;|S(?:Hcy;|cy;)|a(?:b;|u;)|c(?:aron;|edil;|y;)|fr;|h(?:e(?:refore;|ta;)|i(?:ckSpace;|nSpace;))|ilde(?:;|Equal;|FullEqual;|Tilde;)|opf;|ripleDot;|s(?:cr;|trok;))|U(?:a(?:cute;?|rr(?:;|ocir;))|br(?:cy;|eve;)|c(?:irc;?|y;)|dblac;|fr;|grave;?|macr;|n(?:der(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;)|ion(?:;|Plus;))|o(?:gon;|pf;)|p(?:Arrow(?:;|Bar;|DownArrow;)|DownArrow;|Equilibrium;|Tee(?:;|Arrow;)|arrow;|downarrow;|per(?:LeftArrow;|RightArrow;)|si(?:;|lon;))|ring;|scr;|tilde;|uml;?)|V(?:Dash;|bar;|cy;|dash(?:;|l;)|e(?:e;|r(?:bar;|t(?:;|ical(?:Bar;|Line;|Separator;|Tilde;))|yThinSpace;))|fr;|opf;|scr;|vdash;)|W(?:circ;|edge;|fr;|opf;|scr;)|X(?:fr;|i;|opf;|scr;)|Y(?:Acy;|Icy;|Ucy;|acute;?|c(?:irc;|y;)|fr;|opf;|scr;|uml;)|Z(?:Hcy;|acute;|c(?:aron;|y;)|dot;|e(?:roWidthSpace;|ta;)|fr;|opf;|scr;)|a(?:acute;?|breve;|c(?:;|E;|d;|irc;?|ute;?|y;)|elig;?|f(?:;|r;)|grave;?|l(?:e(?:fsym;|ph;)|pha;)|m(?:a(?:cr;|lg;)|p;?)|n(?:d(?:;|and;|d;|slope;|v;)|g(?:;|e;|le;|msd(?:;|a(?:a;|b;|c;|d;|e;|f;|g;|h;))|rt(?:;|vb(?:;|d;))|s(?:ph;|t;)|zarr;))|o(?:gon;|pf;)|p(?:;|E;|acir;|e;|id;|os;|prox(?:;|eq;))|ring;?|s(?:cr;|t;|ymp(?:;|eq;))|tilde;?|uml;?|w(?:conint;|int;))|b(?:Not;|a(?:ck(?:cong;|epsilon;|prime;|sim(?:;|eq;))|r(?:vee;|wed(?:;|ge;)))|brk(?:;|tbrk;)|c(?:ong;|y;)|dquo;|e(?:caus(?:;|e;)|mptyv;|psi;|rnou;|t(?:a;|h;|ween;))|fr;|ig(?:c(?:ap;|irc;|up;)|o(?:dot;|plus;|times;)|s(?:qcup;|tar;)|triangle(?:down;|up;)|uplus;|vee;|wedge;)|karow;|l(?:a(?:ck(?:lozenge;|square;|triangle(?:;|down;|left;|right;))|nk;)|k(?:1(?:2;|4;)|34;)|ock;)|n(?:e(?:;|quiv;)|ot;)|o(?:pf;|t(?:;|tom;)|wtie;|x(?:D(?:L;|R;|l;|r;)|H(?:;|D;|U;|d;|u;)|U(?:L;|R;|l;|r;)|V(?:;|H;|L;|R;|h;|l;|r;)|box;|d(?:L;|R;|l;|r;)|h(?:;|D;|U;|d;|u;)|minus;|plus;|times;|u(?:L;|R;|l;|r;)|v(?:;|H;|L;|R;|h;|l;|r;)))|prime;|r(?:eve;|vbar;?)|s(?:cr;|emi;|im(?:;|e;)|ol(?:;|b;|hsub;))|u(?:ll(?:;|et;)|mp(?:;|E;|e(?:;|q;))))|c(?:a(?:cute;|p(?:;|and;|brcup;|c(?:ap;|up;)|dot;|s;)|r(?:et;|on;))|c(?:a(?:ps;|ron;)|edil;?|irc;|ups(?:;|sm;))|dot;|e(?:dil;?|mptyv;|nt(?:;|erdot;|))|fr;|h(?:cy;|eck(?:;|mark;)|i;)|ir(?:;|E;|c(?:;|eq;|le(?:arrow(?:left;|right;)|d(?:R;|S;|ast;|circ;|dash;)))|e;|fnint;|mid;|scir;)|lubs(?:;|uit;)|o(?:lon(?:;|e(?:;|q;))|m(?:ma(?:;|t;)|p(?:;|fn;|le(?:ment;|xes;)))|n(?:g(?:;|dot;)|int;)|p(?:f;|rod;|y(?:;|sr;|)))|r(?:arr;|oss;)|s(?:cr;|u(?:b(?:;|e;)|p(?:;|e;)))|tdot;|u(?:darr(?:l;|r;)|e(?:pr;|sc;)|larr(?:;|p;)|p(?:;|brcap;|c(?:ap;|up;)|dot;|or;|s;)|r(?:arr(?:;|m;)|ly(?:eq(?:prec;|succ;)|vee;|wedge;)|ren;?|vearrow(?:left;|right;))|vee;|wed;)|w(?:conint;|int;)|ylcty;)|d(?:Arr;|Har;|a(?:gger;|leth;|rr;|sh(?:;|v;))|b(?:karow;|lac;)|c(?:aron;|y;)|d(?:;|a(?:gger;|rr;)|otseq;)|e(?:g;?|lta;|mptyv;)|f(?:isht;|r;)|har(?:l;|r;)|i(?:am(?:;|ond(?:;|suit;)|s;)|e;|gamma;|sin;|v(?:;|ide(?:;|ontimes;|)|onx;))|jcy;|lc(?:orn;|rop;)|o(?:llar;|pf;|t(?:;|eq(?:;|dot;)|minus;|plus;|square;)|ublebarwedge;|wn(?:arrow;|downarrows;|harpoon(?:left;|right;)))|r(?:bkarow;|c(?:orn;|rop;))|s(?:c(?:r;|y;)|ol;|trok;)|t(?:dot;|ri(?:;|f;))|u(?:arr;|har;)|wangle;|z(?:cy;|igrarr;))|e(?:D(?:Dot;|ot;)|a(?:cute;?|ster;)|c(?:aron;|ir(?:;|c;?)|olon;|y;)|dot;|e;|f(?:Dot;|r;)|g(?:;|rave;?|s(?:;|dot;))|l(?:;|inters;|l;|s(?:;|dot;))|m(?:acr;|pty(?:;|set;|v;)|sp(?:1(?:3;|4;)|;))|n(?:g;|sp;)|o(?:gon;|pf;)|p(?:ar(?:;|sl;)|lus;|si(?:;|lon;|v;))|q(?:c(?:irc;|olon;)|s(?:im;|lant(?:gtr;|less;))|u(?:als;|est;|iv(?:;|DD;))|vparsl;)|r(?:Dot;|arr;)|s(?:cr;|dot;|im;)|t(?:a;|h;?)|u(?:ml;?|ro;)|x(?:cl;|ist;|p(?:ectation;|onentiale;)))|f(?:allingdotseq;|cy;|emale;|f(?:ilig;|l(?:ig;|lig;)|r;)|ilig;|jlig;|l(?:at;|lig;|tns;)|nof;|o(?:pf;|r(?:all;|k(?:;|v;)))|partint;|r(?:a(?:c(?:1(?:2;?|3;|4;?|5;|6;|8;)|2(?:3;|5;)|3(?:4;?|5;|8;)|45;|5(?:6;|8;)|78;)|sl;)|own;)|scr;)|g(?:E(?:;|l;)|a(?:cute;|mma(?:;|d;)|p;)|breve;|c(?:irc;|y;)|dot;|e(?:;|l;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|l;))|l(?:;|es;)))|fr;|g(?:;|g;)|imel;|jcy;|l(?:;|E;|a;|j;)|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|opf;|rave;|s(?:cr;|im(?:;|e;|l;))|t(?:;|c(?:c;|ir;)|dot;|lPar;|quest;|r(?:a(?:pprox;|rr;)|dot;|eq(?:less;|qless;)|less;|sim;)|)|v(?:ertneqq;|nE;))|h(?:Arr;|a(?:irsp;|lf;|milt;|r(?:dcy;|r(?:;|cir;|w;)))|bar;|circ;|e(?:arts(?:;|uit;)|llip;|rcon;)|fr;|ks(?:earow;|warow;)|o(?:arr;|mtht;|ok(?:leftarrow;|rightarrow;)|pf;|rbar;)|s(?:cr;|lash;|trok;)|y(?:bull;|phen;))|i(?:acute;?|c(?:;|irc;?|y;)|e(?:cy;|xcl;?)|f(?:f;|r;)|grave;?|i(?:;|i(?:int;|nt;)|nfin;|ota;)|jlig;|m(?:a(?:cr;|g(?:e;|line;|part;)|th;)|of;|ped;)|n(?:;|care;|fin(?:;|tie;)|odot;|t(?:;|cal;|e(?:gers;|rcal;)|larhk;|prod;))|o(?:cy;|gon;|pf;|ta;)|prod;|quest;?|s(?:cr;|in(?:;|E;|dot;|s(?:;|v;)|v;))|t(?:;|ilde;)|u(?:kcy;|ml;?))|j(?:c(?:irc;|y;)|fr;|math;|opf;|s(?:cr;|ercy;)|ukcy;)|k(?:appa(?:;|v;)|c(?:edil;|y;)|fr;|green;|hcy;|jcy;|opf;|scr;)|l(?:A(?:arr;|rr;|tail;)|Barr;|E(?:;|g;)|Har;|a(?:cute;|emptyv;|gran;|mbda;|ng(?:;|d;|le;)|p;|quo;?|rr(?:;|b(?:;|fs;)|fs;|hk;|lp;|pl;|sim;|tl;)|t(?:;|ail;|e(?:;|s;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|quo(?:;|r;)|r(?:dhar;|ushar;)|sh;)|e(?:;|ft(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|leftarrows;|right(?:arrow(?:;|s;)|harpoons;|squigarrow;)|threetimes;)|g;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|r;))|g(?:;|es;)|s(?:approx;|dot;|eq(?:gtr;|qgtr;)|gtr;|sim;)))|f(?:isht;|loor;|r;)|g(?:;|E;)|h(?:ar(?:d;|u(?:;|l;))|blk;)|jcy;|l(?:;|arr;|corner;|hard;|tri;)|m(?:idot;|oust(?:;|ache;))|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|o(?:a(?:ng;|rr;)|brk;|ng(?:left(?:arrow;|rightarrow;)|mapsto;|rightarrow;)|oparrow(?:left;|right;)|p(?:ar;|f;|lus;)|times;|w(?:ast;|bar;)|z(?:;|enge;|f;))|par(?:;|lt;)|r(?:arr;|corner;|har(?:;|d;)|m;|tri;)|s(?:aquo;|cr;|h;|im(?:;|e;|g;)|q(?:b;|uo(?:;|r;))|trok;)|t(?:;|c(?:c;|ir;)|dot;|hree;|imes;|larr;|quest;|r(?:Par;|i(?:;|e;|f;))|)|ur(?:dshar;|uhar;)|v(?:ertneqq;|nE;))|m(?:DDot;|a(?:cr;?|l(?:e;|t(?:;|ese;))|p(?:;|sto(?:;|down;|left;|up;))|rker;)|c(?:omma;|y;)|dash;|easuredangle;|fr;|ho;|i(?:cro;?|d(?:;|ast;|cir;|dot;?)|nus(?:;|b;|d(?:;|u;)))|l(?:cp;|dr;)|nplus;|o(?:dels;|pf;)|p;|s(?:cr;|tpos;)|u(?:;|ltimap;|map;))|n(?:G(?:g;|t(?:;|v;))|L(?:eft(?:arrow;|rightarrow;)|l;|t(?:;|v;))|Rightarrow;|V(?:Dash;|dash;)|a(?:bla;|cute;|ng;|p(?:;|E;|id;|os;|prox;)|tur(?:;|al(?:;|s;)))|b(?:sp;?|ump(?:;|e;))|c(?:a(?:p;|ron;)|edil;|ong(?:;|dot;)|up;|y;)|dash;|e(?:;|Arr;|ar(?:hk;|r(?:;|ow;))|dot;|quiv;|s(?:ear;|im;)|xist(?:;|s;))|fr;|g(?:E;|e(?:;|q(?:;|q;|slant;)|s;)|sim;|t(?:;|r;))|h(?:Arr;|arr;|par;)|i(?:;|s(?:;|d;)|v;)|jcy;|l(?:Arr;|E;|arr;|dr;|e(?:;|ft(?:arrow;|rightarrow;)|q(?:;|q;|slant;)|s(?:;|s;))|sim;|t(?:;|ri(?:;|e;)))|mid;|o(?:pf;|t(?:;|in(?:;|E;|dot;|v(?:a;|b;|c;))|ni(?:;|v(?:a;|b;|c;))|))|p(?:ar(?:;|allel;|sl;|t;)|olint;|r(?:;|cue;|e(?:;|c(?:;|eq;))))|r(?:Arr;|arr(?:;|c;|w;)|ightarrow;|tri(?:;|e;))|s(?:c(?:;|cue;|e;|r;)|hort(?:mid;|parallel;)|im(?:;|e(?:;|q;))|mid;|par;|qsu(?:be;|pe;)|u(?:b(?:;|E;|e;|set(?:;|eq(?:;|q;)))|cc(?:;|eq;)|p(?:;|E;|e;|set(?:;|eq(?:;|q;)))))|t(?:gl;|ilde;?|lg;|riangle(?:left(?:;|eq;)|right(?:;|eq;)))|u(?:;|m(?:;|ero;|sp;))|v(?:Dash;|Harr;|ap;|dash;|g(?:e;|t;)|infin;|l(?:Arr;|e;|t(?:;|rie;))|r(?:Arr;|trie;)|sim;)|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|near;))|o(?:S;|a(?:cute;?|st;)|c(?:ir(?:;|c;?)|y;)|d(?:ash;|blac;|iv;|ot;|sold;)|elig;|f(?:cir;|r;)|g(?:on;|rave;?|t;)|h(?:bar;|m;)|int;|l(?:arr;|c(?:ir;|ross;)|ine;|t;)|m(?:acr;|ega;|i(?:cron;|d;|nus;))|opf;|p(?:ar;|erp;|lus;)|r(?:;|arr;|d(?:;|er(?:;|of;)|f;?|m;?)|igof;|or;|slope;|v;)|s(?:cr;|lash;?|ol;)|ti(?:lde;?|mes(?:;|as;))|uml;?|vbar;)|p(?:ar(?:;|a(?:;|llel;|)|s(?:im;|l;)|t;)|cy;|er(?:cnt;|iod;|mil;|p;|tenk;)|fr;|h(?:i(?:;|v;)|mmat;|one;)|i(?:;|tchfork;|v;)|l(?:an(?:ck(?:;|h;)|kv;)|us(?:;|acir;|b;|cir;|d(?:o;|u;)|e;|mn;?|sim;|two;))|m;|o(?:intint;|pf;|und;?)|r(?:;|E;|ap;|cue;|e(?:;|c(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;))|ime(?:;|s;)|n(?:E;|ap;|sim;)|o(?:d;|f(?:alar;|line;|surf;)|p(?:;|to;))|sim;|urel;)|s(?:cr;|i;)|uncsp;)|q(?:fr;|int;|opf;|prime;|scr;|u(?:at(?:ernions;|int;)|est(?:;|eq;)|ot;?))|r(?:A(?:arr;|rr;|tail;)|Barr;|Har;|a(?:c(?:e;|ute;)|dic;|emptyv;|ng(?:;|d;|e;|le;)|quo;?|rr(?:;|ap;|b(?:;|fs;)|c;|fs;|hk;|lp;|pl;|sim;|tl;|w;)|t(?:ail;|io(?:;|nals;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|ldhar;|quo(?:;|r;)|sh;)|e(?:al(?:;|ine;|part;|s;)|ct;|g;?)|f(?:isht;|loor;|r;)|h(?:ar(?:d;|u(?:;|l;))|o(?:;|v;))|i(?:ght(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|left(?:arrows;|harpoons;)|rightarrows;|squigarrow;|threetimes;)|ng;|singdotseq;)|l(?:arr;|har;|m;)|moust(?:;|ache;)|nmid;|o(?:a(?:ng;|rr;)|brk;|p(?:ar;|f;|lus;)|times;)|p(?:ar(?:;|gt;)|polint;)|rarr;|s(?:aquo;|cr;|h;|q(?:b;|uo(?:;|r;)))|t(?:hree;|imes;|ri(?:;|e;|f;|ltri;))|uluhar;|x;)|s(?:acute;|bquo;|c(?:;|E;|a(?:p;|ron;)|cue;|e(?:;|dil;)|irc;|n(?:E;|ap;|sim;)|polint;|sim;|y;)|dot(?:;|b;|e;)|e(?:Arr;|ar(?:hk;|r(?:;|ow;))|ct;?|mi;|swar;|tm(?:inus;|n;)|xt;)|fr(?:;|own;)|h(?:arp;|c(?:hcy;|y;)|ort(?:mid;|parallel;)|y;?)|i(?:gma(?:;|f;|v;)|m(?:;|dot;|e(?:;|q;)|g(?:;|E;)|l(?:;|E;)|ne;|plus;|rarr;))|larr;|m(?:a(?:llsetminus;|shp;)|eparsl;|i(?:d;|le;)|t(?:;|e(?:;|s;)))|o(?:ftcy;|l(?:;|b(?:;|ar;))|pf;)|pa(?:des(?:;|uit;)|r;)|q(?:c(?:ap(?:;|s;)|up(?:;|s;))|su(?:b(?:;|e;|set(?:;|eq;))|p(?:;|e;|set(?:;|eq;)))|u(?:;|ar(?:e;|f;)|f;))|rarr;|s(?:cr;|etmn;|mile;|tarf;)|t(?:ar(?:;|f;)|r(?:aight(?:epsilon;|phi;)|ns;))|u(?:b(?:;|E;|dot;|e(?:;|dot;)|mult;|n(?:E;|e;)|plus;|rarr;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;)))|cc(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;)|m;|ng;|p(?:1;?|2;?|3;?|;|E;|d(?:ot;|sub;)|e(?:;|dot;)|hs(?:ol;|ub;)|larr;|mult;|n(?:E;|e;)|plus;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;))))|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|nwar;)|zlig;?)|t(?:a(?:rget;|u;)|brk;|c(?:aron;|edil;|y;)|dot;|elrec;|fr;|h(?:e(?:re(?:4;|fore;)|ta(?:;|sym;|v;))|i(?:ck(?:approx;|sim;)|nsp;)|k(?:ap;|sim;)|orn;?)|i(?:lde;|mes(?:;|b(?:;|ar;)|d;|)|nt;)|o(?:ea;|p(?:;|bot;|cir;|f(?:;|ork;))|sa;)|prime;|r(?:ade;|i(?:angle(?:;|down;|left(?:;|eq;)|q;|right(?:;|eq;))|dot;|e;|minus;|plus;|sb;|time;)|pezium;)|s(?:c(?:r;|y;)|hcy;|trok;)|w(?:ixt;|ohead(?:leftarrow;|rightarrow;)))|u(?:Arr;|Har;|a(?:cute;?|rr;)|br(?:cy;|eve;)|c(?:irc;?|y;)|d(?:arr;|blac;|har;)|f(?:isht;|r;)|grave;?|h(?:ar(?:l;|r;)|blk;)|l(?:c(?:orn(?:;|er;)|rop;)|tri;)|m(?:acr;|l;?)|o(?:gon;|pf;)|p(?:arrow;|downarrow;|harpoon(?:left;|right;)|lus;|si(?:;|h;|lon;)|uparrows;)|r(?:c(?:orn(?:;|er;)|rop;)|ing;|tri;)|scr;|t(?:dot;|ilde;|ri(?:;|f;))|u(?:arr;|ml;?)|wangle;)|v(?:Arr;|Bar(?:;|v;)|Dash;|a(?:ngrt;|r(?:epsilon;|kappa;|nothing;|p(?:hi;|i;|ropto;)|r(?:;|ho;)|s(?:igma;|u(?:bsetneq(?:;|q;)|psetneq(?:;|q;)))|t(?:heta;|riangle(?:left;|right;))))|cy;|dash;|e(?:e(?:;|bar;|eq;)|llip;|r(?:bar;|t;))|fr;|ltri;|nsu(?:b;|p;)|opf;|prop;|rtri;|s(?:cr;|u(?:bn(?:E;|e;)|pn(?:E;|e;)))|zigzag;)|w(?:circ;|e(?:d(?:bar;|ge(?:;|q;))|ierp;)|fr;|opf;|p;|r(?:;|eath;)|scr;)|x(?:c(?:ap;|irc;|up;)|dtri;|fr;|h(?:Arr;|arr;)|i;|l(?:Arr;|arr;)|map;|nis;|o(?:dot;|p(?:f;|lus;)|time;)|r(?:Arr;|arr;)|s(?:cr;|qcup;)|u(?:plus;|tri;)|vee;|wedge;)|y(?:ac(?:ute;?|y;)|c(?:irc;|y;)|en;?|fr;|icy;|opf;|scr;|u(?:cy;|ml;?))|z(?:acute;|c(?:aron;|y;)|dot;|e(?:etrf;|ta;)|fr;|hcy;|igrarr;|opf;|scr;|w(?:j;|nj;)))|[\s\S]/g;

var NAMEDCHARREF_MAXLEN = 32;

// Regular expression constants used by the tokenizer and parser

// Note that \r is included in all of these regexps because it will need
// to be converted to LF by the scanChars() function.
var DBLQUOTEATTRVAL = /[^\r"&\u0000]+/g;
var SINGLEQUOTEATTRVAL = /[^\r'&\u0000]+/g;
var UNQUOTEDATTRVAL = /[^\r\t\n\f &>\u0000]+/g;
var TAGNAME = /[^\r\t\n\f \/>A-Z\u0000]+/g;
var ATTRNAME = /[^\r\t\n\f \/=>A-Z\u0000]+/g;

var CDATATEXT = /[^\]\r\u0000\uffff]*/g;
var DATATEXT = /[^&<\r\u0000\uffff]*/g;
var RAWTEXT = /[^<\r\u0000\uffff]*/g;
var PLAINTEXT = /[^\r\u0000\uffff]*/g;
// Since we don't have the 'sticky tag', add '|.' to the end of SIMPLETAG
// and SIMPLEATTR so that we are guaranteed to always match.  This prevents
// us from scanning past the lastIndex set. (Note that the desired matches
// are always greater than 1 char long, so longest-match will ensure that .
// is not matched unless the desired match fails.)
var SIMPLETAG = /(?:(\/)?([a-z]+)>)|[\s\S]/g;
var SIMPLEATTR = /(?:([-a-z]+)[ \t\n\f]*=[ \t\n\f]*('[^'&\r\u0000]*'|"[^"&\r\u0000]*"|[^\t\n\r\f "&'\u0000>][^&> \t\n\r\f\u0000]*[ \t\n\f]))|[\s\S]/g;

var NONWS = /[^\x09\x0A\x0C\x0D\x20]/;
var ALLNONWS = /[^\x09\x0A\x0C\x0D\x20]/g; // like above, with g flag
var NONWSNONNUL = /[^\x00\x09\x0A\x0C\x0D\x20]/; // don't allow NUL either
var LEADINGWS = /^[\x09\x0A\x0C\x0D\x20]+/;
var NULCHARS = /\x00/g;

/***
 * These are utility functions that don't use any of the parser's
 * internal state.
 */
function buf2str(buf) {
  var CHUNKSIZE=16384;
  if (buf.length < CHUNKSIZE) {
    return String.fromCharCode.apply(String, buf);
  }
  // special case for large strings, to avoid busting the stack.
  var result = '';
  for (var i = 0; i < buf.length; i += CHUNKSIZE) {
    result += String.fromCharCode.apply(String, buf.slice(i, i+CHUNKSIZE));
  }
  return result;
}

function str2buf(s) {
  var result = [];
  for (var i=0; i<s.length; i++) {
    result[i] = s.charCodeAt(i);
  }
  return result;
}

// Determine whether the element is a member of the set.
// The set is an object that maps namespaces to objects. The objects
// then map local tagnames to the value true if that tag is part of the set
function isA(elt, set) {
  if (typeof set === 'string') {
    // convenience case for testing a particular HTML element
    return elt.namespaceURI === NAMESPACE.HTML &&
      elt.localName === set;
  }
  var tagnames = set[elt.namespaceURI];
  return tagnames && tagnames[elt.localName];
}

function isMathmlTextIntegrationPoint(n) {
  return isA(n, mathmlTextIntegrationPointSet);
}

function isHTMLIntegrationPoint(n) {
  if (isA(n, htmlIntegrationPointSet)) return true;
  if (n.namespaceURI === NAMESPACE.MATHML &&
    n.localName === "annotation-xml") {
    var encoding = n.getAttribute("encoding");
    if (encoding) encoding = encoding.toLowerCase();
    if (encoding === "text/html" ||
      encoding === "application/xhtml+xml")
      return true;
  }
  return false;
}

function adjustSVGTagName(name) {
  if (name in svgTagNameAdjustments)
    return svgTagNameAdjustments[name];
  else
    return name;
}

function adjustSVGAttributes(attrs) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] in svgAttrAdjustments) {
      attrs[i][0] = svgAttrAdjustments[attrs[i][0]];
    }
  }
}

function adjustMathMLAttributes(attrs) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] === "definitionurl") {
      attrs[i][0] = "definitionURL";
      break;
    }
  }
}

function adjustForeignAttributes(attrs) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    if (attrs[i][0] in foreignAttributes) {
      // Attributes with namespaces get a 3rd element:
      // [Qname, value, namespace]
      attrs[i].push(foreignAttributes[attrs[i][0]]);
    }
  }
}

// For each attribute in attrs, if elt doesn't have an attribute
// by that name, add the attribute to elt
// XXX: I'm ignoring namespaces for now
function transferAttributes(attrs, elt) {
  for(var i = 0, n = attrs.length; i < n; i++) {
    var name = attrs[i][0], value = attrs[i][1];
    if (elt.hasAttribute(name)) continue;
    elt._setAttribute(name, value);
  }
}

/***
 * The ElementStack class
 */
HTMLParser.ElementStack = function ElementStack() {
  this.elements = [];
  this.top = null; // stack.top is the "current node" in the spec
};

/*
// This is for debugging only
HTMLParser.ElementStack.prototype.toString = function(e) {
  return "STACK: " +
  this.elements.map(function(e) {return e.localName;}).join("-");
}
*/

HTMLParser.ElementStack.prototype.push = function(e) {
  this.elements.push(e);
  this.top = e;
};

HTMLParser.ElementStack.prototype.pop = function(e) {
  this.elements.pop();
  this.top = this.elements[this.elements.length-1];
};

// Pop elements off the stack up to and including the first
// element with the specified (HTML) tagname
HTMLParser.ElementStack.prototype.popTag = function(tag) {
  for(var i = this.elements.length-1; i > 0; i--) {
    var e = this.elements[i];
    if (isA(e, tag)) break;
  }
  this.elements.length = i;
  this.top = this.elements[i-1];
};

// Pop elements off the stack up to and including the first
// element that is an instance of the specified type
HTMLParser.ElementStack.prototype.popElementType = function(type) {
  for(var i = this.elements.length-1; i > 0; i--) {
    if (this.elements[i] instanceof type) break;
  }
  this.elements.length = i;
  this.top = this.elements[i-1];
};

// Pop elements off the stack up to and including the element e.
// Note that this is very different from removeElement()
// This requires that e is on the stack.
HTMLParser.ElementStack.prototype.popElement = function(e) {
  for(var i = this.elements.length-1; i > 0; i--) {
    if (this.elements[i] === e) break;
  }
  this.elements.length = i;
  this.top = this.elements[i-1];
};

// Remove a specific element from the stack.
// Do nothing if the element is not on the stack
HTMLParser.ElementStack.prototype.removeElement = function(e) {
  if (this.top === e) this.pop();
  else {
    var idx = this.elements.lastIndexOf(e);
    if (idx !== -1)
      this.elements.splice(idx, 1);
  }
};

HTMLParser.ElementStack.prototype.clearToContext = function(set) {
  // Note that we don't loop to 0. Never pop the <html> elt off.
  for(var i = this.elements.length-1; i > 0; i--) {
    if (isA(this.elements[i], set)) break;
  }
  this.elements.length = i+1;
  this.top = this.elements[i];
};

HTMLParser.ElementStack.prototype.contains = function(tag) {
  return this.inSpecificScope(tag, Object.create(null));
};

HTMLParser.ElementStack.prototype.inSpecificScope = function(tag, set) {
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (isA(elt, tag)) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

// Like the above, but for a specific element, not a tagname
HTMLParser.ElementStack.prototype.elementInSpecificScope = function(target, set) {
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt === target) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

// Like the above, but for an element interface, not a tagname
HTMLParser.ElementStack.prototype.elementTypeInSpecificScope = function(target, set) {
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt instanceof target) return true;
    if (isA(elt, set)) return false;
  }
  return false;
};

HTMLParser.ElementStack.prototype.inScope = function(tag) {
  return this.inSpecificScope(tag, inScopeSet);
};

HTMLParser.ElementStack.prototype.elementInScope = function(e) {
  return this.elementInSpecificScope(e, inScopeSet);
};

HTMLParser.ElementStack.prototype.elementTypeInScope = function(type) {
  return this.elementTypeInSpecificScope(type, inScopeSet);
};

HTMLParser.ElementStack.prototype.inButtonScope = function(tag) {
  return this.inSpecificScope(tag, inButtonScopeSet);
};

HTMLParser.ElementStack.prototype.inListItemScope = function(tag) {
  return this.inSpecificScope(tag, inListItemScopeSet);
};

HTMLParser.ElementStack.prototype.inTableScope = function(tag) {
  return this.inSpecificScope(tag, inTableScopeSet);
};

HTMLParser.ElementStack.prototype.inSelectScope = function(tag) {
  // Can't implement this one with inSpecificScope, since it involves
  // a set defined by inverting another set. So implement manually.
  for(var i = this.elements.length-1; i >= 0; i--) {
    var elt = this.elements[i];
    if (elt.namespaceURI !== NAMESPACE.HTML) return false;
    var localname = elt.localName;
    if (localname === tag) return true;
    if (localname !== "optgroup" && localname !== "option")
      return false;
  }
  return false;
};

HTMLParser.ElementStack.prototype.generateImpliedEndTags = function(butnot, thorough) {
  var endTagSet = thorough ? thoroughImpliedEndTagsSet : impliedEndTagsSet;
  for(var i = this.elements.length-1; i >= 0; i--) {
    var e = this.elements[i];
    if (butnot && isA(e, butnot)) break;
    if (!isA(this.elements[i], endTagSet)) break;
  }

  this.elements.length = i+1;
  this.top = this.elements[i];
};

/***
 * The ActiveFormattingElements class
 */
HTMLParser.ActiveFormattingElements = function AFE() {
  this.list = []; // elements
  this.attrs = []; // attribute tokens for cloning
};

HTMLParser.ActiveFormattingElements.prototype.MARKER = { localName: "|" };

/*
// For debugging
HTMLParser.ActiveFormattingElements.prototype.toString = function() {
  return "AFE: " +
  this.list.map(function(e) { return e.localName; }).join("-");
}
*/

HTMLParser.ActiveFormattingElements.prototype.insertMarker = function() {
  this.list.push(this.MARKER);
  this.attrs.push(this.MARKER);
};

HTMLParser.ActiveFormattingElements.prototype.push = function(elt, attrs) {
  // Scan backwards: if there are already 3 copies of this element
  // before we encounter a marker, then drop the last one
  var count = 0;
  for(var i = this.list.length-1; i >= 0; i--) {
    if (this.list[i] === this.MARKER) break;
    // equal() is defined below
    if (equal(elt, this.list[i], this.attrs[i])) {
      count++;
      if (count === 3) {
        this.list.splice(i, 1);
        this.attrs.splice(i, 1);
        break;
      }
    }
  }


  // Now push the element onto the list
  this.list.push(elt);

  // Copy the attributes and push those on, too
  var attrcopy = [];
  for(var ii = 0; ii < attrs.length; ii++) {
    attrcopy[ii] = attrs[ii];
  }

  this.attrs.push(attrcopy);

  // This function defines equality of two elements for the purposes
  // of the AFE list.  Note that it compares the new elements
  // attributes to the saved array of attributes associated with
  // the old element because a script could have changed the
  // old element's set of attributes
  function equal(newelt, oldelt, oldattrs) {
    if (newelt.localName !== oldelt.localName) return false;
    if (newelt._numattrs !== oldattrs.length) return false;
    for(var i = 0, n = oldattrs.length; i < n; i++) {
      var oldname = oldattrs[i][0];
      var oldval = oldattrs[i][1];
      if (!newelt.hasAttribute(oldname)) return false;
      if (newelt.getAttribute(oldname) !== oldval) return false;
    }
    return true;
  }
};

HTMLParser.ActiveFormattingElements.prototype.clearToMarker = function() {
  for(var i = this.list.length-1; i >= 0; i--) {
    if (this.list[i] === this.MARKER) break;
  }
  if (i < 0) i = 0;
  this.list.length = i;
  this.attrs.length = i;
};

// Find and return the last element with the specified tag between the
// end of the list and the last marker on the list.
// Used when parsing <a> in_body_mode()
HTMLParser.ActiveFormattingElements.prototype.findElementByTag = function(tag) {
  for(var i = this.list.length-1; i >= 0; i--) {
    var elt = this.list[i];
    if (elt === this.MARKER) break;
    if (elt.localName === tag) return elt;
  }
  return null;
};

HTMLParser.ActiveFormattingElements.prototype.indexOf = function(e) {
  return this.list.lastIndexOf(e);
};

// Find the element e in the list and remove it
// Used when parsing <a> in_body()
HTMLParser.ActiveFormattingElements.prototype.remove = function(e) {
  var idx = this.list.lastIndexOf(e);
  if (idx !== -1) {
    this.list.splice(idx, 1);
    this.attrs.splice(idx, 1);
  }
};

// Find element a in the list and replace it with element b
// XXX: Do I need to handle attributes here?
HTMLParser.ActiveFormattingElements.prototype.replace = function(a, b, attrs) {
  var idx = this.list.lastIndexOf(a);
  if (idx !== -1) {
    this.list[idx] = b;
    this.attrs[idx] = attrs;
  }
};

// Find a in the list and insert b after it
// This is only used for insert a bookmark object, so the
// attrs array doesn't really matter
HTMLParser.ActiveFormattingElements.prototype.insertAfter = function(a,b) {
  var idx = this.list.lastIndexOf(a);
  if (idx !== -1) {
    this.list.splice(idx, 0, b);
    this.attrs.splice(idx, 0, b);
  }
};




/***
 * This is the parser factory function. It is the return value of
 * the outer closure that it is defined within.  Most of the parser
 * implementation details are inside this function.
 */
function HTMLParser(address, fragmentContext, options) {
  /***
   * These are the parser's state variables
   */
  // Scanner state
  var chars = null;
  var numchars = 0; // Length of chars
  var nextchar = 0; // Index of next char
  var input_complete = false; // Becomes true when end() called.
  var scanner_skip_newline = false; // If previous char was CR
  var reentrant_invocations = 0;
  var saved_scanner_state = [];
  var leftovers = "";
  var first_batch = true;
  var paused = 0; // Becomes non-zero while loading scripts


  // Tokenizer state
  var tokenizer = data_state; // Current tokenizer state
  var return_state;
  var character_reference_code;
  var tagnamebuf = "";
  var lasttagname = ""; // holds the target end tag for text states
  var tempbuf = [];
  var attrnamebuf = "";
  var attrvaluebuf = "";
  var commentbuf = [];
  var doctypenamebuf = [];
  var doctypepublicbuf = [];
  var doctypesystembuf = [];
  var attributes = [];
  var is_end_tag = false;

  // Tree builder state
  var parser = initial_mode; // Current insertion mode
  var originalInsertionMode = null; // A saved insertion mode
  var templateInsertionModes = []; // Stack of template insertion modes.
  var stack = new HTMLParser.ElementStack(); // Stack of open elements
  var afe = new HTMLParser.ActiveFormattingElements(); // mis-nested tags
  var fragment = (fragmentContext!==undefined); // For innerHTML, etc.
  var head_element_pointer = null;
  var form_element_pointer = null;
  var scripting_enabled = true;
  if (fragmentContext) {
	scripting_enabled = fragmentContext.ownerDocument._scripting_enabled;
  }
  if (options && options.scripting_enabled === false)
    scripting_enabled = false;
  var frameset_ok = true;
  var force_quirks = false;
  var pending_table_text;
  var text_integration_mode; // XXX a spec bug workaround?

  // A single run of characters, buffered up to be sent to
  // the parser as a single string.
  var textrun = [];
  var textIncludesNUL = false;
  var ignore_linefeed = false;

  /***
   * This is the parser object that will be the return value of this
   * factory function, which is some 5000 lines below.
   * Note that the variable "parser" is the current state of the
   * parser's state machine.  This variable "htmlparser" is the
   * return value and defines the public API of the parser
   */
  var htmlparser = {
    document: function() {
      return doc;
    },

    // Internal function used from HTMLScriptElement to pause the
    // parser while a script is being loaded from the network
    pause: function() {
      // print("pausing parser");
      paused++;
    },

    // Called when a script finishes loading
    resume: function() {
      // print("resuming parser");
      paused--;
      // XXX: added this to force a resumption.
      // Is this the right thing to do?
      this.parse("");
    },

    // Parse the HTML text s.
    // The second argument should be true if there is no more
    // text to be parsed, and should be false or omitted otherwise.
    // The second argument must not be set for recursive invocations
    // from document.write()
    parse: function(s, end) {

      // If we're paused, remember the text to parse, but
      // don't parse it now.
      if (paused > 0) {
        leftovers += s;
        return;
      }


      if (reentrant_invocations === 0) {
        // A normal, top-level invocation
        if (leftovers) {
          s = leftovers + s;
          leftovers = "";
        }

        // Add a special marker character to the end of
        // the buffer.  If the scanner is at the end of
        // the buffer and input_complete is set, then this
        // character will transform into an EOF token.
        // Having an actual character that represents EOF
        // in the character buffer makes lookahead regexp
        // matching work more easily, and this is
        // important for character references.
        if (end) {
          s += "\uFFFF";
          input_complete = true; // Makes scanChars() send EOF
        }

        chars = s;
        numchars = s.length;
        nextchar = 0;

        if (first_batch) {
          // We skip a leading Byte Order Mark (\uFEFF)
          // on first batch of text we're given
          first_batch = false;
          if (chars.charCodeAt(0) === 0xFEFF) nextchar = 1;
        }

        reentrant_invocations++;
        scanChars();
        leftovers = chars.substring(nextchar, numchars);
        reentrant_invocations--;
      }
      else {
        // This is the re-entrant case, which we have to
        // handle a little differently.
        reentrant_invocations++;

        // Save current scanner state
        saved_scanner_state.push(chars, numchars, nextchar);

        // Set new scanner state
        chars = s;
        numchars = s.length;
        nextchar = 0;

        // Now scan as many of these new chars as we can
        scanChars();

        leftovers = chars.substring(nextchar, numchars);

        // restore old scanner state
        nextchar = saved_scanner_state.pop();
        numchars = saved_scanner_state.pop();
        chars = saved_scanner_state.pop();

        // If there were leftover chars from this invocation
        // insert them into the pending invocation's buffer
        // and trim already processed chars at the same time
        if (leftovers) {
          chars = leftovers + chars.substring(nextchar);
          numchars = chars.length;
          nextchar = 0;
          leftovers = "";
        }

        // Decrement the counter
        reentrant_invocations--;
      }
    }
  };


  // This is the document we'll be building up
  var doc = new Document(true, address);

  // The document needs to know about the parser, for document.write().
  // This _parser property will be deleted when we're done parsing.
  doc._parser = htmlparser;

  // XXX I think that any document we use this parser on should support
  // scripts. But I may need to configure that through a parser parameter
  // Only documents with windows ("browsing contexts" to be precise)
  // allow scripting.
  doc._scripting_enabled = scripting_enabled;


  /***
   * The actual code of the HTMLParser() factory function begins here.
   */

  if (fragmentContext) { // for innerHTML parsing
    if (fragmentContext.ownerDocument._quirks)
      doc._quirks = true;
    if (fragmentContext.ownerDocument._limitedQuirks)
      doc._limitedQuirks = true;

    // Set the initial tokenizer state
    if (fragmentContext.namespaceURI === NAMESPACE.HTML) {
      switch(fragmentContext.localName) {
      case "title":
      case "textarea":
        tokenizer = rcdata_state;
        break;
      case "style":
      case "xmp":
      case "iframe":
      case "noembed":
      case "noframes":
      case "script":
      case "plaintext":
        tokenizer = plaintext_state;
        break;
      case "noscript":
        if (scripting_enabled)
          tokenizer = plaintext_state;
      }
    }

    var root = doc.createElement("html");
    doc._appendChild(root);
    stack.push(root);
    if (fragmentContext instanceof impl.HTMLTemplateElement) {
      templateInsertionModes.push(in_template_mode);
    }
    resetInsertionMode();

    for(var e = fragmentContext; e !== null; e = e.parentElement) {
      if (e instanceof impl.HTMLFormElement) {
        form_element_pointer = e;
        break;
      }
    }
  }

  /***
   * Scanner functions
   */
  // Loop through the characters in chars, and pass them one at a time
  // to the tokenizer FSM. Return when no more characters can be processed
  // (This may leave 1 or more characters in the buffer: like a CR
  // waiting to see if the next char is LF, or for states that require
  // lookahead...)
  function scanChars() {
    var codepoint, s, pattern, eof;

    while(nextchar < numchars) {

      // If we just tokenized a </script> tag, then the paused flag
      // may have been set to tell us to stop tokenizing while
      // the script is loading
      if (paused > 0) {
        return;
      }


      switch(typeof tokenizer.lookahead) {
      case 'undefined':
        codepoint = chars.charCodeAt(nextchar++);
        if (scanner_skip_newline) {
          scanner_skip_newline = false;
          if (codepoint === 0x000A) {
            nextchar++;
            continue;
          }
        }
        switch(codepoint) {
        case 0x000D:
          // CR always turns into LF, but if the next character
          // is LF, then that second LF is skipped.
          if (nextchar < numchars) {
            if (chars.charCodeAt(nextchar) === 0x000A)
              nextchar++;
          }
          else {
            // We don't know the next char right now, so we
            // can't check if it is a LF.  So set a flag
            scanner_skip_newline = true;
          }

          // In either case, emit a LF
          tokenizer(0x000A);

          break;
        case 0xFFFF:
          if (input_complete && nextchar === numchars) {
            tokenizer(EOF); // codepoint will be 0xFFFF here
            break;
          }
          /* falls through */
        default:
          tokenizer(codepoint);
          break;
        }
        break;

      case 'number':
        codepoint = chars.charCodeAt(nextchar);

        // The only tokenizer states that require fixed lookahead
        // only consume alphanum characters, so we don't have
        // to worry about CR and LF in this case

        // tokenizer wants n chars of lookahead
        var n = tokenizer.lookahead;
        var needsString = true;
        if (n < 0) {
          needsString = false;
          n = -n;
        }

        if (n < numchars - nextchar) {
          // If we can look ahead that far
          s = needsString ? chars.substring(nextchar, nextchar+n) : null;
          eof = false;
        }
        else { // if we don't have that many characters
          if (input_complete) { // If no more are coming
            // Just return what we have
            s = needsString ? chars.substring(nextchar, numchars) : null;
            eof = true;
            if (codepoint === 0xFFFF && nextchar === numchars-1)
              codepoint = EOF;
          }
          else {
            // Return now and wait for more chars later
            return;
          }
        }
        tokenizer(codepoint, s, eof);
        break;
      case 'string':
        codepoint = chars.charCodeAt(nextchar);

        // tokenizer wants characters up to a matching string
        pattern = tokenizer.lookahead;
        var pos = chars.indexOf(pattern, nextchar);
        if (pos !== -1) {
          s = chars.substring(nextchar, pos + pattern.length);
          eof = false;
        }
        else {  // No match
          // If more characters coming, wait for them
          if (!input_complete) return;

          // Otherwise, we've got to return what we've got
          s = chars.substring(nextchar, numchars);
          if (codepoint === 0xFFFF && nextchar === numchars-1)
            codepoint = EOF;
          eof = true;
        }

        // The tokenizer states that require this kind of
        // lookahead have to be careful to handle CR characters
        // correctly
        tokenizer(codepoint, s, eof);
        break;
      }
    }
  }


  /***
   * Tokenizer utility functions
   */
  function addAttribute(name,value) {
    // Make sure there isn't already an attribute with this name
    // If there is, ignore this one.
    for(var i = 0; i < attributes.length; i++) {
      if (attributes[i][0] === name) return;
    }

    if (value !== undefined) {
      attributes.push([name, value]);
    }
    else {
      attributes.push([name]);
    }
  }

  // Shortcut for simple attributes
  function handleSimpleAttribute() {
    SIMPLEATTR.lastIndex = nextchar-1;
    var matched = SIMPLEATTR.exec(chars);
    if (!matched) throw new Error("should never happen");
    var name = matched[1];
    if (!name) return false;
    var value = matched[2];
    var len = value.length;
    switch(value[0]) {
    case '"':
    case "'":
      value = value.substring(1, len-1);
      nextchar += (matched[0].length-1);
      tokenizer = after_attribute_value_quoted_state;
      break;
    default:
      tokenizer = before_attribute_name_state;
      nextchar += (matched[0].length-1);
      value = value.substring(0, len-1);
      break;
    }

    // Make sure there isn't already an attribute with this name
    // If there is, ignore this one.
    for(var i = 0; i < attributes.length; i++) {
      if (attributes[i][0] === name) return true;
    }

    attributes.push([name, value]);
    return true;
  }

  function beginTagName() {
    is_end_tag = false;
    tagnamebuf = "";
    attributes.length = 0;
  }
  function beginEndTagName() {
    is_end_tag = true;
    tagnamebuf = "";
    attributes.length = 0;
  }

  function beginTempBuf() { tempbuf.length = 0; }
  function beginAttrName() { attrnamebuf = ""; }
  function beginAttrValue() { attrvaluebuf = ""; }
  function beginComment() { commentbuf.length = 0; }
  function beginDoctype() {
    doctypenamebuf.length = 0;
    doctypepublicbuf = null;
    doctypesystembuf = null;
  }
  function beginDoctypePublicId() { doctypepublicbuf = []; }
  function beginDoctypeSystemId() { doctypesystembuf = []; }
  function forcequirks() { force_quirks = true; }
  function cdataAllowed() {
    return stack.top &&
      stack.top.namespaceURI !== "http://www.w3.org/1999/xhtml";
  }

  // Return true if the codepoints in the specified buffer match the
  // characters of lasttagname
  function appropriateEndTag(buf) {
    return lasttagname === buf;
  }

  function flushText() {
    if (textrun.length > 0) {
      var s = buf2str(textrun);
      textrun.length = 0;

      if (ignore_linefeed) {
        ignore_linefeed = false;
        if (s[0] === "\n") s = s.substring(1);
        if (s.length === 0) return;
      }

      insertToken(TEXT, s);
      textIncludesNUL = false;
    }
    ignore_linefeed = false;
  }

  // Consume chars matched by the pattern and return them as a string. Starts
  // matching at the current position, so users should drop the current char
  // otherwise.
  function getMatchingChars(pattern) {
    pattern.lastIndex = nextchar - 1;
    var match = pattern.exec(chars);
    if (match && match.index === nextchar - 1) {
      match = match[0];
      nextchar += match.length - 1;
      /* Careful!  Make sure we haven't matched the EOF character! */
      if (input_complete && nextchar === numchars) {
        // Oops, backup one.
        match = match.slice(0, -1);
        nextchar--;
      }
      return match;
    } else {
      throw new Error("should never happen");
    }
  }

  // emit a string of chars that match a regexp
  // Returns false if no chars matched.
  function emitCharsWhile(pattern) {
    pattern.lastIndex = nextchar-1;
    var match = pattern.exec(chars)[0];
    if (!match) return false;
    emitCharString(match);
    nextchar += match.length - 1;
    return true;
  }

  // This is used by CDATA sections
  function emitCharString(s) {
    if (textrun.length > 0) flushText();

    if (ignore_linefeed) {
      ignore_linefeed = false;
      if (s[0] === "\n") s = s.substring(1);
      if (s.length === 0) return;
    }

    insertToken(TEXT, s);
  }

  function emitTag() {
    if (is_end_tag) insertToken(ENDTAG, tagnamebuf);
    else {
      // Remember the last open tag we emitted
      var tagname = tagnamebuf;
      tagnamebuf = "";
      lasttagname = tagname;
      insertToken(TAG, tagname, attributes);
    }
  }


  // A shortcut: look ahead and if this is a open or close tag
  // in lowercase with no spaces and no attributes, just emit it now.
  function emitSimpleTag() {
    SIMPLETAG.lastIndex = nextchar;
    var matched = SIMPLETAG.exec(chars);
    if (!matched) throw new Error("should never happen");
    var tagname = matched[2];
    if (!tagname) return false;
    var endtag = matched[1];
    if (endtag) {
      nextchar += (tagname.length+2);
      insertToken(ENDTAG, tagname);
    }
    else {
      nextchar += (tagname.length+1);
      lasttagname = tagname;
      insertToken(TAG, tagname, NOATTRS);
    }
    return true;
  }

  function emitSelfClosingTag() {
    if (is_end_tag) insertToken(ENDTAG, tagnamebuf, null, true);
    else {
      insertToken(TAG, tagnamebuf, attributes, true);
    }
  }

  function emitDoctype() {
    insertToken(DOCTYPE,
          buf2str(doctypenamebuf),
          doctypepublicbuf ? buf2str(doctypepublicbuf) : undefined,
          doctypesystembuf ? buf2str(doctypesystembuf) : undefined);
  }

  function emitEOF() {
    flushText();
    parser(EOF); // EOF never goes to insertForeignContent()
    doc.modclock = 1; // Start tracking modifications
  }

  // Insert a token, either using the current parser insertion mode
  // (for HTML stuff) or using the insertForeignToken() method.
  var insertToken = htmlparser.insertToken = function insertToken(t, value, arg3, arg4) {
    flushText();
    var current = stack.top;

    if (!current || current.namespaceURI === NAMESPACE.HTML) {
      // This is the common case
      parser(t, value, arg3, arg4);
    }
    else {
      // Otherwise we may need to insert this token as foreign content
      if (t !== TAG && t !== TEXT) {
        insertForeignToken(t, value, arg3, arg4);
      }
      else {
        // But in some cases we treat it as regular content
        if ((isMathmlTextIntegrationPoint(current) &&
           (t === TEXT ||
            (t === TAG &&
             value !== "mglyph" && value !== "malignmark"))) ||
          (t === TAG &&
           value === "svg" &&
           current.namespaceURI === NAMESPACE.MATHML &&
           current.localName === "annotation-xml") ||
          isHTMLIntegrationPoint(current)) {

          // XXX: the text_integration_mode stuff is an
          // attempted bug workaround of mine
          text_integration_mode = true;
          parser(t, value, arg3, arg4);
          text_integration_mode = false;
        }
        // Otherwise it is foreign content
        else {
          insertForeignToken(t, value, arg3, arg4);
        }
      }
    }
  };


  /***
   * Tree building utility functions
   */
  function insertComment(data) {
    var parent = stack.top;
    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
      fosterParent(function(doc) { return doc.createComment(data); });
    } else {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      if (parent instanceof impl.HTMLTemplateElement) {
        parent = parent.content;
      }
      parent._appendChild(parent.ownerDocument.createComment(data));
    }
  }

  function insertText(s) {
    var parent = stack.top;
    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
      fosterParent(function(doc) { return doc.createTextNode(s); });
    } else {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      if (parent instanceof impl.HTMLTemplateElement) {
        parent = parent.content;
      }
      // "If there is a Text node immediately before the adjusted insertion
      // location, then append data to that Text node's data."
      var lastChild = parent.lastChild;
      if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
        lastChild.appendData(s);
      } else {
        parent._appendChild(parent.ownerDocument.createTextNode(s));
      }
    }
  }

  function createHTMLElt(doc, name, attrs) {
    // Create the element this way, rather than with
    // doc.createElement because createElement() does error
    // checking on the element name that we need to avoid here.
    var elt = html.createElement(doc, name, null);

    if (attrs) {
      for(var i = 0, n = attrs.length; i < n; i++) {
        // Use the _ version to avoid testing the validity
        // of the attribute name
        elt._setAttribute(attrs[i][0], attrs[i][1]);
      }
    }
    // XXX
    // If the element is a resettable form element,
    // run its reset algorithm now
    // XXX
    // handle case where form-element-pointer is not null
    return elt;
  }

  // The in_table insertion mode turns on this flag, and that makes
  // insertHTMLElement use the foster parenting algorithm for elements
  // tags inside a table
  var foster_parent_mode = false;

  function insertHTMLElement(name, attrs) {
    var elt = insertElement(function(doc) {
      return createHTMLElt(doc, name, attrs);
    });

    // XXX
    // If this is a form element, set its form attribute property here
    if (isA(elt, formassociatedSet)) {
      elt._form = form_element_pointer;
    }

    return elt;
  }

  // Insert the element into the open element or foster parent it
  function insertElement(eltFunc) {
    var elt;
    if (foster_parent_mode && isA(stack.top, tablesectionrowSet)) {
      elt = fosterParent(eltFunc);
    }
    else if (stack.top instanceof impl.HTMLTemplateElement) {
      // "If the adjusted insertion location is inside a template element,
      // let it instead be inside the template element's template contents"
      elt = eltFunc(stack.top.content.ownerDocument);
      stack.top.content._appendChild(elt);
    } else {
      elt = eltFunc(stack.top.ownerDocument);
      stack.top._appendChild(elt);
    }

    stack.push(elt);
    return elt;
  }

  function insertForeignElement(name, attrs, ns) {
    return insertElement(function(doc) {
      var elt = doc.createElementNS(ns, name);
      if (attrs) {
        for(var i = 0, n = attrs.length; i < n; i++) {
          var attr = attrs[i];
          if (attr.length === 2)
            elt._setAttribute(attr[0], attr[1]);
          else {
            elt._setAttributeNS(attr[2], attr[0], attr[1]);
          }
        }
      }
      return elt;
    });
  }

  function lastElementOfType(type) {
    for(var i = stack.elements.length-1; i >= 0; i--) {
      if (stack.elements[i] instanceof type) {
        return i;
      }
    }
    return -1;
  }

  function fosterParent(eltFunc) {
    var parent, before, lastTable = -1, lastTemplate = -1, elt;

    lastTable = lastElementOfType(impl.HTMLTableElement);
    lastTemplate = lastElementOfType(impl.HTMLTemplateElement);

    if (lastTemplate >= 0 && (lastTable < 0 || lastTemplate > lastTable)) {
      parent = stack.elements[lastTemplate];
    } else if (lastTable >= 0) {
      parent = stack.elements[lastTable].parentNode;
      if (parent) {
        before = stack.elements[lastTable];
      } else {
        parent = stack.elements[lastTable - 1];
      }
    }
    if (!parent) parent = stack.elements[0]; // the `html` element.

    // "If the adjusted insertion location is inside a template element,
    // let it instead be inside the template element's template contents"
    if (parent instanceof impl.HTMLTemplateElement) {
      parent = parent.content;
    }
    // Create element in the appropriate document.
    elt = eltFunc(parent.ownerDocument);

    if (elt.nodeType === Node.TEXT_NODE) {
      var prev;
      if (before) prev = before.previousSibling;
      else prev = parent.lastChild;
      if (prev && prev.nodeType === Node.TEXT_NODE) {
        prev.appendData(elt.data);
        return elt;
      }
    }
    if (before)
      parent.insertBefore(elt, before);
    else
      parent._appendChild(elt);
    return elt;
  }


  function resetInsertionMode() {
    var last = false;
    for(var i = stack.elements.length-1; i >= 0; i--) {
      var node = stack.elements[i];
      if (i === 0) {
        last = true;
        if (fragment) {
          node = fragmentContext;
        }
      }
      if (node.namespaceURI === NAMESPACE.HTML) {
        var tag = node.localName;
        switch(tag) {
        case "select":
          for(var j = i; j > 0; ) {
            var ancestor = stack.elements[--j];
            if (ancestor instanceof impl.HTMLTemplateElement) {
              break;
            } else if (ancestor instanceof impl.HTMLTableElement) {
              parser = in_select_in_table_mode;
              return;
            }
          }
          parser = in_select_mode;
          return;
        case "tr":
          parser = in_row_mode;
          return;
        case "tbody":
        case "tfoot":
        case "thead":
          parser = in_table_body_mode;
          return;
        case "caption":
          parser = in_caption_mode;
          return;
        case "colgroup":
          parser = in_column_group_mode;
          return;
        case "table":
          parser = in_table_mode;
          return;
        case "template":
          parser = templateInsertionModes[templateInsertionModes.length-1];
          return;
        case "body":
          parser = in_body_mode;
          return;
        case "frameset":
          parser = in_frameset_mode;
          return;
        case "html":
          if (head_element_pointer === null) {
            parser = before_head_mode;
          } else {
            parser = after_head_mode;
          }
          return;
        default:
          if (!last) {
            if (tag === "head") {
              parser = in_head_mode;
              return;
            }
            if (tag === "td" || tag === "th") {
              parser = in_cell_mode;
              return;
            }
          }
        }
      }
      if (last) {
        parser = in_body_mode;
        return;
      }
    }
  }


  function parseRawText(name, attrs) {
    insertHTMLElement(name, attrs);
    tokenizer = rawtext_state;
    originalInsertionMode = parser;
    parser = text_mode;
  }

  function parseRCDATA(name, attrs) {
    insertHTMLElement(name, attrs);
    tokenizer = rcdata_state;
    originalInsertionMode = parser;
    parser = text_mode;
  }

  // Make a copy of element i on the list of active formatting
  // elements, using its original attributes, not current
  // attributes (which may have been modified by a script)
  function afeclone(doc, i) {
    return {
      elt: createHTMLElt(doc, afe.list[i].localName, afe.attrs[i]),
      attrs: afe.attrs[i],
    };
  }


  function afereconstruct() {
    if (afe.list.length === 0) return;
    var entry = afe.list[afe.list.length-1];
    // If the last is a marker , do nothing
    if (entry === afe.MARKER) return;
    // Or if it is an open element, do nothing
    if (stack.elements.lastIndexOf(entry) !== -1) return;

    // Loop backward through the list until we find a marker or an
    // open element, and then move forward one from there.
    for(var i = afe.list.length-2; i >= 0; i--) {
      entry = afe.list[i];
      if (entry === afe.MARKER) break;
      if (stack.elements.lastIndexOf(entry) !== -1) break;
    }

    // Now loop forward, starting from the element after the current
    // one, recreating formatting elements and pushing them back onto
    // the list of open elements
    for(i = i+1; i < afe.list.length; i++) {
      var newelt = insertElement(function(doc) { return afeclone(doc, i).elt; });
      afe.list[i] = newelt;
    }
  }

  // Used by the adoptionAgency() function
  var BOOKMARK = {localName:"BM"};

  function adoptionAgency(tag) {
    // If the current node is an HTML element whose tag name is subject,
    // and the current node is not in the list of active formatting
    // elements, then pop the current node off the stack of open
    // elements and abort these steps.
    if (isA(stack.top, tag) && afe.indexOf(stack.top) === -1) {
      stack.pop();
      return true; // no more handling required
    }

    // Let outer loop counter be zero.
    var outer = 0;

    // Outer loop: If outer loop counter is greater than or
    // equal to eight, then abort these steps.
    while(outer < 8) {
      // Increment outer loop counter by one.
      outer++;

      // Let the formatting element be the last element in the list
      // of active formatting elements that: is between the end of
      // the list and the last scope marker in the list, if any, or
      // the start of the list otherwise, and has the same tag name
      // as the token.
      var fmtelt = afe.findElementByTag(tag);

      // If there is no such node, then abort these steps and instead
      // act as described in the "any other end tag" entry below.
      if (!fmtelt) {
        return false; // false means handle by the default case
      }

      // Otherwise, if there is such a node, but that node is not in
      // the stack of open elements, then this is a parse error;
      // remove the element from the list, and abort these steps.
      var index = stack.elements.lastIndexOf(fmtelt);
      if (index === -1) {
        afe.remove(fmtelt);
        return true;   // true means no more handling required
      }

      // Otherwise, if there is such a node, and that node is also in
      // the stack of open elements, but the element is not in scope,
      // then this is a parse error; ignore the token, and abort
      // these steps.
      if (!stack.elementInScope(fmtelt)) {
        return true;
      }

      // Let the furthest block be the topmost node in the stack of
      // open elements that is lower in the stack than the formatting
      // element, and is an element in the special category. There
      // might not be one.
      var furthestblock = null, furthestblockindex;
      for(var i = index+1; i < stack.elements.length; i++) {
        if (isA(stack.elements[i], specialSet)) {
          furthestblock = stack.elements[i];
          furthestblockindex = i;
          break;
        }
      }

      // If there is no furthest block, then the UA must skip the
      // subsequent steps and instead just pop all the nodes from the
      // bottom of the stack of open elements, from the current node
      // up to and including the formatting element, and remove the
      // formatting element from the list of active formatting
      // elements.
      if (!furthestblock) {
        stack.popElement(fmtelt);
        afe.remove(fmtelt);
        return true;
      }
      else {
        // Let the common ancestor be the element immediately above
        // the formatting element in the stack of open elements.
        var ancestor = stack.elements[index-1];

        // Let a bookmark note the position of the formatting
        // element in the list of active formatting elements
        // relative to the elements on either side of it in the
        // list.
        afe.insertAfter(fmtelt, BOOKMARK);

        // Let node and last node be the furthest block.
        var node = furthestblock;
        var lastnode = furthestblock;
        var nodeindex = furthestblockindex;
        var nodeafeindex;

        // Let inner loop counter be zero.
        var inner = 0;

        while (true) {

          // Increment inner loop counter by one.
          inner++;

          // Let node be the element immediately above node in
          // the stack of open elements, or if node is no longer
          // in the stack of open elements (e.g. because it got
          // removed by this algorithm), the element that was
          // immediately above node in the stack of open elements
          // before node was removed.
          node = stack.elements[--nodeindex];

          // If node is the formatting element, then go
          // to the next step in the overall algorithm.
          if (node === fmtelt) break;

          // If the inner loop counter is greater than three and node
          // is in the list of active formatting elements, then remove
          // node from the list of active formatting elements.
          nodeafeindex = afe.indexOf(node);
          if (inner > 3 && nodeafeindex !== -1) {
            afe.remove(node);
            nodeafeindex = -1;
          }

          // If node is not in the list of active formatting
          // elements, then remove node from the stack of open
          // elements and then go back to the step labeled inner
          // loop.
          if (nodeafeindex === -1) {
            stack.removeElement(node);
            continue;
          }

          // Create an element for the token for which the
          // element node was created with common ancestor as
          // the intended parent, replace the entry for node
          // in the list of active formatting elements with an
          // entry for the new element, replace the entry for
          // node in the stack of open elements with an entry for
          // the new element, and let node be the new element.
          var newelt = afeclone(ancestor.ownerDocument, nodeafeindex);
          afe.replace(node, newelt.elt, newelt.attrs);
          stack.elements[nodeindex] = newelt.elt;
          node = newelt.elt;

          // If last node is the furthest block, then move the
          // aforementioned bookmark to be immediately after the
          // new node in the list of active formatting elements.
          if (lastnode === furthestblock) {
            afe.remove(BOOKMARK);
            afe.insertAfter(newelt.elt, BOOKMARK);
          }

          // Insert last node into node, first removing it from
          // its previous parent node if any.
          node._appendChild(lastnode);

          // Let last node be node.
          lastnode = node;
        }

        // If the common ancestor node is a table, tbody, tfoot,
        // thead, or tr element, then, foster parent whatever last
        // node ended up being in the previous step, first removing
        // it from its previous parent node if any.
        if (foster_parent_mode && isA(ancestor, tablesectionrowSet)) {
          fosterParent(function() { return lastnode; });
        }
        // Otherwise, append whatever last node ended up being in
        // the previous step to the common ancestor node, first
        // removing it from its previous parent node if any.
        else if (ancestor instanceof impl.HTMLTemplateElement) {
          ancestor.content._appendChild(lastnode);
        } else {
          ancestor._appendChild(lastnode);
        }

        // Create an element for the token for which the
        // formatting element was created, with furthest block
        // as the intended parent.
        var newelt2 = afeclone(furthestblock.ownerDocument, afe.indexOf(fmtelt));

        // Take all of the child nodes of the furthest block and
        // append them to the element created in the last step.
        while(furthestblock.hasChildNodes()) {
          newelt2.elt._appendChild(furthestblock.firstChild);
        }

        // Append that new element to the furthest block.
        furthestblock._appendChild(newelt2.elt);

        // Remove the formatting element from the list of active
        // formatting elements, and insert the new element into the
        // list of active formatting elements at the position of
        // the aforementioned bookmark.
        afe.remove(fmtelt);
        afe.replace(BOOKMARK, newelt2.elt, newelt2.attrs);

        // Remove the formatting element from the stack of open
        // elements, and insert the new element into the stack of
        // open elements immediately below the position of the
        // furthest block in that stack.
        stack.removeElement(fmtelt);
        var pos = stack.elements.lastIndexOf(furthestblock);
        stack.elements.splice(pos+1, 0, newelt2.elt);
      }
    }

    return true;
  }

  // We do this when we get /script in in_text_mode
  function handleScriptEnd() {
    // XXX:
    // This is just a stub implementation right now and doesn't run scripts.
    // Getting this method right involves the event loop, URL resolution
    // script fetching etc. For now I just want to be able to parse
    // documents and test the parser.

    //var script = stack.top;
    stack.pop();
    parser = originalInsertionMode;
    //script._prepare();
    return;

    // XXX: here is what this method is supposed to do

    // Provide a stable state.

    // Let script be the current node (which will be a script
    // element).

    // Pop the current node off the stack of open elements.

    // Switch the insertion mode to the original insertion mode.

    // Let the old insertion point have the same value as the current
    // insertion point. Let the insertion point be just before the
    // next input character.

    // Increment the parser's script nesting level by one.

    // Prepare the script. This might cause some script to execute,
    // which might cause new characters to be inserted into the
    // tokenizer, and might cause the tokenizer to output more tokens,
    // resulting in a reentrant invocation of the parser.

    // Decrement the parser's script nesting level by one. If the
    // parser's script nesting level is zero, then set the parser
    // pause flag to false.

    // Let the insertion point have the value of the old insertion
    // point. (In other words, restore the insertion point to its
    // previous value. This value might be the "undefined" value.)

    // At this stage, if there is a pending parsing-blocking script,
    // then:

    // If the script nesting level is not zero:

    //   Set the parser pause flag to true, and abort the processing
    //   of any nested invocations of the tokenizer, yielding
    //   control back to the caller. (Tokenization will resume when
    //   the caller returns to the "outer" tree construction stage.)

    //   The tree construction stage of this particular parser is
    //   being called reentrantly, say from a call to
    //   document.write().

    // Otherwise:

    //     Run these steps:

    //       Let the script be the pending parsing-blocking
    //       script. There is no longer a pending
    //       parsing-blocking script.

    //       Block the tokenizer for this instance of the HTML
    //       parser, such that the event loop will not run tasks
    //       that invoke the tokenizer.

    //       If the parser's Document has a style sheet that is
    //       blocking scripts or the script's "ready to be
    //       parser-executed" flag is not set: spin the event
    //       loop until the parser's Document has no style sheet
    //       that is blocking scripts and the script's "ready to
    //       be parser-executed" flag is set.

    //       Unblock the tokenizer for this instance of the HTML
    //       parser, such that tasks that invoke the tokenizer
    //       can again be run.

    //       Let the insertion point be just before the next
    //       input character.

    //       Increment the parser's script nesting level by one
    //       (it should be zero before this step, so this sets
    //       it to one).

    //       Execute the script.

    //       Decrement the parser's script nesting level by
    //       one. If the parser's script nesting level is zero
    //       (which it always should be at this point), then set
    //       the parser pause flag to false.

    //       Let the insertion point be undefined again.

    //       If there is once again a pending parsing-blocking
    //       script, then repeat these steps from step 1.


  }

  function stopParsing() {
    // XXX This is just a temporary implementation to get the parser working.
    // A full implementation involves scripts and events and the event loop.

    // Remove the link from document to parser.
    // This is instead of "set the insertion point to undefined".
    // It means that document.write() can't write into the doc anymore.
    delete doc._parser;

    stack.elements.length = 0; // pop everything off

    // If there is a window object associated with the document
    // then trigger an load event on it
    if (doc.defaultView) {
      doc.defaultView.dispatchEvent(new impl.Event("load",{}));
    }

  }

  /****
   * Tokenizer states
   */

  /**
   * This file was partially mechanically generated from
   * http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html
   *
   * After mechanical conversion, it was further converted from
   * prose to JS by hand, but the intent is that it is a very
   * faithful rendering of the HTML tokenization spec in
   * JavaScript.
   *
   * It is not a goal of this tokenizer to detect or report
   * parse errors.
   *
   * XXX The tokenizer is supposed to work with straight UTF32
   * codepoints. But I don't think it has any dependencies on
   * any character outside of the BMP so I think it is safe to
   * pass it UTF16 characters. I don't think it will ever change
   * state in the middle of a surrogate pair.
   */

  /*
   * Each state is represented by a function.  For most states, the
   * scanner simply passes the next character (as an integer
   * codepoint) to the current state function and automatically
   * consumes the character.  If the state function can't process
   * the character it can call pushback() to push it back to the
   * scanner.
   *
   * Some states require lookahead, though.  If a state function has
   * a lookahead property, then it is invoked differently.  In this
   * case, the scanner invokes the function with 3 arguments: 1) the
   * next codepoint 2) a string of lookahead text 3) a boolean that
   * is true if the lookahead goes all the way to the EOF. (XXX
   * actually maybe this third is not necessary... the lookahead
   * could just include \uFFFF?)
   *
   * If the lookahead property of a state function is an integer, it
   * specifies the number of characters required. If it is a string,
   * then the scanner will scan for that string and return all
   * characters up to and including that sequence, or up to EOF.  If
   * the lookahead property is a regexp, then the scanner will match
   * the regexp at the current point and return the matching string.
   *
   * States that require lookahead are responsible for explicitly
   * consuming the characters they process. They do this by
   * incrementing nextchar by the number of processed characters.
   */
  function reconsume(c, new_state) {
    tokenizer = new_state;
    nextchar--; // pushback
  }

  function data_state(c) {
    switch(c) {
    case 0x0026: // AMPERSAND
      return_state = data_state;
      tokenizer = character_reference_state;
      break;
    case 0x003C: // LESS-THAN SIGN
      if (emitSimpleTag()) // Shortcut for <p>, <dl>, </div> etc.
        break;
      tokenizer = tag_open_state;
      break;
    case 0x0000: // NULL
      // Usually null characters emitted by the tokenizer will be
      // ignored by the tree builder, but sometimes they'll be
      // converted to \uFFFD.  I don't want to have the search every
      // string emitted to replace NULs, so I'll set a flag
      // if I've emitted a NUL.
      textrun.push(c);
      textIncludesNUL = true;
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      // Instead of just pushing a single character and then
      // coming back to the very same place, lookahead and
      // emit everything we can at once.
      /*jshint -W030 */
      emitCharsWhile(DATATEXT) || textrun.push(c);
      break;
    }
  }

  function rcdata_state(c) {
    // Save the open tag so we can find a matching close tag
    switch(c) {
    case 0x0026: // AMPERSAND
      return_state = rcdata_state;
      tokenizer = character_reference_state;
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = rcdata_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      textIncludesNUL = true;
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      textrun.push(c);
      break;
    }
  }

  function rawtext_state(c) {
    switch(c) {
    case 0x003C: // LESS-THAN SIGN
      tokenizer = rawtext_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      /*jshint -W030 */
      emitCharsWhile(RAWTEXT) || textrun.push(c);
      break;
    }
  }

  function script_data_state(c) {
    switch(c) {
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      /*jshint -W030 */
      emitCharsWhile(RAWTEXT) || textrun.push(c);
      break;
    }
  }

  function plaintext_state(c) {
    switch(c) {
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      /*jshint -W030 */
      emitCharsWhile(PLAINTEXT) || textrun.push(c);
      break;
    }
  }

  function tag_open_state(c) {
    switch(c) {
    case 0x0021: // EXCLAMATION MARK
      tokenizer = markup_declaration_open_state;
      break;
    case 0x002F: // SOLIDUS
      tokenizer = end_tag_open_state;
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginTagName();
      reconsume(c, tag_name_state);
      break;
    case 0x003F: // QUESTION MARK
      reconsume(c, bogus_comment_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, data_state);
      break;
    }
  }

  function end_tag_open_state(c) {
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, tag_name_state);
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      break;
    case -1: // EOF
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      emitEOF();
      break;
    default:
      reconsume(c, bogus_comment_state);
      break;
    }
  }

  function tag_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_attribute_name_state;
      break;
    case 0x002F: // SOLIDUS
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitTag();
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tagnamebuf += String.fromCharCode(c + 0x0020);
      break;
    case 0x0000: // NULL
      tagnamebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tagnamebuf += getMatchingChars(TAGNAME);
      break;
    }
  }

  function rcdata_less_than_sign_state(c) {
    /* identical to the RAWTEXT less-than sign state, except s/RAWTEXT/RCDATA/g */
    if (c === 0x002F) {  // SOLIDUS
      beginTempBuf();
      tokenizer = rcdata_end_tag_open_state;
    }
    else {
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, rcdata_state);
    }
  }

  function rcdata_end_tag_open_state(c) {
    /* identical to the RAWTEXT (and Script data) end tag open state, except s/RAWTEXT/RCDATA/g */
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, rcdata_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, rcdata_state);
      break;
    }
  }

  function rcdata_end_tag_name_state(c) {
    /* identical to the RAWTEXT (and Script data) end tag name state, except s/RAWTEXT/RCDATA/g */
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:

      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:

      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun, tempbuf);
    reconsume(c, rcdata_state);
  }

  function rawtext_less_than_sign_state(c) {
    /* identical to the RCDATA less-than sign state, except s/RCDATA/RAWTEXT/g
     */
    if (c === 0x002F) { // SOLIDUS
      beginTempBuf();
      tokenizer = rawtext_end_tag_open_state;
    }
    else {
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, rawtext_state);
    }
  }

  function rawtext_end_tag_open_state(c) {
    /* identical to the RCDATA (and Script data) end tag open state, except s/RCDATA/RAWTEXT/g */
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, rawtext_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, rawtext_state);
      break;
    }
  }

  function rawtext_end_tag_name_state(c) {
    /* identical to the RCDATA (and Script data) end tag name state, except s/RCDATA/RAWTEXT/g */
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun,tempbuf);
    reconsume(c, rawtext_state);
  }

  function script_data_less_than_sign_state(c) {
    switch(c) {
    case 0x002F: // SOLIDUS
      beginTempBuf();
      tokenizer = script_data_end_tag_open_state;
      break;
    case 0x0021: // EXCLAMATION MARK
      tokenizer = script_data_escape_start_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x0021); // EXCLAMATION MARK
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, script_data_state);
      break;
    }
  }

  function script_data_end_tag_open_state(c) {
    /* identical to the RCDATA (and RAWTEXT) end tag open state, except s/RCDATA/Script data/g */
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, script_data_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, script_data_state);
      break;
    }
  }

  function script_data_end_tag_name_state(c) {
    /* identical to the RCDATA (and RAWTEXT) end tag name state, except s/RCDATA/Script data/g */
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:

      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:

      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // If we don't return in one of the cases above, then this was not
    // an appropriately matching close tag, so back out by emitting all
    // the characters as text
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun,tempbuf);
    reconsume(c, script_data_state);
  }

  function script_data_escape_start_state(c) {
    if (c === 0x002D) { // HYPHEN-MINUS
      tokenizer = script_data_escape_start_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
    }
    else {
      reconsume(c, script_data_state);
    }
  }

  function script_data_escape_start_dash_state(c) {
    if (c === 0x002D) { // HYPHEN-MINUS
      tokenizer = script_data_escaped_dash_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
    }
    else {
      reconsume(c, script_data_state);
    }
  }

  function script_data_escaped_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_escaped_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_escaped_less_than_sign_state;
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      textrun.push(c);
      break;
    }
  }

  function script_data_escaped_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_escaped_dash_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_escaped_less_than_sign_state;
      break;
    case 0x0000: // NULL
      tokenizer = script_data_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_escaped_dash_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_escaped_less_than_sign_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = script_data_state;
      textrun.push(0x003E); // GREATER-THAN SIGN
      break;
    case 0x0000: // NULL
      tokenizer = script_data_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_escaped_less_than_sign_state(c) {
    switch(c) {
    case 0x002F: // SOLIDUS
      beginTempBuf();
      tokenizer = script_data_escaped_end_tag_open_state;
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginTempBuf();
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, script_data_double_escape_start_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      reconsume(c, script_data_escaped_state);
      break;
    }
  }

  function script_data_escaped_end_tag_open_state(c) {
    switch(c) {
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      beginEndTagName();
      reconsume(c, script_data_escaped_end_tag_name_state);
      break;
    default:
      textrun.push(0x003C); // LESS-THAN SIGN
      textrun.push(0x002F); // SOLIDUS
      reconsume(c, script_data_escaped_state);
      break;
    }
  }

  function script_data_escaped_end_tag_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = before_attribute_name_state;
        return;
      }
      break;
    case 0x002F: // SOLIDUS
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = self_closing_start_tag_state;
        return;
      }
      break;
    case 0x003E: // GREATER-THAN SIGN
      if (appropriateEndTag(tagnamebuf)) {
        tokenizer = data_state;
        emitTag();
        return;
      }
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tagnamebuf += String.fromCharCode(c + 0x0020);
      tempbuf.push(c);
      return;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tagnamebuf += String.fromCharCode(c);
      tempbuf.push(c);
      return;
    default:
      break;
    }

    // We get here in the default case, and if the closing tagname
    // is not an appropriate tagname.
    textrun.push(0x003C); // LESS-THAN SIGN
    textrun.push(0x002F); // SOLIDUS
    pushAll(textrun,tempbuf);
    reconsume(c, script_data_escaped_state);
  }

  function script_data_double_escape_start_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
    case 0x002F: // SOLIDUS
    case 0x003E: // GREATER-THAN SIGN
      if (buf2str(tempbuf) === "script") {
        tokenizer = script_data_double_escaped_state;
      }
      else {
        tokenizer = script_data_escaped_state;
      }
      textrun.push(c);
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tempbuf.push(c + 0x0020);
      textrun.push(c);
      break;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tempbuf.push(c);
      textrun.push(c);
      break;
    default:
      reconsume(c, script_data_escaped_state);
      break;
    }
  }

  function script_data_double_escaped_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_double_escaped_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_double_escaped_less_than_sign_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      break;
    case 0x0000: // NULL
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      textrun.push(c);
      break;
    }
  }

  function script_data_double_escaped_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = script_data_double_escaped_dash_dash_state;
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_double_escaped_less_than_sign_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      break;
    case 0x0000: // NULL
      tokenizer = script_data_double_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_double_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_double_escaped_dash_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      textrun.push(0x002D); // HYPHEN-MINUS
      break;
    case 0x003C: // LESS-THAN SIGN
      tokenizer = script_data_double_escaped_less_than_sign_state;
      textrun.push(0x003C); // LESS-THAN SIGN
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = script_data_state;
      textrun.push(0x003E); // GREATER-THAN SIGN
      break;
    case 0x0000: // NULL
      tokenizer = script_data_double_escaped_state;
      textrun.push(0xFFFD); // REPLACEMENT CHARACTER
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      tokenizer = script_data_double_escaped_state;
      textrun.push(c);
      break;
    }
  }

  function script_data_double_escaped_less_than_sign_state(c) {
    if (c === 0x002F) { // SOLIDUS
      beginTempBuf();
      tokenizer = script_data_double_escape_end_state;
      textrun.push(0x002F); // SOLIDUS
    }
    else {
      reconsume(c, script_data_double_escaped_state);
    }
  }

  function script_data_double_escape_end_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
    case 0x002F: // SOLIDUS
    case 0x003E: // GREATER-THAN SIGN
      if (buf2str(tempbuf) === "script") {
        tokenizer = script_data_escaped_state;
      }
      else {
        tokenizer = script_data_double_escaped_state;
      }
      textrun.push(c);
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      tempbuf.push(c + 0x0020);
      textrun.push(c);
      break;
    case 0x0061:  // [a-z]
    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:
    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:
    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:
    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:
    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:
      tempbuf.push(c);
      textrun.push(c);
      break;
    default:
      reconsume(c, script_data_double_escaped_state);
      break;
    }
  }

  function before_attribute_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    // For SOLIDUS, GREATER-THAN SIGN, and EOF, spec says "reconsume in
    // the after attribute name state", but in our implementation that
    // state always has an active attribute in attrnamebuf.  Just clone
    // the rules here, without the addAttribute business.
    case 0x002F: // SOLIDUS
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitTag();
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x003D: // EQUALS SIGN
      beginAttrName();
      attrnamebuf += String.fromCharCode(c);
      tokenizer = attribute_name_state;
      break;
    default:
      if (handleSimpleAttribute()) break;
      beginAttrName();
      reconsume(c, attribute_name_state);
      break;
    }
  }

  // beginAttrName() must have been called before this point
  // There is an active attribute in attrnamebuf (but not attrvaluebuf)
  function attribute_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
    case 0x002F: // SOLIDUS
    case 0x003E: // GREATER-THAN SIGN
    case -1: // EOF
      reconsume(c, after_attribute_name_state);
      break;
    case 0x003D: // EQUALS SIGN
      tokenizer = before_attribute_value_state;
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      attrnamebuf += String.fromCharCode(c + 0x0020);
      break;
    case 0x0000: // NULL
      attrnamebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x0022: // QUOTATION MARK
    case 0x0027: // APOSTROPHE
    case 0x003C: // LESS-THAN SIGN
      /* falls through */
    default:
      attrnamebuf += getMatchingChars(ATTRNAME);
      break;
    }
  }

  // There is an active attribute in attrnamebuf, but not yet in attrvaluebuf.
  function after_attribute_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x002F: // SOLIDUS
      // Keep in sync with before_attribute_name_state.
      addAttribute(attrnamebuf);
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003D: // EQUALS SIGN
      tokenizer = before_attribute_value_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      // Keep in sync with before_attribute_name_state.
      tokenizer = data_state;
      addAttribute(attrnamebuf);
      emitTag();
      break;
    case -1: // EOF
      // Keep in sync with before_attribute_name_state.
      addAttribute(attrnamebuf);
      emitEOF();
      break;
    default:
      addAttribute(attrnamebuf);
      beginAttrName();
      reconsume(c, attribute_name_state);
      break;
    }
  }

  function before_attribute_value_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x0022: // QUOTATION MARK
      beginAttrValue();
      tokenizer = attribute_value_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginAttrValue();
      tokenizer = attribute_value_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      /* falls through */
    default:
      beginAttrValue();
      reconsume(c, attribute_value_unquoted_state);
      break;
    }
  }

  function attribute_value_double_quoted_state(c) {
    switch(c) {
    case 0x0022: // QUOTATION MARK
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = after_attribute_value_quoted_state;
      break;
    case 0x0026: // AMPERSAND
      return_state = attribute_value_double_quoted_state;
      tokenizer = character_reference_state;
      break;
    case 0x0000: // NULL
      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x000A: // LF
      // this could be a converted \r, so don't use getMatchingChars
      attrvaluebuf += String.fromCharCode(c);
      break;
    default:
      attrvaluebuf += getMatchingChars(DBLQUOTEATTRVAL);
      break;
    }
  }

  function attribute_value_single_quoted_state(c) {
    switch(c) {
    case 0x0027: // APOSTROPHE
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = after_attribute_value_quoted_state;
      break;
    case 0x0026: // AMPERSAND
      return_state = attribute_value_single_quoted_state;
      tokenizer = character_reference_state;
      break;
    case 0x0000: // NULL
      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x000A: // LF
      // this could be a converted \r, so don't use getMatchingChars
      attrvaluebuf += String.fromCharCode(c);
      break;
    default:
      attrvaluebuf += getMatchingChars(SINGLEQUOTEATTRVAL);
      break;
    }
  }

  function attribute_value_unquoted_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = before_attribute_name_state;
      break;
    case 0x0026: // AMPERSAND
      return_state = attribute_value_unquoted_state;
      tokenizer = character_reference_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      addAttribute(attrnamebuf, attrvaluebuf);
      tokenizer = data_state;
      emitTag();
      break;
    case 0x0000: // NULL
      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      nextchar--; // pushback
      tokenizer = data_state;
      break;
    case 0x0022: // QUOTATION MARK
    case 0x0027: // APOSTROPHE
    case 0x003C: // LESS-THAN SIGN
    case 0x003D: // EQUALS SIGN
    case 0x0060: // GRAVE ACCENT
      /* falls through */
    default:
      attrvaluebuf += getMatchingChars(UNQUOTEDATTRVAL);
      break;
    }
  }

  function after_attribute_value_quoted_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_attribute_name_state;
      break;
    case 0x002F: // SOLIDUS
      tokenizer = self_closing_start_tag_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitTag();
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      reconsume(c, before_attribute_name_state);
      break;
    }
  }

  function self_closing_start_tag_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
      // Set the <i>self-closing flag</i> of the current tag token.
      tokenizer = data_state;
      emitSelfClosingTag(true);
      break;
    case -1: // EOF
      emitEOF();
      break;
    default:
      reconsume(c, before_attribute_name_state);
      break;
    }
  }

  function bogus_comment_state(c, lookahead, eof) {
    var len = lookahead.length;

    if (eof) {
      nextchar += len-1; // don't consume the eof
    }
    else {
      nextchar += len;
    }

    var comment = lookahead.substring(0, len-1);

    comment = comment.replace(/\u0000/g,"\uFFFD");
    comment = comment.replace(/\u000D\u000A/g,"\u000A");
    comment = comment.replace(/\u000D/g,"\u000A");

    insertToken(COMMENT, comment);
    tokenizer = data_state;
  }
  bogus_comment_state.lookahead = ">";

  function markup_declaration_open_state(c, lookahead, eof) {
    if (lookahead[0] === "-" && lookahead[1] === "-") {
      nextchar += 2;
      beginComment();
      tokenizer = comment_start_state;
      return;
    }

    if (lookahead.toUpperCase() === "DOCTYPE") {
      nextchar += 7;
      tokenizer = doctype_state;
    }
    else if (lookahead === "[CDATA[" && cdataAllowed()) {
      nextchar += 7;
      tokenizer = cdata_section_state;
    }
    else {
      tokenizer = bogus_comment_state;
    }
  }
  markup_declaration_open_state.lookahead = 7;

  function comment_start_state(c) {
    beginComment();
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_start_dash_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break; /* see comment in comment end state */
    default:
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_start_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_end_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(0x002D /* HYPHEN-MINUS */);
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_state(c) {
    switch(c) {
    case 0x003C: // LESS-THAN SIGN
      commentbuf.push(c);
      tokenizer = comment_less_than_sign_state;
      break;
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_end_dash_state;
      break;
    case 0x0000: // NULL
      commentbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(c);
      break;
    }
  }

  function comment_less_than_sign_state(c) {
    switch(c) {
    case 0x0021: // EXCLAMATION MARK
      commentbuf.push(c);
      tokenizer = comment_less_than_sign_bang_state;
      break;
    case 0x003C: // LESS-THAN SIGN
      commentbuf.push(c);
      break;
    default:
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_less_than_sign_bang_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_less_than_sign_bang_dash_state;
      break;
    default:
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_less_than_sign_bang_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_less_than_sign_bang_dash_dash_state;
      break;
    default:
      reconsume(c, comment_end_dash_state);
      break;
    }
  }

  function comment_less_than_sign_bang_dash_dash_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
    case -1: // EOF
      reconsume(c, comment_end_state);
      break;
    default:
      // parse error
      reconsume(c, comment_end_state);
      break;
    }
  }

  function comment_end_dash_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      tokenizer = comment_end_state;
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(0x002D /* HYPHEN-MINUS */);
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_end_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break;
    case 0x0021: // EXCLAMATION MARK
      tokenizer = comment_end_bang_state;
      break;
    case 0x002D: // HYPHEN-MINUS
      commentbuf.push(0x002D);
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* For security reasons: otherwise, hostile user could put a script in a comment e.g. in a blog comment and then DOS the server so that the end tag isn't read, and then the commented script tag would be treated as live code */
    default:
      commentbuf.push(0x002D);
      commentbuf.push(0x002D);
      reconsume(c, comment_state);
      break;
    }
  }

  function comment_end_bang_state(c) {
    switch(c) {
    case 0x002D: // HYPHEN-MINUS
      commentbuf.push(0x002D);
      commentbuf.push(0x002D);
      commentbuf.push(0x0021);
      tokenizer = comment_end_dash_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      insertToken(COMMENT, buf2str(commentbuf));
      break;
    case -1: // EOF
      insertToken(COMMENT, buf2str(commentbuf));
      emitEOF();
      break; /* see comment in comment end state */
    default:
      commentbuf.push(0x002D);
      commentbuf.push(0x002D);
      commentbuf.push(0x0021);
      reconsume(c, comment_state);
      break;
    }
  }

  function doctype_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_doctype_name_state;
      break;
    case -1: // EOF
      beginDoctype();
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      reconsume(c, before_doctype_name_state);
      break;
    }
  }

  function before_doctype_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      beginDoctype();
      doctypenamebuf.push(c + 0x0020);
      tokenizer = doctype_name_state;
      break;
    case 0x0000: // NULL
      beginDoctype();
      doctypenamebuf.push(0xFFFD);
      tokenizer = doctype_name_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      beginDoctype();
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      beginDoctype();
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      beginDoctype();
      doctypenamebuf.push(c);
      tokenizer = doctype_name_state;
      break;
    }
  }

  function doctype_name_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = after_doctype_name_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case 0x0041:  // [A-Z]
    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:
    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:
    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:
    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:
    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:
      doctypenamebuf.push(c + 0x0020);
      break;
    case 0x0000: // NULL
      doctypenamebuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypenamebuf.push(c);
      break;
    }
  }

  function after_doctype_name_state(c, lookahead, eof) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      nextchar += 1;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      nextchar += 1;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      lookahead = lookahead.toUpperCase();
      if (lookahead === "PUBLIC") {
        nextchar += 6;
        tokenizer = after_doctype_public_keyword_state;
      }
      else if (lookahead === "SYSTEM") {
        nextchar += 6;
        tokenizer = after_doctype_system_keyword_state;
      }
      else {
        forcequirks();
        tokenizer = bogus_doctype_state;
      }
      break;
    }
  }
  after_doctype_name_state.lookahead = 6;

  function after_doctype_public_keyword_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_doctype_public_identifier_state;
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function before_doctype_public_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypePublicId();
      tokenizer = doctype_public_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function doctype_public_identifier_double_quoted_state(c) {
    switch(c) {
    case 0x0022: // QUOTATION MARK
      tokenizer = after_doctype_public_identifier_state;
      break;
    case 0x0000: // NULL
      doctypepublicbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypepublicbuf.push(c);
      break;
    }
  }

  function doctype_public_identifier_single_quoted_state(c) {
    switch(c) {
    case 0x0027: // APOSTROPHE
      tokenizer = after_doctype_public_identifier_state;
      break;
    case 0x0000: // NULL
      doctypepublicbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypepublicbuf.push(c);
      break;
    }
  }

  function after_doctype_public_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = between_doctype_public_and_system_identifiers_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function between_doctype_public_and_system_identifiers_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE Ignore the character.
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function after_doctype_system_keyword_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      tokenizer = before_doctype_system_identifier_state;
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function before_doctype_system_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE Ignore the character.
      break;
    case 0x0022: // QUOTATION MARK
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_double_quoted_state;
      break;
    case 0x0027: // APOSTROPHE
      beginDoctypeSystemId();
      tokenizer = doctype_system_identifier_single_quoted_state;
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      forcequirks();
      tokenizer = bogus_doctype_state;
      break;
    }
  }

  function doctype_system_identifier_double_quoted_state(c) {
    switch(c) {
    case 0x0022: // QUOTATION MARK
      tokenizer = after_doctype_system_identifier_state;
      break;
    case 0x0000: // NULL
      doctypesystembuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypesystembuf.push(c);
      break;
    }
  }

  function doctype_system_identifier_single_quoted_state(c) {
    switch(c) {
    case 0x0027: // APOSTROPHE
      tokenizer = after_doctype_system_identifier_state;
      break;
    case 0x0000: // NULL
      doctypesystembuf.push(0xFFFD /* REPLACEMENT CHARACTER */);
      break;
    case 0x003E: // GREATER-THAN SIGN
      forcequirks();
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      doctypesystembuf.push(c);
      break;
    }
  }

  function after_doctype_system_identifier_state(c) {
    switch(c) {
    case 0x0009: // CHARACTER TABULATION (tab)
    case 0x000A: // LINE FEED (LF)
    case 0x000C: // FORM FEED (FF)
    case 0x0020: // SPACE
      /* Ignore the character. */
      break;
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      forcequirks();
      emitDoctype();
      emitEOF();
      break;
    default:
      tokenizer = bogus_doctype_state;
      /* This does *not* set the DOCTYPE token's force-quirks flag. */
      break;
    }
  }

  function bogus_doctype_state(c) {
    switch(c) {
    case 0x003E: // GREATER-THAN SIGN
      tokenizer = data_state;
      emitDoctype();
      break;
    case -1: // EOF
      emitDoctype();
      emitEOF();
      break;
    default:
      /* Ignore the character. */
      break;
    }
  }

  function cdata_section_state(c) {
    switch(c) {
    case 0x005D: // RIGHT SQUARE BRACKET
      tokenizer = cdata_section_bracket_state;
      break;
    case -1: // EOF
      emitEOF();
      break;
    case 0x0000: // NULL
      textIncludesNUL = true;
      /* fall through */
    default:
      // Instead of just pushing a single character and then
      // coming back to the very same place, lookahead and
      // emit everything we can at once.
      /*jshint -W030 */
      emitCharsWhile(CDATATEXT) || textrun.push(c);
      break;
    }
  }

  function cdata_section_bracket_state(c) {
    switch(c) {
    case 0x005D: // RIGHT SQUARE BRACKET
      tokenizer = cdata_section_end_state;
      break;
    default:
      textrun.push(0x005D);
      reconsume(c, cdata_section_state);
      break;
    }
  }

  function cdata_section_end_state(c) {
    switch(c) {
    case 0x005D: // RIGHT SQUARE BRACKET
      textrun.push(0x005D);
      break;
    case 0x003E: // GREATER-THAN SIGN
      flushText();
      tokenizer = data_state;
      break;
    default:
      textrun.push(0x005D);
      textrun.push(0x005D);
      reconsume(c, cdata_section_state);
      break;
    }
  }

  function character_reference_state(c) {
    beginTempBuf();
    tempbuf.push(0x0026);
    switch(c) {
    case 0x0009: // TAB
    case 0x000A: // LINE FEED
    case 0x000C: // FORM FEED
    case 0x0020: // SPACE
    case 0x003C: // LESS-THAN SIGN
    case 0x0026: // AMPERSAND
    case -1: // EOF
      reconsume(c, character_reference_end_state);
      break;
    case 0x0023: // NUMBER SIGN
      tempbuf.push(c);
      tokenizer = numeric_character_reference_state;
      break;
    default:
      reconsume(c, named_character_reference_state);
      break;
    }
  }

  function named_character_reference_state(c) {
    NAMEDCHARREF.lastIndex = nextchar; // w/ lookahead no char has been consumed
    var matched = NAMEDCHARREF.exec(chars);
    if (!matched) throw new Error("should never happen");
    var name = matched[1];
    if (!name) {
      // If no match can be made, switch to the character reference end state
      tokenizer = character_reference_end_state;
      return;
    }

    // Consume the matched characters and append them to temporary buffer
    nextchar += name.length;
    pushAll(tempbuf, str2buf(name));

    switch(return_state) {
    case attribute_value_double_quoted_state:
    case attribute_value_single_quoted_state:
    case attribute_value_unquoted_state:
      // If the character reference was consumed as part of an attribute...
      if (name[name.length-1] !== ';') { // ...and the last char is not ;
        if (/[=A-Za-z0-9]/.test(chars[nextchar])) {
          tokenizer = character_reference_end_state;
          return;
        }
      }
      break;
    default:
      break;
    }

    beginTempBuf();
    var rv = namedCharRefs[name];
    if (typeof rv === 'number') {
      tempbuf.push(rv);
    } else {
      pushAll(tempbuf, rv);
    }
    tokenizer = character_reference_end_state;
  }
  // We might need to pause tokenization until we have enough characters
  // in the buffer for longest possible character reference.
  named_character_reference_state.lookahead = -NAMEDCHARREF_MAXLEN;

  function numeric_character_reference_state(c) {
    character_reference_code = 0;
    switch(c) {
    case 0x0078: // x
    case 0x0058: // X
      tempbuf.push(c);
      tokenizer = hexadecimal_character_reference_start_state;
      break;
    default:
      reconsume(c, decimal_character_reference_start_state);
      break;
    }
  }

  function hexadecimal_character_reference_start_state(c) {
    switch(c) {
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
    case 0x0041: case 0x0042: case 0x0043: case 0x0044: case 0x0045:
    case 0x0046: // [A-F]
    case 0x0061: case 0x0062: case 0x0063: case 0x0064: case 0x0065:
    case 0x0066: // [a-f]
      reconsume(c, hexadecimal_character_reference_state);
      break;
    default:
      reconsume(c, character_reference_end_state);
      break;
    }
  }

  function decimal_character_reference_start_state(c) {
    switch(c) {
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
      reconsume(c, decimal_character_reference_state);
      break;
    default:
      reconsume(c, character_reference_end_state);
      break;
    }
  }

  function hexadecimal_character_reference_state(c) {
    switch(c) {
    case 0x0041: case 0x0042: case 0x0043: case 0x0044: case 0x0045:
    case 0x0046: // [A-F]
      character_reference_code *= 16;
      character_reference_code += (c - 0x0037);
      break;
    case 0x0061: case 0x0062: case 0x0063: case 0x0064: case 0x0065:
    case 0x0066: // [a-f]
      character_reference_code *= 16;
      character_reference_code += (c - 0x0057);
      break;
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
      character_reference_code *= 16;
      character_reference_code += (c - 0x0030);
      break;
    case 0x003B: // SEMICOLON
      tokenizer = numeric_character_reference_end_state;
      break;
    default:
      reconsume(c, numeric_character_reference_end_state);
      break;
    }
  }

  function decimal_character_reference_state(c) {
    switch(c) {
    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:
    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]
      character_reference_code *= 10;
      character_reference_code += (c - 0x0030);
      break;
    case 0x003B: // SEMICOLON
      tokenizer = numeric_character_reference_end_state;
      break;
    default:
      reconsume(c, numeric_character_reference_end_state);
      break;
    }
  }

  function numeric_character_reference_end_state(c) {
    if (character_reference_code in numericCharRefReplacements) {
      character_reference_code = numericCharRefReplacements[character_reference_code];
    } else if (character_reference_code > 0x10FFFF || (character_reference_code >= 0xD800 && character_reference_code < 0xE000)) {
      character_reference_code = 0xFFFD;
    }

    beginTempBuf();
    if (character_reference_code <= 0xFFFF) {
      tempbuf.push(character_reference_code);
    } else {
      character_reference_code = character_reference_code - 0x10000;
      /* jshint bitwise: false */
      tempbuf.push(0xD800 + (character_reference_code >> 10));
      tempbuf.push(0xDC00 + (character_reference_code & 0x03FF));
    }
    reconsume(c, character_reference_end_state);
  }

  function character_reference_end_state(c) {
    switch(return_state) {
    case attribute_value_double_quoted_state:
    case attribute_value_single_quoted_state:
    case attribute_value_unquoted_state:
      // append each character to the current attribute's value
      attrvaluebuf += buf2str(tempbuf);
      break;
    default:
      pushAll(textrun, tempbuf);
      break;
    }
    reconsume(c, return_state);
  }

  /***
   * The tree builder insertion modes
   */

  // 11.2.5.4.1 The "initial" insertion mode
  function initial_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      value = value.replace(LEADINGWS, ""); // Ignore spaces
      if (value.length === 0) return; // Are we done?
      break; // Handle anything non-space text below
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      var name = value;
      var publicid = arg3;
      var systemid = arg4;
      // Use the constructor directly instead of
      // implementation.createDocumentType because the create
      // function throws errors on invalid characters, and
      // we don't want the parser to throw them.
      doc.appendChild(new DocumentType(name,publicid, systemid));

      // Note that there is no public API for setting quirks mode We can
      // do this here because we have access to implementation details
      if (force_quirks ||
        name.toLowerCase() !== "html" ||
        quirkyPublicIds.test(publicid) ||
        (systemid && systemid.toLowerCase() === quirkySystemId) ||
        (systemid === undefined &&
         conditionallyQuirkyPublicIds.test(publicid)))
        doc._quirks = true;
      else if (limitedQuirkyPublicIds.test(publicid) ||
           (systemid !== undefined &&
            conditionallyQuirkyPublicIds.test(publicid)))
        doc._limitedQuirks = true;
      parser = before_html_mode;
      return;
    }

    // tags or non-whitespace text
    doc._quirks = true;
    parser = before_html_mode;
    parser(t,value,arg3,arg4);
  }

  // 11.2.5.4.2 The "before html" insertion mode
  function before_html_mode(t,value,arg3,arg4) {
    var elt;
    switch(t) {
    case 1: // TEXT
      value = value.replace(LEADINGWS, ""); // Ignore spaces
      if (value.length === 0) return; // Are we done?
      break; // Handle anything non-space text below
    case 5: // DOCTYPE
      /* ignore the token */
      return;
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 2: // TAG
      if (value === "html") {
        elt = createHTMLElt(doc, value, arg3);
        stack.push(elt);
        doc.appendChild(elt);
        // XXX: handle application cache here
        parser = before_head_mode;
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "html":
      case "head":
      case "body":
      case "br":
        break;  // fall through on these
      default:
        return; // ignore most end tags
      }
    }

    // Anything that didn't get handled above is handled like this:
    elt = createHTMLElt(doc, "html", null);
    stack.push(elt);
    doc.appendChild(elt);
    // XXX: handle application cache here
    parser = before_head_mode;
    parser(t,value,arg3,arg4);
  }

  // 11.2.5.4.3 The "before head" insertion mode
  function before_head_mode(t,value,arg3,arg4) {
    switch(t) {
    case 1: // TEXT
      value = value.replace(LEADINGWS, "");  // Ignore spaces
      if (value.length === 0) return; // Are we done?
      break;  // Handle anything non-space text below
    case 5: // DOCTYPE
      /* ignore the token */
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t,value,arg3,arg4);
        return;
      case "head":
        var elt = insertHTMLElement(value, arg3);
        head_element_pointer = elt;
        parser = in_head_mode;
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "html":
      case "head":
      case "body":
      case "br":
        break;
      default:
        return; // ignore most end tags
      }
    }

    // If not handled explicitly above
    before_head_mode(TAG, "head", null); // create a head tag
    parser(t, value, arg3, arg4); // then try again with this token
  }

  function in_head_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        insertText(ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return;
      break; // Handle non-whitespace below
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "meta":
        // XXX:
        // May need to change the encoding based on this tag
        /* falls through */
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
        insertHTMLElement(value, arg3);
        stack.pop();
        return;
      case "title":
        parseRCDATA(value, arg3);
        return;
      case "noscript":
        if (!scripting_enabled) {
          insertHTMLElement(value, arg3);
          parser = in_head_noscript_mode;
          return;
        }
        // Otherwise, if scripting is enabled...
        /* falls through */
      case "noframes":
      case "style":
        parseRawText(value,arg3);
        return;
      case "script":
        insertElement(function(doc) {
          var elt = createHTMLElt(doc, value, arg3);
          elt._parser_inserted = true;
          elt._force_async = false;
          if (fragment) elt._already_started = true;
          flushText();
          return elt;
        });
        tokenizer = script_data_state;
        originalInsertionMode = parser;
        parser = text_mode;
        return;
      case "template":
        insertHTMLElement(value, arg3);
        afe.insertMarker();
        frameset_ok = false;
        parser = in_template_mode;
        templateInsertionModes.push(parser);
        return;
      case "head":
        return; // ignore it
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "head":
        stack.pop();
        parser = after_head_mode;
        return;
      case "body":
      case "html":
      case "br":
        break; // handle these at the bottom of the function
      case "template":
        if (!stack.contains("template")) {
          return;
        }
        stack.generateImpliedEndTags(null, "thorough");
        stack.popTag("template");
        afe.clearToMarker();
        templateInsertionModes.pop();
        resetInsertionMode();
        return;
      default:
        // ignore any other end tag
        return;
      }
      break;
    }

    // If not handled above
    in_head_mode(ENDTAG, "head", null);   // synthetic </head>
    parser(t, value, arg3, arg4);   // Then redo this one
  }

  // 13.2.5.4.5 The "in head noscript" insertion mode
  function in_head_noscript_mode(t, value, arg3, arg4) {
    switch(t) {
    case 5: // DOCTYPE
      return;
    case 4: // COMMENT
      in_head_mode(t, value);
      return;
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        in_head_mode(t, ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return; // no more text
      break; // Handle non-whitespace below
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "style":
        in_head_mode(t, value, arg3);
        return;
      case "head":
      case "noscript":
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "noscript":
        stack.pop();
        parser = in_head_mode;
        return;
      case "br":
        break;  // goes to the outer default
      default:
        return; // ignore other end tags
      }
      break;
    }

    // If not handled above
    in_head_noscript_mode(ENDTAG, "noscript", null);
    parser(t, value, arg3, arg4);
  }

  function after_head_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        insertText(ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return;
      break; // Handle non-whitespace below
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "body":
        insertHTMLElement(value, arg3);
        frameset_ok = false;
        parser = in_body_mode;
        return;
      case "frameset":
        insertHTMLElement(value, arg3);
        parser = in_frameset_mode;
        return;
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "script":
      case "style":
      case "template":
      case "title":
        stack.push(head_element_pointer);
        in_head_mode(TAG, value, arg3);
        stack.removeElement(head_element_pointer);
        return;
      case "head":
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "template":
        return in_head_mode(t, value, arg3, arg4);
      case "body":
      case "html":
      case "br":
        break;
      default:
        return;  // ignore any other end tag
      }
      break;
    }

    after_head_mode(TAG, "body", null);
    frameset_ok = true;
    parser(t, value, arg3, arg4);
  }

  // 13.2.5.4.7 The "in body" insertion mode
  function in_body_mode(t,value,arg3,arg4) {
    var body, i, node, elt;
    switch(t) {
    case 1: // TEXT
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "");
        if (value.length === 0) return;
      }
      // If any non-space characters
      if (frameset_ok && NONWS.test(value))
        frameset_ok = false;
      afereconstruct();
      insertText(value);
      return;
    case 5: // DOCTYPE
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case -1: // EOF
      if (templateInsertionModes.length) {
        return in_template_mode(t);
      }
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        if (stack.contains("template")) {
          return;
        }
        transferAttributes(arg3, stack.elements[0]);
        return;
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "script":
      case "style":
      case "template":
      case "title":
        in_head_mode(TAG, value, arg3);
        return;
      case "body":
        body = stack.elements[1];
        if (!body || !(body instanceof impl.HTMLBodyElement) ||
            stack.contains("template"))
          return;
        frameset_ok = false;
        transferAttributes(arg3, body);
        return;
      case "frameset":
        if (!frameset_ok) return;
        body = stack.elements[1];
        if (!body || !(body instanceof impl.HTMLBodyElement))
          return;
        if (body.parentNode) body.parentNode.removeChild(body);
        while(!(stack.top instanceof impl.HTMLHtmlElement))
          stack.pop();
        insertHTMLElement(value, arg3);
        parser = in_frameset_mode;
        return;

      case "address":
      case "article":
      case "aside":
      case "blockquote":
      case "center":
      case "details":
      case "dialog":
      case "dir":
      case "div":
      case "dl":
      case "fieldset":
      case "figcaption":
      case "figure":
      case "footer":
      case "header":
      case "hgroup":
      case "main":
      case "nav":
      case "ol":
      case "p":
      case "section":
      case "summary":
      case "ul":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        return;

      case "menu":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        if (isA(stack.top, 'menuitem')) {
          stack.pop();
        }
        insertHTMLElement(value, arg3);
        return;

      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        if (stack.top instanceof impl.HTMLHeadingElement)
          stack.pop();
        insertHTMLElement(value, arg3);
        return;

      case "pre":
      case "listing":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        ignore_linefeed = true;
        frameset_ok = false;
        return;

      case "form":
        if (form_element_pointer && !stack.contains("template")) return;
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        elt = insertHTMLElement(value, arg3);
        if (!stack.contains("template"))
          form_element_pointer = elt;
        return;

      case "li":
        frameset_ok = false;
        for(i = stack.elements.length-1; i >= 0; i--) {
          node = stack.elements[i];
          if (node instanceof impl.HTMLLIElement) {
            in_body_mode(ENDTAG, "li");
            break;
          }
          if (isA(node, specialSet) && !isA(node, addressdivpSet))
            break;
        }
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        return;

      case "dd":
      case "dt":
        frameset_ok = false;
        for(i = stack.elements.length-1; i >= 0; i--) {
          node = stack.elements[i];
          if (isA(node, dddtSet)) {
            in_body_mode(ENDTAG, node.localName);
            break;
          }
          if (isA(node, specialSet) && !isA(node, addressdivpSet))
            break;
        }
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        return;

      case "plaintext":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        insertHTMLElement(value, arg3);
        tokenizer = plaintext_state;
        return;

      case "button":
        if (stack.inScope("button")) {
          in_body_mode(ENDTAG, "button");
          parser(t, value, arg3, arg4);
        }
        else {
          afereconstruct();
          insertHTMLElement(value, arg3);
          frameset_ok = false;
        }
        return;

      case "a":
        var activeElement = afe.findElementByTag("a");
        if (activeElement) {
          in_body_mode(ENDTAG, value);
          afe.remove(activeElement);
          stack.removeElement(activeElement);
        }
        /* falls through */
      case "b":
      case "big":
      case "code":
      case "em":
      case "font":
      case "i":
      case "s":
      case "small":
      case "strike":
      case "strong":
      case "tt":
      case "u":
        afereconstruct();
        afe.push(insertHTMLElement(value,arg3), arg3);
        return;

      case "nobr":
        afereconstruct();

        if (stack.inScope(value)) {
          in_body_mode(ENDTAG, value);
          afereconstruct();
        }
        afe.push(insertHTMLElement(value,arg3), arg3);
        return;

      case "applet":
      case "marquee":
      case "object":
        afereconstruct();
        insertHTMLElement(value,arg3);
        afe.insertMarker();
        frameset_ok = false;
        return;

      case "table":
        if (!doc._quirks && stack.inButtonScope("p")) {
          in_body_mode(ENDTAG, "p");
        }
        insertHTMLElement(value,arg3);
        frameset_ok = false;
        parser = in_table_mode;
        return;

      case "area":
      case "br":
      case "embed":
      case "img":
      case "keygen":
      case "wbr":
        afereconstruct();
        insertHTMLElement(value,arg3);
        stack.pop();
        frameset_ok = false;
        return;

      case "input":
        afereconstruct();
        elt = insertHTMLElement(value,arg3);
        stack.pop();
        var type = elt.getAttribute("type");
        if (!type || type.toLowerCase() !== "hidden")
          frameset_ok = false;
        return;

      case "param":
      case "source":
      case "track":
        insertHTMLElement(value,arg3);
        stack.pop();
        return;

      case "hr":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        if (isA(stack.top, 'menuitem')) {
          stack.pop();
        }
        insertHTMLElement(value,arg3);
        stack.pop();
        frameset_ok = false;
        return;

      case "image":
        in_body_mode(TAG, "img", arg3, arg4);
        return;

      case "textarea":
        insertHTMLElement(value,arg3);
        ignore_linefeed = true;
        frameset_ok = false;
        tokenizer = rcdata_state;
        originalInsertionMode = parser;
        parser = text_mode;
        return;

      case "xmp":
        if (stack.inButtonScope("p")) in_body_mode(ENDTAG, "p");
        afereconstruct();
        frameset_ok = false;
        parseRawText(value, arg3);
        return;

      case "iframe":
        frameset_ok = false;
        parseRawText(value, arg3);
        return;

      case "noembed":
        parseRawText(value,arg3);
        return;

      case "noscript":
        if (scripting_enabled) {
          parseRawText(value,arg3);
          return;
        }
        break;  // XXX Otherwise treat it as any other open tag?

      case "select":
        afereconstruct();
        insertHTMLElement(value,arg3);
        frameset_ok = false;
        if (parser === in_table_mode ||
          parser === in_caption_mode ||
          parser === in_table_body_mode ||
          parser === in_row_mode ||
          parser === in_cell_mode)
          parser = in_select_in_table_mode;
        else
          parser = in_select_mode;
        return;

      case "optgroup":
      case "option":
        if (stack.top instanceof impl.HTMLOptionElement) {
          in_body_mode(ENDTAG, "option");
        }
        afereconstruct();
        insertHTMLElement(value,arg3);
        return;

      case "menuitem":
        if (isA(stack.top, 'menuitem')) {
          stack.pop();
        }
        afereconstruct();
        insertHTMLElement(value, arg3);
        return;

      case "rb":
      case "rtc":
        if (stack.inScope("ruby")) {
          stack.generateImpliedEndTags();
        }
        insertHTMLElement(value,arg3);
        return;

      case "rp":
      case "rt":
        if (stack.inScope("ruby")) {
          stack.generateImpliedEndTags("rtc");
        }
        insertHTMLElement(value,arg3);
        return;

      case "math":
        afereconstruct();
        adjustMathMLAttributes(arg3);
        adjustForeignAttributes(arg3);
        insertForeignElement(value, arg3, NAMESPACE.MATHML);
        if (arg4) // self-closing flag
          stack.pop();
        return;

      case "svg":
        afereconstruct();
        adjustSVGAttributes(arg3);
        adjustForeignAttributes(arg3);
        insertForeignElement(value, arg3, NAMESPACE.SVG);
        if (arg4) // self-closing flag
          stack.pop();
        return;

      case "caption":
      case "col":
      case "colgroup":
      case "frame":
      case "head":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        // Ignore table tags if we're not in_table mode
        return;
      }

      // Handle any other start tag here
      // (and also noscript tags when scripting is disabled)
      afereconstruct();
      insertHTMLElement(value,arg3);
      return;

    case 3: // ENDTAG
      switch(value) {
      case "template":
        in_head_mode(ENDTAG, value, arg3);
        return;
      case "body":
        if (!stack.inScope("body")) return;
        parser = after_body_mode;
        return;
      case "html":
        if (!stack.inScope("body")) return;
        parser = after_body_mode;
        parser(t, value, arg3);
        return;

      case "address":
      case "article":
      case "aside":
      case "blockquote":
      case "button":
      case "center":
      case "details":
      case "dialog":
      case "dir":
      case "div":
      case "dl":
      case "fieldset":
      case "figcaption":
      case "figure":
      case "footer":
      case "header":
      case "hgroup":
      case "listing":
      case "main":
      case "menu":
      case "nav":
      case "ol":
      case "pre":
      case "section":
      case "summary":
      case "ul":
        // Ignore if there is not a matching open tag
        if (!stack.inScope(value)) return;
        stack.generateImpliedEndTags();
        stack.popTag(value);
        return;

      case "form":
        if (!stack.contains("template")) {
          var openform = form_element_pointer;
          form_element_pointer = null;
          if (!openform || !stack.elementInScope(openform)) return;
          stack.generateImpliedEndTags();
          stack.removeElement(openform);
        } else {
          if (!stack.inScope("form")) return;
          stack.generateImpliedEndTags();
          stack.popTag("form");
        }
        return;

      case "p":
        if (!stack.inButtonScope(value)) {
          in_body_mode(TAG, value, null);
          parser(t, value, arg3, arg4);
        }
        else {
          stack.generateImpliedEndTags(value);
          stack.popTag(value);
        }
        return;

      case "li":
        if (!stack.inListItemScope(value)) return;
        stack.generateImpliedEndTags(value);
        stack.popTag(value);
        return;

      case "dd":
      case "dt":
        if (!stack.inScope(value)) return;
        stack.generateImpliedEndTags(value);
        stack.popTag(value);
        return;

      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
        if (!stack.elementTypeInScope(impl.HTMLHeadingElement)) return;
        stack.generateImpliedEndTags();
        stack.popElementType(impl.HTMLHeadingElement);
        return;

      case "sarcasm":
        // Take a deep breath, and then:
        break;

      case "a":
      case "b":
      case "big":
      case "code":
      case "em":
      case "font":
      case "i":
      case "nobr":
      case "s":
      case "small":
      case "strike":
      case "strong":
      case "tt":
      case "u":
        var result = adoptionAgency(value);
        if (result) return;  // If we did something we're done
        break;         // Go to the "any other end tag" case

      case "applet":
      case "marquee":
      case "object":
        if (!stack.inScope(value)) return;
        stack.generateImpliedEndTags();
        stack.popTag(value);
        afe.clearToMarker();
        return;

      case "br":
        in_body_mode(TAG, value, null);  // Turn </br> into <br>
        return;
      }

      // Any other end tag goes here
      for(i = stack.elements.length-1; i >= 0; i--) {
        node = stack.elements[i];
        if (isA(node, value)) {
          stack.generateImpliedEndTags(value);
          stack.popElement(node);
          break;
        }
        else if (isA(node, specialSet)) {
          return;
        }
      }

      return;
    }
  }

  function text_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      insertText(value);
      return;
    case -1: // EOF
      if (stack.top instanceof impl.HTMLScriptElement)
        stack.top._already_started = true;
      stack.pop();
      parser = originalInsertionMode;
      parser(t);
      return;
    case 3: // ENDTAG
      if (value === "script") {
        handleScriptEnd();
      }
      else {
        stack.pop();
        parser = originalInsertionMode;
      }
      return;
    default:
      // We should never get any other token types
      return;
    }
  }

  function in_table_mode(t, value, arg3, arg4) {
    function getTypeAttr(attrs) {
      for(var i = 0, n = attrs.length; i < n; i++) {
        if (attrs[i][0] === "type")
          return attrs[i][1].toLowerCase();
      }
      return null;
    }

    switch(t) {
    case 1: // TEXT
      // XXX the text_integration_mode stuff is
      // just a hack I made up
      if (text_integration_mode) {
        in_body_mode(t, value, arg3, arg4);
        return;
      }
      else if (isA(stack.top, tablesectionrowSet)) {
        pending_table_text = [];
        originalInsertionMode = parser;
        parser = in_table_text_mode;
        parser(t, value, arg3, arg4);
        return;
      }
      break;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "caption":
        stack.clearToContext(tableContextSet);
        afe.insertMarker();
        insertHTMLElement(value,arg3);
        parser = in_caption_mode;
        return;
      case "colgroup":
        stack.clearToContext(tableContextSet);
        insertHTMLElement(value,arg3);
        parser = in_column_group_mode;
        return;
      case "col":
        in_table_mode(TAG, "colgroup", null);
        parser(t, value, arg3, arg4);
        return;
      case "tbody":
      case "tfoot":
      case "thead":
        stack.clearToContext(tableContextSet);
        insertHTMLElement(value,arg3);
        parser = in_table_body_mode;
        return;
      case "td":
      case "th":
      case "tr":
        in_table_mode(TAG, "tbody", null);
        parser(t, value, arg3, arg4);
        return;

      case "table":
        if (!stack.inTableScope(value)) {
          return; // Ignore the token
        }
        in_table_mode(ENDTAG, value);
        parser(t, value, arg3, arg4);
        return;

      case "style":
      case "script":
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;

      case "input":
        var type = getTypeAttr(arg3);
        if (type !== "hidden") break;  // to the anything else case
        insertHTMLElement(value,arg3);
        stack.pop();
        return;

      case "form":
        if (form_element_pointer || stack.contains("template")) return;
        form_element_pointer = insertHTMLElement(value, arg3);
        stack.popElement(form_element_pointer);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "table":
        if (!stack.inTableScope(value)) return;
        stack.popTag(value);
        resetInsertionMode();
        return;
      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        return;
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }

      break;
    case -1: // EOF
      in_body_mode(t, value, arg3, arg4);
      return;
    }

    // This is the anything else case
    foster_parent_mode = true;
    in_body_mode(t, value, arg3, arg4);
    foster_parent_mode = false;
  }

  function in_table_text_mode(t, value, arg3, arg4) {
    if (t === TEXT) {
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "");
        if (value.length === 0) return;
      }
      pending_table_text.push(value);
    }
    else {
      var s = pending_table_text.join("");
      pending_table_text.length = 0;
      if (NONWS.test(s)) { // If any non-whitespace characters
        // This must be the same code as the "anything else"
        // case of the in_table mode above.
        foster_parent_mode = true;
        in_body_mode(TEXT, s);
        foster_parent_mode = false;
      }
      else {
        insertText(s);
      }
      parser = originalInsertionMode;
      parser(t, value, arg3, arg4);
    }
  }


  function in_caption_mode(t, value, arg3, arg4) {
    function end_caption() {
      if (!stack.inTableScope("caption")) return false;
      stack.generateImpliedEndTags();
      stack.popTag("caption");
      afe.clearToMarker();
      parser = in_table_mode;
      return true;
    }

    switch(t) {
    case 2: // TAG
      switch(value) {
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        if (end_caption()) parser(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "caption":
        end_caption();
        return;
      case "table":
        if (end_caption()) parser(t, value, arg3, arg4);
        return;
      case "body":
      case "col":
      case "colgroup":
      case "html":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        return;
      }
      break;
    }

    // The Anything Else case
    in_body_mode(t, value, arg3, arg4);
  }

  function in_column_group_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      var ws = value.match(LEADINGWS);
      if (ws) {
        insertText(ws[0]);
        value = value.substring(ws[0].length);
      }
      if (value.length === 0) return;
      break; // Handle non-whitespace below

    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "col":
        insertHTMLElement(value, arg3);
        stack.pop();
        return;
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "colgroup":
        if (!isA(stack.top, 'colgroup')) {
          return; // Ignore the token.
        }
        stack.pop();
        parser = in_table_mode;
        return;
      case "col":
        return;
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case -1: // EOF
      in_body_mode(t, value, arg3, arg4);
      return;
    }

    // Anything else
    if (!isA(stack.top, 'colgroup')) {
      return; // Ignore the token.
    }
    in_column_group_mode(ENDTAG, "colgroup");
    parser(t, value, arg3, arg4);
  }

  function in_table_body_mode(t, value, arg3, arg4) {
    function endsect() {
      if (!stack.inTableScope("tbody") &&
        !stack.inTableScope("thead") &&
        !stack.inTableScope("tfoot"))
        return;
      stack.clearToContext(tableBodyContextSet);
      in_table_body_mode(ENDTAG, stack.top.localName, null);
      parser(t, value, arg3, arg4);
    }

    switch(t) {
    case 2: // TAG
      switch(value) {
      case "tr":
        stack.clearToContext(tableBodyContextSet);
        insertHTMLElement(value, arg3);
        parser = in_row_mode;
        return;
      case "th":
      case "td":
        in_table_body_mode(TAG, "tr", null);
        parser(t, value, arg3, arg4);
        return;
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "tfoot":
      case "thead":
        endsect();
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "table":
        endsect();
        return;
      case "tbody":
      case "tfoot":
      case "thead":
        if (stack.inTableScope(value)) {
          stack.clearToContext(tableBodyContextSet);
          stack.pop();
          parser = in_table_mode;
        }
        return;
      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
      case "td":
      case "th":
      case "tr":
        return;
      }
      break;
    }

    // Anything else:
    in_table_mode(t, value, arg3, arg4);
  }

  function in_row_mode(t, value, arg3, arg4) {
    function endrow() {
      if (!stack.inTableScope("tr")) return false;
      stack.clearToContext(tableRowContextSet);
      stack.pop();
      parser = in_table_body_mode;
      return true;
    }

    switch(t) {
    case 2: // TAG
      switch(value) {
      case "th":
      case "td":
        stack.clearToContext(tableRowContextSet);
        insertHTMLElement(value, arg3);
        parser = in_cell_mode;
        afe.insertMarker();
        return;
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "tfoot":
      case "thead":
      case "tr":
        if (endrow()) parser(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "tr":
        endrow();
        return;
      case "table":
        if (endrow()) parser(t, value, arg3, arg4);
        return;
      case "tbody":
      case "tfoot":
      case "thead":
        if (stack.inTableScope(value)) {
          if (endrow()) parser(t, value, arg3, arg4);
        }
        return;
      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
      case "td":
      case "th":
        return;
      }
      break;
    }

    // anything else
    in_table_mode(t, value, arg3, arg4);
  }

  function in_cell_mode(t, value, arg3, arg4) {
    switch(t) {
    case 2: // TAG
      switch(value) {
      case "caption":
      case "col":
      case "colgroup":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        if (stack.inTableScope("td")) {
          in_cell_mode(ENDTAG, "td");
          parser(t, value, arg3, arg4);
        }
        else if (stack.inTableScope("th")) {
          in_cell_mode(ENDTAG, "th");
          parser(t, value, arg3, arg4);
        }
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "td":
      case "th":
        if (!stack.inTableScope(value)) return;
        stack.generateImpliedEndTags();
        stack.popTag(value);
        afe.clearToMarker();
        parser = in_row_mode;
        return;

      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "html":
        return;

      case "table":
      case "tbody":
      case "tfoot":
      case "thead":
      case "tr":
        if (!stack.inTableScope(value)) return;
        in_cell_mode(ENDTAG, stack.inTableScope("td") ? "td" : "th");
        parser(t, value, arg3, arg4);
        return;
      }
      break;
    }

    // anything else
    in_body_mode(t, value, arg3, arg4);
  }

  function in_select_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "");
        if (value.length === 0) return;
      }
      insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      in_body_mode(t, value, arg3, arg4);
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "option":
        if (stack.top instanceof impl.HTMLOptionElement)
          in_select_mode(ENDTAG, value);
        insertHTMLElement(value, arg3);
        return;
      case "optgroup":
        if (stack.top instanceof impl.HTMLOptionElement)
          in_select_mode(ENDTAG, "option");
        if (stack.top instanceof impl.HTMLOptGroupElement)
          in_select_mode(ENDTAG, value);
        insertHTMLElement(value, arg3);
        return;
      case "select":
        in_select_mode(ENDTAG, value); // treat it as a close tag
        return;

      case "input":
      case "keygen":
      case "textarea":
        if (!stack.inSelectScope("select")) return;
        in_select_mode(ENDTAG, "select");
        parser(t, value, arg3, arg4);
        return;

      case "script":
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      switch(value) {
      case "optgroup":
        if (stack.top instanceof impl.HTMLOptionElement &&
          stack.elements[stack.elements.length-2] instanceof
          impl.HTMLOptGroupElement) {
          in_select_mode(ENDTAG, "option");
        }
        if (stack.top instanceof impl.HTMLOptGroupElement)
          stack.pop();

        return;

      case "option":
        if (stack.top instanceof impl.HTMLOptionElement)
          stack.pop();
        return;

      case "select":
        if (!stack.inSelectScope(value)) return;
        stack.popTag(value);
        resetInsertionMode();
        return;

      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      }

      break;
    }

    // anything else: just ignore the token
  }

  function in_select_in_table_mode(t, value, arg3, arg4) {
    switch(value) {
    case "caption":
    case "table":
    case "tbody":
    case "tfoot":
    case "thead":
    case "tr":
    case "td":
    case "th":
      switch(t) {
      case 2: // TAG
        in_select_in_table_mode(ENDTAG, "select");
        parser(t, value, arg3, arg4);
        return;
      case 3: // ENDTAG
        if (stack.inTableScope(value)) {
          in_select_in_table_mode(ENDTAG, "select");
          parser(t, value, arg3, arg4);
        }
        return;
      }
    }

    // anything else
    in_select_mode(t, value, arg3, arg4);
  }

  function in_template_mode(t, value, arg3, arg4) {
    function switchModeAndReprocess(mode) {
      parser = mode;
      templateInsertionModes[templateInsertionModes.length-1] = parser;
      parser(t, value, arg3, arg4);
    }
    switch(t) {
    case 1: // TEXT
    case 4: // COMMENT
    case 5: // DOCTYPE
      in_body_mode(t, value, arg3, arg4);
      return;
    case -1: // EOF
      if (!stack.contains("template")) {
        stopParsing();
      } else {
        stack.popTag("template");
        afe.clearToMarker();
        templateInsertionModes.pop();
        resetInsertionMode();
        parser(t, value, arg3, arg4);
      }
      return;
    case 2: // TAG
      switch(value) {
      case "base":
      case "basefont":
      case "bgsound":
      case "link":
      case "meta":
      case "noframes":
      case "script":
      case "style":
      case "template":
      case "title":
        in_head_mode(t, value, arg3, arg4);
        return;
      case "caption":
      case "colgroup":
      case "tbody":
      case "tfoot":
      case "thead":
        switchModeAndReprocess(in_table_mode);
        return;
      case "col":
        switchModeAndReprocess(in_column_group_mode);
        return;
      case "tr":
        switchModeAndReprocess(in_table_body_mode);
        return;
      case "td":
      case "th":
        switchModeAndReprocess(in_row_mode);
        return;
      }
      switchModeAndReprocess(in_body_mode);
      return;
    case 3: // ENDTAG
      switch(value) {
      case "template":
        in_head_mode(t, value, arg3, arg4);
        return;
      default:
        return;
      }
    }
  }

  function after_body_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // If any non-space chars, handle below
      if (NONWS.test(value)) break;
      in_body_mode(t, value);
      return;
    case 4: // COMMENT
      // Append it to the <html> element
      stack.elements[0]._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      if (value === "html") {
        in_body_mode(t, value, arg3, arg4);
        return;
      }
      break; // for any other tags
    case 3: // ENDTAG
      if (value === "html") {
        if (fragment) return;
        parser = after_after_body_mode;
        return;
      }
      break; // for any other tags
    }

    // anything else
    parser = in_body_mode;
    parser(t, value, arg3, arg4);
  }

  function in_frameset_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // Ignore any non-space characters
      value = value.replace(ALLNONWS, "");
      if (value.length > 0) insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "frameset":
        insertHTMLElement(value, arg3);
        return;
      case "frame":
        insertHTMLElement(value, arg3);
        stack.pop();
        return;
      case "noframes":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      if (value === "frameset") {
        if (fragment && stack.top instanceof impl.HTMLHtmlElement)
          return;
        stack.pop();
        if (!fragment &&
          !(stack.top instanceof impl.HTMLFrameSetElement))
          parser = after_frameset_mode;
        return;
      }
      break;
    }

    // ignore anything else
  }

  function after_frameset_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // Ignore any non-space characters
      value = value.replace(ALLNONWS, "");
      if (value.length > 0) insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "noframes":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    case 3: // ENDTAG
      if (value === "html") {
        parser = after_after_frameset_mode;
        return;
      }
      break;
    }

    // ignore anything else
  }

  function after_after_body_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // If any non-space chars, handle below
      if (NONWS.test(value)) break;
      in_body_mode(t, value, arg3, arg4);
      return;
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      in_body_mode(t, value, arg3, arg4);
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      if (value === "html") {
        in_body_mode(t, value, arg3, arg4);
        return;
      }
      break;
    }

    // anything else
    parser = in_body_mode;
    parser(t, value, arg3, arg4);
  }

  function after_after_frameset_mode(t, value, arg3, arg4) {
    switch(t) {
    case 1: // TEXT
      // Ignore any non-space characters
      value = value.replace(ALLNONWS, "");
      if (value.length > 0)
        in_body_mode(t, value, arg3, arg4);
      return;
    case 4: // COMMENT
      doc._appendChild(doc.createComment(value));
      return;
    case 5: // DOCTYPE
      in_body_mode(t, value, arg3, arg4);
      return;
    case -1: // EOF
      stopParsing();
      return;
    case 2: // TAG
      switch(value) {
      case "html":
        in_body_mode(t, value, arg3, arg4);
        return;
      case "noframes":
        in_head_mode(t, value, arg3, arg4);
        return;
      }
      break;
    }

    // ignore anything else
  }


  // 13.2.5.5 The rules for parsing tokens in foreign content
  //
  // This is like one of the insertion modes above, but is
  // invoked somewhat differently when the current token is not HTML.
  // See the insertToken() function.
  function insertForeignToken(t, value, arg3, arg4) {
    // A <font> tag is an HTML font tag if it has a color, font, or size
    // attribute.  Otherwise we assume it is foreign content
    function isHTMLFont(attrs) {
      for(var i = 0, n = attrs.length; i < n; i++) {
        switch(attrs[i][0]) {
        case "color":
        case "face":
        case "size":
          return true;
        }
      }
      return false;
    }

    var current;

    switch(t) {
    case 1: // TEXT
      // If any non-space, non-nul characters
      if (frameset_ok && NONWSNONNUL.test(value))
        frameset_ok = false;
      if (textIncludesNUL) {
        value = value.replace(NULCHARS, "\uFFFD");
      }
      insertText(value);
      return;
    case 4: // COMMENT
      insertComment(value);
      return;
    case 5: // DOCTYPE
      // ignore it
      return;
    case 2: // TAG
      switch(value) {
      case "font":
        if (!isHTMLFont(arg3)) break;
        /* falls through */
      case "b":
      case "big":
      case "blockquote":
      case "body":
      case "br":
      case "center":
      case "code":
      case "dd":
      case "div":
      case "dl":
      case "dt":
      case "em":
      case "embed":
      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
      case "head":
      case "hr":
      case "i":
      case "img":
      case "li":
      case "listing":
      case "menu":
      case "meta":
      case "nobr":
      case "ol":
      case "p":
      case "pre":
      case "ruby":
      case "s":
      case "small":
      case "span":
      case "strong":
      case "strike":
      case "sub":
      case "sup":
      case "table":
      case "tt":
      case "u":
      case "ul":
      case "var":
        if (fragment) {
          break;
        }
        do {
          stack.pop();
          current = stack.top;
        } while(current.namespaceURI !== NAMESPACE.HTML &&
            !isMathmlTextIntegrationPoint(current) &&
            !isHTMLIntegrationPoint(current));

        insertToken(t, value, arg3, arg4);  // reprocess
        return;
      }

      // Any other start tag case goes here
      current = (stack.elements.length===1 && fragment) ? fragmentContext :
        stack.top;
      if (current.namespaceURI === NAMESPACE.MATHML) {
        adjustMathMLAttributes(arg3);
      }
      else if (current.namespaceURI === NAMESPACE.SVG) {
        value = adjustSVGTagName(value);
        adjustSVGAttributes(arg3);
      }
      adjustForeignAttributes(arg3);

      insertForeignElement(value, arg3, current.namespaceURI);
      if (arg4) { // the self-closing flag
        if (value === 'script' && current.namespaceURI === NAMESPACE.SVG) {
          // XXX deal with SVG scripts here
        }
        stack.pop();
      }
      return;

    case 3: // ENDTAG
      current = stack.top;
      if (value === "script" &&
        current.namespaceURI === NAMESPACE.SVG &&
        current.localName === "script") {

        stack.pop();

        // XXX
        // Deal with SVG scripts here
      }
      else {
        // The any other end tag case
        var i = stack.elements.length-1;
        var node = stack.elements[i];
        for(;;) {
          if (node.localName.toLowerCase() === value) {
            stack.popElement(node);
            break;
          }
          node = stack.elements[--i];
          // If non-html, keep looping
          if (node.namespaceURI !== NAMESPACE.HTML)
            continue;
          // Otherwise process the end tag as html
          parser(t, value, arg3, arg4);
          break;
        }
      }
      return;
    }
  }

  /***
   * Finally, this is the end of the HTMLParser() factory function.
   * It returns the htmlparser object with the append() and end() methods.
   */

  // Sneak another method into the htmlparser object to allow us to run
  // tokenizer tests.  This can be commented out in production code.
  // This is a hook for testing the tokenizer. It has to be here
  // because the tokenizer details are all hidden away within the closure.
  // It should return an array of tokens generated while parsing the
  // input string.
  htmlparser.testTokenizer = function(input, initialState, lastStartTag, charbychar) {
    var tokens = [];

    switch(initialState) {
    case "PCDATA state":
      tokenizer = data_state;
      break;
    case "RCDATA state":
      tokenizer = rcdata_state;
      break;
    case "RAWTEXT state":
      tokenizer = rawtext_state;
      break;
    case "PLAINTEXT state":
      tokenizer = plaintext_state;
      break;
    }

    if (lastStartTag) {
      lasttagname = lastStartTag;
    }

    insertToken = function(t, value, arg3, arg4) {
      flushText();
      switch(t) {
      case 1: // TEXT
        if (tokens.length > 0 &&
          tokens[tokens.length-1][0] === "Character") {
          tokens[tokens.length-1][1] += value;
        }
        else tokens.push(["Character", value]);
        break;
      case 4: // COMMENT
        tokens.push(["Comment", value]);
        break;
      case 5: // DOCTYPE
        tokens.push(["DOCTYPE", value,
               arg3 === undefined ? null : arg3,
               arg4 === undefined ? null : arg4,
               !force_quirks]);
        break;
      case 2: // TAG
        var attrs = Object.create(null);
        for(var i = 0; i < arg3.length; i++) {
          // XXX: does attribute order matter?
          var a = arg3[i];
          if (a.length === 1) {
            attrs[a[0]] = "";
          }
          else {
            attrs[a[0]] = a[1];
          }
        }
        var token = ["StartTag", value, attrs];
        if (arg4) token.push(true);
        tokens.push(token);
        break;
      case 3: // ENDTAG
        tokens.push(["EndTag", value]);
        break;
      case -1: // EOF
        break;
      }
    };

    if (!charbychar) {
      this.parse(input, true);
    }
    else {
      for(var i = 0; i < input.length; i++) {
        this.parse(input[i]);
      }
      this.parse("", true);
    }
    return tokens;
  };

  // Return the parser object from the HTMLParser() factory function
  return htmlparser;
}


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(105);

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.2.3
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(0), __webpack_require__(30), __webpack_require__(31), __webpack_require__(9), __webpack_require__(10), __webpack_require__(34), __webpack_require__(75), __webpack_require__(76), __webpack_require__(8), __webpack_require__(77), __webpack_require__(35), __webpack_require__(78), __webpack_require__(33), __webpack_require__(28), __webpack_require__(79)) :
	typeof define === 'function' && define.amd ? define('@angular/platform-server', ['exports', '@angular/core', '@angular/platform-browser', '@angular/animations/browser', '@angular/common', '@angular/common/http', '@angular/http', '@angular/platform-browser-dynamic', '@angular/platform-browser/animations', 'rxjs/Observable', 'rxjs/Subject', 'url', '@angular/compiler', 'rxjs/operator/filter', 'rxjs/operator/first', 'rxjs/operator/toPromise'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.platformServer = {}),global.ng.core,global.ng.platformBrowser,global.ng.animations.browser,global.ng.common,global.ng.common.http,global.ng.http,global.ng.platformBrowserDynamic,global.ng.platformBrowser.animations,global.Rx,global.Rx,global.url,global.ng.compiler,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype));
}(this, (function (exports,_angular_core,_angular_platformBrowser,_angular_animations_browser,_angular_common,_angular_common_http,_angular_http,_angular_platformBrowserDynamic,_angular_platformBrowser_animations,rxjs_Observable,rxjs_Subject,url,_angular_compiler,rxjs_operator_filter,rxjs_operator_first,rxjs_operator_toPromise) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * @license Angular v5.2.3
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var domino = __webpack_require__(80);
/**
 * @param {?} methodName
 * @return {?}
 */
function _notImplemented(methodName) {
    return new Error('This method is not implemented in DominoAdapter: ' + methodName);
}
/**
 * Parses a document string to a Document object.
 * @param {?} html
 * @param {?=} url
 * @return {?}
 */
function parseDocument(html, url$$1) {
    if (url$$1 === void 0) { url$$1 = '/'; }
    var /** @type {?} */ window = domino.createWindow(html, url$$1);
    var /** @type {?} */ doc = window.document;
    return doc;
}
/**
 * Serializes a document to string.
 * @param {?} doc
 * @return {?}
 */
function serializeDocument(doc) {
    return (/** @type {?} */ (doc)).serialize();
}
/**
 * DOM Adapter for the server platform based on https://github.com/fgnass/domino.
 */
var DominoAdapter = /** @class */ (function (_super) {
    __extends(DominoAdapter, _super);
    function DominoAdapter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    DominoAdapter.makeCurrent = /**
     * @return {?}
     */
    function () { _angular_platformBrowser.ɵsetRootDomAdapter(new DominoAdapter()); };
    /**
     * @param {?} error
     * @return {?}
     */
    DominoAdapter.prototype.logError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) { console.error(error); };
    /**
     * @param {?} error
     * @return {?}
     */
    DominoAdapter.prototype.log = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        // tslint:disable-next-line:no-console
        console.log(error);
    };
    /**
     * @param {?} error
     * @return {?}
     */
    DominoAdapter.prototype.logGroup = /**
     * @param {?} error
     * @return {?}
     */
    function (error) { console.error(error); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.logGroupEnd = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsDOMEvents = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsNativeShadowDOM = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @param {?} nodeA
     * @param {?} nodeB
     * @return {?}
     */
    DominoAdapter.prototype.contains = /**
     * @param {?} nodeA
     * @param {?} nodeB
     * @return {?}
     */
    function (nodeA, nodeB) {
        var /** @type {?} */ inner = nodeB;
        while (inner) {
            if (inner === nodeA)
                return true;
            inner = inner.parent;
        }
        return false;
    };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.createHtmlDocument = /**
     * @return {?}
     */
    function () {
        return parseDocument('<html><head><title>fakeTitle</title></head><body></body></html>');
    };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getDefaultDocument = /**
     * @return {?}
     */
    function () {
        if (!DominoAdapter.defaultDoc) {
            DominoAdapter.defaultDoc = domino.createDocument();
        }
        return DominoAdapter.defaultDoc;
    };
    /**
     * @param {?} el
     * @param {?=} doc
     * @return {?}
     */
    DominoAdapter.prototype.createShadowRoot = /**
     * @param {?} el
     * @param {?=} doc
     * @return {?}
     */
    function (el, doc) {
        if (doc === void 0) { doc = document; }
        el.shadowRoot = doc.createDocumentFragment();
        el.shadowRoot.parent = el;
        return el.shadowRoot;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    DominoAdapter.prototype.getShadowRoot = /**
     * @param {?} el
     * @return {?}
     */
    function (el) { return el.shadowRoot; };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isTextNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return node.nodeType === DominoAdapter.defaultDoc.TEXT_NODE; };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isCommentNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.nodeType === DominoAdapter.defaultDoc.COMMENT_NODE;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isElementNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node ? node.nodeType === DominoAdapter.defaultDoc.ELEMENT_NODE : false;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.hasShadowRoot = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return node.shadowRoot != null; };
    /**
     * @param {?} node
     * @return {?}
     */
    DominoAdapter.prototype.isShadowRoot = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return this.getShadowRoot(node) == node; };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DominoAdapter.prototype.getProperty = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) {
        if (name === 'href') {
            // Domino tries tp resolve href-s which we do not want. Just return the
            // atribute value.
            return this.getAttribute(el, 'href');
        }
        else if (name === 'innerText') {
            // Domino does not support innerText. Just map it to textContent.
            return el.textContent;
        }
        return (/** @type {?} */ (el))[name];
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DominoAdapter.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        if (name === 'href') {
            // Eventhough the server renderer reflects any properties to attributes
            // map 'href' to atribute just to handle when setProperty is directly called.
            this.setAttribute(el, 'href', value);
        }
        else if (name === 'innerText') {
            // Domino does not support innerText. Just map it to textContent.
            el.textContent = value;
        }
        (/** @type {?} */ (el))[name] = value;
    };
    /**
     * @param {?} doc
     * @param {?} target
     * @return {?}
     */
    DominoAdapter.prototype.getGlobalEventTarget = /**
     * @param {?} doc
     * @param {?} target
     * @return {?}
     */
    function (doc, target) {
        if (target === 'window') {
            return doc.defaultView;
        }
        if (target === 'document') {
            return doc;
        }
        if (target === 'body') {
            return doc.body;
        }
        return null;
    };
    /**
     * @param {?} doc
     * @return {?}
     */
    DominoAdapter.prototype.getBaseHref = /**
     * @param {?} doc
     * @return {?}
     */
    function (doc) {
        var /** @type {?} */ base = this.querySelector(doc.documentElement, 'base');
        var /** @type {?} */ href = '';
        if (base) {
            href = this.getHref(base);
        }
        // TODO(alxhub): Need relative path logic from BrowserDomAdapter here?
        return href;
    };
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @return {?}
     */
    DominoAdapter.prototype._readStyleAttribute = /**
     * \@internal
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ styleMap = {};
        var /** @type {?} */ styleAttribute = element.getAttribute('style');
        if (styleAttribute) {
            var /** @type {?} */ styleList = styleAttribute.split(/;+/g);
            for (var /** @type {?} */ i = 0; i < styleList.length; i++) {
                if (styleList[i].length > 0) {
                    var /** @type {?} */ style = /** @type {?} */ (styleList[i]);
                    var /** @type {?} */ colon = style.indexOf(':');
                    if (colon === -1) {
                        throw new Error("Invalid CSS style: " + style);
                    }
                    (/** @type {?} */ (styleMap))[style.substr(0, colon).trim()] = style.substr(colon + 1).trim();
                }
            }
        }
        return styleMap;
    };
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @param {?} styleMap
     * @return {?}
     */
    DominoAdapter.prototype._writeStyleAttribute = /**
     * \@internal
     * @param {?} element
     * @param {?} styleMap
     * @return {?}
     */
    function (element, styleMap) {
        var /** @type {?} */ styleAttrValue = '';
        for (var /** @type {?} */ key in styleMap) {
            var /** @type {?} */ newValue = styleMap[key];
            if (newValue) {
                styleAttrValue += key + ':' + styleMap[key] + ';';
            }
        }
        element.setAttribute('style', styleAttrValue);
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    DominoAdapter.prototype.setStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    function (element, styleName, styleValue) {
        var /** @type {?} */ styleMap = this._readStyleAttribute(element);
        (/** @type {?} */ (styleMap))[styleName] = styleValue;
        this._writeStyleAttribute(element, styleMap);
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    DominoAdapter.prototype.removeStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    function (element, styleName) { this.setStyle(element, styleName, null); };
    /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    DominoAdapter.prototype.getStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @return {?}
     */
    function (element, styleName) {
        var /** @type {?} */ styleMap = this._readStyleAttribute(element);
        return styleMap.hasOwnProperty(styleName) ? (/** @type {?} */ (styleMap))[styleName] : '';
    };
    /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    DominoAdapter.prototype.hasStyle = /**
     * @param {?} element
     * @param {?} styleName
     * @param {?=} styleValue
     * @return {?}
     */
    function (element, styleName, styleValue) {
        var /** @type {?} */ value = this.getStyle(element, styleName) || '';
        return styleValue ? value == styleValue : value.length > 0;
    };
    /**
     * @param {?} el
     * @param {?} evt
     * @return {?}
     */
    DominoAdapter.prototype.dispatchEvent = /**
     * @param {?} el
     * @param {?} evt
     * @return {?}
     */
    function (el, evt) {
        el.dispatchEvent(evt);
        // Dispatch the event to the window also.
        var /** @type {?} */ doc = el.ownerDocument || el;
        var /** @type {?} */ win = (/** @type {?} */ (doc)).defaultView;
        if (win) {
            win.dispatchEvent(evt);
        }
    };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getHistory = /**
     * @return {?}
     */
    function () { throw _notImplemented('getHistory'); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getLocation = /**
     * @return {?}
     */
    function () { throw _notImplemented('getLocation'); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getUserAgent = /**
     * @return {?}
     */
    function () { return 'Fake user agent'; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsWebAnimation = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.performanceNow = /**
     * @return {?}
     */
    function () { return Date.now(); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getAnimationPrefix = /**
     * @return {?}
     */
    function () { return ''; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.getTransitionEnd = /**
     * @return {?}
     */
    function () { return 'transitionend'; };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsAnimation = /**
     * @return {?}
     */
    function () { return true; };
    /**
     * @param {?} el
     * @return {?}
     */
    DominoAdapter.prototype.getDistributedNodes = /**
     * @param {?} el
     * @return {?}
     */
    function (el) { throw _notImplemented('getDistributedNodes'); };
    /**
     * @return {?}
     */
    DominoAdapter.prototype.supportsCookies = /**
     * @return {?}
     */
    function () { return false; };
    /**
     * @param {?} name
     * @return {?}
     */
    DominoAdapter.prototype.getCookie = /**
     * @param {?} name
     * @return {?}
     */
    function (name) { throw _notImplemented('getCookie'); };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DominoAdapter.prototype.setCookie = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) { throw _notImplemented('setCookie'); };
    return DominoAdapter;
}(_angular_platformBrowser.ɵBrowserDomAdapter));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Representation of the current platform state.
 *
 * \@experimental
 */
var PlatformState = /** @class */ (function () {
    function PlatformState(_doc) {
        this._doc = _doc;
    }
    /**
     * Renders the current state of the platform to string.
     */
    /**
     * Renders the current state of the platform to string.
     * @return {?}
     */
    PlatformState.prototype.renderToString = /**
     * Renders the current state of the platform to string.
     * @return {?}
     */
    function () { return serializeDocument(this._doc); };
    /**
     * Returns the current DOM state.
     */
    /**
     * Returns the current DOM state.
     * @return {?}
     */
    PlatformState.prototype.getDocument = /**
     * Returns the current DOM state.
     * @return {?}
     */
    function () { return this._doc; };
    PlatformState.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    PlatformState.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
    ]; };
    return PlatformState;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var xhr2 = __webpack_require__(90);
var isAbsoluteUrl = /^[a-zA-Z\-\+.]+:\/\//;
/**
 * @param {?} url
 * @return {?}
 */
function validateRequestUrl(url$$1) {
    if (!isAbsoluteUrl.test(url$$1)) {
        throw new Error("URLs requested via Http on the server must be absolute. URL: " + url$$1);
    }
}
var ServerXhr = /** @class */ (function () {
    function ServerXhr() {
    }
    /**
     * @return {?}
     */
    ServerXhr.prototype.build = /**
     * @return {?}
     */
    function () { return new xhr2.XMLHttpRequest(); };
    ServerXhr.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerXhr.ctorParameters = function () { return []; };
    return ServerXhr;
}());
var ServerXsrfStrategy = /** @class */ (function () {
    function ServerXsrfStrategy() {
    }
    /**
     * @param {?} req
     * @return {?}
     */
    ServerXsrfStrategy.prototype.configureRequest = /**
     * @param {?} req
     * @return {?}
     */
    function (req) { };
    ServerXsrfStrategy.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerXsrfStrategy.ctorParameters = function () { return []; };
    return ServerXsrfStrategy;
}());
/**
 * @abstract
 */
var ZoneMacroTaskWrapper = /** @class */ (function () {
    function ZoneMacroTaskWrapper() {
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskWrapper.prototype.wrap = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        var _this = this;
        return new rxjs_Observable.Observable(function (observer) {
            var /** @type {?} */ task = /** @type {?} */ ((null));
            var /** @type {?} */ scheduled = false;
            var /** @type {?} */ sub = null;
            var /** @type {?} */ savedResult = null;
            var /** @type {?} */ savedError = null;
            var /** @type {?} */ scheduleTask = function (_task) {
                task = _task;
                scheduled = true;
                var /** @type {?} */ delegate = _this.delegate(request);
                sub = delegate.subscribe(function (res) { return savedResult = res; }, function (err) {
                    if (!scheduled) {
                        throw new Error('An http observable was completed twice. This shouldn\'t happen, please file a bug.');
                    }
                    savedError = err;
                    scheduled = false;
                    task.invoke();
                }, function () {
                    if (!scheduled) {
                        throw new Error('An http observable was completed twice. This shouldn\'t happen, please file a bug.');
                    }
                    scheduled = false;
                    task.invoke();
                });
            };
            var /** @type {?} */ cancelTask = function (_task) {
                if (!scheduled) {
                    return;
                }
                scheduled = false;
                if (sub) {
                    sub.unsubscribe();
                    sub = null;
                }
            };
            var /** @type {?} */ onComplete = function () {
                if (savedError !== null) {
                    observer.error(savedError);
                }
                else {
                    observer.next(savedResult);
                    observer.complete();
                }
            };
            // MockBackend for Http is synchronous, which means that if scheduleTask is by
            // scheduleMacroTask, the request will hit MockBackend and the response will be
            // sent, causing task.invoke() to be called.
            var /** @type {?} */ _task = Zone.current.scheduleMacroTask('ZoneMacroTaskWrapper.subscribe', onComplete, {}, function () { return null; }, cancelTask);
            scheduleTask(_task);
            return function () {
                if (scheduled && task) {
                    task.zone.cancelTask(task);
                    scheduled = false;
                }
                if (sub) {
                    sub.unsubscribe();
                    sub = null;
                }
            };
        });
    };
    return ZoneMacroTaskWrapper;
}());
var ZoneMacroTaskConnection = /** @class */ (function (_super) {
    __extends(ZoneMacroTaskConnection, _super);
    function ZoneMacroTaskConnection(request, backend) {
        var _this = _super.call(this) || this;
        _this.request = request;
        _this.backend = backend;
        validateRequestUrl(request.url);
        _this.response = _this.wrap(request);
        return _this;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskConnection.prototype.delegate = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        this.lastConnection = this.backend.createConnection(request);
        return /** @type {?} */ (this.lastConnection.response);
    };
    Object.defineProperty(ZoneMacroTaskConnection.prototype, "readyState", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.lastConnection ? this.lastConnection.readyState : _angular_http.ReadyState.Unsent;
        },
        enumerable: true,
        configurable: true
    });
    return ZoneMacroTaskConnection;
}(ZoneMacroTaskWrapper));
var ZoneMacroTaskBackend = /** @class */ (function () {
    function ZoneMacroTaskBackend(backend) {
        this.backend = backend;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneMacroTaskBackend.prototype.createConnection = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        return new ZoneMacroTaskConnection(request, this.backend);
    };
    return ZoneMacroTaskBackend;
}());
var ZoneClientBackend = /** @class */ (function (_super) {
    __extends(ZoneClientBackend, _super);
    function ZoneClientBackend(backend) {
        var _this = _super.call(this) || this;
        _this.backend = backend;
        return _this;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneClientBackend.prototype.handle = /**
     * @param {?} request
     * @return {?}
     */
    function (request) { return this.wrap(request); };
    /**
     * @param {?} request
     * @return {?}
     */
    ZoneClientBackend.prototype.delegate = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        return this.backend.handle(request);
    };
    return ZoneClientBackend;
}(ZoneMacroTaskWrapper));
/**
 * @param {?} xhrBackend
 * @param {?} options
 * @return {?}
 */
function httpFactory(xhrBackend, options) {
    var /** @type {?} */ macroBackend = new ZoneMacroTaskBackend(xhrBackend);
    return new _angular_http.Http(macroBackend, options);
}
/**
 * @param {?} backend
 * @param {?} interceptors
 * @return {?}
 */
function zoneWrappedInterceptingHandler(backend, interceptors) {
    var /** @type {?} */ realBackend = _angular_common_http.ɵinterceptingHandler(backend, interceptors);
    return new ZoneClientBackend(realBackend);
}
var SERVER_HTTP_PROVIDERS = [
    { provide: _angular_http.Http, useFactory: httpFactory, deps: [_angular_http.XHRBackend, _angular_http.RequestOptions] },
    { provide: _angular_http.BrowserXhr, useClass: ServerXhr }, { provide: _angular_http.XSRFStrategy, useClass: ServerXsrfStrategy },
    { provide: _angular_common_http.XhrFactory, useClass: ServerXhr }, {
        provide: _angular_common_http.HttpHandler,
        useFactory: zoneWrappedInterceptingHandler,
        deps: [_angular_common_http.HttpBackend, [new _angular_core.Optional(), _angular_common_http.HTTP_INTERCEPTORS]]
    }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Config object passed to initialize the platform.
 *
 * \@experimental
 * @record
 */

/**
 * The DI token for setting the initial config for the platform.
 *
 * \@experimental
 */
var INITIAL_CONFIG = new _angular_core.InjectionToken('Server.INITIAL_CONFIG');
/**
 * A function that will be executed when calling `renderModuleFactory` or `renderModule` just
 * before current platform state is rendered to string.
 *
 * \@experimental
 */
var BEFORE_APP_SERIALIZED = new _angular_core.InjectionToken('Server.RENDER_MODULE_HOOK');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} urlStr
 * @return {?}
 */
function parseUrl(urlStr) {
    var /** @type {?} */ parsedUrl = url.parse(urlStr);
    return {
        pathname: parsedUrl.pathname || '',
        search: parsedUrl.search || '',
        hash: parsedUrl.hash || '',
    };
}
/**
 * Server-side implementation of URL state. Implements `pathname`, `search`, and `hash`
 * but not the state stack.
 */
var ServerPlatformLocation = /** @class */ (function () {
    function ServerPlatformLocation(_doc, _config) {
        this._doc = _doc;
        this.pathname = '/';
        this.search = '';
        this.hash = '';
        this._hashUpdate = new rxjs_Subject.Subject();
        var /** @type {?} */ config = /** @type {?} */ (_config);
        if (!!config && !!config.url) {
            var /** @type {?} */ parsedUrl = parseUrl(config.url);
            this.pathname = parsedUrl.pathname;
            this.search = parsedUrl.search;
            this.hash = parsedUrl.hash;
        }
    }
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.getBaseHrefFromDOM = /**
     * @return {?}
     */
    function () { return /** @type {?} */ ((_angular_platformBrowser.ɵgetDOM().getBaseHref(this._doc))); };
    /**
     * @param {?} fn
     * @return {?}
     */
    ServerPlatformLocation.prototype.onPopState = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        // No-op: a state stack is not implemented, so
        // no events will ever come.
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ServerPlatformLocation.prototype.onHashChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._hashUpdate.subscribe(fn); };
    Object.defineProperty(ServerPlatformLocation.prototype, "url", {
        get: /**
         * @return {?}
         */
        function () { return "" + this.pathname + this.search + this.hash; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} oldUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.setHash = /**
     * @param {?} value
     * @param {?} oldUrl
     * @return {?}
     */
    function (value, oldUrl) {
        var _this = this;
        if (this.hash === value) {
            // Don't fire events if the hash has not changed.
            return;
        }
        (/** @type {?} */ (this)).hash = value;
        var /** @type {?} */ newUrl = this.url;
        scheduleMicroTask(function () { return _this._hashUpdate.next(/** @type {?} */ ({ type: 'hashchange', oldUrl: oldUrl, newUrl: newUrl })); });
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.replaceState = /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    function (state, title, newUrl) {
        var /** @type {?} */ oldUrl = this.url;
        var /** @type {?} */ parsedUrl = parseUrl(newUrl);
        (/** @type {?} */ (this)).pathname = parsedUrl.pathname;
        (/** @type {?} */ (this)).search = parsedUrl.search;
        this.setHash(parsedUrl.hash, oldUrl);
    };
    /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    ServerPlatformLocation.prototype.pushState = /**
     * @param {?} state
     * @param {?} title
     * @param {?} newUrl
     * @return {?}
     */
    function (state, title, newUrl) {
        this.replaceState(state, title, newUrl);
    };
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.forward = /**
     * @return {?}
     */
    function () { throw new Error('Not implemented'); };
    /**
     * @return {?}
     */
    ServerPlatformLocation.prototype.back = /**
     * @return {?}
     */
    function () { throw new Error('Not implemented'); };
    ServerPlatformLocation.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerPlatformLocation.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
        { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [INITIAL_CONFIG,] },] },
    ]; };
    return ServerPlatformLocation;
}());
/**
 * @param {?} fn
 * @return {?}
 */
function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var EMPTY_ARRAY = [];
var ServerRendererFactory2 = /** @class */ (function () {
    function ServerRendererFactory2(ngZone, document, sharedStylesHost) {
        this.ngZone = ngZone;
        this.document = document;
        this.sharedStylesHost = sharedStylesHost;
        this.rendererByCompId = new Map();
        this.schema = new _angular_compiler.DomElementSchemaRegistry();
        this.defaultRenderer = new DefaultServerRenderer2(document, ngZone, this.schema);
    }
    /**
     * @param {?} element
     * @param {?} type
     * @return {?}
     */
    ServerRendererFactory2.prototype.createRenderer = /**
     * @param {?} element
     * @param {?} type
     * @return {?}
     */
    function (element, type) {
        if (!element || !type) {
            return this.defaultRenderer;
        }
        switch (type.encapsulation) {
            case _angular_core.ViewEncapsulation.Native:
            case _angular_core.ViewEncapsulation.Emulated: {
                var /** @type {?} */ renderer = this.rendererByCompId.get(type.id);
                if (!renderer) {
                    renderer = new EmulatedEncapsulationServerRenderer2(this.document, this.ngZone, this.sharedStylesHost, this.schema, type);
                    this.rendererByCompId.set(type.id, renderer);
                }
                (/** @type {?} */ (renderer)).applyToHost(element);
                return renderer;
            }
            case _angular_core.ViewEncapsulation.Native:
                throw new Error('Native encapsulation is not supported on the server!');
            default: {
                if (!this.rendererByCompId.has(type.id)) {
                    var /** @type {?} */ styles = _angular_platformBrowser.ɵflattenStyles(type.id, type.styles, []);
                    this.sharedStylesHost.addStyles(styles);
                    this.rendererByCompId.set(type.id, this.defaultRenderer);
                }
                return this.defaultRenderer;
            }
        }
    };
    /**
     * @return {?}
     */
    ServerRendererFactory2.prototype.begin = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    ServerRendererFactory2.prototype.end = /**
     * @return {?}
     */
    function () { };
    ServerRendererFactory2.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerRendererFactory2.ctorParameters = function () { return [
        { type: _angular_core.NgZone, },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
        { type: _angular_platformBrowser.ɵSharedStylesHost, },
    ]; };
    return ServerRendererFactory2;
}());
var DefaultServerRenderer2 = /** @class */ (function () {
    function DefaultServerRenderer2(document, ngZone, schema) {
        this.document = document;
        this.ngZone = ngZone;
        this.schema = schema;
        this.data = Object.create(null);
    }
    /**
     * @return {?}
     */
    DefaultServerRenderer2.prototype.destroy = /**
     * @return {?}
     */
    function () { };
    /**
     * @param {?} name
     * @param {?=} namespace
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createElement = /**
     * @param {?} name
     * @param {?=} namespace
     * @param {?=} debugInfo
     * @return {?}
     */
    function (name, namespace, debugInfo) {
        if (namespace) {
            return _angular_platformBrowser.ɵgetDOM().createElementNS(_angular_platformBrowser.ɵNAMESPACE_URIS[namespace], name);
        }
        return _angular_platformBrowser.ɵgetDOM().createElement(name);
    };
    /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createComment = /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    function (value, debugInfo) { return _angular_platformBrowser.ɵgetDOM().createComment(value); };
    /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.createText = /**
     * @param {?} value
     * @param {?=} debugInfo
     * @return {?}
     */
    function (value, debugInfo) { return _angular_platformBrowser.ɵgetDOM().createTextNode(value); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.appendChild = /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    function (parent, newChild) { _angular_platformBrowser.ɵgetDOM().appendChild(parent, newChild); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.insertBefore = /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    function (parent, newChild, refChild) {
        if (parent) {
            _angular_platformBrowser.ɵgetDOM().insertBefore(parent, refChild, newChild);
        }
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeChild = /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    function (parent, oldChild) {
        if (parent) {
            _angular_platformBrowser.ɵgetDOM().removeChild(parent, oldChild);
        }
    };
    /**
     * @param {?} selectorOrNode
     * @param {?=} debugInfo
     * @return {?}
     */
    DefaultServerRenderer2.prototype.selectRootElement = /**
     * @param {?} selectorOrNode
     * @param {?=} debugInfo
     * @return {?}
     */
    function (selectorOrNode, debugInfo) {
        var /** @type {?} */ el;
        if (typeof selectorOrNode === 'string') {
            el = _angular_platformBrowser.ɵgetDOM().querySelector(this.document, selectorOrNode);
            if (!el) {
                throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
            }
        }
        else {
            el = selectorOrNode;
        }
        _angular_platformBrowser.ɵgetDOM().clearNodes(el);
        return el;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    DefaultServerRenderer2.prototype.parentNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return _angular_platformBrowser.ɵgetDOM().parentElement(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    DefaultServerRenderer2.prototype.nextSibling = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return _angular_platformBrowser.ɵgetDOM().nextSibling(node); };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, value, namespace) {
        if (namespace) {
            _angular_platformBrowser.ɵgetDOM().setAttributeNS(el, _angular_platformBrowser.ɵNAMESPACE_URIS[namespace], namespace + ':' + name, value);
        }
        else {
            _angular_platformBrowser.ɵgetDOM().setAttribute(el, name, value);
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, namespace) {
        if (namespace) {
            _angular_platformBrowser.ɵgetDOM().removeAttributeNS(el, _angular_platformBrowser.ɵNAMESPACE_URIS[namespace], name);
        }
        else {
            _angular_platformBrowser.ɵgetDOM().removeAttribute(el, name);
        }
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DefaultServerRenderer2.prototype.addClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { _angular_platformBrowser.ɵgetDOM().addClass(el, name); };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { _angular_platformBrowser.ɵgetDOM().removeClass(el, name); };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?} flags
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?} flags
     * @return {?}
     */
    function (el, style, value, flags) {
        _angular_platformBrowser.ɵgetDOM().setStyle(el, style, value);
    };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} flags
     * @return {?}
     */
    DefaultServerRenderer2.prototype.removeStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?} flags
     * @return {?}
     */
    function (el, style, flags) {
        _angular_platformBrowser.ɵgetDOM().removeStyle(el, style);
    };
    /**
     * @param {?} tagName
     * @param {?} propertyName
     * @return {?}
     */
    DefaultServerRenderer2.prototype._isSafeToReflectProperty = /**
     * @param {?} tagName
     * @param {?} propertyName
     * @return {?}
     */
    function (tagName, propertyName) {
        return this.schema.securityContext(tagName, propertyName, true) ===
            this.schema.securityContext(tagName, propertyName, false);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        checkNoSyntheticProp(name, 'property');
        _angular_platformBrowser.ɵgetDOM().setProperty(el, name, value);
        // Mirror property values for known HTML element properties in the attributes.
        var /** @type {?} */ tagName = (/** @type {?} */ (el.tagName)).toLowerCase();
        if (value != null && (typeof value === 'number' || typeof value == 'string') &&
            this.schema.hasElement(tagName, EMPTY_ARRAY) &&
            this.schema.hasProperty(tagName, name, EMPTY_ARRAY) &&
            this._isSafeToReflectProperty(tagName, name)) {
            this.setAttribute(el, name, value.toString());
        }
    };
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    DefaultServerRenderer2.prototype.setValue = /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    function (node, value) { _angular_platformBrowser.ɵgetDOM().setText(node, value); };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    DefaultServerRenderer2.prototype.listen = /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (target, eventName, callback) {
        var _this = this;
        // Note: We are not using the EventsPlugin here as this is not needed
        // to run our tests.
        checkNoSyntheticProp(eventName, 'listener');
        var /** @type {?} */ el = typeof target === 'string' ? _angular_platformBrowser.ɵgetDOM().getGlobalEventTarget(this.document, target) : target;
        var /** @type {?} */ outsideHandler = function (event) { return _this.ngZone.runGuarded(function () { return callback(event); }); };
        return this.ngZone.runOutsideAngular(function () { return (_angular_platformBrowser.ɵgetDOM().onAndCancel(el, eventName, outsideHandler)); });
    };
    return DefaultServerRenderer2;
}());
var AT_CHARCODE = '@'.charCodeAt(0);
/**
 * @param {?} name
 * @param {?} nameKind
 * @return {?}
 */
function checkNoSyntheticProp(name, nameKind) {
    if (name.charCodeAt(0) === AT_CHARCODE) {
        throw new Error("Found the synthetic " + nameKind + " " + name + ". Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.");
    }
}
var EmulatedEncapsulationServerRenderer2 = /** @class */ (function (_super) {
    __extends(EmulatedEncapsulationServerRenderer2, _super);
    function EmulatedEncapsulationServerRenderer2(document, ngZone, sharedStylesHost, schema, component) {
        var _this = _super.call(this, document, ngZone, schema) || this;
        _this.component = component;
        var /** @type {?} */ styles = _angular_platformBrowser.ɵflattenStyles(component.id, component.styles, []);
        sharedStylesHost.addStyles(styles);
        _this.contentAttr = _angular_platformBrowser.ɵshimContentAttribute(component.id);
        _this.hostAttr = _angular_platformBrowser.ɵshimHostAttribute(component.id);
        return _this;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    EmulatedEncapsulationServerRenderer2.prototype.applyToHost = /**
     * @param {?} element
     * @return {?}
     */
    function (element) { _super.prototype.setAttribute.call(this, element, this.hostAttr, ''); };
    /**
     * @param {?} parent
     * @param {?} name
     * @return {?}
     */
    EmulatedEncapsulationServerRenderer2.prototype.createElement = /**
     * @param {?} parent
     * @param {?} name
     * @return {?}
     */
    function (parent, name) {
        var /** @type {?} */ el = _super.prototype.createElement.call(this, parent, name);
        _super.prototype.setAttribute.call(this, el, this.contentAttr, '');
        return el;
    };
    return EmulatedEncapsulationServerRenderer2;
}(DefaultServerRenderer2));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ServerStylesHost = /** @class */ (function (_super) {
    __extends(ServerStylesHost, _super);
    function ServerStylesHost(doc, transitionId) {
        var _this = _super.call(this) || this;
        _this.doc = doc;
        _this.transitionId = transitionId;
        _this.head = null;
        _this.head = _angular_platformBrowser.ɵgetDOM().getElementsByTagName(doc, 'head')[0];
        return _this;
    }
    /**
     * @param {?} style
     * @return {?}
     */
    ServerStylesHost.prototype._addStyle = /**
     * @param {?} style
     * @return {?}
     */
    function (style) {
        var /** @type {?} */ adapter = _angular_platformBrowser.ɵgetDOM();
        var /** @type {?} */ el = adapter.createElement('style');
        adapter.setText(el, style);
        if (!!this.transitionId) {
            adapter.setAttribute(el, 'ng-transition', this.transitionId);
        }
        adapter.appendChild(this.head, el);
    };
    /**
     * @param {?} additions
     * @return {?}
     */
    ServerStylesHost.prototype.onStylesAdded = /**
     * @param {?} additions
     * @return {?}
     */
    function (additions) {
        var _this = this;
        additions.forEach(function (style) { return _this._addStyle(style); });
    };
    ServerStylesHost.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    ServerStylesHost.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
        { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [_angular_platformBrowser.ɵTRANSITION_ID,] },] },
    ]; };
    return ServerStylesHost;
}(_angular_platformBrowser.ɵSharedStylesHost));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var INTERNAL_SERVER_PLATFORM_PROVIDERS = [
    { provide: _angular_platformBrowser.DOCUMENT, useFactory: _document, deps: [_angular_core.Injector] },
    { provide: _angular_core.PLATFORM_ID, useValue: _angular_common.ɵPLATFORM_SERVER_ID },
    { provide: _angular_core.PLATFORM_INITIALIZER, useFactory: initDominoAdapter, multi: true, deps: [_angular_core.Injector] }, {
        provide: _angular_common.PlatformLocation,
        useClass: ServerPlatformLocation,
        deps: [_angular_platformBrowser.DOCUMENT, [_angular_core.Optional, INITIAL_CONFIG]]
    },
    { provide: PlatformState, deps: [_angular_platformBrowser.DOCUMENT] },
    // Add special provider that allows multiple instances of platformServer* to be created.
    { provide: _angular_core.ɵALLOW_MULTIPLE_PLATFORMS, useValue: true }
];
/**
 * @param {?} injector
 * @return {?}
 */
function initDominoAdapter(injector) {
    return function () { DominoAdapter.makeCurrent(); };
}
/**
 * @param {?} renderer
 * @param {?} engine
 * @param {?} zone
 * @return {?}
 */
function instantiateServerRendererFactory(renderer, engine, zone) {
    return new _angular_platformBrowser_animations.ɵAnimationRendererFactory(renderer, engine, zone);
}
var SERVER_RENDER_PROVIDERS = [
    ServerRendererFactory2,
    {
        provide: _angular_core.RendererFactory2,
        useFactory: instantiateServerRendererFactory,
        deps: [ServerRendererFactory2, _angular_animations_browser.ɵAnimationEngine, _angular_core.NgZone]
    },
    ServerStylesHost,
    { provide: _angular_platformBrowser.ɵSharedStylesHost, useExisting: ServerStylesHost },
];
/**
 * The ng module for the server.
 *
 * \@experimental
 */
var ServerModule = /** @class */ (function () {
    function ServerModule() {
    }
    ServerModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    exports: [_angular_platformBrowser.BrowserModule],
                    imports: [_angular_http.HttpModule, _angular_common_http.HttpClientModule, _angular_platformBrowser_animations.NoopAnimationsModule],
                    providers: [
                        SERVER_RENDER_PROVIDERS,
                        SERVER_HTTP_PROVIDERS,
                        { provide: _angular_core.Testability, useValue: null },
                    ],
                },] },
    ];
    /** @nocollapse */
    ServerModule.ctorParameters = function () { return []; };
    return ServerModule;
}());
/**
 * @param {?} injector
 * @return {?}
 */
function _document(injector) {
    var /** @type {?} */ config = injector.get(INITIAL_CONFIG, null);
    if (config && config.document) {
        return parseDocument(config.document, config.url);
    }
    else {
        return _angular_platformBrowser.ɵgetDOM().createHtmlDocument();
    }
}
/**
 * \@experimental
 */
var platformServer = _angular_core.createPlatformFactory(_angular_core.platformCore, 'server', INTERNAL_SERVER_PLATFORM_PROVIDERS);
/**
 * The server platform that supports the runtime compiler.
 *
 * \@experimental
 */
var platformDynamicServer = _angular_core.createPlatformFactory(_angular_platformBrowserDynamic.ɵplatformCoreDynamic, 'serverDynamic', INTERNAL_SERVER_PLATFORM_PROVIDERS);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} doc
 * @param {?} appId
 * @param {?} transferStore
 * @return {?}
 */
function serializeTransferStateFactory(doc, appId, transferStore) {
    return function () {
        var /** @type {?} */ script = doc.createElement('script');
        script.id = appId + '-state';
        script.setAttribute('type', 'application/json');
        script.textContent = _angular_platformBrowser.ɵescapeHtml(transferStore.toJson());
        doc.body.appendChild(script);
    };
}
/**
 * NgModule to install on the server side while using the `TransferState` to transfer state from
 * server to client.
 *
 * \@experimental
 */
var ServerTransferStateModule = /** @class */ (function () {
    function ServerTransferStateModule() {
    }
    ServerTransferStateModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    providers: [
                        _angular_platformBrowser.TransferState, {
                            provide: BEFORE_APP_SERIALIZED,
                            useFactory: serializeTransferStateFactory,
                            deps: [_angular_platformBrowser.DOCUMENT, _angular_core.APP_ID, _angular_platformBrowser.TransferState],
                            multi: true,
                        }
                    ]
                },] },
    ];
    /** @nocollapse */
    ServerTransferStateModule.ctorParameters = function () { return []; };
    return ServerTransferStateModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @param {?} platformFactory
 * @param {?} options
 * @return {?}
 */
function _getPlatform(platformFactory, options) {
    var /** @type {?} */ extraProviders = options.extraProviders ? options.extraProviders : [];
    return platformFactory([
        { provide: INITIAL_CONFIG, useValue: { document: options.document, url: options.url } },
        extraProviders
    ]);
}
/**
 * @template T
 * @param {?} platform
 * @param {?} moduleRefPromise
 * @return {?}
 */
function _render(platform, moduleRefPromise) {
    return moduleRefPromise.then(function (moduleRef) {
        var /** @type {?} */ transitionId = moduleRef.injector.get(_angular_platformBrowser.ɵTRANSITION_ID, null);
        if (!transitionId) {
            throw new Error("renderModule[Factory]() requires the use of BrowserModule.withServerTransition() to ensure\nthe server-rendered app can be properly bootstrapped into a client app.");
        }
        var /** @type {?} */ applicationRef = moduleRef.injector.get(_angular_core.ApplicationRef);
        return rxjs_operator_toPromise.toPromise
            .call(rxjs_operator_first.first.call(rxjs_operator_filter.filter.call(applicationRef.isStable, function (isStable) { return isStable; })))
            .then(function () {
            var /** @type {?} */ platformState = platform.injector.get(PlatformState);
            // Run any BEFORE_APP_SERIALIZED callbacks just before rendering to string.
            var /** @type {?} */ callbacks = moduleRef.injector.get(BEFORE_APP_SERIALIZED, null);
            if (callbacks) {
                for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
                    var callback = callbacks_1[_i];
                    try {
                        callback();
                    }
                    catch (/** @type {?} */ e) {
                        // Ignore exceptions.
                        console.warn('Ignoring BEFORE_APP_SERIALIZED Exception: ', e);
                    }
                }
            }
            var /** @type {?} */ output = platformState.renderToString();
            platform.destroy();
            return output;
        });
    });
}
/**
 * Renders a Module to string.
 *
 * `document` is the full document HTML of the page to render, as a string.
 * `url` is the URL for the current render request.
 * `extraProviders` are the platform level providers for the current render request.
 *
 * Do not use this in a production server environment. Use pre-compiled {\@link NgModuleFactory} with
 * {\@link renderModuleFactory} instead.
 *
 * \@experimental
 * @template T
 * @param {?} module
 * @param {?} options
 * @return {?}
 */
function renderModule(module, options) {
    var /** @type {?} */ platform = _getPlatform(platformDynamicServer, options);
    return _render(platform, platform.bootstrapModule(module));
}
/**
 * Renders a {\@link NgModuleFactory} to string.
 *
 * `document` is the full document HTML of the page to render, as a string.
 * `url` is the URL for the current render request.
 * `extraProviders` are the platform level providers for the current render request.
 *
 * \@experimental
 * @template T
 * @param {?} moduleFactory
 * @param {?} options
 * @return {?}
 */
function renderModuleFactory(moduleFactory, options) {
    var /** @type {?} */ platform = _getPlatform(platformServer, options);
    return _render(platform, platform.bootstrapModuleFactory(moduleFactory));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@stable
 */
var VERSION = new _angular_core.Version('5.2.3');

exports.PlatformState = PlatformState;
exports.ServerModule = ServerModule;
exports.platformDynamicServer = platformDynamicServer;
exports.platformServer = platformServer;
exports.BEFORE_APP_SERIALIZED = BEFORE_APP_SERIALIZED;
exports.INITIAL_CONFIG = INITIAL_CONFIG;
exports.ServerTransferStateModule = ServerTransferStateModule;
exports.renderModule = renderModule;
exports.renderModuleFactory = renderModuleFactory;
exports.VERSION = VERSION;
exports.ɵINTERNAL_SERVER_PLATFORM_PROVIDERS = INTERNAL_SERVER_PLATFORM_PROVIDERS;
exports.ɵSERVER_RENDER_PROVIDERS = SERVER_RENDER_PROVIDERS;
exports.ɵServerRendererFactory2 = ServerRendererFactory2;
exports.ɵh = SERVER_HTTP_PROVIDERS;
exports.ɵd = ServerXhr;
exports.ɵe = ServerXsrfStrategy;
exports.ɵf = httpFactory;
exports.ɵg = zoneWrappedInterceptingHandler;
exports.ɵa = instantiateServerRendererFactory;
exports.ɵc = ServerStylesHost;
exports.ɵb = serializeTransferStateFactory;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=platform-server.umd.js.map


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(6);

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.2.3
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(32)) :
	typeof define === 'function' && define.amd ? define('@angular/animations/browser', ['exports', '@angular/animations'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.animations = global.ng.animations || {}, global.ng.animations.browser = {}),global.ng.animations));
}(this, (function (exports,_angular_animations) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

/**
 * @license Angular v5.2.3
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} players
 * @return {?}
 */
function optimizeGroupPlayer(players) {
    switch (players.length) {
        case 0:
            return new _angular_animations.NoopAnimationPlayer();
        case 1:
            return players[0];
        default:
            return new _angular_animations.ɵAnimationGroupPlayer(players);
    }
}
/**
 * @param {?} driver
 * @param {?} normalizer
 * @param {?} element
 * @param {?} keyframes
 * @param {?=} preStyles
 * @param {?=} postStyles
 * @return {?}
 */
function normalizeKeyframes(driver, normalizer, element, keyframes, preStyles, postStyles) {
    if (preStyles === void 0) { preStyles = {}; }
    if (postStyles === void 0) { postStyles = {}; }
    var /** @type {?} */ errors = [];
    var /** @type {?} */ normalizedKeyframes = [];
    var /** @type {?} */ previousOffset = -1;
    var /** @type {?} */ previousKeyframe = null;
    keyframes.forEach(function (kf) {
        var /** @type {?} */ offset = /** @type {?} */ (kf['offset']);
        var /** @type {?} */ isSameOffset = offset == previousOffset;
        var /** @type {?} */ normalizedKeyframe = (isSameOffset && previousKeyframe) || {};
        Object.keys(kf).forEach(function (prop) {
            var /** @type {?} */ normalizedProp = prop;
            var /** @type {?} */ normalizedValue = kf[prop];
            if (prop !== 'offset') {
                normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);
                switch (normalizedValue) {
                    case _angular_animations.ɵPRE_STYLE:
                        normalizedValue = preStyles[prop];
                        break;
                    case _angular_animations.AUTO_STYLE:
                        normalizedValue = postStyles[prop];
                        break;
                    default:
                        normalizedValue =
                            normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
                        break;
                }
            }
            normalizedKeyframe[normalizedProp] = normalizedValue;
        });
        if (!isSameOffset) {
            normalizedKeyframes.push(normalizedKeyframe);
        }
        previousKeyframe = normalizedKeyframe;
        previousOffset = offset;
    });
    if (errors.length) {
        var /** @type {?} */ LINE_START = '\n - ';
        throw new Error("Unable to animate due to the following errors:" + LINE_START + errors.join(LINE_START));
    }
    return normalizedKeyframes;
}
/**
 * @param {?} player
 * @param {?} eventName
 * @param {?} event
 * @param {?} callback
 * @return {?}
 */
function listenOnPlayer(player, eventName, event, callback) {
    switch (eventName) {
        case 'start':
            player.onStart(function () { return callback(event && copyAnimationEvent(event, 'start', player.totalTime)); });
            break;
        case 'done':
            player.onDone(function () { return callback(event && copyAnimationEvent(event, 'done', player.totalTime)); });
            break;
        case 'destroy':
            player.onDestroy(function () { return callback(event && copyAnimationEvent(event, 'destroy', player.totalTime)); });
            break;
    }
}
/**
 * @param {?} e
 * @param {?=} phaseName
 * @param {?=} totalTime
 * @return {?}
 */
function copyAnimationEvent(e, phaseName, totalTime) {
    var /** @type {?} */ event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime);
    var /** @type {?} */ data = (/** @type {?} */ (e))['_data'];
    if (data != null) {
        (/** @type {?} */ (event))['_data'] = data;
    }
    return event;
}
/**
 * @param {?} element
 * @param {?} triggerName
 * @param {?} fromState
 * @param {?} toState
 * @param {?=} phaseName
 * @param {?=} totalTime
 * @return {?}
 */
function makeAnimationEvent(element, triggerName, fromState, toState, phaseName, totalTime) {
    if (phaseName === void 0) { phaseName = ''; }
    if (totalTime === void 0) { totalTime = 0; }
    return { element: element, triggerName: triggerName, fromState: fromState, toState: toState, phaseName: phaseName, totalTime: totalTime };
}
/**
 * @param {?} map
 * @param {?} key
 * @param {?} defaultValue
 * @return {?}
 */
function getOrSetAsInMap(map, key, defaultValue) {
    var /** @type {?} */ value;
    if (map instanceof Map) {
        value = map.get(key);
        if (!value) {
            map.set(key, value = defaultValue);
        }
    }
    else {
        value = map[key];
        if (!value) {
            value = map[key] = defaultValue;
        }
    }
    return value;
}
/**
 * @param {?} command
 * @return {?}
 */
function parseTimelineCommand(command) {
    var /** @type {?} */ separatorPos = command.indexOf(':');
    var /** @type {?} */ id = command.substring(1, separatorPos);
    var /** @type {?} */ action = command.substr(separatorPos + 1);
    return [id, action];
}
var _contains = function (elm1, elm2) { return false; };
var _matches = function (element, selector) {
    return false;
};
var _query = function (element, selector, multi) {
    return [];
};
if (typeof Element != 'undefined') {
    // this is well supported in all browsers
    _contains = function (elm1, elm2) { return /** @type {?} */ (elm1.contains(elm2)); };
    if (Element.prototype.matches) {
        _matches = function (element, selector) { return element.matches(selector); };
    }
    else {
        var /** @type {?} */ proto = /** @type {?} */ (Element.prototype);
        var /** @type {?} */ fn_1 = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||
            proto.oMatchesSelector || proto.webkitMatchesSelector;
        if (fn_1) {
            _matches = function (element, selector) { return fn_1.apply(element, [selector]); };
        }
    }
    _query = function (element, selector, multi) {
        var /** @type {?} */ results = [];
        if (multi) {
            results.push.apply(results, element.querySelectorAll(selector));
        }
        else {
            var /** @type {?} */ elm = element.querySelector(selector);
            if (elm) {
                results.push(elm);
            }
        }
        return results;
    };
}
/**
 * @param {?} prop
 * @return {?}
 */
function containsVendorPrefix(prop) {
    // Webkit is the only real popular vendor prefix nowadays
    // cc: http://shouldiprefix.com/
    return prop.substring(1, 6) == 'ebkit'; // webkit or Webkit
}
var _CACHED_BODY = null;
var _IS_WEBKIT = false;
/**
 * @param {?} prop
 * @return {?}
 */
function validateStyleProperty(prop) {
    if (!_CACHED_BODY) {
        _CACHED_BODY = getBodyNode() || {};
        _IS_WEBKIT = /** @type {?} */ ((_CACHED_BODY)).style ? ('WebkitAppearance' in /** @type {?} */ ((_CACHED_BODY)).style) : false;
    }
    var /** @type {?} */ result = true;
    if (/** @type {?} */ ((_CACHED_BODY)).style && !containsVendorPrefix(prop)) {
        result = prop in /** @type {?} */ ((_CACHED_BODY)).style;
        if (!result && _IS_WEBKIT) {
            var /** @type {?} */ camelProp = 'Webkit' + prop.charAt(0).toUpperCase() + prop.substr(1);
            result = camelProp in /** @type {?} */ ((_CACHED_BODY)).style;
        }
    }
    return result;
}
/**
 * @return {?}
 */
function getBodyNode() {
    if (typeof document != 'undefined') {
        return document.body;
    }
    return null;
}
var matchesElement = _matches;
var containsElement = _contains;
var invokeQuery = _query;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@experimental
 */
var NoopAnimationDriver = /** @class */ (function () {
    function NoopAnimationDriver() {
    }
    /**
     * @param {?} prop
     * @return {?}
     */
    NoopAnimationDriver.prototype.validateStyleProperty = /**
     * @param {?} prop
     * @return {?}
     */
    function (prop) { return validateStyleProperty(prop); };
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    NoopAnimationDriver.prototype.matchesElement = /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    function (element, selector) {
        return matchesElement(element, selector);
    };
    /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    NoopAnimationDriver.prototype.containsElement = /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    function (elm1, elm2) { return containsElement(elm1, elm2); };
    /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    NoopAnimationDriver.prototype.query = /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    function (element, selector, multi) {
        return invokeQuery(element, selector, multi);
    };
    /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    NoopAnimationDriver.prototype.computeStyle = /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    function (element, prop, defaultValue) {
        return defaultValue || '';
    };
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    NoopAnimationDriver.prototype.animate = /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    function (element, keyframes, duration, delay, easing, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        return new _angular_animations.NoopAnimationPlayer();
    };
    return NoopAnimationDriver;
}());
/**
 * \@experimental
 * @abstract
 */
var AnimationDriver = /** @class */ (function () {
    function AnimationDriver() {
    }
    AnimationDriver.NOOP = new NoopAnimationDriver();
    return AnimationDriver;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ONE_SECOND = 1000;
var SUBSTITUTION_EXPR_START = '{{';
var SUBSTITUTION_EXPR_END = '}}';
var ENTER_CLASSNAME = 'ng-enter';
var LEAVE_CLASSNAME = 'ng-leave';


var NG_TRIGGER_CLASSNAME = 'ng-trigger';
var NG_TRIGGER_SELECTOR = '.ng-trigger';
var NG_ANIMATING_CLASSNAME = 'ng-animating';
var NG_ANIMATING_SELECTOR = '.ng-animating';
/**
 * @param {?} value
 * @return {?}
 */
function resolveTimingValue(value) {
    if (typeof value == 'number')
        return value;
    var /** @type {?} */ matches = (/** @type {?} */ (value)).match(/^(-?[\.\d]+)(m?s)/);
    if (!matches || matches.length < 2)
        return 0;
    return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
}
/**
 * @param {?} value
 * @param {?} unit
 * @return {?}
 */
function _convertTimeValueToMS(value, unit) {
    switch (unit) {
        case 's':
            return value * ONE_SECOND;
        default:
            // ms or something else
            return value;
    }
}
/**
 * @param {?} timings
 * @param {?} errors
 * @param {?=} allowNegativeValues
 * @return {?}
 */
function resolveTiming(timings, errors, allowNegativeValues) {
    return timings.hasOwnProperty('duration') ? /** @type {?} */ (timings) :
        parseTimeExpression(/** @type {?} */ (timings), errors, allowNegativeValues);
}
/**
 * @param {?} exp
 * @param {?} errors
 * @param {?=} allowNegativeValues
 * @return {?}
 */
function parseTimeExpression(exp, errors, allowNegativeValues) {
    var /** @type {?} */ regex = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
    var /** @type {?} */ duration;
    var /** @type {?} */ delay = 0;
    var /** @type {?} */ easing = '';
    if (typeof exp === 'string') {
        var /** @type {?} */ matches = exp.match(regex);
        if (matches === null) {
            errors.push("The provided timing value \"" + exp + "\" is invalid.");
            return { duration: 0, delay: 0, easing: '' };
        }
        duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
        var /** @type {?} */ delayMatch = matches[3];
        if (delayMatch != null) {
            delay = _convertTimeValueToMS(Math.floor(parseFloat(delayMatch)), matches[4]);
        }
        var /** @type {?} */ easingVal = matches[5];
        if (easingVal) {
            easing = easingVal;
        }
    }
    else {
        duration = /** @type {?} */ (exp);
    }
    if (!allowNegativeValues) {
        var /** @type {?} */ containsErrors = false;
        var /** @type {?} */ startIndex = errors.length;
        if (duration < 0) {
            errors.push("Duration values below 0 are not allowed for this animation step.");
            containsErrors = true;
        }
        if (delay < 0) {
            errors.push("Delay values below 0 are not allowed for this animation step.");
            containsErrors = true;
        }
        if (containsErrors) {
            errors.splice(startIndex, 0, "The provided timing value \"" + exp + "\" is invalid.");
        }
    }
    return { duration: duration, delay: delay, easing: easing };
}
/**
 * @param {?} obj
 * @param {?=} destination
 * @return {?}
 */
function copyObj(obj, destination) {
    if (destination === void 0) { destination = {}; }
    Object.keys(obj).forEach(function (prop) { destination[prop] = obj[prop]; });
    return destination;
}
/**
 * @param {?} styles
 * @return {?}
 */
function normalizeStyles(styles) {
    var /** @type {?} */ normalizedStyles = {};
    if (Array.isArray(styles)) {
        styles.forEach(function (data) { return copyStyles(data, false, normalizedStyles); });
    }
    else {
        copyStyles(styles, false, normalizedStyles);
    }
    return normalizedStyles;
}
/**
 * @param {?} styles
 * @param {?} readPrototype
 * @param {?=} destination
 * @return {?}
 */
function copyStyles(styles, readPrototype, destination) {
    if (destination === void 0) { destination = {}; }
    if (readPrototype) {
        // we make use of a for-in loop so that the
        // prototypically inherited properties are
        // revealed from the backFill map
        for (var /** @type {?} */ prop in styles) {
            destination[prop] = styles[prop];
        }
    }
    else {
        copyObj(styles, destination);
    }
    return destination;
}
/**
 * @param {?} element
 * @param {?} styles
 * @return {?}
 */
function setStyles(element, styles) {
    if (element['style']) {
        Object.keys(styles).forEach(function (prop) {
            var /** @type {?} */ camelProp = dashCaseToCamelCase(prop);
            element.style[camelProp] = styles[prop];
        });
    }
}
/**
 * @param {?} element
 * @param {?} styles
 * @return {?}
 */
function eraseStyles(element, styles) {
    if (element['style']) {
        Object.keys(styles).forEach(function (prop) {
            var /** @type {?} */ camelProp = dashCaseToCamelCase(prop);
            element.style[camelProp] = '';
        });
    }
}
/**
 * @param {?} steps
 * @return {?}
 */
function normalizeAnimationEntry(steps) {
    if (Array.isArray(steps)) {
        if (steps.length == 1)
            return steps[0];
        return _angular_animations.sequence(steps);
    }
    return /** @type {?} */ (steps);
}
/**
 * @param {?} value
 * @param {?} options
 * @param {?} errors
 * @return {?}
 */
function validateStyleParams(value, options, errors) {
    var /** @type {?} */ params = options.params || {};
    var /** @type {?} */ matches = extractStyleParams(value);
    if (matches.length) {
        matches.forEach(function (varName) {
            if (!params.hasOwnProperty(varName)) {
                errors.push("Unable to resolve the local animation param " + varName + " in the given list of values");
            }
        });
    }
}
var PARAM_REGEX = new RegExp(SUBSTITUTION_EXPR_START + "\\s*(.+?)\\s*" + SUBSTITUTION_EXPR_END, 'g');
/**
 * @param {?} value
 * @return {?}
 */
function extractStyleParams(value) {
    var /** @type {?} */ params = [];
    if (typeof value === 'string') {
        var /** @type {?} */ val = value.toString();
        var /** @type {?} */ match = void 0;
        while (match = PARAM_REGEX.exec(val)) {
            params.push(/** @type {?} */ (match[1]));
        }
        PARAM_REGEX.lastIndex = 0;
    }
    return params;
}
/**
 * @param {?} value
 * @param {?} params
 * @param {?} errors
 * @return {?}
 */
function interpolateParams(value, params, errors) {
    var /** @type {?} */ original = value.toString();
    var /** @type {?} */ str = original.replace(PARAM_REGEX, function (_, varName) {
        var /** @type {?} */ localVal = params[varName];
        // this means that the value was never overidden by the data passed in by the user
        if (!params.hasOwnProperty(varName)) {
            errors.push("Please provide a value for the animation param " + varName);
            localVal = '';
        }
        return localVal.toString();
    });
    // we do this to assert that numeric values stay as they are
    return str == original ? value : str;
}
/**
 * @param {?} iterator
 * @return {?}
 */
function iteratorToArray(iterator) {
    var /** @type {?} */ arr = [];
    var /** @type {?} */ item = iterator.next();
    while (!item.done) {
        arr.push(item.value);
        item = iterator.next();
    }
    return arr;
}
/**
 * @param {?} source
 * @param {?} destination
 * @return {?}
 */

var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
/**
 * @param {?} input
 * @return {?}
 */
function dashCaseToCamelCase(input) {
    return input.replace(DASH_CASE_REGEXP, function () {
        var m = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            m[_i] = arguments[_i];
        }
        return m[1].toUpperCase();
    });
}
/**
 * @param {?} duration
 * @param {?} delay
 * @return {?}
 */
function allowPreviousPlayerStylesMerge(duration, delay) {
    return duration === 0 || delay === 0;
}
/**
 * @param {?} visitor
 * @param {?} node
 * @param {?} context
 * @return {?}
 */
function visitDslNode(visitor, node, context) {
    switch (node.type) {
        case 7 /* Trigger */:
            return visitor.visitTrigger(node, context);
        case 0 /* State */:
            return visitor.visitState(node, context);
        case 1 /* Transition */:
            return visitor.visitTransition(node, context);
        case 2 /* Sequence */:
            return visitor.visitSequence(node, context);
        case 3 /* Group */:
            return visitor.visitGroup(node, context);
        case 4 /* Animate */:
            return visitor.visitAnimate(node, context);
        case 5 /* Keyframes */:
            return visitor.visitKeyframes(node, context);
        case 6 /* Style */:
            return visitor.visitStyle(node, context);
        case 8 /* Reference */:
            return visitor.visitReference(node, context);
        case 9 /* AnimateChild */:
            return visitor.visitAnimateChild(node, context);
        case 10 /* AnimateRef */:
            return visitor.visitAnimateRef(node, context);
        case 11 /* Query */:
            return visitor.visitQuery(node, context);
        case 12 /* Stagger */:
            return visitor.visitStagger(node, context);
        default:
            throw new Error("Unable to resolve animation metadata node #" + node.type);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ANY_STATE = '*';
/**
 * @param {?} transitionValue
 * @param {?} errors
 * @return {?}
 */
function parseTransitionExpr(transitionValue, errors) {
    var /** @type {?} */ expressions = [];
    if (typeof transitionValue == 'string') {
        (/** @type {?} */ (transitionValue))
            .split(/\s*,\s*/)
            .forEach(function (str) { return parseInnerTransitionStr(str, expressions, errors); });
    }
    else {
        expressions.push(/** @type {?} */ (transitionValue));
    }
    return expressions;
}
/**
 * @param {?} eventStr
 * @param {?} expressions
 * @param {?} errors
 * @return {?}
 */
function parseInnerTransitionStr(eventStr, expressions, errors) {
    if (eventStr[0] == ':') {
        var /** @type {?} */ result = parseAnimationAlias(eventStr, errors);
        if (typeof result == 'function') {
            expressions.push(result);
            return;
        }
        eventStr = /** @type {?} */ (result);
    }
    var /** @type {?} */ match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
    if (match == null || match.length < 4) {
        errors.push("The provided transition expression \"" + eventStr + "\" is not supported");
        return expressions;
    }
    var /** @type {?} */ fromState = match[1];
    var /** @type {?} */ separator = match[2];
    var /** @type {?} */ toState = match[3];
    expressions.push(makeLambdaFromStates(fromState, toState));
    var /** @type {?} */ isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
    if (separator[0] == '<' && !isFullAnyStateExpr) {
        expressions.push(makeLambdaFromStates(toState, fromState));
    }
}
/**
 * @param {?} alias
 * @param {?} errors
 * @return {?}
 */
function parseAnimationAlias(alias, errors) {
    switch (alias) {
        case ':enter':
            return 'void => *';
        case ':leave':
            return '* => void';
        case ':increment':
            return function (fromState, toState) { return parseFloat(toState) > parseFloat(fromState); };
        case ':decrement':
            return function (fromState, toState) { return parseFloat(toState) < parseFloat(fromState); };
        default:
            errors.push("The transition alias value \"" + alias + "\" is not supported");
            return '* => *';
    }
}
// DO NOT REFACTOR ... keep the follow set instantiations
// with the values intact (closure compiler for some reason
// removes follow-up lines that add the values outside of
// the constructor...
var TRUE_BOOLEAN_VALUES = new Set(['true', '1']);
var FALSE_BOOLEAN_VALUES = new Set(['false', '0']);
/**
 * @param {?} lhs
 * @param {?} rhs
 * @return {?}
 */
function makeLambdaFromStates(lhs, rhs) {
    var /** @type {?} */ LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);
    var /** @type {?} */ RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);
    return function (fromState, toState) {
        var /** @type {?} */ lhsMatch = lhs == ANY_STATE || lhs == fromState;
        var /** @type {?} */ rhsMatch = rhs == ANY_STATE || rhs == toState;
        if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {
            lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);
        }
        if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {
            rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);
        }
        return lhsMatch && rhsMatch;
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SELF_TOKEN = ':self';
var SELF_TOKEN_REGEX = new RegExp("s*" + SELF_TOKEN + "s*,?", 'g');
/**
 * @param {?} driver
 * @param {?} metadata
 * @param {?} errors
 * @return {?}
 */
function buildAnimationAst(driver, metadata, errors) {
    return new AnimationAstBuilderVisitor(driver).build(metadata, errors);
}
var ROOT_SELECTOR = '';
var AnimationAstBuilderVisitor = /** @class */ (function () {
    function AnimationAstBuilderVisitor(_driver) {
        this._driver = _driver;
    }
    /**
     * @param {?} metadata
     * @param {?} errors
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.build = /**
     * @param {?} metadata
     * @param {?} errors
     * @return {?}
     */
    function (metadata, errors) {
        var /** @type {?} */ context = new AnimationAstBuilderContext(errors);
        this._resetContextStyleTimingState(context);
        return /** @type {?} */ (visitDslNode(this, normalizeAnimationEntry(metadata), context));
    };
    /**
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._resetContextStyleTimingState = /**
     * @param {?} context
     * @return {?}
     */
    function (context) {
        context.currentQuerySelector = ROOT_SELECTOR;
        context.collectedStyles = {};
        context.collectedStyles[ROOT_SELECTOR] = {};
        context.currentTime = 0;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitTrigger = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        var /** @type {?} */ queryCount = context.queryCount = 0;
        var /** @type {?} */ depCount = context.depCount = 0;
        var /** @type {?} */ states = [];
        var /** @type {?} */ transitions = [];
        if (metadata.name.charAt(0) == '@') {
            context.errors.push('animation triggers cannot be prefixed with an `@` sign (e.g. trigger(\'@foo\', [...]))');
        }
        metadata.definitions.forEach(function (def) {
            _this._resetContextStyleTimingState(context);
            if (def.type == 0 /* State */) {
                var /** @type {?} */ stateDef_1 = /** @type {?} */ (def);
                var /** @type {?} */ name_1 = stateDef_1.name;
                name_1.split(/\s*,\s*/).forEach(function (n) {
                    stateDef_1.name = n;
                    states.push(_this.visitState(stateDef_1, context));
                });
                stateDef_1.name = name_1;
            }
            else if (def.type == 1 /* Transition */) {
                var /** @type {?} */ transition = _this.visitTransition(/** @type {?} */ (def), context);
                queryCount += transition.queryCount;
                depCount += transition.depCount;
                transitions.push(transition);
            }
            else {
                context.errors.push('only state() and transition() definitions can sit inside of a trigger()');
            }
        });
        return {
            type: 7 /* Trigger */,
            name: metadata.name, states: states, transitions: transitions, queryCount: queryCount, depCount: depCount,
            options: null
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitState = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ styleAst = this.visitStyle(metadata.styles, context);
        var /** @type {?} */ astParams = (metadata.options && metadata.options.params) || null;
        if (styleAst.containsDynamicStyles) {
            var /** @type {?} */ missingSubs_1 = new Set();
            var /** @type {?} */ params_1 = astParams || {};
            styleAst.styles.forEach(function (value) {
                if (isObject(value)) {
                    var /** @type {?} */ stylesObj_1 = /** @type {?} */ (value);
                    Object.keys(stylesObj_1).forEach(function (prop) {
                        extractStyleParams(stylesObj_1[prop]).forEach(function (sub) {
                            if (!params_1.hasOwnProperty(sub)) {
                                missingSubs_1.add(sub);
                            }
                        });
                    });
                }
            });
            if (missingSubs_1.size) {
                var /** @type {?} */ missingSubsArr = iteratorToArray(missingSubs_1.values());
                context.errors.push("state(\"" + metadata.name + "\", ...) must define default values for all the following style substitutions: " + missingSubsArr.join(', '));
            }
        }
        return {
            type: 0 /* State */,
            name: metadata.name,
            style: styleAst,
            options: astParams ? { params: astParams } : null
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitTransition = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        context.queryCount = 0;
        context.depCount = 0;
        var /** @type {?} */ animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
        var /** @type {?} */ matchers = parseTransitionExpr(metadata.expr, context.errors);
        return {
            type: 1 /* Transition */,
            matchers: matchers,
            animation: animation,
            queryCount: context.queryCount,
            depCount: context.depCount,
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitSequence = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        return {
            type: 2 /* Sequence */,
            steps: metadata.steps.map(function (s) { return visitDslNode(_this, s, context); }),
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitGroup = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        var /** @type {?} */ currentTime = context.currentTime;
        var /** @type {?} */ furthestTime = 0;
        var /** @type {?} */ steps = metadata.steps.map(function (step) {
            context.currentTime = currentTime;
            var /** @type {?} */ innerAst = visitDslNode(_this, step, context);
            furthestTime = Math.max(furthestTime, context.currentTime);
            return innerAst;
        });
        context.currentTime = furthestTime;
        return {
            type: 3 /* Group */,
            steps: steps,
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimate = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ timingAst = constructTimingAst(metadata.timings, context.errors);
        context.currentAnimateTimings = timingAst;
        var /** @type {?} */ styleAst;
        var /** @type {?} */ styleMetadata = metadata.styles ? metadata.styles : _angular_animations.style({});
        if (styleMetadata.type == 5 /* Keyframes */) {
            styleAst = this.visitKeyframes(/** @type {?} */ (styleMetadata), context);
        }
        else {
            var /** @type {?} */ styleMetadata_1 = /** @type {?} */ (metadata.styles);
            var /** @type {?} */ isEmpty = false;
            if (!styleMetadata_1) {
                isEmpty = true;
                var /** @type {?} */ newStyleData = {};
                if (timingAst.easing) {
                    newStyleData['easing'] = timingAst.easing;
                }
                styleMetadata_1 = _angular_animations.style(newStyleData);
            }
            context.currentTime += timingAst.duration + timingAst.delay;
            var /** @type {?} */ _styleAst = this.visitStyle(styleMetadata_1, context);
            _styleAst.isEmptyStep = isEmpty;
            styleAst = _styleAst;
        }
        context.currentAnimateTimings = null;
        return {
            type: 4 /* Animate */,
            timings: timingAst,
            style: styleAst,
            options: null
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitStyle = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ ast = this._makeStyleAst(metadata, context);
        this._validateStyleAst(ast, context);
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._makeStyleAst = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ styles = [];
        if (Array.isArray(metadata.styles)) {
            (/** @type {?} */ (metadata.styles)).forEach(function (styleTuple) {
                if (typeof styleTuple == 'string') {
                    if (styleTuple == _angular_animations.AUTO_STYLE) {
                        styles.push(/** @type {?} */ (styleTuple));
                    }
                    else {
                        context.errors.push("The provided style string value " + styleTuple + " is not allowed.");
                    }
                }
                else {
                    styles.push(/** @type {?} */ (styleTuple));
                }
            });
        }
        else {
            styles.push(metadata.styles);
        }
        var /** @type {?} */ containsDynamicStyles = false;
        var /** @type {?} */ collectedEasing = null;
        styles.forEach(function (styleData) {
            if (isObject(styleData)) {
                var /** @type {?} */ styleMap = /** @type {?} */ (styleData);
                var /** @type {?} */ easing = styleMap['easing'];
                if (easing) {
                    collectedEasing = /** @type {?} */ (easing);
                    delete styleMap['easing'];
                }
                if (!containsDynamicStyles) {
                    for (var /** @type {?} */ prop in styleMap) {
                        var /** @type {?} */ value = styleMap[prop];
                        if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {
                            containsDynamicStyles = true;
                            break;
                        }
                    }
                }
            }
        });
        return {
            type: 6 /* Style */,
            styles: styles,
            easing: collectedEasing,
            offset: metadata.offset, containsDynamicStyles: containsDynamicStyles,
            options: null
        };
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype._validateStyleAst = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        var /** @type {?} */ timings = context.currentAnimateTimings;
        var /** @type {?} */ endTime = context.currentTime;
        var /** @type {?} */ startTime = context.currentTime;
        if (timings && startTime > 0) {
            startTime -= timings.duration + timings.delay;
        }
        ast.styles.forEach(function (tuple) {
            if (typeof tuple == 'string')
                return;
            Object.keys(tuple).forEach(function (prop) {
                if (!_this._driver.validateStyleProperty(prop)) {
                    context.errors.push("The provided animation property \"" + prop + "\" is not a supported CSS property for animations");
                    return;
                }
                var /** @type {?} */ collectedStyles = context.collectedStyles[/** @type {?} */ ((context.currentQuerySelector))];
                var /** @type {?} */ collectedEntry = collectedStyles[prop];
                var /** @type {?} */ updateCollectedStyle = true;
                if (collectedEntry) {
                    if (startTime != endTime && startTime >= collectedEntry.startTime &&
                        endTime <= collectedEntry.endTime) {
                        context.errors.push("The CSS property \"" + prop + "\" that exists between the times of \"" + collectedEntry.startTime + "ms\" and \"" + collectedEntry.endTime + "ms\" is also being animated in a parallel animation between the times of \"" + startTime + "ms\" and \"" + endTime + "ms\"");
                        updateCollectedStyle = false;
                    }
                    // we always choose the smaller start time value since we
                    // want to have a record of the entire animation window where
                    // the style property is being animated in between
                    startTime = collectedEntry.startTime;
                }
                if (updateCollectedStyle) {
                    collectedStyles[prop] = { startTime: startTime, endTime: endTime };
                }
                if (context.options) {
                    validateStyleParams(tuple[prop], context.options, context.errors);
                }
            });
        });
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitKeyframes = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var _this = this;
        var /** @type {?} */ ast = { type: 5 /* Keyframes */, styles: [], options: null };
        if (!context.currentAnimateTimings) {
            context.errors.push("keyframes() must be placed inside of a call to animate()");
            return ast;
        }
        var /** @type {?} */ MAX_KEYFRAME_OFFSET = 1;
        var /** @type {?} */ totalKeyframesWithOffsets = 0;
        var /** @type {?} */ offsets = [];
        var /** @type {?} */ offsetsOutOfOrder = false;
        var /** @type {?} */ keyframesOutOfRange = false;
        var /** @type {?} */ previousOffset = 0;
        var /** @type {?} */ keyframes = metadata.steps.map(function (styles) {
            var /** @type {?} */ style$$1 = _this._makeStyleAst(styles, context);
            var /** @type {?} */ offsetVal = style$$1.offset != null ? style$$1.offset : consumeOffset(style$$1.styles);
            var /** @type {?} */ offset = 0;
            if (offsetVal != null) {
                totalKeyframesWithOffsets++;
                offset = style$$1.offset = offsetVal;
            }
            keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;
            offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;
            previousOffset = offset;
            offsets.push(offset);
            return style$$1;
        });
        if (keyframesOutOfRange) {
            context.errors.push("Please ensure that all keyframe offsets are between 0 and 1");
        }
        if (offsetsOutOfOrder) {
            context.errors.push("Please ensure that all keyframe offsets are in order");
        }
        var /** @type {?} */ length = metadata.steps.length;
        var /** @type {?} */ generatedOffset = 0;
        if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
            context.errors.push("Not all style() steps within the declared keyframes() contain offsets");
        }
        else if (totalKeyframesWithOffsets == 0) {
            generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
        }
        var /** @type {?} */ limit = length - 1;
        var /** @type {?} */ currentTime = context.currentTime;
        var /** @type {?} */ currentAnimateTimings = /** @type {?} */ ((context.currentAnimateTimings));
        var /** @type {?} */ animateDuration = currentAnimateTimings.duration;
        keyframes.forEach(function (kf, i) {
            var /** @type {?} */ offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];
            var /** @type {?} */ durationUpToThisFrame = offset * animateDuration;
            context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;
            currentAnimateTimings.duration = durationUpToThisFrame;
            _this._validateStyleAst(kf, context);
            kf.offset = offset;
            ast.styles.push(kf);
        });
        return ast;
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitReference = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        return {
            type: 8 /* Reference */,
            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimateChild = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        context.depCount++;
        return {
            type: 9 /* AnimateChild */,
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitAnimateRef = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        return {
            type: 10 /* AnimateRef */,
            animation: this.visitReference(metadata.animation, context),
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitQuery = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        var /** @type {?} */ parentSelector = /** @type {?} */ ((context.currentQuerySelector));
        var /** @type {?} */ options = /** @type {?} */ ((metadata.options || {}));
        context.queryCount++;
        context.currentQuery = metadata;
        var _a = normalizeSelector(metadata.selector), selector = _a[0], includeSelf = _a[1];
        context.currentQuerySelector =
            parentSelector.length ? (parentSelector + ' ' + selector) : selector;
        getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});
        var /** @type {?} */ animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
        context.currentQuery = null;
        context.currentQuerySelector = parentSelector;
        return {
            type: 11 /* Query */,
            selector: selector,
            limit: options.limit || 0,
            optional: !!options.optional, includeSelf: includeSelf, animation: animation,
            originalSelector: metadata.selector,
            options: normalizeAnimationOptions(metadata.options)
        };
    };
    /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    AnimationAstBuilderVisitor.prototype.visitStagger = /**
     * @param {?} metadata
     * @param {?} context
     * @return {?}
     */
    function (metadata, context) {
        if (!context.currentQuery) {
            context.errors.push("stagger() can only be used inside of query()");
        }
        var /** @type {?} */ timings = metadata.timings === 'full' ?
            { duration: 0, delay: 0, easing: 'full' } :
            resolveTiming(metadata.timings, context.errors, true);
        return {
            type: 12 /* Stagger */,
            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context), timings: timings,
            options: null
        };
    };
    return AnimationAstBuilderVisitor;
}());
/**
 * @param {?} selector
 * @return {?}
 */
function normalizeSelector(selector) {
    var /** @type {?} */ hasAmpersand = selector.split(/\s*,\s*/).find(function (token) { return token == SELF_TOKEN; }) ? true : false;
    if (hasAmpersand) {
        selector = selector.replace(SELF_TOKEN_REGEX, '');
    }
    // the :enter and :leave selectors are filled in at runtime during timeline building
    selector = selector.replace(/@\*/g, NG_TRIGGER_SELECTOR)
        .replace(/@\w+/g, function (match) { return NG_TRIGGER_SELECTOR + '-' + match.substr(1); })
        .replace(/:animating/g, NG_ANIMATING_SELECTOR);
    return [selector, hasAmpersand];
}
/**
 * @param {?} obj
 * @return {?}
 */
function normalizeParams(obj) {
    return obj ? copyObj(obj) : null;
}
var AnimationAstBuilderContext = /** @class */ (function () {
    function AnimationAstBuilderContext(errors) {
        this.errors = errors;
        this.queryCount = 0;
        this.depCount = 0;
        this.currentTransition = null;
        this.currentQuery = null;
        this.currentQuerySelector = null;
        this.currentAnimateTimings = null;
        this.currentTime = 0;
        this.collectedStyles = {};
        this.options = null;
    }
    return AnimationAstBuilderContext;
}());
/**
 * @param {?} styles
 * @return {?}
 */
function consumeOffset(styles) {
    if (typeof styles == 'string')
        return null;
    var /** @type {?} */ offset = null;
    if (Array.isArray(styles)) {
        styles.forEach(function (styleTuple) {
            if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {
                var /** @type {?} */ obj = /** @type {?} */ (styleTuple);
                offset = parseFloat(/** @type {?} */ (obj['offset']));
                delete obj['offset'];
            }
        });
    }
    else if (isObject(styles) && styles.hasOwnProperty('offset')) {
        var /** @type {?} */ obj = /** @type {?} */ (styles);
        offset = parseFloat(/** @type {?} */ (obj['offset']));
        delete obj['offset'];
    }
    return offset;
}
/**
 * @param {?} value
 * @return {?}
 */
function isObject(value) {
    return !Array.isArray(value) && typeof value == 'object';
}
/**
 * @param {?} value
 * @param {?} errors
 * @return {?}
 */
function constructTimingAst(value, errors) {
    var /** @type {?} */ timings = null;
    if (value.hasOwnProperty('duration')) {
        timings = /** @type {?} */ (value);
    }
    else if (typeof value == 'number') {
        var /** @type {?} */ duration = resolveTiming(/** @type {?} */ (value), errors).duration;
        return makeTimingAst(/** @type {?} */ (duration), 0, '');
    }
    var /** @type {?} */ strValue = /** @type {?} */ (value);
    var /** @type {?} */ isDynamic = strValue.split(/\s+/).some(function (v) { return v.charAt(0) == '{' && v.charAt(1) == '{'; });
    if (isDynamic) {
        var /** @type {?} */ ast = /** @type {?} */ (makeTimingAst(0, 0, ''));
        ast.dynamic = true;
        ast.strValue = strValue;
        return /** @type {?} */ (ast);
    }
    timings = timings || resolveTiming(strValue, errors);
    return makeTimingAst(timings.duration, timings.delay, timings.easing);
}
/**
 * @param {?} options
 * @return {?}
 */
function normalizeAnimationOptions(options) {
    if (options) {
        options = copyObj(options);
        if (options['params']) {
            options['params'] = /** @type {?} */ ((normalizeParams(options['params'])));
        }
    }
    else {
        options = {};
    }
    return options;
}
/**
 * @param {?} duration
 * @param {?} delay
 * @param {?} easing
 * @return {?}
 */
function makeTimingAst(duration, delay, easing) {
    return { duration: duration, delay: delay, easing: easing };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * @param {?} element
 * @param {?} keyframes
 * @param {?} preStyleProps
 * @param {?} postStyleProps
 * @param {?} duration
 * @param {?} delay
 * @param {?=} easing
 * @param {?=} subTimeline
 * @return {?}
 */
function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing, subTimeline) {
    if (easing === void 0) { easing = null; }
    if (subTimeline === void 0) { subTimeline = false; }
    return {
        type: 1 /* TimelineAnimation */,
        element: element,
        keyframes: keyframes,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        duration: duration,
        delay: delay,
        totalTime: duration + delay, easing: easing, subTimeline: subTimeline
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ElementInstructionMap = /** @class */ (function () {
    function ElementInstructionMap() {
        this._map = new Map();
    }
    /**
     * @param {?} element
     * @return {?}
     */
    ElementInstructionMap.prototype.consume = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ instructions = this._map.get(element);
        if (instructions) {
            this._map.delete(element);
        }
        else {
            instructions = [];
        }
        return instructions;
    };
    /**
     * @param {?} element
     * @param {?} instructions
     * @return {?}
     */
    ElementInstructionMap.prototype.append = /**
     * @param {?} element
     * @param {?} instructions
     * @return {?}
     */
    function (element, instructions) {
        var /** @type {?} */ existingInstructions = this._map.get(element);
        if (!existingInstructions) {
            this._map.set(element, existingInstructions = []);
        }
        existingInstructions.push.apply(existingInstructions, instructions);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    ElementInstructionMap.prototype.has = /**
     * @param {?} element
     * @return {?}
     */
    function (element) { return this._map.has(element); };
    /**
     * @return {?}
     */
    ElementInstructionMap.prototype.clear = /**
     * @return {?}
     */
    function () { this._map.clear(); };
    return ElementInstructionMap;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ONE_FRAME_IN_MILLISECONDS = 1;
var ENTER_TOKEN = ':enter';
var ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');
var LEAVE_TOKEN = ':leave';
var LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');
/**
 * @param {?} driver
 * @param {?} rootElement
 * @param {?} ast
 * @param {?} enterClassName
 * @param {?} leaveClassName
 * @param {?=} startingStyles
 * @param {?=} finalStyles
 * @param {?=} options
 * @param {?=} subInstructions
 * @param {?=} errors
 * @return {?}
 */
function buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors) {
    if (startingStyles === void 0) { startingStyles = {}; }
    if (finalStyles === void 0) { finalStyles = {}; }
    if (errors === void 0) { errors = []; }
    return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);
}
var AnimationTimelineBuilderVisitor = /** @class */ (function () {
    function AnimationTimelineBuilderVisitor() {
    }
    /**
     * @param {?} driver
     * @param {?} rootElement
     * @param {?} ast
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @param {?} startingStyles
     * @param {?} finalStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @param {?=} errors
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.buildKeyframes = /**
     * @param {?} driver
     * @param {?} rootElement
     * @param {?} ast
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @param {?} startingStyles
     * @param {?} finalStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @param {?=} errors
     * @return {?}
     */
    function (driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors) {
        if (errors === void 0) { errors = []; }
        subInstructions = subInstructions || new ElementInstructionMap();
        var /** @type {?} */ context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);
        context.options = options;
        context.currentTimeline.setStyles([startingStyles], null, context.errors, options);
        visitDslNode(this, ast, context);
        // this checks to see if an actual animation happened
        var /** @type {?} */ timelines = context.timelines.filter(function (timeline) { return timeline.containsAnimation(); });
        if (timelines.length && Object.keys(finalStyles).length) {
            var /** @type {?} */ tl = timelines[timelines.length - 1];
            if (!tl.allowOnlyTimelineStyles()) {
                tl.setStyles([finalStyles], null, context.errors, options);
            }
        }
        return timelines.length ? timelines.map(function (timeline) { return timeline.buildKeyframes(); }) :
            [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTrigger = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitState = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitTransition = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        // these values are not visited in this AST
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimateChild = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ elementInstructions = context.subInstructions.consume(context.element);
        if (elementInstructions) {
            var /** @type {?} */ innerContext = context.createSubContext(ast.options);
            var /** @type {?} */ startTime = context.currentTimeline.currentTime;
            var /** @type {?} */ endTime = this._visitSubInstructions(elementInstructions, innerContext, /** @type {?} */ (innerContext.options));
            if (startTime != endTime) {
                // we do this on the upper context because we created a sub context for
                // the sub child animations
                context.transformIntoNewTimeline(endTime);
            }
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimateRef = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ innerContext = context.createSubContext(ast.options);
        innerContext.transformIntoNewTimeline();
        this.visitReference(ast.animation, innerContext);
        context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);
        context.previousNode = ast;
    };
    /**
     * @param {?} instructions
     * @param {?} context
     * @param {?} options
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype._visitSubInstructions = /**
     * @param {?} instructions
     * @param {?} context
     * @param {?} options
     * @return {?}
     */
    function (instructions, context, options) {
        var /** @type {?} */ startTime = context.currentTimeline.currentTime;
        var /** @type {?} */ furthestTime = startTime;
        // this is a special-case for when a user wants to skip a sub
        // animation from being fired entirely.
        var /** @type {?} */ duration = options.duration != null ? resolveTimingValue(options.duration) : null;
        var /** @type {?} */ delay = options.delay != null ? resolveTimingValue(options.delay) : null;
        if (duration !== 0) {
            instructions.forEach(function (instruction) {
                var /** @type {?} */ instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);
                furthestTime =
                    Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
            });
        }
        return furthestTime;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitReference = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        context.updateOptions(ast.options, true);
        visitDslNode(this, ast.animation, context);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitSequence = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        var /** @type {?} */ subContextCount = context.subContextCount;
        var /** @type {?} */ ctx = context;
        var /** @type {?} */ options = ast.options;
        if (options && (options.params || options.delay)) {
            ctx = context.createSubContext(options);
            ctx.transformIntoNewTimeline();
            if (options.delay != null) {
                if (ctx.previousNode.type == 6 /* Style */) {
                    ctx.currentTimeline.snapshotCurrentStyles();
                    ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
                }
                var /** @type {?} */ delay = resolveTimingValue(options.delay);
                ctx.delayNextStep(delay);
            }
        }
        if (ast.steps.length) {
            ast.steps.forEach(function (s) { return visitDslNode(_this, s, ctx); });
            // this is here just incase the inner steps only contain or end with a style() call
            ctx.currentTimeline.applyStylesToKeyframe();
            // this means that some animation function within the sequence
            // ended up creating a sub timeline (which means the current
            // timeline cannot overlap with the contents of the sequence)
            if (ctx.subContextCount > subContextCount) {
                ctx.transformIntoNewTimeline();
            }
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitGroup = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        var /** @type {?} */ innerTimelines = [];
        var /** @type {?} */ furthestTime = context.currentTimeline.currentTime;
        var /** @type {?} */ delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
        ast.steps.forEach(function (s) {
            var /** @type {?} */ innerContext = context.createSubContext(ast.options);
            if (delay) {
                innerContext.delayNextStep(delay);
            }
            visitDslNode(_this, s, innerContext);
            furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
            innerTimelines.push(innerContext.currentTimeline);
        });
        // this operation is run after the AST loop because otherwise
        // if the parent timeline's collected styles were updated then
        // it would pass in invalid data into the new-to-be forked items
        innerTimelines.forEach(function (timeline) { return context.currentTimeline.mergeTimelineCollectedStyles(timeline); });
        context.transformIntoNewTimeline(furthestTime);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype._visitTiming = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        if ((/** @type {?} */ (ast)).dynamic) {
            var /** @type {?} */ strValue = (/** @type {?} */ (ast)).strValue;
            var /** @type {?} */ timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;
            return resolveTiming(timingValue, context.errors);
        }
        else {
            return { duration: ast.duration, delay: ast.delay, easing: ast.easing };
        }
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitAnimate = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);
        var /** @type {?} */ timeline = context.currentTimeline;
        if (timings.delay) {
            context.incrementTime(timings.delay);
            timeline.snapshotCurrentStyles();
        }
        var /** @type {?} */ style$$1 = ast.style;
        if (style$$1.type == 5 /* Keyframes */) {
            this.visitKeyframes(style$$1, context);
        }
        else {
            context.incrementTime(timings.duration);
            this.visitStyle(/** @type {?} */ (style$$1), context);
            timeline.applyStylesToKeyframe();
        }
        context.currentAnimateTimings = null;
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitStyle = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ timeline = context.currentTimeline;
        var /** @type {?} */ timings = /** @type {?} */ ((context.currentAnimateTimings));
        // this is a special case for when a style() call
        // directly follows  an animate() call (but not inside of an animate() call)
        if (!timings && timeline.getCurrentStyleProperties().length) {
            timeline.forwardFrame();
        }
        var /** @type {?} */ easing = (timings && timings.easing) || ast.easing;
        if (ast.isEmptyStep) {
            timeline.applyEmptyStep(easing);
        }
        else {
            timeline.setStyles(ast.styles, easing, context.errors, context.options);
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitKeyframes = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ currentAnimateTimings = /** @type {?} */ ((context.currentAnimateTimings));
        var /** @type {?} */ startTime = (/** @type {?} */ ((context.currentTimeline))).duration;
        var /** @type {?} */ duration = currentAnimateTimings.duration;
        var /** @type {?} */ innerContext = context.createSubContext();
        var /** @type {?} */ innerTimeline = innerContext.currentTimeline;
        innerTimeline.easing = currentAnimateTimings.easing;
        ast.styles.forEach(function (step) {
            var /** @type {?} */ offset = step.offset || 0;
            innerTimeline.forwardTime(offset * duration);
            innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);
            innerTimeline.applyStylesToKeyframe();
        });
        // this will ensure that the parent timeline gets all the styles from
        // the child even if the new timeline below is not used
        context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);
        // we do this because the window between this timeline and the sub timeline
        // should ensure that the styles within are exactly the same as they were before
        context.transformIntoNewTimeline(startTime + duration);
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitQuery = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var _this = this;
        // in the event that the first step before this is a style step we need
        // to ensure the styles are applied before the children are animated
        var /** @type {?} */ startTime = context.currentTimeline.currentTime;
        var /** @type {?} */ options = /** @type {?} */ ((ast.options || {}));
        var /** @type {?} */ delay = options.delay ? resolveTimingValue(options.delay) : 0;
        if (delay && (context.previousNode.type === 6 /* Style */ ||
            (startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length))) {
            context.currentTimeline.snapshotCurrentStyles();
            context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        }
        var /** @type {?} */ furthestTime = startTime;
        var /** @type {?} */ elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);
        context.currentQueryTotal = elms.length;
        var /** @type {?} */ sameElementTimeline = null;
        elms.forEach(function (element, i) {
            context.currentQueryIndex = i;
            var /** @type {?} */ innerContext = context.createSubContext(ast.options, element);
            if (delay) {
                innerContext.delayNextStep(delay);
            }
            if (element === context.element) {
                sameElementTimeline = innerContext.currentTimeline;
            }
            visitDslNode(_this, ast.animation, innerContext);
            // this is here just incase the inner steps only contain or end
            // with a style() call (which is here to signal that this is a preparatory
            // call to style an element before it is animated again)
            innerContext.currentTimeline.applyStylesToKeyframe();
            var /** @type {?} */ endTime = innerContext.currentTimeline.currentTime;
            furthestTime = Math.max(furthestTime, endTime);
        });
        context.currentQueryIndex = 0;
        context.currentQueryTotal = 0;
        context.transformIntoNewTimeline(furthestTime);
        if (sameElementTimeline) {
            context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);
            context.currentTimeline.snapshotCurrentStyles();
        }
        context.previousNode = ast;
    };
    /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    AnimationTimelineBuilderVisitor.prototype.visitStagger = /**
     * @param {?} ast
     * @param {?} context
     * @return {?}
     */
    function (ast, context) {
        var /** @type {?} */ parentContext = /** @type {?} */ ((context.parentContext));
        var /** @type {?} */ tl = context.currentTimeline;
        var /** @type {?} */ timings = ast.timings;
        var /** @type {?} */ duration = Math.abs(timings.duration);
        var /** @type {?} */ maxTime = duration * (context.currentQueryTotal - 1);
        var /** @type {?} */ delay = duration * context.currentQueryIndex;
        var /** @type {?} */ staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;
        switch (staggerTransformer) {
            case 'reverse':
                delay = maxTime - delay;
                break;
            case 'full':
                delay = parentContext.currentStaggerTime;
                break;
        }
        var /** @type {?} */ timeline = context.currentTimeline;
        if (delay) {
            timeline.delayNextStep(delay);
        }
        var /** @type {?} */ startingTime = timeline.currentTime;
        visitDslNode(this, ast.animation, context);
        context.previousNode = ast;
        // time = duration + delay
        // the reason why this computation is so complex is because
        // the inner timeline may either have a delay value or a stretched
        // keyframe depending on if a subtimeline is not used or is used.
        parentContext.currentStaggerTime =
            (tl.currentTime - startingTime) + (tl.startTime - parentContext.currentTimeline.startTime);
    };
    return AnimationTimelineBuilderVisitor;
}());
var DEFAULT_NOOP_PREVIOUS_NODE = /** @type {?} */ ({});
var AnimationTimelineContext = /** @class */ (function () {
    function AnimationTimelineContext(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {
        this._driver = _driver;
        this.element = element;
        this.subInstructions = subInstructions;
        this._enterClassName = _enterClassName;
        this._leaveClassName = _leaveClassName;
        this.errors = errors;
        this.timelines = timelines;
        this.parentContext = null;
        this.currentAnimateTimings = null;
        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        this.subContextCount = 0;
        this.options = {};
        this.currentQueryIndex = 0;
        this.currentQueryTotal = 0;
        this.currentStaggerTime = 0;
        this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);
        timelines.push(this.currentTimeline);
    }
    Object.defineProperty(AnimationTimelineContext.prototype, "params", {
        get: /**
         * @return {?}
         */
        function () { return this.options.params; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} options
     * @param {?=} skipIfExists
     * @return {?}
     */
    AnimationTimelineContext.prototype.updateOptions = /**
     * @param {?} options
     * @param {?=} skipIfExists
     * @return {?}
     */
    function (options, skipIfExists) {
        var _this = this;
        if (!options)
            return;
        var /** @type {?} */ newOptions = /** @type {?} */ (options);
        var /** @type {?} */ optionsToUpdate = this.options;
        // NOTE: this will get patched up when other animation methods support duration overrides
        if (newOptions.duration != null) {
            (/** @type {?} */ (optionsToUpdate)).duration = resolveTimingValue(newOptions.duration);
        }
        if (newOptions.delay != null) {
            optionsToUpdate.delay = resolveTimingValue(newOptions.delay);
        }
        var /** @type {?} */ newParams = newOptions.params;
        if (newParams) {
            var /** @type {?} */ paramsToUpdate_1 = /** @type {?} */ ((optionsToUpdate.params));
            if (!paramsToUpdate_1) {
                paramsToUpdate_1 = this.options.params = {};
            }
            Object.keys(newParams).forEach(function (name) {
                if (!skipIfExists || !paramsToUpdate_1.hasOwnProperty(name)) {
                    paramsToUpdate_1[name] = interpolateParams(newParams[name], paramsToUpdate_1, _this.errors);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    AnimationTimelineContext.prototype._copyOptions = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ options = {};
        if (this.options) {
            var /** @type {?} */ oldParams_1 = this.options.params;
            if (oldParams_1) {
                var /** @type {?} */ params_1 = options['params'] = {};
                Object.keys(oldParams_1).forEach(function (name) { params_1[name] = oldParams_1[name]; });
            }
        }
        return options;
    };
    /**
     * @param {?=} options
     * @param {?=} element
     * @param {?=} newTime
     * @return {?}
     */
    AnimationTimelineContext.prototype.createSubContext = /**
     * @param {?=} options
     * @param {?=} element
     * @param {?=} newTime
     * @return {?}
     */
    function (options, element, newTime) {
        if (options === void 0) { options = null; }
        var /** @type {?} */ target = element || this.element;
        var /** @type {?} */ context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
        context.previousNode = this.previousNode;
        context.currentAnimateTimings = this.currentAnimateTimings;
        context.options = this._copyOptions();
        context.updateOptions(options);
        context.currentQueryIndex = this.currentQueryIndex;
        context.currentQueryTotal = this.currentQueryTotal;
        context.parentContext = this;
        this.subContextCount++;
        return context;
    };
    /**
     * @param {?=} newTime
     * @return {?}
     */
    AnimationTimelineContext.prototype.transformIntoNewTimeline = /**
     * @param {?=} newTime
     * @return {?}
     */
    function (newTime) {
        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        this.currentTimeline = this.currentTimeline.fork(this.element, newTime);
        this.timelines.push(this.currentTimeline);
        return this.currentTimeline;
    };
    /**
     * @param {?} instruction
     * @param {?} duration
     * @param {?} delay
     * @return {?}
     */
    AnimationTimelineContext.prototype.appendInstructionToTimeline = /**
     * @param {?} instruction
     * @param {?} duration
     * @param {?} delay
     * @return {?}
     */
    function (instruction, duration, delay) {
        var /** @type {?} */ updatedTimings = {
            duration: duration != null ? duration : instruction.duration,
            delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,
            easing: ''
        };
        var /** @type {?} */ builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
        this.timelines.push(builder);
        return updatedTimings;
    };
    /**
     * @param {?} time
     * @return {?}
     */
    AnimationTimelineContext.prototype.incrementTime = /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
    };
    /**
     * @param {?} delay
     * @return {?}
     */
    AnimationTimelineContext.prototype.delayNextStep = /**
     * @param {?} delay
     * @return {?}
     */
    function (delay) {
        // negative delays are not yet supported
        if (delay > 0) {
            this.currentTimeline.delayNextStep(delay);
        }
    };
    /**
     * @param {?} selector
     * @param {?} originalSelector
     * @param {?} limit
     * @param {?} includeSelf
     * @param {?} optional
     * @param {?} errors
     * @return {?}
     */
    AnimationTimelineContext.prototype.invokeQuery = /**
     * @param {?} selector
     * @param {?} originalSelector
     * @param {?} limit
     * @param {?} includeSelf
     * @param {?} optional
     * @param {?} errors
     * @return {?}
     */
    function (selector, originalSelector, limit, includeSelf, optional, errors) {
        var /** @type {?} */ results = [];
        if (includeSelf) {
            results.push(this.element);
        }
        if (selector.length > 0) {
            // if :self is only used then the selector is empty
            selector = selector.replace(ENTER_TOKEN_REGEX, '.' + this._enterClassName);
            selector = selector.replace(LEAVE_TOKEN_REGEX, '.' + this._leaveClassName);
            var /** @type {?} */ multi = limit != 1;
            var /** @type {?} */ elements = this._driver.query(this.element, selector, multi);
            if (limit !== 0) {
                elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) :
                    elements.slice(0, limit);
            }
            results.push.apply(results, elements);
        }
        if (!optional && results.length == 0) {
            errors.push("`query(\"" + originalSelector + "\")` returned zero elements. (Use `query(\"" + originalSelector + "\", { optional: true })` if you wish to allow this.)");
        }
        return results;
    };
    return AnimationTimelineContext;
}());
var TimelineBuilder = /** @class */ (function () {
    function TimelineBuilder(_driver, element, startTime, _elementTimelineStylesLookup) {
        this._driver = _driver;
        this.element = element;
        this.startTime = startTime;
        this._elementTimelineStylesLookup = _elementTimelineStylesLookup;
        this.duration = 0;
        this._previousKeyframe = {};
        this._currentKeyframe = {};
        this._keyframes = new Map();
        this._styleSummary = {};
        this._pendingStyles = {};
        this._backFill = {};
        this._currentEmptyStepKeyframe = null;
        if (!this._elementTimelineStylesLookup) {
            this._elementTimelineStylesLookup = new Map();
        }
        this._localTimelineStyles = Object.create(this._backFill, {});
        this._globalTimelineStyles = /** @type {?} */ ((this._elementTimelineStylesLookup.get(element)));
        if (!this._globalTimelineStyles) {
            this._globalTimelineStyles = this._localTimelineStyles;
            this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);
        }
        this._loadKeyframe();
    }
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.containsAnimation = /**
     * @return {?}
     */
    function () {
        switch (this._keyframes.size) {
            case 0:
                return false;
            case 1:
                return this.getCurrentStyleProperties().length > 0;
            default:
                return true;
        }
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.getCurrentStyleProperties = /**
     * @return {?}
     */
    function () { return Object.keys(this._currentKeyframe); };
    Object.defineProperty(TimelineBuilder.prototype, "currentTime", {
        get: /**
         * @return {?}
         */
        function () { return this.startTime + this.duration; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} delay
     * @return {?}
     */
    TimelineBuilder.prototype.delayNextStep = /**
     * @param {?} delay
     * @return {?}
     */
    function (delay) {
        // in the event that a style() step is placed right before a stagger()
        // and that style() step is the very first style() value in the animation
        // then we need to make a copy of the keyframe [0, copy, 1] so that the delay
        // properly applies the style() values to work with the stagger...
        var /** @type {?} */ hasPreStyleStep = this._keyframes.size == 1 && Object.keys(this._pendingStyles).length;
        if (this.duration || hasPreStyleStep) {
            this.forwardTime(this.currentTime + delay);
            if (hasPreStyleStep) {
                this.snapshotCurrentStyles();
            }
        }
        else {
            this.startTime += delay;
        }
    };
    /**
     * @param {?} element
     * @param {?=} currentTime
     * @return {?}
     */
    TimelineBuilder.prototype.fork = /**
     * @param {?} element
     * @param {?=} currentTime
     * @return {?}
     */
    function (element, currentTime) {
        this.applyStylesToKeyframe();
        return new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype._loadKeyframe = /**
     * @return {?}
     */
    function () {
        if (this._currentKeyframe) {
            this._previousKeyframe = this._currentKeyframe;
        }
        this._currentKeyframe = /** @type {?} */ ((this._keyframes.get(this.duration)));
        if (!this._currentKeyframe) {
            this._currentKeyframe = Object.create(this._backFill, {});
            this._keyframes.set(this.duration, this._currentKeyframe);
        }
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.forwardFrame = /**
     * @return {?}
     */
    function () {
        this.duration += ONE_FRAME_IN_MILLISECONDS;
        this._loadKeyframe();
    };
    /**
     * @param {?} time
     * @return {?}
     */
    TimelineBuilder.prototype.forwardTime = /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        this.applyStylesToKeyframe();
        this.duration = time;
        this._loadKeyframe();
    };
    /**
     * @param {?} prop
     * @param {?} value
     * @return {?}
     */
    TimelineBuilder.prototype._updateStyle = /**
     * @param {?} prop
     * @param {?} value
     * @return {?}
     */
    function (prop, value) {
        this._localTimelineStyles[prop] = value;
        this._globalTimelineStyles[prop] = value;
        this._styleSummary[prop] = { time: this.currentTime, value: value };
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.allowOnlyTimelineStyles = /**
     * @return {?}
     */
    function () { return this._currentEmptyStepKeyframe !== this._currentKeyframe; };
    /**
     * @param {?} easing
     * @return {?}
     */
    TimelineBuilder.prototype.applyEmptyStep = /**
     * @param {?} easing
     * @return {?}
     */
    function (easing) {
        var _this = this;
        if (easing) {
            this._previousKeyframe['easing'] = easing;
        }
        // special case for animate(duration):
        // all missing styles are filled with a `*` value then
        // if any destination styles are filled in later on the same
        // keyframe then they will override the overridden styles
        // We use `_globalTimelineStyles` here because there may be
        // styles in previous keyframes that are not present in this timeline
        Object.keys(this._globalTimelineStyles).forEach(function (prop) {
            _this._backFill[prop] = _this._globalTimelineStyles[prop] || _angular_animations.AUTO_STYLE;
            _this._currentKeyframe[prop] = _angular_animations.AUTO_STYLE;
        });
        this._currentEmptyStepKeyframe = this._currentKeyframe;
    };
    /**
     * @param {?} input
     * @param {?} easing
     * @param {?} errors
     * @param {?=} options
     * @return {?}
     */
    TimelineBuilder.prototype.setStyles = /**
     * @param {?} input
     * @param {?} easing
     * @param {?} errors
     * @param {?=} options
     * @return {?}
     */
    function (input, easing, errors, options) {
        var _this = this;
        if (easing) {
            this._previousKeyframe['easing'] = easing;
        }
        var /** @type {?} */ params = (options && options.params) || {};
        var /** @type {?} */ styles = flattenStyles(input, this._globalTimelineStyles);
        Object.keys(styles).forEach(function (prop) {
            var /** @type {?} */ val = interpolateParams(styles[prop], params, errors);
            _this._pendingStyles[prop] = val;
            if (!_this._localTimelineStyles.hasOwnProperty(prop)) {
                _this._backFill[prop] = _this._globalTimelineStyles.hasOwnProperty(prop) ?
                    _this._globalTimelineStyles[prop] :
                    _angular_animations.AUTO_STYLE;
            }
            _this._updateStyle(prop, val);
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.applyStylesToKeyframe = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ styles = this._pendingStyles;
        var /** @type {?} */ props = Object.keys(styles);
        if (props.length == 0)
            return;
        this._pendingStyles = {};
        props.forEach(function (prop) {
            var /** @type {?} */ val = styles[prop];
            _this._currentKeyframe[prop] = val;
        });
        Object.keys(this._localTimelineStyles).forEach(function (prop) {
            if (!_this._currentKeyframe.hasOwnProperty(prop)) {
                _this._currentKeyframe[prop] = _this._localTimelineStyles[prop];
            }
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.snapshotCurrentStyles = /**
     * @return {?}
     */
    function () {
        var _this = this;
        Object.keys(this._localTimelineStyles).forEach(function (prop) {
            var /** @type {?} */ val = _this._localTimelineStyles[prop];
            _this._pendingStyles[prop] = val;
            _this._updateStyle(prop, val);
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.getFinalKeyframe = /**
     * @return {?}
     */
    function () { return this._keyframes.get(this.duration); };
    Object.defineProperty(TimelineBuilder.prototype, "properties", {
        get: /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ properties = [];
            for (var /** @type {?} */ prop in this._currentKeyframe) {
                properties.push(prop);
            }
            return properties;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} timeline
     * @return {?}
     */
    TimelineBuilder.prototype.mergeTimelineCollectedStyles = /**
     * @param {?} timeline
     * @return {?}
     */
    function (timeline) {
        var _this = this;
        Object.keys(timeline._styleSummary).forEach(function (prop) {
            var /** @type {?} */ details0 = _this._styleSummary[prop];
            var /** @type {?} */ details1 = timeline._styleSummary[prop];
            if (!details0 || details1.time > details0.time) {
                _this._updateStyle(prop, details1.value);
            }
        });
    };
    /**
     * @return {?}
     */
    TimelineBuilder.prototype.buildKeyframes = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.applyStylesToKeyframe();
        var /** @type {?} */ preStyleProps = new Set();
        var /** @type {?} */ postStyleProps = new Set();
        var /** @type {?} */ isEmpty = this._keyframes.size === 1 && this.duration === 0;
        var /** @type {?} */ finalKeyframes = [];
        this._keyframes.forEach(function (keyframe, time) {
            var /** @type {?} */ finalKeyframe = copyStyles(keyframe, true);
            Object.keys(finalKeyframe).forEach(function (prop) {
                var /** @type {?} */ value = finalKeyframe[prop];
                if (value == _angular_animations.ɵPRE_STYLE) {
                    preStyleProps.add(prop);
                }
                else if (value == _angular_animations.AUTO_STYLE) {
                    postStyleProps.add(prop);
                }
            });
            if (!isEmpty) {
                finalKeyframe['offset'] = time / _this.duration;
            }
            finalKeyframes.push(finalKeyframe);
        });
        var /** @type {?} */ preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];
        var /** @type {?} */ postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];
        // special case for a 0-second animation (which is designed just to place styles onscreen)
        if (isEmpty) {
            var /** @type {?} */ kf0 = finalKeyframes[0];
            var /** @type {?} */ kf1 = copyObj(kf0);
            kf0['offset'] = 0;
            kf1['offset'] = 1;
            finalKeyframes = [kf0, kf1];
        }
        return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);
    };
    return TimelineBuilder;
}());
var SubTimelineBuilder = /** @class */ (function (_super) {
    __extends(SubTimelineBuilder, _super);
    function SubTimelineBuilder(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe) {
        if (_stretchStartingKeyframe === void 0) { _stretchStartingKeyframe = false; }
        var _this = _super.call(this, driver, element, timings.delay) || this;
        _this.element = element;
        _this.keyframes = keyframes;
        _this.preStyleProps = preStyleProps;
        _this.postStyleProps = postStyleProps;
        _this._stretchStartingKeyframe = _stretchStartingKeyframe;
        _this.timings = { duration: timings.duration, delay: timings.delay, easing: timings.easing };
        return _this;
    }
    /**
     * @return {?}
     */
    SubTimelineBuilder.prototype.containsAnimation = /**
     * @return {?}
     */
    function () { return this.keyframes.length > 1; };
    /**
     * @return {?}
     */
    SubTimelineBuilder.prototype.buildKeyframes = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ keyframes = this.keyframes;
        var _a = this.timings, delay = _a.delay, duration = _a.duration, easing = _a.easing;
        if (this._stretchStartingKeyframe && delay) {
            var /** @type {?} */ newKeyframes = [];
            var /** @type {?} */ totalTime = duration + delay;
            var /** @type {?} */ startingGap = delay / totalTime;
            // the original starting keyframe now starts once the delay is done
            var /** @type {?} */ newFirstKeyframe = copyStyles(keyframes[0], false);
            newFirstKeyframe['offset'] = 0;
            newKeyframes.push(newFirstKeyframe);
            var /** @type {?} */ oldFirstKeyframe = copyStyles(keyframes[0], false);
            oldFirstKeyframe['offset'] = roundOffset(startingGap);
            newKeyframes.push(oldFirstKeyframe);
            /*
                    When the keyframe is stretched then it means that the delay before the animation
                    starts is gone. Instead the first keyframe is placed at the start of the animation
                    and it is then copied to where it starts when the original delay is over. This basically
                    means nothing animates during that delay, but the styles are still renderered. For this
                    to work the original offset values that exist in the original keyframes must be "warped"
                    so that they can take the new keyframe + delay into account.
            
                    delay=1000, duration=1000, keyframes = 0 .5 1
            
                    turns into
            
                    delay=0, duration=2000, keyframes = 0 .33 .66 1
                   */
            // offsets between 1 ... n -1 are all warped by the keyframe stretch
            var /** @type {?} */ limit = keyframes.length - 1;
            for (var /** @type {?} */ i = 1; i <= limit; i++) {
                var /** @type {?} */ kf = copyStyles(keyframes[i], false);
                var /** @type {?} */ oldOffset = /** @type {?} */ (kf['offset']);
                var /** @type {?} */ timeAtKeyframe = delay + oldOffset * duration;
                kf['offset'] = roundOffset(timeAtKeyframe / totalTime);
                newKeyframes.push(kf);
            }
            // the new starting keyframe should be added at the start
            duration = totalTime;
            delay = 0;
            easing = '';
            keyframes = newKeyframes;
        }
        return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);
    };
    return SubTimelineBuilder;
}(TimelineBuilder));
/**
 * @param {?} offset
 * @param {?=} decimalPoints
 * @return {?}
 */
function roundOffset(offset, decimalPoints) {
    if (decimalPoints === void 0) { decimalPoints = 3; }
    var /** @type {?} */ mult = Math.pow(10, decimalPoints - 1);
    return Math.round(offset * mult) / mult;
}
/**
 * @param {?} input
 * @param {?} allStyles
 * @return {?}
 */
function flattenStyles(input, allStyles) {
    var /** @type {?} */ styles = {};
    var /** @type {?} */ allProperties;
    input.forEach(function (token) {
        if (token === '*') {
            allProperties = allProperties || Object.keys(allStyles);
            allProperties.forEach(function (prop) { styles[prop] = _angular_animations.AUTO_STYLE; });
        }
        else {
            copyStyles(/** @type {?} */ (token), false, styles);
        }
    });
    return styles;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Animation = /** @class */ (function () {
    function Animation(_driver, input) {
        this._driver = _driver;
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = buildAnimationAst(_driver, input, errors);
        if (errors.length) {
            var /** @type {?} */ errorMessage = "animation validation failed:\n" + errors.join("\n");
            throw new Error(errorMessage);
        }
        this._animationAst = ast;
    }
    /**
     * @param {?} element
     * @param {?} startingStyles
     * @param {?} destinationStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @return {?}
     */
    Animation.prototype.buildTimelines = /**
     * @param {?} element
     * @param {?} startingStyles
     * @param {?} destinationStyles
     * @param {?} options
     * @param {?=} subInstructions
     * @return {?}
     */
    function (element, startingStyles, destinationStyles, options, subInstructions) {
        var /** @type {?} */ start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) : /** @type {?} */ (startingStyles);
        var /** @type {?} */ dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) : /** @type {?} */ (destinationStyles);
        var /** @type {?} */ errors = [];
        subInstructions = subInstructions || new ElementInstructionMap();
        var /** @type {?} */ result = buildAnimationTimelines(this._driver, element, this._animationAst, ENTER_CLASSNAME, LEAVE_CLASSNAME, start, dest, options, subInstructions, errors);
        if (errors.length) {
            var /** @type {?} */ errorMessage = "animation building failed:\n" + errors.join("\n");
            throw new Error(errorMessage);
        }
        return result;
    };
    return Animation;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * \@experimental Animation support is experimental.
 * @abstract
 */
var AnimationStyleNormalizer = /** @class */ (function () {
    function AnimationStyleNormalizer() {
    }
    return AnimationStyleNormalizer;
}());
/**
 * \@experimental Animation support is experimental.
 */
var NoopAnimationStyleNormalizer = /** @class */ (function () {
    function NoopAnimationStyleNormalizer() {
    }
    /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    NoopAnimationStyleNormalizer.prototype.normalizePropertyName = /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    function (propertyName, errors) { return propertyName; };
    /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    NoopAnimationStyleNormalizer.prototype.normalizeStyleValue = /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    function (userProvidedProperty, normalizedProperty, value, errors) {
        return /** @type {?} */ (value);
    };
    return NoopAnimationStyleNormalizer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var WebAnimationsStyleNormalizer = /** @class */ (function (_super) {
    __extends(WebAnimationsStyleNormalizer, _super);
    function WebAnimationsStyleNormalizer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    WebAnimationsStyleNormalizer.prototype.normalizePropertyName = /**
     * @param {?} propertyName
     * @param {?} errors
     * @return {?}
     */
    function (propertyName, errors) {
        return dashCaseToCamelCase(propertyName);
    };
    /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    WebAnimationsStyleNormalizer.prototype.normalizeStyleValue = /**
     * @param {?} userProvidedProperty
     * @param {?} normalizedProperty
     * @param {?} value
     * @param {?} errors
     * @return {?}
     */
    function (userProvidedProperty, normalizedProperty, value, errors) {
        var /** @type {?} */ unit = '';
        var /** @type {?} */ strVal = value.toString().trim();
        if (DIMENSIONAL_PROP_MAP[normalizedProperty] && value !== 0 && value !== '0') {
            if (typeof value === 'number') {
                unit = 'px';
            }
            else {
                var /** @type {?} */ valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);
                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
                    errors.push("Please provide a CSS unit value for " + userProvidedProperty + ":" + value);
                }
            }
        }
        return strVal + unit;
    };
    return WebAnimationsStyleNormalizer;
}(AnimationStyleNormalizer));
var DIMENSIONAL_PROP_MAP = makeBooleanMap('width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective'
    .split(','));
/**
 * @param {?} keys
 * @return {?}
 */
function makeBooleanMap(keys) {
    var /** @type {?} */ map = {};
    keys.forEach(function (key) { return map[key] = true; });
    return map;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * @param {?} element
 * @param {?} triggerName
 * @param {?} fromState
 * @param {?} toState
 * @param {?} isRemovalTransition
 * @param {?} fromStyles
 * @param {?} toStyles
 * @param {?} timelines
 * @param {?} queriedElements
 * @param {?} preStyleProps
 * @param {?} postStyleProps
 * @param {?=} errors
 * @return {?}
 */
function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, errors) {
    return {
        type: 0 /* TransitionAnimation */,
        element: element,
        triggerName: triggerName,
        isRemovalTransition: isRemovalTransition,
        fromState: fromState,
        fromStyles: fromStyles,
        toState: toState,
        toStyles: toStyles,
        timelines: timelines,
        queriedElements: queriedElements,
        preStyleProps: preStyleProps,
        postStyleProps: postStyleProps,
        errors: errors
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var EMPTY_OBJECT = {};
var AnimationTransitionFactory = /** @class */ (function () {
    function AnimationTransitionFactory(_triggerName, ast, _stateStyles) {
        this._triggerName = _triggerName;
        this.ast = ast;
        this._stateStyles = _stateStyles;
    }
    /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    AnimationTransitionFactory.prototype.match = /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    function (currentState, nextState) {
        return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState);
    };
    /**
     * @param {?} stateName
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationTransitionFactory.prototype.buildStyles = /**
     * @param {?} stateName
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    function (stateName, params, errors) {
        var /** @type {?} */ backupStateStyler = this._stateStyles['*'];
        var /** @type {?} */ stateStyler = this._stateStyles[stateName];
        var /** @type {?} */ backupStyles = backupStateStyler ? backupStateStyler.buildStyles(params, errors) : {};
        return stateStyler ? stateStyler.buildStyles(params, errors) : backupStyles;
    };
    /**
     * @param {?} driver
     * @param {?} element
     * @param {?} currentState
     * @param {?} nextState
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @param {?=} currentOptions
     * @param {?=} nextOptions
     * @param {?=} subInstructions
     * @return {?}
     */
    AnimationTransitionFactory.prototype.build = /**
     * @param {?} driver
     * @param {?} element
     * @param {?} currentState
     * @param {?} nextState
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @param {?=} currentOptions
     * @param {?=} nextOptions
     * @param {?=} subInstructions
     * @return {?}
     */
    function (driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions) {
        var /** @type {?} */ errors = [];
        var /** @type {?} */ transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;
        var /** @type {?} */ currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;
        var /** @type {?} */ currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);
        var /** @type {?} */ nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;
        var /** @type {?} */ nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);
        var /** @type {?} */ queriedElements = new Set();
        var /** @type {?} */ preStyleMap = new Map();
        var /** @type {?} */ postStyleMap = new Map();
        var /** @type {?} */ isRemoval = nextState === 'void';
        var /** @type {?} */ animationOptions = { params: __assign({}, transitionAnimationParams, nextAnimationParams) };
        var /** @type {?} */ timelines = buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
        if (errors.length) {
            return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, errors);
        }
        timelines.forEach(function (tl) {
            var /** @type {?} */ elm = tl.element;
            var /** @type {?} */ preProps = getOrSetAsInMap(preStyleMap, elm, {});
            tl.preStyleProps.forEach(function (prop) { return preProps[prop] = true; });
            var /** @type {?} */ postProps = getOrSetAsInMap(postStyleMap, elm, {});
            tl.postStyleProps.forEach(function (prop) { return postProps[prop] = true; });
            if (elm !== element) {
                queriedElements.add(elm);
            }
        });
        var /** @type {?} */ queriedElementsList = iteratorToArray(queriedElements.values());
        return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap);
    };
    return AnimationTransitionFactory;
}());
/**
 * @param {?} matchFns
 * @param {?} currentState
 * @param {?} nextState
 * @return {?}
 */
function oneOrMoreTransitionsMatch(matchFns, currentState, nextState) {
    return matchFns.some(function (fn) { return fn(currentState, nextState); });
}
var AnimationStateStyles = /** @class */ (function () {
    function AnimationStateStyles(styles, defaultParams) {
        this.styles = styles;
        this.defaultParams = defaultParams;
    }
    /**
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationStateStyles.prototype.buildStyles = /**
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    function (params, errors) {
        var /** @type {?} */ finalStyles = {};
        var /** @type {?} */ combinedParams = copyObj(this.defaultParams);
        Object.keys(params).forEach(function (key) {
            var /** @type {?} */ value = params[key];
            if (value != null) {
                combinedParams[key] = value;
            }
        });
        this.styles.styles.forEach(function (value) {
            if (typeof value !== 'string') {
                var /** @type {?} */ styleObj_1 = /** @type {?} */ (value);
                Object.keys(styleObj_1).forEach(function (prop) {
                    var /** @type {?} */ val = styleObj_1[prop];
                    if (val.length > 1) {
                        val = interpolateParams(val, combinedParams, errors);
                    }
                    finalStyles[prop] = val;
                });
            }
        });
        return finalStyles;
    };
    return AnimationStateStyles;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@experimental Animation support is experimental.
 * @param {?} name
 * @param {?} ast
 * @return {?}
 */
function buildTrigger(name, ast) {
    return new AnimationTrigger(name, ast);
}
/**
 * \@experimental Animation support is experimental.
 */
var AnimationTrigger = /** @class */ (function () {
    function AnimationTrigger(name, ast) {
        var _this = this;
        this.name = name;
        this.ast = ast;
        this.transitionFactories = [];
        this.states = {};
        ast.states.forEach(function (ast) {
            var /** @type {?} */ defaultParams = (ast.options && ast.options.params) || {};
            _this.states[ast.name] = new AnimationStateStyles(ast.style, defaultParams);
        });
        balanceProperties(this.states, 'true', '1');
        balanceProperties(this.states, 'false', '0');
        ast.transitions.forEach(function (ast) {
            _this.transitionFactories.push(new AnimationTransitionFactory(name, ast, _this.states));
        });
        this.fallbackTransition = createFallbackTransition(name, this.states);
    }
    Object.defineProperty(AnimationTrigger.prototype, "containsQueries", {
        get: /**
         * @return {?}
         */
        function () { return this.ast.queryCount > 0; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    AnimationTrigger.prototype.matchTransition = /**
     * @param {?} currentState
     * @param {?} nextState
     * @return {?}
     */
    function (currentState, nextState) {
        var /** @type {?} */ entry = this.transitionFactories.find(function (f) { return f.match(currentState, nextState); });
        return entry || null;
    };
    /**
     * @param {?} currentState
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    AnimationTrigger.prototype.matchStyles = /**
     * @param {?} currentState
     * @param {?} params
     * @param {?} errors
     * @return {?}
     */
    function (currentState, params, errors) {
        return this.fallbackTransition.buildStyles(currentState, params, errors);
    };
    return AnimationTrigger;
}());
/**
 * @param {?} triggerName
 * @param {?} states
 * @return {?}
 */
function createFallbackTransition(triggerName, states) {
    var /** @type {?} */ matchers = [function (fromState, toState) { return true; }];
    var /** @type {?} */ animation = { type: 2 /* Sequence */, steps: [], options: null };
    var /** @type {?} */ transition = {
        type: 1 /* Transition */,
        animation: animation,
        matchers: matchers,
        options: null,
        queryCount: 0,
        depCount: 0
    };
    return new AnimationTransitionFactory(triggerName, transition, states);
}
/**
 * @param {?} obj
 * @param {?} key1
 * @param {?} key2
 * @return {?}
 */
function balanceProperties(obj, key1, key2) {
    if (obj.hasOwnProperty(key1)) {
        if (!obj.hasOwnProperty(key2)) {
            obj[key2] = obj[key1];
        }
    }
    else if (obj.hasOwnProperty(key2)) {
        obj[key1] = obj[key2];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();
var TimelineAnimationEngine = /** @class */ (function () {
    function TimelineAnimationEngine(_driver, _normalizer) {
        this._driver = _driver;
        this._normalizer = _normalizer;
        this._animations = {};
        this._playersById = {};
        this.players = [];
    }
    /**
     * @param {?} id
     * @param {?} metadata
     * @return {?}
     */
    TimelineAnimationEngine.prototype.register = /**
     * @param {?} id
     * @param {?} metadata
     * @return {?}
     */
    function (id, metadata) {
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = buildAnimationAst(this._driver, metadata, errors);
        if (errors.length) {
            throw new Error("Unable to build the animation due to the following errors: " + errors.join("\n"));
        }
        else {
            this._animations[id] = ast;
        }
    };
    /**
     * @param {?} i
     * @param {?} preStyles
     * @param {?=} postStyles
     * @return {?}
     */
    TimelineAnimationEngine.prototype._buildPlayer = /**
     * @param {?} i
     * @param {?} preStyles
     * @param {?=} postStyles
     * @return {?}
     */
    function (i, preStyles, postStyles) {
        var /** @type {?} */ element = i.element;
        var /** @type {?} */ keyframes = normalizeKeyframes(this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);
        return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, []);
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    TimelineAnimationEngine.prototype.create = /**
     * @param {?} id
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    function (id, element, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var /** @type {?} */ errors = [];
        var /** @type {?} */ ast = this._animations[id];
        var /** @type {?} */ instructions;
        var /** @type {?} */ autoStylesMap = new Map();
        if (ast) {
            instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, {}, {}, options, EMPTY_INSTRUCTION_MAP, errors);
            instructions.forEach(function (inst) {
                var /** @type {?} */ styles = getOrSetAsInMap(autoStylesMap, inst.element, {});
                inst.postStyleProps.forEach(function (prop) { return styles[prop] = null; });
            });
        }
        else {
            errors.push('The requested animation doesn\'t exist or has already been destroyed');
            instructions = [];
        }
        if (errors.length) {
            throw new Error("Unable to create the animation due to the following errors: " + errors.join("\n"));
        }
        autoStylesMap.forEach(function (styles, element) {
            Object.keys(styles).forEach(function (prop) { styles[prop] = _this._driver.computeStyle(element, prop, _angular_animations.AUTO_STYLE); });
        });
        var /** @type {?} */ players = instructions.map(function (i) {
            var /** @type {?} */ styles = autoStylesMap.get(i.element);
            return _this._buildPlayer(i, {}, styles);
        });
        var /** @type {?} */ player = optimizeGroupPlayer(players);
        this._playersById[id] = player;
        player.onDestroy(function () { return _this.destroy(id); });
        this.players.push(player);
        return player;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TimelineAnimationEngine.prototype.destroy = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var /** @type {?} */ player = this._getPlayer(id);
        player.destroy();
        delete this._playersById[id];
        var /** @type {?} */ index = this.players.indexOf(player);
        if (index >= 0) {
            this.players.splice(index, 1);
        }
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TimelineAnimationEngine.prototype._getPlayer = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var /** @type {?} */ player = this._playersById[id];
        if (!player) {
            throw new Error("Unable to find the timeline player referenced by " + id);
        }
        return player;
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    TimelineAnimationEngine.prototype.listen = /**
     * @param {?} id
     * @param {?} element
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (id, element, eventName, callback) {
        // triggerName, fromState, toState are all ignored for timeline animations
        var /** @type {?} */ baseEvent = makeAnimationEvent(element, '', '', '');
        listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);
        return function () { };
    };
    /**
     * @param {?} id
     * @param {?} element
     * @param {?} command
     * @param {?} args
     * @return {?}
     */
    TimelineAnimationEngine.prototype.command = /**
     * @param {?} id
     * @param {?} element
     * @param {?} command
     * @param {?} args
     * @return {?}
     */
    function (id, element, command, args) {
        if (command == 'register') {
            this.register(id, /** @type {?} */ (args[0]));
            return;
        }
        if (command == 'create') {
            var /** @type {?} */ options = /** @type {?} */ ((args[0] || {}));
            this.create(id, element, options);
            return;
        }
        var /** @type {?} */ player = this._getPlayer(id);
        switch (command) {
            case 'play':
                player.play();
                break;
            case 'pause':
                player.pause();
                break;
            case 'reset':
                player.reset();
                break;
            case 'restart':
                player.restart();
                break;
            case 'finish':
                player.finish();
                break;
            case 'init':
                player.init();
                break;
            case 'setPosition':
                player.setPosition(parseFloat(/** @type {?} */ (args[0])));
                break;
            case 'destroy':
                this.destroy(id);
                break;
        }
    };
    return TimelineAnimationEngine;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var QUEUED_CLASSNAME = 'ng-animate-queued';
var QUEUED_SELECTOR = '.ng-animate-queued';
var DISABLED_CLASSNAME = 'ng-animate-disabled';
var DISABLED_SELECTOR = '.ng-animate-disabled';
var STAR_CLASSNAME = 'ng-star-inserted';
var STAR_SELECTOR = '.ng-star-inserted';
var EMPTY_PLAYER_ARRAY = [];
var NULL_REMOVAL_STATE = {
    namespaceId: '',
    setForRemoval: null,
    hasAnimation: false,
    removedBeforeQueried: false
};
var NULL_REMOVED_QUERIED_STATE = {
    namespaceId: '',
    setForRemoval: null,
    hasAnimation: false,
    removedBeforeQueried: true
};
/**
 * @record
 */

var REMOVAL_FLAG = '__ng_removed';
/**
 * @record
 */

var StateValue = /** @class */ (function () {
    function StateValue(input, namespaceId) {
        if (namespaceId === void 0) { namespaceId = ''; }
        this.namespaceId = namespaceId;
        var /** @type {?} */ isObj = input && input.hasOwnProperty('value');
        var /** @type {?} */ value = isObj ? input['value'] : input;
        this.value = normalizeTriggerValue(value);
        if (isObj) {
            var /** @type {?} */ options = copyObj(/** @type {?} */ (input));
            delete options['value'];
            this.options = /** @type {?} */ (options);
        }
        else {
            this.options = {};
        }
        if (!this.options.params) {
            this.options.params = {};
        }
    }
    Object.defineProperty(StateValue.prototype, "params", {
        get: /**
         * @return {?}
         */
        function () { return /** @type {?} */ (this.options.params); },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} options
     * @return {?}
     */
    StateValue.prototype.absorbOptions = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        var /** @type {?} */ newParams = options.params;
        if (newParams) {
            var /** @type {?} */ oldParams_1 = /** @type {?} */ ((this.options.params));
            Object.keys(newParams).forEach(function (prop) {
                if (oldParams_1[prop] == null) {
                    oldParams_1[prop] = newParams[prop];
                }
            });
        }
    };
    return StateValue;
}());
var VOID_VALUE = 'void';
var DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);
var DELETED_STATE_VALUE = new StateValue('DELETED');
var AnimationTransitionNamespace = /** @class */ (function () {
    function AnimationTransitionNamespace(id, hostElement, _engine) {
        this.id = id;
        this.hostElement = hostElement;
        this._engine = _engine;
        this.players = [];
        this._triggers = {};
        this._queue = [];
        this._elementListeners = new Map();
        this._hostClassName = 'ng-tns-' + id;
        addClass(hostElement, this._hostClassName);
    }
    /**
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.listen = /**
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    function (element, name, phase, callback) {
        var _this = this;
        if (!this._triggers.hasOwnProperty(name)) {
            throw new Error("Unable to listen on the animation trigger event \"" + phase + "\" because the animation trigger \"" + name + "\" doesn't exist!");
        }
        if (phase == null || phase.length == 0) {
            throw new Error("Unable to listen on the animation trigger \"" + name + "\" because the provided event is undefined!");
        }
        if (!isTriggerEventValid(phase)) {
            throw new Error("The provided animation trigger event \"" + phase + "\" for the animation trigger \"" + name + "\" is not supported!");
        }
        var /** @type {?} */ listeners = getOrSetAsInMap(this._elementListeners, element, []);
        var /** @type {?} */ data = { name: name, phase: phase, callback: callback };
        listeners.push(data);
        var /** @type {?} */ triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});
        if (!triggersWithStates.hasOwnProperty(name)) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);
            triggersWithStates[name] = DEFAULT_STATE_VALUE;
        }
        return function () {
            // the event listener is removed AFTER the flush has occurred such
            // that leave animations callbacks can fire (otherwise if the node
            // is removed in between then the listeners would be deregistered)
            // the event listener is removed AFTER the flush has occurred such
            // that leave animations callbacks can fire (otherwise if the node
            // is removed in between then the listeners would be deregistered)
            _this._engine.afterFlush(function () {
                var /** @type {?} */ index = listeners.indexOf(data);
                if (index >= 0) {
                    listeners.splice(index, 1);
                }
                if (!_this._triggers[name]) {
                    delete triggersWithStates[name];
                }
            });
        };
    };
    /**
     * @param {?} name
     * @param {?} ast
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.register = /**
     * @param {?} name
     * @param {?} ast
     * @return {?}
     */
    function (name, ast) {
        if (this._triggers[name]) {
            // throw
            return false;
        }
        else {
            this._triggers[name] = ast;
            return true;
        }
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AnimationTransitionNamespace.prototype._getTrigger = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        var /** @type {?} */ trigger = this._triggers[name];
        if (!trigger) {
            throw new Error("The provided animation trigger \"" + name + "\" has not been registered!");
        }
        return trigger;
    };
    /**
     * @param {?} element
     * @param {?} triggerName
     * @param {?} value
     * @param {?=} defaultToFallback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.trigger = /**
     * @param {?} element
     * @param {?} triggerName
     * @param {?} value
     * @param {?=} defaultToFallback
     * @return {?}
     */
    function (element, triggerName, value, defaultToFallback) {
        var _this = this;
        if (defaultToFallback === void 0) { defaultToFallback = true; }
        var /** @type {?} */ trigger = this._getTrigger(triggerName);
        var /** @type {?} */ player = new TransitionAnimationPlayer(this.id, triggerName, element);
        var /** @type {?} */ triggersWithStates = this._engine.statesByElement.get(element);
        if (!triggersWithStates) {
            addClass(element, NG_TRIGGER_CLASSNAME);
            addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);
            this._engine.statesByElement.set(element, triggersWithStates = {});
        }
        var /** @type {?} */ fromState = triggersWithStates[triggerName];
        var /** @type {?} */ toState = new StateValue(value, this.id);
        var /** @type {?} */ isObj = value && value.hasOwnProperty('value');
        if (!isObj && fromState) {
            toState.absorbOptions(fromState.options);
        }
        triggersWithStates[triggerName] = toState;
        if (!fromState) {
            fromState = DEFAULT_STATE_VALUE;
        }
        else if (fromState === DELETED_STATE_VALUE) {
            return player;
        }
        var /** @type {?} */ isRemoval = toState.value === VOID_VALUE;
        // normally this isn't reached by here, however, if an object expression
        // is passed in then it may be a new object each time. Comparing the value
        // is important since that will stay the same despite there being a new object.
        // The removal arc here is special cased because the same element is triggered
        // twice in the event that it contains animations on the outer/inner portions
        // of the host container
        if (!isRemoval && fromState.value === toState.value) {
            // this means that despite the value not changing, some inner params
            // have changed which means that the animation final styles need to be applied
            if (!objEquals(fromState.params, toState.params)) {
                var /** @type {?} */ errors = [];
                var /** @type {?} */ fromStyles_1 = trigger.matchStyles(fromState.value, fromState.params, errors);
                var /** @type {?} */ toStyles_1 = trigger.matchStyles(toState.value, toState.params, errors);
                if (errors.length) {
                    this._engine.reportError(errors);
                }
                else {
                    this._engine.afterFlush(function () {
                        eraseStyles(element, fromStyles_1);
                        setStyles(element, toStyles_1);
                    });
                }
            }
            return;
        }
        var /** @type {?} */ playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);
        playersOnElement.forEach(function (player) {
            // only remove the player if it is queued on the EXACT same trigger/namespace
            // we only also deal with queued players here because if the animation has
            // started then we want to keep the player alive until the flush happens
            // (which is where the previousPlayers are passed into the new palyer)
            if (player.namespaceId == _this.id && player.triggerName == triggerName && player.queued) {
                player.destroy();
            }
        });
        var /** @type {?} */ transition = trigger.matchTransition(fromState.value, toState.value);
        var /** @type {?} */ isFallbackTransition = false;
        if (!transition) {
            if (!defaultToFallback)
                return;
            transition = trigger.fallbackTransition;
            isFallbackTransition = true;
        }
        this._engine.totalQueuedPlayers++;
        this._queue.push({ element: element, triggerName: triggerName, transition: transition, fromState: fromState, toState: toState, player: player, isFallbackTransition: isFallbackTransition });
        if (!isFallbackTransition) {
            addClass(element, QUEUED_CLASSNAME);
            player.onStart(function () { removeClass(element, QUEUED_CLASSNAME); });
        }
        player.onDone(function () {
            var /** @type {?} */ index = _this.players.indexOf(player);
            if (index >= 0) {
                _this.players.splice(index, 1);
            }
            var /** @type {?} */ players = _this._engine.playersByElement.get(element);
            if (players) {
                var /** @type {?} */ index_1 = players.indexOf(player);
                if (index_1 >= 0) {
                    players.splice(index_1, 1);
                }
            }
        });
        this.players.push(player);
        playersOnElement.push(player);
        return player;
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.deregister = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        var _this = this;
        delete this._triggers[name];
        this._engine.statesByElement.forEach(function (stateMap, element) { delete stateMap[name]; });
        this._elementListeners.forEach(function (listeners, element) {
            _this._elementListeners.set(element, listeners.filter(function (entry) { return entry.name != name; }));
        });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.clearElementCache = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        this._engine.statesByElement.delete(element);
        this._elementListeners.delete(element);
        var /** @type {?} */ elementPlayers = this._engine.playersByElement.get(element);
        if (elementPlayers) {
            elementPlayers.forEach(function (player) { return player.destroy(); });
            this._engine.playersByElement.delete(element);
        }
    };
    /**
     * @param {?} rootElement
     * @param {?} context
     * @param {?=} animate
     * @return {?}
     */
    AnimationTransitionNamespace.prototype._signalRemovalForInnerTriggers = /**
     * @param {?} rootElement
     * @param {?} context
     * @param {?=} animate
     * @return {?}
     */
    function (rootElement, context, animate) {
        var _this = this;
        if (animate === void 0) { animate = false; }
        // emulate a leave animation for all inner nodes within this node.
        // If there are no animations found for any of the nodes then clear the cache
        // for the element.
        this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true).forEach(function (elm) {
            // this means that an inner remove() operation has already kicked off
            // the animation on this element...
            if (elm[REMOVAL_FLAG])
                return;
            var /** @type {?} */ namespaces = _this._engine.fetchNamespacesByElement(elm);
            if (namespaces.size) {
                namespaces.forEach(function (ns) { return ns.triggerLeaveAnimation(elm, context, false, true); });
            }
            else {
                _this.clearElementCache(elm);
            }
        });
    };
    /**
     * @param {?} element
     * @param {?} context
     * @param {?=} destroyAfterComplete
     * @param {?=} defaultToFallback
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.triggerLeaveAnimation = /**
     * @param {?} element
     * @param {?} context
     * @param {?=} destroyAfterComplete
     * @param {?=} defaultToFallback
     * @return {?}
     */
    function (element, context, destroyAfterComplete, defaultToFallback) {
        var _this = this;
        var /** @type {?} */ triggerStates = this._engine.statesByElement.get(element);
        if (triggerStates) {
            var /** @type {?} */ players_1 = [];
            Object.keys(triggerStates).forEach(function (triggerName) {
                // this check is here in the event that an element is removed
                // twice (both on the host level and the component level)
                if (_this._triggers[triggerName]) {
                    var /** @type {?} */ player = _this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);
                    if (player) {
                        players_1.push(player);
                    }
                }
            });
            if (players_1.length) {
                this._engine.markElementAsRemoved(this.id, element, true, context);
                if (destroyAfterComplete) {
                    optimizeGroupPlayer(players_1).onDone(function () { return _this._engine.processLeaveNode(element); });
                }
                return true;
            }
        }
        return false;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.prepareLeaveAnimationListeners = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var _this = this;
        var /** @type {?} */ listeners = this._elementListeners.get(element);
        if (listeners) {
            var /** @type {?} */ visitedTriggers_1 = new Set();
            listeners.forEach(function (listener) {
                var /** @type {?} */ triggerName = listener.name;
                if (visitedTriggers_1.has(triggerName))
                    return;
                visitedTriggers_1.add(triggerName);
                var /** @type {?} */ trigger = _this._triggers[triggerName];
                var /** @type {?} */ transition = trigger.fallbackTransition;
                var /** @type {?} */ elementStates = /** @type {?} */ ((_this._engine.statesByElement.get(element)));
                var /** @type {?} */ fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;
                var /** @type {?} */ toState = new StateValue(VOID_VALUE);
                var /** @type {?} */ player = new TransitionAnimationPlayer(_this.id, triggerName, element);
                _this._engine.totalQueuedPlayers++;
                _this._queue.push({
                    element: element,
                    triggerName: triggerName,
                    transition: transition,
                    fromState: fromState,
                    toState: toState,
                    player: player,
                    isFallbackTransition: true
                });
            });
        }
    };
    /**
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.removeNode = /**
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    function (element, context) {
        var _this = this;
        var /** @type {?} */ engine = this._engine;
        if (element.childElementCount) {
            this._signalRemovalForInnerTriggers(element, context, true);
        }
        // this means that a * => VOID animation was detected and kicked off
        if (this.triggerLeaveAnimation(element, context, true))
            return;
        // find the player that is animating and make sure that the
        // removal is delayed until that player has completed
        var /** @type {?} */ containsPotentialParentTransition = false;
        if (engine.totalAnimations) {
            var /** @type {?} */ currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
            // when this `if statement` does not continue forward it means that
            // a previous animation query has selected the current element and
            // is animating it. In this situation want to continue fowards and
            // allow the element to be queued up for animation later.
            if (currentPlayers && currentPlayers.length) {
                containsPotentialParentTransition = true;
            }
            else {
                var /** @type {?} */ parent_1 = element;
                while (parent_1 = parent_1.parentNode) {
                    var /** @type {?} */ triggers = engine.statesByElement.get(parent_1);
                    if (triggers) {
                        containsPotentialParentTransition = true;
                        break;
                    }
                }
            }
        }
        // at this stage we know that the element will either get removed
        // during flush or will be picked up by a parent query. Either way
        // we need to fire the listeners for this element when it DOES get
        // removed (once the query parent animation is done or after flush)
        this.prepareLeaveAnimationListeners(element);
        // whether or not a parent has an animation we need to delay the deferral of the leave
        // operation until we have more information (which we do after flush() has been called)
        if (containsPotentialParentTransition) {
            engine.markElementAsRemoved(this.id, element, false, context);
        }
        else {
            // we do this after the flush has occurred such
            // that the callbacks can be fired
            engine.afterFlush(function () { return _this.clearElementCache(element); });
            engine.destroyInnerAnimations(element);
            engine._onRemovalComplete(element, context);
        }
    };
    /**
     * @param {?} element
     * @param {?} parent
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.insertNode = /**
     * @param {?} element
     * @param {?} parent
     * @return {?}
     */
    function (element, parent) { addClass(element, this._hostClassName); };
    /**
     * @param {?} microtaskId
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.drainQueuedTransitions = /**
     * @param {?} microtaskId
     * @return {?}
     */
    function (microtaskId) {
        var _this = this;
        var /** @type {?} */ instructions = [];
        this._queue.forEach(function (entry) {
            var /** @type {?} */ player = entry.player;
            if (player.destroyed)
                return;
            var /** @type {?} */ element = entry.element;
            var /** @type {?} */ listeners = _this._elementListeners.get(element);
            if (listeners) {
                listeners.forEach(function (listener) {
                    if (listener.name == entry.triggerName) {
                        var /** @type {?} */ baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
                        (/** @type {?} */ (baseEvent))['_data'] = microtaskId;
                        listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
                    }
                });
            }
            if (player.markedForDestroy) {
                _this._engine.afterFlush(function () {
                    // now we can destroy the element properly since the event listeners have
                    // been bound to the player
                    player.destroy();
                });
            }
            else {
                instructions.push(entry);
            }
        });
        this._queue = [];
        return instructions.sort(function (a, b) {
            // if depCount == 0 them move to front
            // otherwise if a contains b then move back
            var /** @type {?} */ d0 = a.transition.ast.depCount;
            var /** @type {?} */ d1 = b.transition.ast.depCount;
            if (d0 == 0 || d1 == 0) {
                return d0 - d1;
            }
            return _this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
        });
    };
    /**
     * @param {?} context
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.destroy = /**
     * @param {?} context
     * @return {?}
     */
    function (context) {
        this.players.forEach(function (p) { return p.destroy(); });
        this._signalRemovalForInnerTriggers(this.hostElement, context);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AnimationTransitionNamespace.prototype.elementContainsData = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ containsData = false;
        if (this._elementListeners.has(element))
            containsData = true;
        containsData =
            (this._queue.find(function (entry) { return entry.element === element; }) ? true : false) || containsData;
        return containsData;
    };
    return AnimationTransitionNamespace;
}());
/**
 * @record
 */

var TransitionAnimationEngine = /** @class */ (function () {
    function TransitionAnimationEngine(driver, _normalizer) {
        this.driver = driver;
        this._normalizer = _normalizer;
        this.players = [];
        this.newHostElements = new Map();
        this.playersByElement = new Map();
        this.playersByQueriedElement = new Map();
        this.statesByElement = new Map();
        this.disabledNodes = new Set();
        this.totalAnimations = 0;
        this.totalQueuedPlayers = 0;
        this._namespaceLookup = {};
        this._namespaceList = [];
        this._flushFns = [];
        this._whenQuietFns = [];
        this.namespacesByHostElement = new Map();
        this.collectedEnterElements = [];
        this.collectedLeaveElements = [];
        this.onRemovalComplete = function (element, context) { };
    }
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype._onRemovalComplete = /**
     * \@internal
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    function (element, context) { this.onRemovalComplete(element, context); };
    Object.defineProperty(TransitionAnimationEngine.prototype, "queuedPlayers", {
        get: /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ players = [];
            this._namespaceList.forEach(function (ns) {
                ns.players.forEach(function (player) {
                    if (player.queued) {
                        players.push(player);
                    }
                });
            });
            return players;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.createNamespace = /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    function (namespaceId, hostElement) {
        var /** @type {?} */ ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
        if (hostElement.parentNode) {
            this._balanceNamespaceList(ns, hostElement);
        }
        else {
            // defer this later until flush during when the host element has
            // been inserted so that we know exactly where to place it in
            // the namespace list
            this.newHostElements.set(hostElement, ns);
            // given that this host element is apart of the animation code, it
            // may or may not be inserted by a parent node that is an of an
            // animation renderer type. If this happens then we can still have
            // access to this item when we query for :enter nodes. If the parent
            // is a renderer then the set data-structure will normalize the entry
            this.collectEnterElement(hostElement);
        }
        return this._namespaceLookup[namespaceId] = ns;
    };
    /**
     * @param {?} ns
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype._balanceNamespaceList = /**
     * @param {?} ns
     * @param {?} hostElement
     * @return {?}
     */
    function (ns, hostElement) {
        var /** @type {?} */ limit = this._namespaceList.length - 1;
        if (limit >= 0) {
            var /** @type {?} */ found = false;
            for (var /** @type {?} */ i = limit; i >= 0; i--) {
                var /** @type {?} */ nextNamespace = this._namespaceList[i];
                if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {
                    this._namespaceList.splice(i + 1, 0, ns);
                    found = true;
                    break;
                }
            }
            if (!found) {
                this._namespaceList.splice(0, 0, ns);
            }
        }
        else {
            this._namespaceList.push(ns);
        }
        this.namespacesByHostElement.set(hostElement, ns);
        return ns;
    };
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.register = /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    function (namespaceId, hostElement) {
        var /** @type {?} */ ns = this._namespaceLookup[namespaceId];
        if (!ns) {
            ns = this.createNamespace(namespaceId, hostElement);
        }
        return ns;
    };
    /**
     * @param {?} namespaceId
     * @param {?} name
     * @param {?} trigger
     * @return {?}
     */
    TransitionAnimationEngine.prototype.registerTrigger = /**
     * @param {?} namespaceId
     * @param {?} name
     * @param {?} trigger
     * @return {?}
     */
    function (namespaceId, name, trigger) {
        var /** @type {?} */ ns = this._namespaceLookup[namespaceId];
        if (ns && ns.register(name, trigger)) {
            this.totalAnimations++;
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroy = /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    function (namespaceId, context) {
        var _this = this;
        if (!namespaceId)
            return;
        var /** @type {?} */ ns = this._fetchNamespace(namespaceId);
        this.afterFlush(function () {
            _this.namespacesByHostElement.delete(ns.hostElement);
            delete _this._namespaceLookup[namespaceId];
            var /** @type {?} */ index = _this._namespaceList.indexOf(ns);
            if (index >= 0) {
                _this._namespaceList.splice(index, 1);
            }
        });
        this.afterFlushAnimationsDone(function () { return ns.destroy(context); });
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TransitionAnimationEngine.prototype._fetchNamespace = /**
     * @param {?} id
     * @return {?}
     */
    function (id) { return this._namespaceLookup[id]; };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.fetchNamespacesByElement = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        // normally there should only be one namespace per element, however
        // if @triggers are placed on both the component element and then
        // its host element (within the component code) then there will be
        // two namespaces returned. We use a set here to simply the dedupe
        // of namespaces incase there are multiple triggers both the elm and host
        var /** @type {?} */ namespaces = new Set();
        var /** @type {?} */ elementStates = this.statesByElement.get(element);
        if (elementStates) {
            var /** @type {?} */ keys = Object.keys(elementStates);
            for (var /** @type {?} */ i = 0; i < keys.length; i++) {
                var /** @type {?} */ nsId = elementStates[keys[i]].namespaceId;
                if (nsId) {
                    var /** @type {?} */ ns = this._fetchNamespace(nsId);
                    if (ns) {
                        namespaces.add(ns);
                    }
                }
            }
        }
        return namespaces;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    TransitionAnimationEngine.prototype.trigger = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (namespaceId, element, name, value) {
        if (isElementNode(element)) {
            this._fetchNamespace(namespaceId).trigger(element, name, value);
            return true;
        }
        return false;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    TransitionAnimationEngine.prototype.insertNode = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    function (namespaceId, element, parent, insertBefore) {
        if (!isElementNode(element))
            return;
        // special case for when an element is removed and reinserted (move operation)
        // when this occurs we do not want to use the element for deletion later
        var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval) {
            details.setForRemoval = false;
        }
        // in the event that the namespaceId is blank then the caller
        // code does not contain any animation code in it, but it is
        // just being called so that the node is marked as being inserted
        if (namespaceId) {
            this._fetchNamespace(namespaceId).insertNode(element, parent);
        }
        // only *directives and host elements are inserted before
        if (insertBefore) {
            this.collectEnterElement(element);
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.collectEnterElement = /**
     * @param {?} element
     * @return {?}
     */
    function (element) { this.collectedEnterElements.push(element); };
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    TransitionAnimationEngine.prototype.markElementAsDisabled = /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    function (element, value) {
        if (value) {
            if (!this.disabledNodes.has(element)) {
                this.disabledNodes.add(element);
                addClass(element, DISABLED_CLASSNAME);
            }
        }
        else if (this.disabledNodes.has(element)) {
            this.disabledNodes.delete(element);
            removeClass(element, DISABLED_CLASSNAME);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.removeNode = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    function (namespaceId, element, context) {
        if (!isElementNode(element)) {
            this._onRemovalComplete(element, context);
            return;
        }
        var /** @type {?} */ ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
        if (ns) {
            ns.removeNode(element, context);
        }
        else {
            this.markElementAsRemoved(namespaceId, element, false, context);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?=} hasAnimation
     * @param {?=} context
     * @return {?}
     */
    TransitionAnimationEngine.prototype.markElementAsRemoved = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?=} hasAnimation
     * @param {?=} context
     * @return {?}
     */
    function (namespaceId, element, hasAnimation, context) {
        this.collectedLeaveElements.push(element);
        element[REMOVAL_FLAG] = {
            namespaceId: namespaceId,
            setForRemoval: context, hasAnimation: hasAnimation,
            removedBeforeQueried: false
        };
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.listen = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} name
     * @param {?} phase
     * @param {?} callback
     * @return {?}
     */
    function (namespaceId, element, name, phase, callback) {
        if (isElementNode(element)) {
            return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);
        }
        return function () { };
    };
    /**
     * @param {?} entry
     * @param {?} subTimelines
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildInstruction = /**
     * @param {?} entry
     * @param {?} subTimelines
     * @param {?} enterClassName
     * @param {?} leaveClassName
     * @return {?}
     */
    function (entry, subTimelines, enterClassName, leaveClassName) {
        return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines);
    };
    /**
     * @param {?} containerElement
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroyInnerAnimations = /**
     * @param {?} containerElement
     * @return {?}
     */
    function (containerElement) {
        var _this = this;
        var /** @type {?} */ elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);
        elements.forEach(function (element) { return _this.destroyActiveAnimationsForElement(element); });
        if (this.playersByQueriedElement.size == 0)
            return;
        elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);
        elements.forEach(function (element) { return _this.finishActiveQueriedAnimationOnElement(element); });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.destroyActiveAnimationsForElement = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ players = this.playersByElement.get(element);
        if (players) {
            players.forEach(function (player) {
                // special case for when an element is set for destruction, but hasn't started.
                // in this situation we want to delay the destruction until the flush occurs
                // so that any event listeners attached to the player are triggered.
                if (player.queued) {
                    player.markedForDestroy = true;
                }
                else {
                    player.destroy();
                }
            });
        }
        var /** @type {?} */ stateMap = this.statesByElement.get(element);
        if (stateMap) {
            Object.keys(stateMap).forEach(function (triggerName) { return stateMap[triggerName] = DELETED_STATE_VALUE; });
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.finishActiveQueriedAnimationOnElement = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ players = this.playersByQueriedElement.get(element);
        if (players) {
            players.forEach(function (player) { return player.finish(); });
        }
    };
    /**
     * @return {?}
     */
    TransitionAnimationEngine.prototype.whenRenderingDone = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this.players.length) {
                return optimizeGroupPlayer(_this.players).onDone(function () { return resolve(); });
            }
            else {
                resolve();
            }
        });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.processLeaveNode = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var _this = this;
        var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval) {
            // this will prevent it from removing it twice
            element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;
            if (details.namespaceId) {
                this.destroyInnerAnimations(element);
                var /** @type {?} */ ns = this._fetchNamespace(details.namespaceId);
                if (ns) {
                    ns.clearElementCache(element);
                }
            }
            this._onRemovalComplete(element, details.setForRemoval);
        }
        if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {
            this.markElementAsDisabled(element, false);
        }
        this.driver.query(element, DISABLED_SELECTOR, true).forEach(function (node) {
            _this.markElementAsDisabled(element, false);
        });
    };
    /**
     * @param {?=} microtaskId
     * @return {?}
     */
    TransitionAnimationEngine.prototype.flush = /**
     * @param {?=} microtaskId
     * @return {?}
     */
    function (microtaskId) {
        var _this = this;
        if (microtaskId === void 0) { microtaskId = -1; }
        var /** @type {?} */ players = [];
        if (this.newHostElements.size) {
            this.newHostElements.forEach(function (ns, element) { return _this._balanceNamespaceList(ns, element); });
            this.newHostElements.clear();
        }
        if (this.totalAnimations && this.collectedEnterElements.length) {
            for (var /** @type {?} */ i = 0; i < this.collectedEnterElements.length; i++) {
                var /** @type {?} */ elm = this.collectedEnterElements[i];
                addClass(elm, STAR_CLASSNAME);
            }
        }
        if (this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
            var /** @type {?} */ cleanupFns = [];
            try {
                players = this._flushAnimations(cleanupFns, microtaskId);
            }
            finally {
                for (var /** @type {?} */ i = 0; i < cleanupFns.length; i++) {
                    cleanupFns[i]();
                }
            }
        }
        else {
            for (var /** @type {?} */ i = 0; i < this.collectedLeaveElements.length; i++) {
                var /** @type {?} */ element = this.collectedLeaveElements[i];
                this.processLeaveNode(element);
            }
        }
        this.totalQueuedPlayers = 0;
        this.collectedEnterElements.length = 0;
        this.collectedLeaveElements.length = 0;
        this._flushFns.forEach(function (fn) { return fn(); });
        this._flushFns = [];
        if (this._whenQuietFns.length) {
            // we move these over to a variable so that
            // if any new callbacks are registered in another
            // flush they do not populate the existing set
            var /** @type {?} */ quietFns_1 = this._whenQuietFns;
            this._whenQuietFns = [];
            if (players.length) {
                optimizeGroupPlayer(players).onDone(function () { quietFns_1.forEach(function (fn) { return fn(); }); });
            }
            else {
                quietFns_1.forEach(function (fn) { return fn(); });
            }
        }
    };
    /**
     * @param {?} errors
     * @return {?}
     */
    TransitionAnimationEngine.prototype.reportError = /**
     * @param {?} errors
     * @return {?}
     */
    function (errors) {
        throw new Error("Unable to process animations due to the following failed trigger transitions\n " + errors.join('\n'));
    };
    /**
     * @param {?} cleanupFns
     * @param {?} microtaskId
     * @return {?}
     */
    TransitionAnimationEngine.prototype._flushAnimations = /**
     * @param {?} cleanupFns
     * @param {?} microtaskId
     * @return {?}
     */
    function (cleanupFns, microtaskId) {
        var _this = this;
        var /** @type {?} */ subTimelines = new ElementInstructionMap();
        var /** @type {?} */ skippedPlayers = [];
        var /** @type {?} */ skippedPlayersMap = new Map();
        var /** @type {?} */ queuedInstructions = [];
        var /** @type {?} */ queriedElements = new Map();
        var /** @type {?} */ allPreStyleElements = new Map();
        var /** @type {?} */ allPostStyleElements = new Map();
        var /** @type {?} */ disabledElementsSet = new Set();
        this.disabledNodes.forEach(function (node) {
            disabledElementsSet.add(node);
            var /** @type {?} */ nodesThatAreDisabled = _this.driver.query(node, QUEUED_SELECTOR, true);
            for (var /** @type {?} */ i_1 = 0; i_1 < nodesThatAreDisabled.length; i_1++) {
                disabledElementsSet.add(nodesThatAreDisabled[i_1]);
            }
        });
        var /** @type {?} */ bodyNode = getBodyNode();
        var /** @type {?} */ allTriggerElements = Array.from(this.statesByElement.keys());
        var /** @type {?} */ enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);
        // this must occur before the instructions are built below such that
        // the :enter queries match the elements (since the timeline queries
        // are fired during instruction building).
        var /** @type {?} */ enterNodeMapIds = new Map();
        var /** @type {?} */ i = 0;
        enterNodeMap.forEach(function (nodes, root) {
            var /** @type {?} */ className = ENTER_CLASSNAME + i++;
            enterNodeMapIds.set(root, className);
            nodes.forEach(function (node) { return addClass(node, className); });
        });
        var /** @type {?} */ allLeaveNodes = [];
        var /** @type {?} */ mergedLeaveNodes = new Set();
        var /** @type {?} */ leaveNodesWithoutAnimations = new Set();
        for (var /** @type {?} */ i_2 = 0; i_2 < this.collectedLeaveElements.length; i_2++) {
            var /** @type {?} */ element = this.collectedLeaveElements[i_2];
            var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
            if (details && details.setForRemoval) {
                allLeaveNodes.push(element);
                mergedLeaveNodes.add(element);
                if (details.hasAnimation) {
                    this.driver.query(element, STAR_SELECTOR, true).forEach(function (elm) { return mergedLeaveNodes.add(elm); });
                }
                else {
                    leaveNodesWithoutAnimations.add(element);
                }
            }
        }
        var /** @type {?} */ leaveNodeMapIds = new Map();
        var /** @type {?} */ leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));
        leaveNodeMap.forEach(function (nodes, root) {
            var /** @type {?} */ className = LEAVE_CLASSNAME + i++;
            leaveNodeMapIds.set(root, className);
            nodes.forEach(function (node) { return addClass(node, className); });
        });
        cleanupFns.push(function () {
            enterNodeMap.forEach(function (nodes, root) {
                var /** @type {?} */ className = /** @type {?} */ ((enterNodeMapIds.get(root)));
                nodes.forEach(function (node) { return removeClass(node, className); });
            });
            leaveNodeMap.forEach(function (nodes, root) {
                var /** @type {?} */ className = /** @type {?} */ ((leaveNodeMapIds.get(root)));
                nodes.forEach(function (node) { return removeClass(node, className); });
            });
            allLeaveNodes.forEach(function (element) { _this.processLeaveNode(element); });
        });
        var /** @type {?} */ allPlayers = [];
        var /** @type {?} */ erroneousTransitions = [];
        for (var /** @type {?} */ i_3 = this._namespaceList.length - 1; i_3 >= 0; i_3--) {
            var /** @type {?} */ ns = this._namespaceList[i_3];
            ns.drainQueuedTransitions(microtaskId).forEach(function (entry) {
                var /** @type {?} */ player = entry.player;
                allPlayers.push(player);
                var /** @type {?} */ element = entry.element;
                if (!bodyNode || !_this.driver.containsElement(bodyNode, element)) {
                    player.destroy();
                    return;
                }
                var /** @type {?} */ leaveClassName = /** @type {?} */ ((leaveNodeMapIds.get(element)));
                var /** @type {?} */ enterClassName = /** @type {?} */ ((enterNodeMapIds.get(element)));
                var /** @type {?} */ instruction = /** @type {?} */ ((_this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName)));
                if (instruction.errors && instruction.errors.length) {
                    erroneousTransitions.push(instruction);
                    return;
                }
                // if a unmatched transition is queued to go then it SHOULD NOT render
                // an animation and cancel the previously running animations.
                if (entry.isFallbackTransition) {
                    player.onStart(function () { return eraseStyles(element, instruction.fromStyles); });
                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                    skippedPlayers.push(player);
                    return;
                }
                // this means that if a parent animation uses this animation as a sub trigger
                // then it will instruct the timeline builder to not add a player delay, but
                // instead stretch the first keyframe gap up until the animation starts. The
                // reason this is important is to prevent extra initialization styles from being
                // required by the user in the animation.
                instruction.timelines.forEach(function (tl) { return tl.stretchStartingKeyframe = true; });
                subTimelines.append(element, instruction.timelines);
                var /** @type {?} */ tuple = { instruction: instruction, player: player, element: element };
                queuedInstructions.push(tuple);
                instruction.queriedElements.forEach(function (element) { return getOrSetAsInMap(queriedElements, element, []).push(player); });
                instruction.preStyleProps.forEach(function (stringMap, element) {
                    var /** @type {?} */ props = Object.keys(stringMap);
                    if (props.length) {
                        var /** @type {?} */ setVal_1 = /** @type {?} */ ((allPreStyleElements.get(element)));
                        if (!setVal_1) {
                            allPreStyleElements.set(element, setVal_1 = new Set());
                        }
                        props.forEach(function (prop) { return setVal_1.add(prop); });
                    }
                });
                instruction.postStyleProps.forEach(function (stringMap, element) {
                    var /** @type {?} */ props = Object.keys(stringMap);
                    var /** @type {?} */ setVal = /** @type {?} */ ((allPostStyleElements.get(element)));
                    if (!setVal) {
                        allPostStyleElements.set(element, setVal = new Set());
                    }
                    props.forEach(function (prop) { return setVal.add(prop); });
                });
            });
        }
        if (erroneousTransitions.length) {
            var /** @type {?} */ errors_1 = [];
            erroneousTransitions.forEach(function (instruction) {
                errors_1.push("@" + instruction.triggerName + " has failed due to:\n"); /** @type {?} */
                ((instruction.errors)).forEach(function (error) { return errors_1.push("- " + error + "\n"); });
            });
            allPlayers.forEach(function (player) { return player.destroy(); });
            this.reportError(errors_1);
        }
        var /** @type {?} */ allPreviousPlayersMap = new Map();
        // this map works to tell which element in the DOM tree is contained by
        // which animation. Further down below this map will get populated once
        // the players are built and in doing so it can efficiently figure out
        // if a sub player is skipped due to a parent player having priority.
        var /** @type {?} */ animationElementMap = new Map();
        queuedInstructions.forEach(function (entry) {
            var /** @type {?} */ element = entry.element;
            if (subTimelines.has(element)) {
                animationElementMap.set(element, element);
                _this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);
            }
        });
        skippedPlayers.forEach(function (player) {
            var /** @type {?} */ element = player.element;
            var /** @type {?} */ previousPlayers = _this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);
            previousPlayers.forEach(function (prevPlayer) {
                getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);
                prevPlayer.destroy();
            });
        });
        // this is a special case for nodes that will be removed (either by)
        // having their own leave animations or by being queried in a container
        // that will be removed once a parent animation is complete. The idea
        // here is that * styles must be identical to ! styles because of
        // backwards compatibility (* is also filled in by default in many places).
        // Otherwise * styles will return an empty value or auto since the element
        // that is being getComputedStyle'd will not be visible (since * = destination)
        var /** @type {?} */ replaceNodes = allLeaveNodes.filter(function (node) {
            return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);
        });
        // POST STAGE: fill the * styles
        var /** @type {?} */ postStylesMap = new Map();
        var /** @type {?} */ allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, _angular_animations.AUTO_STYLE);
        allLeaveQueriedNodes.forEach(function (node) {
            if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {
                replaceNodes.push(node);
            }
        });
        // PRE STAGE: fill the ! styles
        var /** @type {?} */ preStylesMap = new Map();
        enterNodeMap.forEach(function (nodes, root) {
            cloakAndComputeStyles(preStylesMap, _this.driver, new Set(nodes), allPreStyleElements, _angular_animations.ɵPRE_STYLE);
        });
        replaceNodes.forEach(function (node) {
            var /** @type {?} */ post = postStylesMap.get(node);
            var /** @type {?} */ pre = preStylesMap.get(node);
            postStylesMap.set(node, /** @type {?} */ (__assign({}, post, pre)));
        });
        var /** @type {?} */ rootPlayers = [];
        var /** @type {?} */ subPlayers = [];
        var /** @type {?} */ NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};
        queuedInstructions.forEach(function (entry) {
            var element = entry.element, player = entry.player, instruction = entry.instruction;
            // this means that it was never consumed by a parent animation which
            // means that it is independent and therefore should be set for animation
            if (subTimelines.has(element)) {
                if (disabledElementsSet.has(element)) {
                    player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                    skippedPlayers.push(player);
                    return;
                }
                // this will flow up the DOM and query the map to figure out
                // if a parent animation has priority over it. In the situation
                // that a parent is detected then it will cancel the loop. If
                // nothing is detected, or it takes a few hops to find a parent,
                // then it will fill in the missing nodes and signal them as having
                // a detected parent (or a NO_PARENT value via a special constant).
                var /** @type {?} */ parentWithAnimation_1 = NO_PARENT_ANIMATION_ELEMENT_DETECTED;
                if (animationElementMap.size > 1) {
                    var /** @type {?} */ elm = element;
                    var /** @type {?} */ parentsToAdd = [];
                    while (elm = elm.parentNode) {
                        var /** @type {?} */ detectedParent = animationElementMap.get(elm);
                        if (detectedParent) {
                            parentWithAnimation_1 = detectedParent;
                            break;
                        }
                        parentsToAdd.push(elm);
                    }
                    parentsToAdd.forEach(function (parent) { return animationElementMap.set(parent, parentWithAnimation_1); });
                }
                var /** @type {?} */ innerPlayer = _this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
                player.setRealPlayer(innerPlayer);
                if (parentWithAnimation_1 === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {
                    rootPlayers.push(player);
                }
                else {
                    var /** @type {?} */ parentPlayers = _this.playersByElement.get(parentWithAnimation_1);
                    if (parentPlayers && parentPlayers.length) {
                        player.parentPlayer = optimizeGroupPlayer(parentPlayers);
                    }
                    skippedPlayers.push(player);
                }
            }
            else {
                eraseStyles(element, instruction.fromStyles);
                player.onDestroy(function () { return setStyles(element, instruction.toStyles); });
                // there still might be a ancestor player animating this
                // element therefore we will still add it as a sub player
                // even if its animation may be disabled
                subPlayers.push(player);
                if (disabledElementsSet.has(element)) {
                    skippedPlayers.push(player);
                }
            }
        });
        // find all of the sub players' corresponding inner animation player
        subPlayers.forEach(function (player) {
            // even if any players are not found for a sub animation then it
            // will still complete itself after the next tick since it's Noop
            var /** @type {?} */ playersForElement = skippedPlayersMap.get(player.element);
            if (playersForElement && playersForElement.length) {
                var /** @type {?} */ innerPlayer = optimizeGroupPlayer(playersForElement);
                player.setRealPlayer(innerPlayer);
            }
        });
        // the reason why we don't actually play the animation is
        // because all that a skipped player is designed to do is to
        // fire the start/done transition callback events
        skippedPlayers.forEach(function (player) {
            if (player.parentPlayer) {
                player.syncPlayerEvents(player.parentPlayer);
            }
            else {
                player.destroy();
            }
        });
        // run through all of the queued removals and see if they
        // were picked up by a query. If not then perform the removal
        // operation right away unless a parent animation is ongoing.
        for (var /** @type {?} */ i_4 = 0; i_4 < allLeaveNodes.length; i_4++) {
            var /** @type {?} */ element = allLeaveNodes[i_4];
            var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
            removeClass(element, LEAVE_CLASSNAME);
            // this means the element has a removal animation that is being
            // taken care of and therefore the inner elements will hang around
            // until that animation is over (or the parent queried animation)
            if (details && details.hasAnimation)
                continue;
            var /** @type {?} */ players = [];
            // if this element is queried or if it contains queried children
            // then we want for the element not to be removed from the page
            // until the queried animations have finished
            if (queriedElements.size) {
                var /** @type {?} */ queriedPlayerResults = queriedElements.get(element);
                if (queriedPlayerResults && queriedPlayerResults.length) {
                    players.push.apply(players, queriedPlayerResults);
                }
                var /** @type {?} */ queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);
                for (var /** @type {?} */ j = 0; j < queriedInnerElements.length; j++) {
                    var /** @type {?} */ queriedPlayers = queriedElements.get(queriedInnerElements[j]);
                    if (queriedPlayers && queriedPlayers.length) {
                        players.push.apply(players, queriedPlayers);
                    }
                }
            }
            var /** @type {?} */ activePlayers = players.filter(function (p) { return !p.destroyed; });
            if (activePlayers.length) {
                removeNodesAfterAnimationDone(this, element, activePlayers);
            }
            else {
                this.processLeaveNode(element);
            }
        }
        // this is required so the cleanup method doesn't remove them
        allLeaveNodes.length = 0;
        rootPlayers.forEach(function (player) {
            _this.players.push(player);
            player.onDone(function () {
                player.destroy();
                var /** @type {?} */ index = _this.players.indexOf(player);
                _this.players.splice(index, 1);
            });
            player.play();
        });
        return rootPlayers;
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @return {?}
     */
    TransitionAnimationEngine.prototype.elementContainsData = /**
     * @param {?} namespaceId
     * @param {?} element
     * @return {?}
     */
    function (namespaceId, element) {
        var /** @type {?} */ containsData = false;
        var /** @type {?} */ details = /** @type {?} */ (element[REMOVAL_FLAG]);
        if (details && details.setForRemoval)
            containsData = true;
        if (this.playersByElement.has(element))
            containsData = true;
        if (this.playersByQueriedElement.has(element))
            containsData = true;
        if (this.statesByElement.has(element))
            containsData = true;
        return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;
    };
    /**
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.afterFlush = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) { this._flushFns.push(callback); };
    /**
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationEngine.prototype.afterFlushAnimationsDone = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) { this._whenQuietFns.push(callback); };
    /**
     * @param {?} element
     * @param {?} isQueriedElement
     * @param {?=} namespaceId
     * @param {?=} triggerName
     * @param {?=} toStateValue
     * @return {?}
     */
    TransitionAnimationEngine.prototype._getPreviousPlayers = /**
     * @param {?} element
     * @param {?} isQueriedElement
     * @param {?=} namespaceId
     * @param {?=} triggerName
     * @param {?=} toStateValue
     * @return {?}
     */
    function (element, isQueriedElement, namespaceId, triggerName, toStateValue) {
        var /** @type {?} */ players = [];
        if (isQueriedElement) {
            var /** @type {?} */ queriedElementPlayers = this.playersByQueriedElement.get(element);
            if (queriedElementPlayers) {
                players = queriedElementPlayers;
            }
        }
        else {
            var /** @type {?} */ elementPlayers = this.playersByElement.get(element);
            if (elementPlayers) {
                var /** @type {?} */ isRemovalAnimation_1 = !toStateValue || toStateValue == VOID_VALUE;
                elementPlayers.forEach(function (player) {
                    if (player.queued)
                        return;
                    if (!isRemovalAnimation_1 && player.triggerName != triggerName)
                        return;
                    players.push(player);
                });
            }
        }
        if (namespaceId || triggerName) {
            players = players.filter(function (player) {
                if (namespaceId && namespaceId != player.namespaceId)
                    return false;
                if (triggerName && triggerName != player.triggerName)
                    return false;
                return true;
            });
        }
        return players;
    };
    /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @return {?}
     */
    TransitionAnimationEngine.prototype._beforeAnimationBuild = /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @return {?}
     */
    function (namespaceId, instruction, allPreviousPlayersMap) {
        var /** @type {?} */ triggerName = instruction.triggerName;
        var /** @type {?} */ rootElement = instruction.element;
        // when a removal animation occurs, ALL previous players are collected
        // and destroyed (even if they are outside of the current namespace)
        var /** @type {?} */ targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;
        var /** @type {?} */ targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;
        var _loop_1 = function (timelineInstruction) {
            var /** @type {?} */ element = timelineInstruction.element;
            var /** @type {?} */ isQueriedElement = element !== rootElement;
            var /** @type {?} */ players = getOrSetAsInMap(allPreviousPlayersMap, element, []);
            var /** @type {?} */ previousPlayers = this_1._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);
            previousPlayers.forEach(function (player) {
                var /** @type {?} */ realPlayer = /** @type {?} */ (player.getRealPlayer());
                if (realPlayer.beforeDestroy) {
                    realPlayer.beforeDestroy();
                }
                player.destroy();
                players.push(player);
            });
        };
        var this_1 = this;
        for (var _i = 0, _a = instruction.timelines; _i < _a.length; _i++) {
            var timelineInstruction = _a[_i];
            _loop_1(timelineInstruction);
        }
        // this needs to be done so that the PRE/POST styles can be
        // computed properly without interfering with the previous animation
        eraseStyles(rootElement, instruction.fromStyles);
    };
    /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @param {?} skippedPlayersMap
     * @param {?} preStylesMap
     * @param {?} postStylesMap
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildAnimation = /**
     * @param {?} namespaceId
     * @param {?} instruction
     * @param {?} allPreviousPlayersMap
     * @param {?} skippedPlayersMap
     * @param {?} preStylesMap
     * @param {?} postStylesMap
     * @return {?}
     */
    function (namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
        var _this = this;
        var /** @type {?} */ triggerName = instruction.triggerName;
        var /** @type {?} */ rootElement = instruction.element;
        // we first run this so that the previous animation player
        // data can be passed into the successive animation players
        var /** @type {?} */ allQueriedPlayers = [];
        var /** @type {?} */ allConsumedElements = new Set();
        var /** @type {?} */ allSubElements = new Set();
        var /** @type {?} */ allNewPlayers = instruction.timelines.map(function (timelineInstruction) {
            var /** @type {?} */ element = timelineInstruction.element;
            allConsumedElements.add(element);
            // FIXME (matsko): make sure to-be-removed animations are removed properly
            var /** @type {?} */ details = element[REMOVAL_FLAG];
            if (details && details.removedBeforeQueried)
                return new _angular_animations.NoopAnimationPlayer();
            var /** @type {?} */ isQueriedElement = element !== rootElement;
            var /** @type {?} */ previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY)
                .map(function (p) { return p.getRealPlayer(); }))
                .filter(function (p) {
                // the `element` is not apart of the AnimationPlayer definition, but
                // Mock/WebAnimations
                // use the element within their implementation. This will be added in Angular5 to
                // AnimationPlayer
                var /** @type {?} */ pp = /** @type {?} */ (p);
                return pp.element ? pp.element === element : false;
            });
            var /** @type {?} */ preStyles = preStylesMap.get(element);
            var /** @type {?} */ postStyles = postStylesMap.get(element);
            var /** @type {?} */ keyframes = normalizeKeyframes(_this.driver, _this._normalizer, element, timelineInstruction.keyframes, preStyles, postStyles);
            var /** @type {?} */ player = _this._buildPlayer(timelineInstruction, keyframes, previousPlayers);
            // this means that this particular player belongs to a sub trigger. It is
            // important that we match this player up with the corresponding (@trigger.listener)
            if (timelineInstruction.subTimeline && skippedPlayersMap) {
                allSubElements.add(element);
            }
            if (isQueriedElement) {
                var /** @type {?} */ wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);
                wrappedPlayer.setRealPlayer(player);
                allQueriedPlayers.push(wrappedPlayer);
            }
            return player;
        });
        allQueriedPlayers.forEach(function (player) {
            getOrSetAsInMap(_this.playersByQueriedElement, player.element, []).push(player);
            player.onDone(function () { return deleteOrUnsetInMap(_this.playersByQueriedElement, player.element, player); });
        });
        allConsumedElements.forEach(function (element) { return addClass(element, NG_ANIMATING_CLASSNAME); });
        var /** @type {?} */ player = optimizeGroupPlayer(allNewPlayers);
        player.onDestroy(function () {
            allConsumedElements.forEach(function (element) { return removeClass(element, NG_ANIMATING_CLASSNAME); });
            setStyles(rootElement, instruction.toStyles);
        });
        // this basically makes all of the callbacks for sub element animations
        // be dependent on the upper players for when they finish
        allSubElements.forEach(function (element) { getOrSetAsInMap(skippedPlayersMap, element, []).push(player); });
        return player;
    };
    /**
     * @param {?} instruction
     * @param {?} keyframes
     * @param {?} previousPlayers
     * @return {?}
     */
    TransitionAnimationEngine.prototype._buildPlayer = /**
     * @param {?} instruction
     * @param {?} keyframes
     * @param {?} previousPlayers
     * @return {?}
     */
    function (instruction, keyframes, previousPlayers) {
        if (keyframes.length > 0) {
            return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);
        }
        // special case for when an empty transition|definition is provided
        // ... there is no point in rendering an empty animation
        return new _angular_animations.NoopAnimationPlayer();
    };
    return TransitionAnimationEngine;
}());
var TransitionAnimationPlayer = /** @class */ (function () {
    function TransitionAnimationPlayer(namespaceId, triggerName, element) {
        this.namespaceId = namespaceId;
        this.triggerName = triggerName;
        this.element = element;
        this._player = new _angular_animations.NoopAnimationPlayer();
        this._containsRealPlayer = false;
        this._queuedCallbacks = {};
        this.destroyed = false;
        this.markedForDestroy = false;
        this.queued = true;
    }
    /**
     * @param {?} player
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.setRealPlayer = /**
     * @param {?} player
     * @return {?}
     */
    function (player) {
        var _this = this;
        if (this._containsRealPlayer)
            return;
        this._player = player;
        Object.keys(this._queuedCallbacks).forEach(function (phase) {
            _this._queuedCallbacks[phase].forEach(function (callback) { return listenOnPlayer(player, phase, undefined, callback); });
        });
        this._queuedCallbacks = {};
        this._containsRealPlayer = true;
        (/** @type {?} */ (this)).queued = false;
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.getRealPlayer = /**
     * @return {?}
     */
    function () { return this._player; };
    /**
     * @param {?} player
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.syncPlayerEvents = /**
     * @param {?} player
     * @return {?}
     */
    function (player) {
        var _this = this;
        var /** @type {?} */ p = /** @type {?} */ (this._player);
        if (p.triggerCallback) {
            player.onStart(function () { return p.triggerCallback('start'); });
        }
        player.onDone(function () { return _this.finish(); });
        player.onDestroy(function () { return _this.destroy(); });
    };
    /**
     * @param {?} name
     * @param {?} callback
     * @return {?}
     */
    TransitionAnimationPlayer.prototype._queueEvent = /**
     * @param {?} name
     * @param {?} callback
     * @return {?}
     */
    function (name, callback) {
        getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onDone = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        if (this.queued) {
            this._queueEvent('done', fn);
        }
        this._player.onDone(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onStart = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        if (this.queued) {
            this._queueEvent('start', fn);
        }
        this._player.onStart(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.onDestroy = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        if (this.queued) {
            this._queueEvent('destroy', fn);
        }
        this._player.onDestroy(fn);
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.init = /**
     * @return {?}
     */
    function () { this._player.init(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.hasStarted = /**
     * @return {?}
     */
    function () { return this.queued ? false : this._player.hasStarted(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.play = /**
     * @return {?}
     */
    function () { !this.queued && this._player.play(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.pause = /**
     * @return {?}
     */
    function () { !this.queued && this._player.pause(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.restart = /**
     * @return {?}
     */
    function () { !this.queued && this._player.restart(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.finish = /**
     * @return {?}
     */
    function () { this._player.finish(); };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        (/** @type {?} */ (this)).destroyed = true;
        this._player.destroy();
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.reset = /**
     * @return {?}
     */
    function () { !this.queued && this._player.reset(); };
    /**
     * @param {?} p
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.setPosition = /**
     * @param {?} p
     * @return {?}
     */
    function (p) {
        if (!this.queued) {
            this._player.setPosition(p);
        }
    };
    /**
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.getPosition = /**
     * @return {?}
     */
    function () { return this.queued ? 0 : this._player.getPosition(); };
    Object.defineProperty(TransitionAnimationPlayer.prototype, "totalTime", {
        get: /**
         * @return {?}
         */
        function () { return this._player.totalTime; },
        enumerable: true,
        configurable: true
    });
    /* @internal */
    /**
     * @param {?} phaseName
     * @return {?}
     */
    TransitionAnimationPlayer.prototype.triggerCallback = /**
     * @param {?} phaseName
     * @return {?}
     */
    function (phaseName) {
        var /** @type {?} */ p = /** @type {?} */ (this._player);
        if (p.triggerCallback) {
            p.triggerCallback(phaseName);
        }
    };
    return TransitionAnimationPlayer;
}());
/**
 * @param {?} map
 * @param {?} key
 * @param {?} value
 * @return {?}
 */
function deleteOrUnsetInMap(map, key, value) {
    var /** @type {?} */ currentValues;
    if (map instanceof Map) {
        currentValues = map.get(key);
        if (currentValues) {
            if (currentValues.length) {
                var /** @type {?} */ index = currentValues.indexOf(value);
                currentValues.splice(index, 1);
            }
            if (currentValues.length == 0) {
                map.delete(key);
            }
        }
    }
    else {
        currentValues = map[key];
        if (currentValues) {
            if (currentValues.length) {
                var /** @type {?} */ index = currentValues.indexOf(value);
                currentValues.splice(index, 1);
            }
            if (currentValues.length == 0) {
                delete map[key];
            }
        }
    }
    return currentValues;
}
/**
 * @param {?} value
 * @return {?}
 */
function normalizeTriggerValue(value) {
    // we use `!= null` here because it's the most simple
    // way to test against a "falsy" value without mixing
    // in empty strings or a zero value. DO NOT OPTIMIZE.
    return value != null ? value : null;
}
/**
 * @param {?} node
 * @return {?}
 */
function isElementNode(node) {
    return node && node['nodeType'] === 1;
}
/**
 * @param {?} eventName
 * @return {?}
 */
function isTriggerEventValid(eventName) {
    return eventName == 'start' || eventName == 'done';
}
/**
 * @param {?} element
 * @param {?=} value
 * @return {?}
 */
function cloakElement(element, value) {
    var /** @type {?} */ oldValue = element.style.display;
    element.style.display = value != null ? value : 'none';
    return oldValue;
}
/**
 * @param {?} valuesMap
 * @param {?} driver
 * @param {?} elements
 * @param {?} elementPropsMap
 * @param {?} defaultStyle
 * @return {?}
 */
function cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {
    var /** @type {?} */ cloakVals = [];
    elements.forEach(function (element) { return cloakVals.push(cloakElement(element)); });
    var /** @type {?} */ failedElements = [];
    elementPropsMap.forEach(function (props, element) {
        var /** @type {?} */ styles = {};
        props.forEach(function (prop) {
            var /** @type {?} */ value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);
            // there is no easy way to detect this because a sub element could be removed
            // by a parent animation element being detached.
            if (!value || value.length == 0) {
                element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;
                failedElements.push(element);
            }
        });
        valuesMap.set(element, styles);
    });
    // we use a index variable here since Set.forEach(a, i) does not return
    // an index value for the closure (but instead just the value)
    var /** @type {?} */ i = 0;
    elements.forEach(function (element) { return cloakElement(element, cloakVals[i++]); });
    return failedElements;
}
/**
 * @param {?} roots
 * @param {?} nodes
 * @return {?}
 */
function buildRootMap(roots, nodes) {
    var /** @type {?} */ rootMap = new Map();
    roots.forEach(function (root) { return rootMap.set(root, []); });
    if (nodes.length == 0)
        return rootMap;
    var /** @type {?} */ NULL_NODE = 1;
    var /** @type {?} */ nodeSet = new Set(nodes);
    var /** @type {?} */ localRootMap = new Map();
    /**
     * @param {?} node
     * @return {?}
     */
    function getRoot(node) {
        if (!node)
            return NULL_NODE;
        var /** @type {?} */ root = localRootMap.get(node);
        if (root)
            return root;
        var /** @type {?} */ parent = node.parentNode;
        if (rootMap.has(parent)) {
            // ngIf inside @trigger
            root = parent;
        }
        else if (nodeSet.has(parent)) {
            // ngIf inside ngIf
            root = NULL_NODE;
        }
        else {
            // recurse upwards
            root = getRoot(parent);
        }
        localRootMap.set(node, root);
        return root;
    }
    nodes.forEach(function (node) {
        var /** @type {?} */ root = getRoot(node);
        if (root !== NULL_NODE) {
            /** @type {?} */ ((rootMap.get(root))).push(node);
        }
    });
    return rootMap;
}
var CLASSES_CACHE_KEY = '$$classes';
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function addClass(element, className) {
    if (element.classList) {
        element.classList.add(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        if (!classes) {
            classes = element[CLASSES_CACHE_KEY] = {};
        }
        classes[className] = true;
    }
}
/**
 * @param {?} element
 * @param {?} className
 * @return {?}
 */
function removeClass(element, className) {
    if (element.classList) {
        element.classList.remove(className);
    }
    else {
        var /** @type {?} */ classes = element[CLASSES_CACHE_KEY];
        if (classes) {
            delete classes[className];
        }
    }
}
/**
 * @param {?} engine
 * @param {?} element
 * @param {?} players
 * @return {?}
 */
function removeNodesAfterAnimationDone(engine, element, players) {
    optimizeGroupPlayer(players).onDone(function () { return engine.processLeaveNode(element); });
}
/**
 * @param {?} players
 * @return {?}
 */
function flattenGroupPlayers(players) {
    var /** @type {?} */ finalPlayers = [];
    _flattenGroupPlayersRecur(players, finalPlayers);
    return finalPlayers;
}
/**
 * @param {?} players
 * @param {?} finalPlayers
 * @return {?}
 */
function _flattenGroupPlayersRecur(players, finalPlayers) {
    for (var /** @type {?} */ i = 0; i < players.length; i++) {
        var /** @type {?} */ player = players[i];
        if (player instanceof _angular_animations.ɵAnimationGroupPlayer) {
            _flattenGroupPlayersRecur(player.players, finalPlayers);
        }
        else {
            finalPlayers.push(/** @type {?} */ (player));
        }
    }
}
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function objEquals(a, b) {
    var /** @type {?} */ k1 = Object.keys(a);
    var /** @type {?} */ k2 = Object.keys(b);
    if (k1.length != k2.length)
        return false;
    for (var /** @type {?} */ i = 0; i < k1.length; i++) {
        var /** @type {?} */ prop = k1[i];
        if (!b.hasOwnProperty(prop) || a[prop] !== b[prop])
            return false;
    }
    return true;
}
/**
 * @param {?} element
 * @param {?} allPreStyleElements
 * @param {?} allPostStyleElements
 * @return {?}
 */
function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
    var /** @type {?} */ postEntry = allPostStyleElements.get(element);
    if (!postEntry)
        return false;
    var /** @type {?} */ preEntry = allPreStyleElements.get(element);
    if (preEntry) {
        postEntry.forEach(function (data) { return ((preEntry)).add(data); });
    }
    else {
        allPreStyleElements.set(element, postEntry);
    }
    allPostStyleElements.delete(element);
    return true;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AnimationEngine = /** @class */ (function () {
    function AnimationEngine(_driver, normalizer) {
        var _this = this;
        this._driver = _driver;
        this._triggerCache = {};
        this.onRemovalComplete = function (element, context) { };
        this._transitionEngine = new TransitionAnimationEngine(_driver, normalizer);
        this._timelineEngine = new TimelineAnimationEngine(_driver, normalizer);
        this._transitionEngine.onRemovalComplete = function (element, context) {
            return _this.onRemovalComplete(element, context);
        };
    }
    /**
     * @param {?} componentId
     * @param {?} namespaceId
     * @param {?} hostElement
     * @param {?} name
     * @param {?} metadata
     * @return {?}
     */
    AnimationEngine.prototype.registerTrigger = /**
     * @param {?} componentId
     * @param {?} namespaceId
     * @param {?} hostElement
     * @param {?} name
     * @param {?} metadata
     * @return {?}
     */
    function (componentId, namespaceId, hostElement, name, metadata) {
        var /** @type {?} */ cacheKey = componentId + '-' + name;
        var /** @type {?} */ trigger = this._triggerCache[cacheKey];
        if (!trigger) {
            var /** @type {?} */ errors = [];
            var /** @type {?} */ ast = /** @type {?} */ (buildAnimationAst(this._driver, /** @type {?} */ (metadata), errors));
            if (errors.length) {
                throw new Error("The animation trigger \"" + name + "\" has failed to build due to the following errors:\n - " + errors.join("\n - "));
            }
            trigger = buildTrigger(name, ast);
            this._triggerCache[cacheKey] = trigger;
        }
        this._transitionEngine.registerTrigger(namespaceId, name, trigger);
    };
    /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    AnimationEngine.prototype.register = /**
     * @param {?} namespaceId
     * @param {?} hostElement
     * @return {?}
     */
    function (namespaceId, hostElement) {
        this._transitionEngine.register(namespaceId, hostElement);
    };
    /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    AnimationEngine.prototype.destroy = /**
     * @param {?} namespaceId
     * @param {?} context
     * @return {?}
     */
    function (namespaceId, context) {
        this._transitionEngine.destroy(namespaceId, context);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    AnimationEngine.prototype.onInsert = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} parent
     * @param {?} insertBefore
     * @return {?}
     */
    function (namespaceId, element, parent, insertBefore) {
        this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    AnimationEngine.prototype.onRemove = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} context
     * @return {?}
     */
    function (namespaceId, element, context) {
        this._transitionEngine.removeNode(namespaceId, element, context);
    };
    /**
     * @param {?} element
     * @param {?} disable
     * @return {?}
     */
    AnimationEngine.prototype.disableAnimations = /**
     * @param {?} element
     * @param {?} disable
     * @return {?}
     */
    function (element, disable) {
        this._transitionEngine.markElementAsDisabled(element, disable);
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    AnimationEngine.prototype.process = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    function (namespaceId, element, property, value) {
        if (property.charAt(0) == '@') {
            var _a = parseTimelineCommand(property), id = _a[0], action = _a[1];
            var /** @type {?} */ args = /** @type {?} */ (value);
            this._timelineEngine.command(id, element, action, args);
        }
        else {
            this._transitionEngine.trigger(namespaceId, element, property, value);
        }
    };
    /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventPhase
     * @param {?} callback
     * @return {?}
     */
    AnimationEngine.prototype.listen = /**
     * @param {?} namespaceId
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventPhase
     * @param {?} callback
     * @return {?}
     */
    function (namespaceId, element, eventName, eventPhase, callback) {
        // @@listen
        if (eventName.charAt(0) == '@') {
            var _a = parseTimelineCommand(eventName), id = _a[0], action = _a[1];
            return this._timelineEngine.listen(id, element, action, callback);
        }
        return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
    };
    /**
     * @param {?=} microtaskId
     * @return {?}
     */
    AnimationEngine.prototype.flush = /**
     * @param {?=} microtaskId
     * @return {?}
     */
    function (microtaskId) {
        if (microtaskId === void 0) { microtaskId = -1; }
        this._transitionEngine.flush(microtaskId);
    };
    Object.defineProperty(AnimationEngine.prototype, "players", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this._transitionEngine.players))
                .concat(/** @type {?} */ (this._timelineEngine.players));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AnimationEngine.prototype.whenRenderingDone = /**
     * @return {?}
     */
    function () { return this._transitionEngine.whenRenderingDone(); };
    return AnimationEngine;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var WebAnimationsPlayer = /** @class */ (function () {
    function WebAnimationsPlayer(element, keyframes, options, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        var _this = this;
        this.element = element;
        this.keyframes = keyframes;
        this.options = options;
        this.previousPlayers = previousPlayers;
        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._initialized = false;
        this._finished = false;
        this._started = false;
        this._destroyed = false;
        this.time = 0;
        this.parentPlayer = null;
        this.previousStyles = {};
        this.currentSnapshot = {};
        this._duration = /** @type {?} */ (options['duration']);
        this._delay = /** @type {?} */ (options['delay']) || 0;
        this.time = this._duration + this._delay;
        if (allowPreviousPlayerStylesMerge(this._duration, this._delay)) {
            previousPlayers.forEach(function (player) {
                var /** @type {?} */ styles = player.currentSnapshot;
                Object.keys(styles).forEach(function (prop) { return _this.previousStyles[prop] = styles[prop]; });
            });
        }
    }
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._onFinish = /**
     * @return {?}
     */
    function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.init = /**
     * @return {?}
     */
    function () {
        this._buildPlayer();
        this._preparePlayerBeforeStart();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._buildPlayer = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._initialized)
            return;
        this._initialized = true;
        var /** @type {?} */ keyframes = this.keyframes.map(function (styles) { return copyStyles(styles, false); });
        var /** @type {?} */ previousStyleProps = Object.keys(this.previousStyles);
        if (previousStyleProps.length && keyframes.length) {
            var /** @type {?} */ startingKeyframe_1 = keyframes[0];
            var /** @type {?} */ missingStyleProps_1 = [];
            previousStyleProps.forEach(function (prop) {
                if (!startingKeyframe_1.hasOwnProperty(prop)) {
                    missingStyleProps_1.push(prop);
                }
                startingKeyframe_1[prop] = _this.previousStyles[prop];
            });
            if (missingStyleProps_1.length) {
                var /** @type {?} */ self_1 = this;
                var _loop_1 = function () {
                    var /** @type {?} */ kf = keyframes[i];
                    missingStyleProps_1.forEach(function (prop) {
                        kf[prop] = _computeStyle(self_1.element, prop);
                    });
                };
                // tslint:disable-next-line
                for (var /** @type {?} */ i = 1; i < keyframes.length; i++) {
                    _loop_1();
                }
            }
        }
        (/** @type {?} */ (this)).domPlayer =
            this._triggerWebAnimation(this.element, keyframes, this.options);
        this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {};
        this.domPlayer.addEventListener('finish', function () { return _this._onFinish(); });
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._preparePlayerBeforeStart = /**
     * @return {?}
     */
    function () {
        // this is required so that the player doesn't start to animate right away
        if (this._delay) {
            this._resetDomPlayerState();
        }
        else {
            this.domPlayer.pause();
        }
    };
    /** @internal */
    /**
     * \@internal
     * @param {?} element
     * @param {?} keyframes
     * @param {?} options
     * @return {?}
     */
    WebAnimationsPlayer.prototype._triggerWebAnimation = /**
     * \@internal
     * @param {?} element
     * @param {?} keyframes
     * @param {?} options
     * @return {?}
     */
    function (element, keyframes, options) {
        // jscompiler doesn't seem to know animate is a native property because it's not fully
        // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]
        return /** @type {?} */ (element['animate'](keyframes, options));
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onStart = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onStartFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onDone = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onDoneFns.push(fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    WebAnimationsPlayer.prototype.onDestroy = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onDestroyFns.push(fn); };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.play = /**
     * @return {?}
     */
    function () {
        this._buildPlayer();
        if (!this.hasStarted()) {
            this._onStartFns.forEach(function (fn) { return fn(); });
            this._onStartFns = [];
            this._started = true;
        }
        this.domPlayer.play();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.pause = /**
     * @return {?}
     */
    function () {
        this.init();
        this.domPlayer.pause();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.finish = /**
     * @return {?}
     */
    function () {
        this.init();
        this._onFinish();
        this.domPlayer.finish();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.reset = /**
     * @return {?}
     */
    function () {
        this._resetDomPlayerState();
        this._destroyed = false;
        this._finished = false;
        this._started = false;
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype._resetDomPlayerState = /**
     * @return {?}
     */
    function () {
        if (this.domPlayer) {
            this.domPlayer.cancel();
        }
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.restart = /**
     * @return {?}
     */
    function () {
        this.reset();
        this.play();
    };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.hasStarted = /**
     * @return {?}
     */
    function () { return this._started; };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (!this._destroyed) {
            this._destroyed = true;
            this._resetDomPlayerState();
            this._onFinish();
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    /**
     * @param {?} p
     * @return {?}
     */
    WebAnimationsPlayer.prototype.setPosition = /**
     * @param {?} p
     * @return {?}
     */
    function (p) { this.domPlayer.currentTime = p * this.time; };
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.getPosition = /**
     * @return {?}
     */
    function () { return this.domPlayer.currentTime / this.time; };
    Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
        get: /**
         * @return {?}
         */
        function () { return this._delay + this._duration; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    WebAnimationsPlayer.prototype.beforeDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ styles = {};
        if (this.hasStarted()) {
            Object.keys(this._finalKeyframe).forEach(function (prop) {
                if (prop != 'offset') {
                    styles[prop] =
                        _this._finished ? _this._finalKeyframe[prop] : _computeStyle(_this.element, prop);
                }
            });
        }
        this.currentSnapshot = styles;
    };
    /* @internal */
    /**
     * @param {?} phaseName
     * @return {?}
     */
    WebAnimationsPlayer.prototype.triggerCallback = /**
     * @param {?} phaseName
     * @return {?}
     */
    function (phaseName) {
        var /** @type {?} */ methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
        methods.forEach(function (fn) { return fn(); });
        methods.length = 0;
    };
    return WebAnimationsPlayer;
}());
/**
 * @param {?} element
 * @param {?} prop
 * @return {?}
 */
function _computeStyle(element, prop) {
    return (/** @type {?} */ (window.getComputedStyle(element)))[prop];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var WebAnimationsDriver = /** @class */ (function () {
    function WebAnimationsDriver() {
    }
    /**
     * @param {?} prop
     * @return {?}
     */
    WebAnimationsDriver.prototype.validateStyleProperty = /**
     * @param {?} prop
     * @return {?}
     */
    function (prop) { return validateStyleProperty(prop); };
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    WebAnimationsDriver.prototype.matchesElement = /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    function (element, selector) {
        return matchesElement(element, selector);
    };
    /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    WebAnimationsDriver.prototype.containsElement = /**
     * @param {?} elm1
     * @param {?} elm2
     * @return {?}
     */
    function (elm1, elm2) { return containsElement(elm1, elm2); };
    /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    WebAnimationsDriver.prototype.query = /**
     * @param {?} element
     * @param {?} selector
     * @param {?} multi
     * @return {?}
     */
    function (element, selector, multi) {
        return invokeQuery(element, selector, multi);
    };
    /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    WebAnimationsDriver.prototype.computeStyle = /**
     * @param {?} element
     * @param {?} prop
     * @param {?=} defaultValue
     * @return {?}
     */
    function (element, prop, defaultValue) {
        return /** @type {?} */ ((/** @type {?} */ (window.getComputedStyle(element)))[prop]);
    };
    /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    WebAnimationsDriver.prototype.animate = /**
     * @param {?} element
     * @param {?} keyframes
     * @param {?} duration
     * @param {?} delay
     * @param {?} easing
     * @param {?=} previousPlayers
     * @return {?}
     */
    function (element, keyframes, duration, delay, easing, previousPlayers) {
        if (previousPlayers === void 0) { previousPlayers = []; }
        var /** @type {?} */ fill = delay == 0 ? 'both' : 'forwards';
        var /** @type {?} */ playerOptions = { duration: duration, delay: delay, fill: fill };
        // we check for this to avoid having a null|undefined value be present
        // for the easing (which results in an error for certain browsers #9752)
        if (easing) {
            playerOptions['easing'] = easing;
        }
        var /** @type {?} */ previousWebAnimationPlayers = /** @type {?} */ (previousPlayers.filter(function (player) { return player instanceof WebAnimationsPlayer; }));
        return new WebAnimationsPlayer(element, keyframes, playerOptions, previousWebAnimationPlayers);
    };
    return WebAnimationsDriver;
}());
/**
 * @return {?}
 */
function supportsWebAnimations() {
    return typeof Element !== 'undefined' && typeof (/** @type {?} */ (Element)).prototype['animate'] === 'function';
}

exports.AnimationDriver = AnimationDriver;
exports.ɵAnimation = Animation;
exports.ɵAnimationStyleNormalizer = AnimationStyleNormalizer;
exports.ɵNoopAnimationStyleNormalizer = NoopAnimationStyleNormalizer;
exports.ɵWebAnimationsStyleNormalizer = WebAnimationsStyleNormalizer;
exports.ɵNoopAnimationDriver = NoopAnimationDriver;
exports.ɵAnimationEngine = AnimationEngine;
exports.ɵWebAnimationsDriver = WebAnimationsDriver;
exports.ɵsupportsWebAnimations = supportsWebAnimations;
exports.ɵWebAnimationsPlayer = WebAnimationsPlayer;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=animations-browser.umd.js.map


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(40);

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(118);

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(87);

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Event = __webpack_require__(6);
var MouseEvent = __webpack_require__(37);
var utils = __webpack_require__(2);

module.exports = EventTarget;

function EventTarget() {}

EventTarget.prototype = {
  // XXX
  // See WebIDL §4.8 for details on object event handlers
  // and how they should behave.  We actually have to accept
  // any object to addEventListener... Can't type check it.
  // on registration.

  // XXX:
  // Capturing event listeners are sort of rare.  I think I can optimize
  // them so that dispatchEvent can skip the capturing phase (or much of
  // it).  Each time a capturing listener is added, increment a flag on
  // the target node and each of its ancestors.  Decrement when removed.
  // And update the counter when nodes are added and removed from the
  // tree as well.  Then, in dispatch event, the capturing phase can
  // abort if it sees any node with a zero count.
  addEventListener: function addEventListener(type, listener, capture) {
    if (!listener) return;
    if (capture === undefined) capture = false;
    if (!this._listeners) this._listeners = Object.create(null);
    if (!this._listeners[type]) this._listeners[type] = [];
    var list = this._listeners[type];

    // If this listener has already been registered, just return
    for(var i = 0, n = list.length; i < n; i++) {
      var l = list[i];
      if (l.listener === listener && l.capture === capture)
        return;
    }

    // Add an object to the list of listeners
    var obj = { listener: listener, capture: capture };
    if (typeof listener === 'function') obj.f = listener;
    list.push(obj);
  },

  removeEventListener: function removeEventListener(type,
                            listener,
                            capture) {
    if (capture === undefined) capture = false;
    if (this._listeners) {
      var list = this._listeners[type];
      if (list) {
        // Find the listener in the list and remove it
        for(var i = 0, n = list.length; i < n; i++) {
          var l = list[i];
          if (l.listener === listener && l.capture === capture) {
            if (list.length === 1) {
              this._listeners[type] = undefined;
            }
            else {
              list.splice(i, 1);
            }
            return;
          }
        }
      }
    }
  },

  // This is the public API for dispatching untrusted public events.
  // See _dispatchEvent for the implementation
  dispatchEvent: function dispatchEvent(event) {
    // Dispatch an untrusted event
    return this._dispatchEvent(event, false);
  },

  //
  // See DOMCore §4.4
  // XXX: I'll probably need another version of this method for
  // internal use, one that does not set isTrusted to false.
  // XXX: see Document._dispatchEvent: perhaps that and this could
  // call a common internal function with different settings of
  // a trusted boolean argument
  //
  // XXX:
  // The spec has changed in how to deal with handlers registered
  // on idl or content attributes rather than with addEventListener.
  // Used to say that they always ran first.  That's how webkit does it
  // Spec now says that they run in a position determined by
  // when they were first set.  FF does it that way.  See:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#event-handlers
  //
  _dispatchEvent: function _dispatchEvent(event, trusted) {
    if (typeof trusted !== 'boolean') trusted = false;
    function invoke(target, event) {
      var type = event.type, phase = event.eventPhase;
      event.currentTarget = target;

      // If there was an individual handler defined, invoke it first
      // XXX: see comment above: this shouldn't always be first.
      if (phase !== Event.CAPTURING_PHASE &&
        target._handlers && target._handlers[type])
      {
        var handler = target._handlers[type];
        var rv;
        if (typeof handler === 'function') {
          rv=handler.call(event.currentTarget, event);
        }
        else {
          var f = handler.handleEvent;
          if (typeof f !== 'function')
            throw new TypeError('handleEvent property of ' +
                                'event handler object is' +
                                'not a function.');
          rv=f.call(handler, event);
        }

        switch(event.type) {
        case 'mouseover':
          if (rv === true)  // Historical baggage
            event.preventDefault();
          break;
        case 'beforeunload':
          // XXX: eventually we need a special case here
          /* falls through */
        default:
          if (rv === false)
            event.preventDefault();
          break;
        }
      }

      // Now invoke list list of listeners for this target and type
      var list = target._listeners && target._listeners[type];
      if (!list) return;
      list = list.slice();
      for(var i = 0, n = list.length; i < n; i++) {
        if (event._immediatePropagationStopped) return;
        var l = list[i];
        if ((phase === Event.CAPTURING_PHASE && !l.capture) ||
          (phase === Event.BUBBLING_PHASE && l.capture))
          continue;
        if (l.f) {
          l.f.call(event.currentTarget, event);
        }
        else {
          var fn = l.listener.handleEvent;
          if (typeof fn !== 'function')
            throw new TypeError('handleEvent property of event listener object is not a function.');
          fn.call(l.listener, event);
        }
      }
    }

    if (!event._initialized || event._dispatching) utils.InvalidStateError();
    event.isTrusted = trusted;

    // Begin dispatching the event now
    event._dispatching = true;
    event.target = this;

    // Build the list of targets for the capturing and bubbling phases
    // XXX: we'll eventually have to add Window to this list.
    var ancestors = [];
    for(var n = this.parentNode; n; n = n.parentNode)
      ancestors.push(n);

    // Capturing phase
    event.eventPhase = Event.CAPTURING_PHASE;
    for(var i = ancestors.length-1; i >= 0; i--) {
      invoke(ancestors[i], event);
      if (event._propagationStopped) break;
    }

    // At target phase
    if (!event._propagationStopped) {
      event.eventPhase = Event.AT_TARGET;
      invoke(this, event);
    }

    // Bubbling phase
    if (event.bubbles && !event._propagationStopped) {
      event.eventPhase = Event.BUBBLING_PHASE;
      for(var ii = 0, nn = ancestors.length; ii < nn; ii++) {
        invoke(ancestors[ii], event);
        if (event._propagationStopped) break;
      }
    }

    event._dispatching = false;
    event.eventPhase = Event.AT_TARGET;
    event.currentTarget = null;

    // Deal with mouse events and figure out when
    // a click has happened
    if (trusted && !event.defaultPrevented && event instanceof MouseEvent) {
      switch(event.type) {
      case 'mousedown':
        this._armed = {
          x: event.clientX,
          y: event.clientY,
          t: event.timeStamp
        };
        break;
      case 'mouseout':
      case 'mouseover':
        this._armed = null;
        break;
      case 'mouseup':
        if (this._isClick(event)) this._doClick(event);
        this._armed = null;
        break;
      }
    }



    return !event.defaultPrevented;
  },

  // Determine whether a click occurred
  // XXX We don't support double clicks for now
  _isClick: function(event) {
    return (this._armed !== null &&
        event.type === 'mouseup' &&
        event.isTrusted &&
        event.button === 0 &&
        event.timeStamp - this._armed.t < 1000 &&
        Math.abs(event.clientX - this._armed.x) < 10 &&
        Math.abs(event.clientY - this._armed.Y) < 10);
  },

  // Clicks are handled like this:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#interactive-content-0
  //
  // Note that this method is similar to the HTMLElement.click() method
  // The event argument must be the trusted mouseup event
  _doClick: function(event) {
    if (this._click_in_progress) return;
    this._click_in_progress = true;

    // Find the nearest enclosing element that is activatable
    // An element is activatable if it has a
    // _post_click_activation_steps hook
    var activated = this;
    while(activated && !activated._post_click_activation_steps)
      activated = activated.parentNode;

    if (activated && activated._pre_click_activation_steps) {
      activated._pre_click_activation_steps();
    }

    var click = this.ownerDocument.createEvent('MouseEvent');
    click.initMouseEvent('click', true, true,
      this.ownerDocument.defaultView, 1,
      event.screenX, event.screenY,
      event.clientX, event.clientY,
      event.ctrlKey, event.altKey,
      event.shiftKey, event.metaKey,
      event.button, null);

    var result = this._dispatchEvent(click, true);

    if (activated) {
      if (result) {
        // This is where hyperlinks get followed, for example.
        if (activated._post_click_activation_steps)
          activated._post_click_activation_steps(click);
      }
      else {
        if (activated._cancelled_activation_steps)
          activated._cancelled_activation_steps();
      }
    }
  },

  //
  // An event handler is like an event listener, but it registered
  // by setting an IDL or content attribute like onload or onclick.
  // There can only be one of these at a time for any event type.
  // This is an internal method for the attribute accessors and
  // content attribute handlers that need to register events handlers.
  // The type argument is the same as in addEventListener().
  // The handler argument is the same as listeners in addEventListener:
  // it can be a function or an object. Pass null to remove any existing
  // handler.  Handlers are always invoked before any listeners of
  // the same type.  They are not invoked during the capturing phase
  // of event dispatch.
  //
  _setEventHandler: function _setEventHandler(type, handler) {
    if (!this._handlers) this._handlers = Object.create(null);
    this._handlers[type] = handler;
  },

  _getEventHandler: function _getEventHandler(type) {
    return (this._handlers && this._handlers[type]) || null;
  }

};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var UIEvent = __webpack_require__(38);

module.exports = MouseEvent;

function MouseEvent() {
  // Just use the superclass constructor to initialize
  UIEvent.call(this);

  this.screenX = this.screenY = this.clientX = this.clientY = 0;
  this.ctrlKey = this.altKey = this.shiftKey = this.metaKey = false;
  this.button = 0;
  this.buttons = 1;
  this.relatedTarget = null;
}
MouseEvent.prototype = Object.create(UIEvent.prototype, {
  constructor: { value: MouseEvent },
  initMouseEvent: { value: function(type, bubbles, cancelable,
    view, detail,
    screenX, screenY, clientX, clientY,
    ctrlKey, altKey, shiftKey, metaKey,
    button, relatedTarget) {

    this.initEvent(type, bubbles, cancelable, view, detail);
    this.screenX = screenX;
    this.screenY = screenY;
    this.clientX = clientX;
    this.clientY = clientY;
    this.ctrlKey = ctrlKey;
    this.altKey = altKey;
    this.shiftKey = shiftKey;
    this.metaKey = metaKey;
    this.button = button;
    switch(button) {
    case 0: this.buttons = 1; break;
    case 1: this.buttons = 4; break;
    case 2: this.buttons = 2; break;
    default: this.buttons = 0; break;
    }
    this.relatedTarget = relatedTarget;
  }},

  getModifierState: { value: function(key) {
    switch(key) {
    case "Alt": return this.altKey;
    case "Control": return this.ctrlKey;
    case "Shift": return this.shiftKey;
    case "Meta": return this.metaKey;
    default: return false;
    }
  }}
});


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Event = __webpack_require__(6);

module.exports = UIEvent;

function UIEvent() {
  // Just use the superclass constructor to initialize
  Event.call(this);
  this.view = null; // FF uses the current window
  this.detail = 0;
}
UIEvent.prototype = Object.create(Event.prototype, {
  constructor: { value: UIEvent },
  initUIEvent: { value: function(type, bubbles, cancelable, view, detail) {
    this.initEvent(type, bubbles, cancelable);
    this.view = view;
    this.detail = detail;
  }}
});


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = DOMException;

var INDEX_SIZE_ERR = 1;
var HIERARCHY_REQUEST_ERR = 3;
var WRONG_DOCUMENT_ERR = 4;
var INVALID_CHARACTER_ERR = 5;
var NO_MODIFICATION_ALLOWED_ERR = 7;
var NOT_FOUND_ERR = 8;
var NOT_SUPPORTED_ERR = 9;
var INVALID_STATE_ERR = 11;
var SYNTAX_ERR = 12;
var INVALID_MODIFICATION_ERR = 13;
var NAMESPACE_ERR = 14;
var INVALID_ACCESS_ERR = 15;
var TYPE_MISMATCH_ERR = 17;
var SECURITY_ERR = 18;
var NETWORK_ERR = 19;
var ABORT_ERR = 20;
var URL_MISMATCH_ERR = 21;
var QUOTA_EXCEEDED_ERR = 22;
var TIMEOUT_ERR = 23;
var INVALID_NODE_TYPE_ERR = 24;
var DATA_CLONE_ERR = 25;

// Code to name
var names = [
  null,  // No error with code 0
  'INDEX_SIZE_ERR',
  null, // historical
  'HIERARCHY_REQUEST_ERR',
  'WRONG_DOCUMENT_ERR',
  'INVALID_CHARACTER_ERR',
  null, // historical
  'NO_MODIFICATION_ALLOWED_ERR',
  'NOT_FOUND_ERR',
  'NOT_SUPPORTED_ERR',
  null, // historical
  'INVALID_STATE_ERR',
  'SYNTAX_ERR',
  'INVALID_MODIFICATION_ERR',
  'NAMESPACE_ERR',
  'INVALID_ACCESS_ERR',
  null, // historical
  'TYPE_MISMATCH_ERR',
  'SECURITY_ERR',
  'NETWORK_ERR',
  'ABORT_ERR',
  'URL_MISMATCH_ERR',
  'QUOTA_EXCEEDED_ERR',
  'TIMEOUT_ERR',
  'INVALID_NODE_TYPE_ERR',
  'DATA_CLONE_ERR',
];

// Code to message
// These strings are from the 13 May 2011 Editor's Draft of DOM Core.
// http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html
// Copyright © 2011 W3C® (MIT, ERCIM, Keio), All Rights Reserved.
// Used under the terms of the W3C Document License:
// http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231
var messages = [
  null,  // No error with code 0
  'INDEX_SIZE_ERR (1): the index is not in the allowed range',
  null,
  'HIERARCHY_REQUEST_ERR (3): the operation would yield an incorrect nodes model',
  'WRONG_DOCUMENT_ERR (4): the object is in the wrong Document, a call to importNode is required',
  'INVALID_CHARACTER_ERR (5): the string contains invalid characters',
  null,
  'NO_MODIFICATION_ALLOWED_ERR (7): the object can not be modified',
  'NOT_FOUND_ERR (8): the object can not be found here',
  'NOT_SUPPORTED_ERR (9): this operation is not supported',
  null,
  'INVALID_STATE_ERR (11): the object is in an invalid state',
  'SYNTAX_ERR (12): the string did not match the expected pattern',
  'INVALID_MODIFICATION_ERR (13): the object can not be modified in this way',
  'NAMESPACE_ERR (14): the operation is not allowed by Namespaces in XML',
  'INVALID_ACCESS_ERR (15): the object does not support the operation or argument',
  null,
  'TYPE_MISMATCH_ERR (17): the type of the object does not match the expected type',
  'SECURITY_ERR (18): the operation is insecure',
  'NETWORK_ERR (19): a network error occurred',
  'ABORT_ERR (20): the user aborted an operation',
  'URL_MISMATCH_ERR (21): the given URL does not match another URL',
  'QUOTA_EXCEEDED_ERR (22): the quota has been exceeded',
  'TIMEOUT_ERR (23): a timeout occurred',
  'INVALID_NODE_TYPE_ERR (24): the supplied node is invalid or has an invalid ancestor for this operation',
  'DATA_CLONE_ERR (25): the object can not be cloned.'
];

// Name to code
var constants = {
  INDEX_SIZE_ERR: INDEX_SIZE_ERR,
  DOMSTRING_SIZE_ERR: 2, // historical
  HIERARCHY_REQUEST_ERR: HIERARCHY_REQUEST_ERR,
  WRONG_DOCUMENT_ERR: WRONG_DOCUMENT_ERR,
  INVALID_CHARACTER_ERR: INVALID_CHARACTER_ERR,
  NO_DATA_ALLOWED_ERR: 6, // historical
  NO_MODIFICATION_ALLOWED_ERR: NO_MODIFICATION_ALLOWED_ERR,
  NOT_FOUND_ERR: NOT_FOUND_ERR,
  NOT_SUPPORTED_ERR: NOT_SUPPORTED_ERR,
  INUSE_ATTRIBUTE_ERR: 10, // historical
  INVALID_STATE_ERR: INVALID_STATE_ERR,
  SYNTAX_ERR: SYNTAX_ERR,
  INVALID_MODIFICATION_ERR: INVALID_MODIFICATION_ERR,
  NAMESPACE_ERR: NAMESPACE_ERR,
  INVALID_ACCESS_ERR: INVALID_ACCESS_ERR,
  VALIDATION_ERR: 16, // historical
  TYPE_MISMATCH_ERR: TYPE_MISMATCH_ERR,
  SECURITY_ERR: SECURITY_ERR,
  NETWORK_ERR: NETWORK_ERR,
  ABORT_ERR: ABORT_ERR,
  URL_MISMATCH_ERR: URL_MISMATCH_ERR,
  QUOTA_EXCEEDED_ERR: QUOTA_EXCEEDED_ERR,
  TIMEOUT_ERR: TIMEOUT_ERR,
  INVALID_NODE_TYPE_ERR: INVALID_NODE_TYPE_ERR,
  DATA_CLONE_ERR: DATA_CLONE_ERR
};

function DOMException(code) {
  Error.call(this);
  Error.captureStackTrace(this, this.constructor);
  this.code = code;
  this.message = messages[code];
  this.name = names[code];
}
DOMException.prototype.__proto__ = Error.prototype;

// Initialize the constants on DOMException and DOMException.prototype
for(var c in constants) {
  var v = { value: constants[c] };
  Object.defineProperty(DOMException, c, v);
  Object.defineProperty(DOMException.prototype, c, v);
}


/***/ }),
/* 40 */
/***/ (function(module, exports) {

/*
 * This file defines Domino behaviour that can be externally configured.
 * To change these settings, set the relevant global property *before*
 * you call `require("domino")`.
 */

exports.isApiWritable = !global.__domino_frozen__;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var utils = __webpack_require__(2);

exports.property = function(attr) {
  if (Array.isArray(attr.type)) {
    var valid = Object.create(null);
    attr.type.forEach(function(val) {
      valid[val.value || val] = val.alias || val;
    });
    var missingValueDefault = attr.missing;
    if (missingValueDefault===undefined) { missingValueDefault = null; }
    var invalidValueDefault = attr.invalid;
    if (invalidValueDefault===undefined) { invalidValueDefault = missingValueDefault; }
    return {
      get: function() {
        var v = this._getattr(attr.name);
        if (v === null) return missingValueDefault;

        v = valid[v.toLowerCase()];
        if (v !== undefined) return v;
        if (invalidValueDefault !== null) return invalidValueDefault;
        return v;
      },
      set: function(v) {
        this._setattr(attr.name, v);
      }
    };
  }
  else if (attr.type === Boolean) {
    return {
      get: function() {
        return this.hasAttribute(attr.name);
      },
      set: function(v) {
        if (v) {
          this._setattr(attr.name, '');
        }
        else {
          this.removeAttribute(attr.name);
        }
      }
    };
  }
  else if (attr.type === Number ||
           attr.type === "long" ||
           attr.type === "unsigned long" ||
           attr.type === "limited unsigned long with fallback") {
    return numberPropDesc(attr);
  }
  else if (!attr.type || attr.type === String) {
    return {
      get: function() { return this._getattr(attr.name) || ''; },
      set: function(v) {
        if (attr.treatNullAsEmptyString && v === null) { v = ''; }
        this._setattr(attr.name, v);
      }
    };
  }
  else if (typeof attr.type === 'function') {
    return attr.type(attr.name, attr);
  }
  throw new Error('Invalid attribute definition');
};

// See http://www.whatwg.org/specs/web-apps/current-work/#reflect
//
// defval is the default value. If it is a function, then that function
// will be invoked as a method of the element to obtain the default.
// If no default is specified for a given attribute, then the default
// depends on the type of the attribute, but since this function handles
// 4 integer cases, you must specify the default value in each call
//
// min and max define a valid range for getting the attribute.
//
// setmin defines a minimum value when setting.  If the value is less
// than that, then throw INDEX_SIZE_ERR.
//
// Conveniently, JavaScript's parseInt function appears to be
// compatible with HTML's 'rules for parsing integers'
function numberPropDesc(a) {
  var def;
  if(typeof a.default === 'function') {
    def = a.default;
  }
  else if(typeof a.default === 'number') {
    def = function() { return a.default; };
  }
  else {
    def = function() { utils.assert(false, typeof a.default); };
  }
  var unsigned_long = (a.type === 'unsigned long');
  var signed_long = (a.type === 'long');
  var unsigned_fallback = (a.type === 'limited unsigned long with fallback');
  var min = a.min, max = a.max, setmin = a.setmin;
  if (min === undefined) {
    if (unsigned_long) min = 0;
    if (signed_long) min = -0x80000000;
    if (unsigned_fallback) min = 1;
  }
  if (max === undefined) {
    if (unsigned_long || signed_long || unsigned_fallback) max = 0x7FFFFFFF;
  }

  return {
    get: function() {
      var v = this._getattr(a.name);
      var n = a.float ? parseFloat(v) : parseInt(v, 10);
      if (v === null || !isFinite(n) || (min !== undefined && n < min) || (max !== undefined && n > max)) {
        return def.call(this);
      }
      if (unsigned_long || signed_long || unsigned_fallback) {
        if (!/^[ \t\n\f\r]*[-+]?[0-9]/.test(v)) { return def.call(this); }
        n = n|0; // jshint ignore:line
      }
      return n;
    },
    set: function(v) {
      if (!a.float) { v = Math.floor(v); }
      if (setmin !== undefined && v < setmin) {
        utils.IndexSizeError(a.name + ' set to ' + v);
      }
      if (unsigned_long) {
        v = (v < 0 || v > 0x7FFFFFFF) ? def.call(this) :
          (v|0);  // jshint ignore:line
      } else if (unsigned_fallback) {
        v = (v < 1 || v > 0x7FFFFFFF) ? def.call(this) :
          (v|0); // jshint ignore:line
      } else if (signed_long) {
        v = (v < -0x80000000 || v > 0x7FFFFFFF) ? def.call(this) :
          (v|0); // jshint ignore:line
      }
      this._setattr(a.name, String(v));
    }
  };
}

// This is a utility function for setting up change handler functions
// for attributes like 'id' that require special handling when they change.
exports.registerChangeHandler = function(c, name, handler) {
  var p = c.prototype;

  // If p does not already have its own _attributeChangeHandlers
  // then create one for it, inheriting from the inherited
  // _attributeChangeHandlers. At the top (for the Element class) the
  // _attributeChangeHandlers object will be created with a null prototype.
  if (!Object.prototype.hasOwnProperty.call(p, '_attributeChangeHandlers')) {
    p._attributeChangeHandlers =
      Object.create(p._attributeChangeHandlers || null);
  }

  p._attributeChangeHandlers[name] = handler;
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// DOMTokenList implementation based on https://github.com/Raynos/DOM-shim
var utils = __webpack_require__(2);

module.exports = DOMTokenList;

function DOMTokenList(getter, setter) {
  this._getString = getter;
  this._setString = setter;
  fixIndex(this, getList(this));
}

DOMTokenList.prototype = {
  item: function(index) {
    if (index >= this.length) {
      return null;
    }
    return this._getString().split(" ")[index];
  },

  contains: function(token) {
    token = String(token);
    handleErrors(token);
    var list = getList(this);
    return list.indexOf(token) > -1;
  },

  add: function(token) {
    handleErrors(token);
    var list = getList(this);
    if (list.indexOf(token) > -1) {
      return;
    }
    list.push(token);
    this._setString(list.join(" ").trim());
    fixIndex(this, list);
  },

  remove: function(token) {
    handleErrors(token);
    var list = getList(this);
    var index = list.indexOf(token);
    if (index > -1) {
      list.splice(index, 1);
      this._setString(list.join(" ").trim());
    }
    fixIndex(this, list);
  },

  toggle: function toggle(token) {
    if (this.contains(token)) {
      this.remove(token);
      return false;
    }
    else {
      this.add(token);
      return true;
    }
  },

  toString: function() {
    return this._getString();
  }
};

function fixIndex(clist, list) {
  clist.length = list.length;
  for (var i = 0; i < list.length; i++) {
    clist[i] = list[i];
  }
}

function handleErrors(token) {
  if (token === "" || token === undefined) {
    utils.SyntaxError();
  }
  if (token.indexOf(" ") > -1) {
    utils.InvalidCharacterError();
  }
}

function getList(clist) {
  var str = clist._getString();
  if (str === "") {
    return [];
  }
  else {
    return str.split(" ");
  }
}


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Node = __webpack_require__(3);

var NonDocumentTypeChildNode = {

  nextElementSibling: { get: function() {
    if (this.parentNode) {
      var sibs = this.parentNode.childNodes;
      for(var i = this.index+1, n = sibs.length; i < n; i++) {
        if (sibs[i].nodeType === Node.ELEMENT_NODE) return sibs[i];
      }
    }
    return null;
  }},

  previousElementSibling: { get: function() {
    if (this.parentNode) {
      var sibs = this.parentNode.childNodes;
      for(var i = this.index-1; i >= 0; i--) {
        if (sibs[i].nodeType === Node.ELEMENT_NODE) return sibs[i];
      }
    }
    return null;
  }}

};

module.exports = NonDocumentTypeChildNode;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Text;

var utils = __webpack_require__(2);
var Node = __webpack_require__(3);
var CharacterData = __webpack_require__(13);

function Text(doc, data) {
  this.nodeType = Node.TEXT_NODE;
  this.ownerDocument = doc;
  this._data = data;
  this._index = undefined;
}

var nodeValue = {
  get: function() { return this._data; },
  set: function(v) {
    if (v === this._data) return;
    this._data = v;
    if (this.rooted)
      this.ownerDocument.mutateValue(this);
    if (this.parentNode &&
      this.parentNode._textchangehook)
      this.parentNode._textchangehook(this);
  }
};

Text.prototype = Object.create(CharacterData.prototype, {
  nodeName: { value: "#text" },
  // These three attributes are all the same.
  // The data attribute has a [TreatNullAs=EmptyString] but we'll
  // implement that at the interface level
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: nodeValue,

  splitText: { value: function splitText(offset) {
    if (offset > this._data.length || offset < 0) utils.IndexSizeError();

    var newdata = this._data.substring(offset),
      newnode = this.ownerDocument.createTextNode(newdata);
    this.data = this.data.substring(0, offset);

    var parent = this.parentNode;
    if (parent !== null)
      parent.insertBefore(newnode, this.nextSibling);

    return newnode;
  }},

  // XXX
  // wholeText and replaceWholeText() are not implemented yet because
  // the DOMCore specification is considering removing or altering them.
  wholeText: {get: utils.nyi },
  replaceWholeText: { value: utils.nyi },

  // Utility methods
  clone: { value: function clone() {
    return new Text(this.ownerDocument, this._data);
  }},

});


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Leaf;

var Node = __webpack_require__(3);
var utils = __webpack_require__(2);
var HierarchyRequestError = utils.HierarchyRequestError;
var NotFoundError = utils.NotFoundError;

// This class defines common functionality for node subtypes that
// can never have children
function Leaf() {
}

Leaf.prototype = Object.create(Node.prototype, {
  hasChildNodes: { value: function() { return false; }},
  firstChild: { value: null },
  lastChild: { value: null },
  insertBefore: { value: function(node, child) {
    if (!node.nodeType) throw new TypeError('not a node');
    HierarchyRequestError();
  }},
  replaceChild: { value: function(node, child) {
    if (!node.nodeType) throw new TypeError('not a node');
    HierarchyRequestError();
  }},
  removeChild: { value: function(node) {
    if (!node.nodeType) throw new TypeError('not a node');
    NotFoundError();
  }},
  childNodes: { get: function() {
    if (!this._childNodes) this._childNodes = [];
    return this._childNodes;
  }}
});


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Comment;

var Node = __webpack_require__(3);
var CharacterData = __webpack_require__(13);

function Comment(doc, data) {
  this.nodeType = Node.COMMENT_NODE;
  this.ownerDocument = doc;
  this._data = data;
  this._index = undefined;
}

var nodeValue = {
  get: function() { return this._data; },
  set: function(v) {
    this._data = v;
    if (this.rooted)
      this.ownerDocument.mutateValue(this);
  }
};

Comment.prototype = Object.create(CharacterData.prototype, {
  nodeName: { value: '#comment' },
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: nodeValue,

  // Utility methods
  clone: { value: function clone() {
    return new Comment(this.ownerDocument, this._data);
  }},
});


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports =  DocumentFragment;

var Node = __webpack_require__(3);
var NodeList = __webpack_require__(12);
var Element = __webpack_require__(7);
var select = __webpack_require__(20);
var utils = __webpack_require__(2);

function DocumentFragment(doc) {
  this.nodeType = Node.DOCUMENT_FRAGMENT_NODE;
  this.ownerDocument = doc;
  this.childNodes = [];
}

DocumentFragment.prototype = Object.create(Node.prototype, {
  nodeName: { value: '#document-fragment' },
  nodeValue: { 
    get: function() { 
      return null;
    },
    set: function() {}
  },
  // Copy the text content getter/setter from Element
  textContent: Object.getOwnPropertyDescriptor(Element.prototype, 'textContent'),

  querySelector: { value: function(selector) {
    // implement in terms of querySelectorAll
    var nodes = this.querySelectorAll(selector);
    return nodes.length ? nodes[0] : null;
  }},
  querySelectorAll: { value: function(selector) {
    // create a context
    var context = Object.create(this);
    // add some methods to the context for zest implementation, without
    // adding them to the public DocumentFragment API
    context.isHTML = true; // in HTML namespace (case-insensitive match)
    context.getElementsByTagName = Element.prototype.getElementsByTagName;
    context.nextElement =
      Object.getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').
      get;
    // invoke zest
    var nodes = select(selector, context);
    return nodes.item ? nodes : new NodeList(nodes);
  }},

  // Utility methods
  clone: { value: function clone() {
      return new DocumentFragment(this.ownerDocument);
  }},
  isEqual: { value: function isEqual(n) {
      // Any two document fragments are shallowly equal.
      // Node.isEqualNode() will test their children for equality
      return true;
  }},

  // Non-standard, but useful (github issue #73)
  innerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },
  outerHTML: {
    get: function() { return this.serialize(); },
    set: utils.nyi
  },

});


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = ProcessingInstruction;

var Node = __webpack_require__(3);
var CharacterData = __webpack_require__(13);

function ProcessingInstruction(doc, target, data) {
  this.nodeType = Node.PROCESSING_INSTRUCTION_NODE;
  this.ownerDocument = doc;
  this.target = target;
  this._data = data;
}

var nodeValue = {
  get: function() { return this._data; },
  set: function(v) {
    this._data = v;
    if (this.rooted) this.ownerDocument.mutateValue(this);
  }
};

ProcessingInstruction.prototype = Object.create(CharacterData.prototype, {
  nodeName: { get: function() { return this.target; }},
  nodeValue: nodeValue,
  textContent: nodeValue,
  data: nodeValue,

  // Utility methods
  clone: { value: function clone() {
      return new ProcessingInstruction(this.ownerDocument, this.target, this._data);
  }},
  isEqual: { value: function isEqual(n) {
      return this.target === n.target && this._data === n._data;
  }}

});


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* exported NodeTraversal */
var NodeTraversal = module.exports = {
  nextSkippingChildren: nextSkippingChildren,
  nextAncestorSibling: nextAncestorSibling,
  next: next,
  previous: previous,
  deepLastChild: deepLastChild
};

/**
 * @based on WebKit's NodeTraversal::nextSkippingChildren
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L109
 */
function nextSkippingChildren(node, stayWithin) {
  if (node === stayWithin) {
    return null;
  }
  if (node.nextSibling !== null) {
    return node.nextSibling;
  }
  return nextAncestorSibling(node, stayWithin);
}

/**
 * @based on WebKit's NodeTraversal::nextAncestorSibling
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.cpp?rev=179143#L93
 */
function nextAncestorSibling(node, stayWithin) {
  for (node = node.parentNode; node !== null; node = node.parentNode) {
    if (node === stayWithin) {
      return null;
    }
    if (node.nextSibling !== null) {
      return node.nextSibling;
    }
  }
  return null;
}

/**
 * @based on WebKit's NodeTraversal::next
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L99
 */
function next(node, stayWithin) {
  var n;
  n = node.firstChild;
  if (n !== null) {
    return n;
  }
  if (node === stayWithin) {
    return null;
  }
  n = node.nextSibling;
  if (n !== null) {
    return n;
  }
  return nextAncestorSibling(node, stayWithin);
}

/**
 * @based on WebKit's NodeTraversal::deepLastChild
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.cpp?rev=179143#L116
 */
function deepLastChild(node) {
  while (node.lastChild) {
    node = node.lastChild;
  }
  return node;
}

/**
 * @based on WebKit's NodeTraversal::previous
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L121
 */
function previous(node, stayWithin) {
  var p;
  p = node.previousSibling;
  if (p !== null) {
    return deepLastChild(p);
  }
  p = node.parentNode;
  if (p === stayWithin) {
    return null;
  }
  return p;
}


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {
  Event: __webpack_require__(6),
  UIEvent: __webpack_require__(38),
  MouseEvent: __webpack_require__(37),
  CustomEvent: __webpack_require__(84)
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var URL = __webpack_require__(22);

module.exports = URLUtils;

// This is an abstract superclass for Location, HTMLAnchorElement and
// other types that have the standard complement of "URL decomposition
// IDL attributes".  This is now standardized as URLUtils, see:
// https://url.spec.whatwg.org/#urlutils
// Subclasses must define a getter/setter on href.
// The getter and setter methods parse and rebuild the URL on each
// invocation; there is no attempt to cache the value and be more efficient
function URLUtils() {}
URLUtils.prototype = {
  constructor: URLUtils,

  get protocol() {
    var url = new URL(this.href);
    if (url.isAbsolute()) return url.scheme + ":";
    else return "";
  },

  get host() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isAuthorityBased())
      return url.host + (url.port ? (":" + url.port) : "");
    else
      return "";
  },

  get hostname() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isAuthorityBased())
      return url.host;
    else
      return "";
  },

  get port() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isAuthorityBased() && url.port!==undefined)
      return url.port;
    else
      return "";
  },

  get pathname() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isHierarchical())
      return url.path;
    else
      return "";
  },

  get search() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.isHierarchical() && url.query!==undefined)
      return "?" + url.query;
    else
      return "";
  },

  get hash() {
    var url = new URL(this.href);
    if (url.isAbsolute() && url.fragment !== undefined)
      return "#" + url.fragment;
    else
      return "";
  },

  get username() {
    var url = new URL(this.href);
    return url.username || '';
  },

  get password() {
    var url = new URL(this.href);
    return url.password || '';
  },

  get origin() {
    var url = new URL(this.href);
    var originForPort = function(defaultPort) {
      var origin = [url.scheme, url.host, +url.port || defaultPort];
      // XXX should be "unicode serialization"
      return origin[0] + '://' + origin[1] +
        (origin[2] === defaultPort ? '' : (':' + origin[2]));
    };
    switch (url.scheme) {
    case 'ftp':
      return originForPort(21);
    case 'gopher':
      return originForPort(70);
    case 'http':
    case 'ws':
      return originForPort(80);
    case 'https':
    case 'wss':
      return originForPort(443);
    default:
      // this is what chrome does
      return url.scheme + '://';
    }
  },

  /*
  get searchParams() {
    var url = new URL(this.href);
    // XXX
  },
  */

  set protocol(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      v = v.replace(/:+$/, "");
      v = v.replace(/[^-+\.a-zA-Z0-9]/g, URL.percentEncode);
      if (v.length > 0) {
        url.scheme = v;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set host(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isAuthorityBased()) {
      v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL.percentEncode);
      if (v.length > 0) {
        url.host = v;
        delete url.port;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set hostname(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isAuthorityBased()) {
      v = v.replace(/^\/+/, "");
      v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL.percentEncode);
      if (v.length > 0) {
        url.host = v;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set port(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isAuthorityBased()) {
      v = '' + v;
      v = v.replace(/[^0-9].*$/, "");
      v = v.replace(/^0+/, "");
      if (v.length === 0) v = "0";
      if (parseInt(v, 10) <= 65535) {
        url.port = v;
        output = url.toString();
      }
    }
    this.href = output;
  },

  set pathname(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isHierarchical()) {
      if (v.charAt(0) !== "/")
        v = "/" + v;
      v = v.replace(/[^-+\._~!$&'()*,;:=@\/a-zA-Z0-9]/g, URL.percentEncode);
      url.path = v;
      output = url.toString();
    }
    this.href = output;
  },

  set search(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute() && url.isHierarchical()) {
      if (v.charAt(0) === "?") v = v.substring(1);
      v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL.percentEncode);
      url.query = v;
      output = url.toString();
    }
    this.href = output;
  },

  set hash(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      if (v.charAt(0) === "#") v = v.substring(1);
      v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL.percentEncode);
      url.fragment = v;
      output = url.toString();
    }
    this.href = output;
  },

  set username(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\:]/g, URL.percentEncode);
      url.username = v;
      output = url.toString();
    }
    this.href = output;
  },

  set password(v) {
    var output = this.href;
    var url = new URL(output);
    if (url.isAbsolute()) {
      if (v==='') {
        url.password = null;
      } else {
        v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\]/g, URL.percentEncode);
        url.password = v;
      }
      output = url.toString();
    }
    this.href = output;
  }/*,

  set searchParams(v) {
    var output = this.href;
    var url = new URL(output);
    // XXX
    this.href = output;
  }
  */
};

URLUtils._inherit = function(proto) {
  // copy getters/setters from URLUtils to o.
  Object.getOwnPropertyNames(URLUtils.prototype).forEach(function(p) {
    if (p==='constructor' || p==='href') { return; }
    var desc = Object.getOwnPropertyDescriptor(URLUtils.prototype, p);
    Object.defineProperty(proto, p, desc);
  });
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var attributes = __webpack_require__(41);
var sloppy = __webpack_require__(53);

module.exports = function(spec, defaultConstructor, tagList, tagNameToImpl) {
  var c = spec.ctor;
  if (c) {
    var props = spec.props || {};

    if (spec.attributes) {
      for (var n in spec.attributes) {
        var attr = spec.attributes[n];
        if (typeof attr !== 'object' || Array.isArray(attr)) attr = {type: attr};
        if (!attr.name) attr.name = n.toLowerCase();
        props[n] = attributes.property(attr);
      }
    }

    props.constructor = { value : c };
    c.prototype = Object.create((spec.superclass || defaultConstructor).prototype, props);
    if (spec.events) {
      addEventHandlers(c, spec.events);
    }
    tagList[c.name] = c;
  }
  else {
    c = defaultConstructor;
  }

  (spec.tags || spec.tag && [spec.tag] || []).forEach(function(tag) {
    tagNameToImpl[tag] = c;
  });

  return c;
};

function EventHandlerBuilder(body, document, form, element) {
  this.body = body;
  this.document = document;
  this.form = form;
  this.element = element;
}

EventHandlerBuilder.prototype.build = sloppy.EventHandlerBuilder_build;

function EventHandlerChangeHandler(elt, name, oldval, newval) {
  var doc = elt.ownerDocument || Object.create(null);
  var form = elt.form || Object.create(null);
  elt[name] = new EventHandlerBuilder(newval, doc, form, elt).build();
}

function addEventHandlers(c, eventHandlerTypes) {
  var p = c.prototype;
  eventHandlerTypes.forEach(function(type) {
    // Define the event handler registration IDL attribute for this type
    Object.defineProperty(p, "on" + type, {
      get: function() {
        return this._getEventHandler(type);
      },
      set: function(v) {
        this._setEventHandler(type, v);
      },
    });

    // Define special behavior for the content attribute as well
    attributes.registerChangeHandler(c, "on" + type, EventHandlerChangeHandler);
  });
}


/***/ }),
/* 53 */
/***/ (function(module, exports) {

/* Domino uses sloppy-mode features (in particular, `with`) for a few
 * minor things.  This file encapsulates all the sloppiness; every
 * other module should be strict. */
/* jshint strict: false */
/* jshint evil: true */
/* jshint -W085 */
module.exports = {
  Window_run: function _run(code, file) {
    if (file) code += '\n//@ sourceURL=' + file;
    with(this) eval(code);
  },
  EventHandlerBuilder_build: function build() {
    try {
      with(this.document.defaultView || Object.create(null))
        with(this.document)
          with(this.form)
            with(this.element)
              return eval("(function(event){" + this.body + "})");
    }
    catch (err) {
      return function() { throw err; };
    }
  }
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var utils = __webpack_require__(2);

exports = module.exports = {
  CSSStyleDeclaration: __webpack_require__(24),
  CharacterData: __webpack_require__(13),
  Comment: __webpack_require__(46),
  DOMException: __webpack_require__(39),
  DOMImplementation: __webpack_require__(11),
  DOMTokenList: __webpack_require__(42),
  Document: __webpack_require__(18),
  DocumentFragment: __webpack_require__(47),
  DocumentType: __webpack_require__(26),
  Element: __webpack_require__(7),
  HTMLParser: __webpack_require__(27),
  Node: __webpack_require__(3),
  NodeList: __webpack_require__(12),
  NodeFilter: __webpack_require__(14),
  ProcessingInstruction: __webpack_require__(48),
  Text: __webpack_require__(44),
  Window: __webpack_require__(25)
};

utils.merge(exports, __webpack_require__(50));
utils.merge(exports, __webpack_require__(23).elements);
utils.merge(exports, __webpack_require__(55).elements);


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Element = __webpack_require__(7);
var defineElement = __webpack_require__(52);
var utils = __webpack_require__(2);
var CSSStyleDeclaration = __webpack_require__(24);

var svgElements = exports.elements = {};
var svgNameToImpl = Object.create(null);

exports.createElement = function(doc, localName, prefix) {
  var impl = svgNameToImpl[localName] || SVGElement;
  return new impl(doc, localName, prefix);
};

function define(spec) {
  return defineElement(spec, SVGElement, svgElements, svgNameToImpl);
}

var SVGElement = define({
  superclass: Element,
  ctor: function SVGElement(doc, localName, prefix) {
    Element.call(this, doc, localName, utils.NAMESPACE.SVG, prefix);
  },
  props: {
    style: { get: function() {
      if (!this._style)
        this._style = new CSSStyleDeclaration(this);
      return this._style;
    }}
  }
});

define({
  ctor: function SVGSVGElement(doc, localName, prefix) {
    SVGElement.call(this, doc, localName, prefix);
  },
  tag: 'svg',
  props: {
    createSVGRect: { value: function () {
      return exports.createElement(this.ownerDocument, 'rect', null);
    } }
  }
});

define({
  tags: [
    'a', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor', 'animateMotion', 'animateTransform',
    'circle', 'clipPath', 'color-profile', 'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',
    'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight',
    'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode',
    'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter',
    'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignObject', 'g',
    'glyph', 'glyphRef', 'hkern', 'image', 'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph',
    'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'script', 'set', 'stop',  'style',
    'switch', 'symbol', 'text', 'textPath', 'title', 'tref', 'tspan', 'use', 'view', 'vkern'
  ]
});


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var AppComponent = /** @class */ (function () {
    function AppComponent() {
    }
    AppComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'app',
            template: __webpack_require__(99),
            styles: [__webpack_require__(100)]
        })
    ], AppComponent);
    return AppComponent;
}());



/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEMAAAATCAMAAAD8mkC2AAABklBMVEVyVDZyUjV0UzWMYjl/WjaEXjaDXDh6VziHXjh4VjaRZDh6VziFXTh/XDfJuZuDXDhyUjVsTzaDXDZyVDZ/Wjbj28F+WjjVyq58WDiHXjiBXDaAWDaAWjiBXDV4WDfPwaV4VjaLYDhyUjaHYDh0UzV+WDZ6WDZwUjV8VjdsUDR6VjaFXjh9WDaEXjaMbEmBXjbb0rdtUDVuUTV/XDivl3fCsZOJYDh3VTVqTzSIXzh4VziGYkDLupyNZDhqTjSLZkCCWzWDWzinj25vUDZ2VDd+VzZuUDaFXDaDXDXd07ewl3iPbUiKZUB2VzaNYzfVya6RYjh9WDi6poiLaUmPbki9qIqHZEDQw6WQbUqBWjVvUDR4WDh2WDZ0VjZvUjdpTzSJZEB2VjWTbkpoTTZ2UjaEXDWYdlKMYjlsTjSVdVGhhWWxl3aqj2+BWja1oH+VdlKghmbBsZPFs5PBr5KmjG2NakijhmWScVKQbkqafFuafV2NakmPbUqJZT+NbEqljG2jh2a1n4GTclOzn4G2n4GdflzkW+rXAAAAC3RSTlPu7u7u7u7u7u7u7lN4egwAAAL4SURBVHgBpI/nb9swFMQJdKBoH0mB4qhICYJtKCqqyHY8DAROYDt7BEma3S9FUaB7773b/7uPTlL0e0/U8Xd8RwEi2/8vcnFiKQiCajUI8yCvBrlnPMBcRcAYBqgQEzpG3HJkbOWhn+XhNpldKGePtbnp7S+dwvgdn/9rJydIrVlyJozv9nq9SmW6gtt0xTsKcRxPAQ1LyCc2jbPjcqtCeqGuFRHUaoXfoqiGVHhDj2qn0a8IH1yAjILopNeqkQuBjIoSAEowSqnDAdxSqJkoYqsAy6szUAwY5gHcUQNY3n9RHs9hrAL4PJAovOwJNTJHMDpc40fGR4AZ9Q1+K8Z5l3FgXQ7mEeerb+Cd4YKPADjWymXeAnIuuCLEUKCsWec8XWt8MoKLlcaIpfviV8rEhropvA0fdsXT5sZw3YgVvME53rm9QpdKUuYTjeR6Imwi/L+kn5M9hVprWNZpNpodZtdN8lgIs5fcb9on3YatK1THJjahIqF2ypLzNy7Fsi21pG1Tr5sPNP5itNZxrNlc+jOdY/RA9XXcR9Ppg/SZlnVDaUyxIts6bmdTbRK3JmIqpV+mTt83D7AjqY9s7rvq4Df0c2YpY5TSDmtKinNEq6m0VEuqpyg5O381cxlqMdt67dzOy+yjQm1JyV69VT++Mif7TCnWz5zbVTtZNrk7njvnFq+5RefuxWRyaUH/6VLcVaOHgSg8dhPCNBrcqBJiEUYSbrayceHmT7tF2lwIIXn/Z8gnuTD8Z0bnckaqmtnc1y85Z496qtdm1ftlWbwu3vvcoJxp+QxZlqf7p1adVYNqraozGnVHY1DiXKPWUHUPdK2qnBDwHhRjKuE+PUBoFJn99PHjEWJkW0Q4nPeWidhwZlN5LhPNN+iErAyCaRVEgTQgPa5r7LdIZau82L+bu4FGzjW94C75r73Mz6+Mb3ZsVmwrm9nBloOiu8MK9ugVwDTip3Hv7gsqSUTSkMQNTiY4jUlI54z9DZNMvDTCQxpc/02CmZH0BzXmzPd5ZzZPAAAAAElFTkSuQmCC"

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF4AAAAbCAMAAADCmciDAAABCFBMVEVOPCdGNiRCMiBKOCRIOCRENSJENCJAMiBKOSQ/MCBDNCJLOCVINiRJNiTPxatKOSZgUDpENCGlmoKRhG1AMCBfUDp0ZlBVRTBgTzp0ZU5pWkSShm3j28BTQCpYRCxQPig2KhtcRi5WQitSPilMOiY2KRtTPypcRy5aRS1UQCpeSC9NOiZQPChSQCm7sZdYQizZ0bfPx61OPCZUQSrj3cGUhm52ZlBbRi5WQipMOyhXRjBUPypkVD2ThW5tXUayp46AcVqwpY2Je2Sxp42ekXrGvKNUPyluXUdkUTzFu6GdkXhcRi2Th2+ViW5WQSpWRTBrW0aLfmVZSDNaSDKKfGR/cFqLemRaRzITaw78AAADl0lEQVR4AbRLO25DMQzzRaRaKvyxAcPDG/yA7FkC9P7HKaUEWjqXDj9i+NJs0kSgYGsyZ5tTGgQqABz9C3/B0YtlT96+8BwynROEyHs60zm9H4hI/6QjIATdgXtn7O4OH9vE4bVgEJV0nFid1HvJQLEHixgoAMyJ9Bcl1IBJoPfEnPmfUJgTa1Zgq/LNe/Nmc8bJas/lZgy29bf/bx2w91arUeG+MbEv2RXflFuTalG9NOD5xzzOCBcIdZpECuB08V++NA3oB8M4oEaoOYygFIswKA3few5QpHyNVCnXVeugB1UDPZ92VVqLCOZcNIjGQvYHN3nU+oCB2PvaO+gCiTJR+lp5vfH9S+e4rjYMw1D4PMIeQEOGePvj1DghCST0fqFN2Ojue/83meQJ2kH3uVJ1FB3Zs0LS/UVxbl3QTyznBo/ZINhItspiFIXjomBRulCSFjYoF8yJGqJX1YeVNueRiI7zhp4LoqhPUDez2XUk13KD4xm4dCWXrEiGFRplTlNk3lVlyctE39I/HN7eq473VXkajzapv2tMy2KgdhDYQqil4vyvtBGIE8D7j7QGltTlz23VxVMey/IvdZ07D1AcbJURcE1LRBFCGjYrYEuorV3BjP/hYJfcJvy+PgxjBD532Cbgi4AewKIa0lMeyhK9Zg0TWjtNwUHxQUJQR4AKKXr4RfRoG2BDRE3n1/TiQ9D1WKQzDK/AZ5vaVQEuePTeeaOXc03QNEV/Hkd/l6QeJz+k+FNouWS9DUIxmLexwXkkfZcBA7yAntNNtPtfUHUFvbOeCix/uog/yewfn2+fxm/kHy+9oMJAvctHlj5KkQQv9JEB8oZ9adCvb4/WXuXd2vfx9YZf8fjY2nvcfrbCJiRXcBG7DCL8Ktnke8/Zy1bzGYaOwEBE1d8zJCaz4jEfwvJdoCEXQesGlEv23Wfjw+VVgZs24VRk0tZJnr4w6NWwit17E8IVRGflq0JnreEMzCJPrGxU4ppNnFNyZdSTfgYT7MVo6XhbII0MCTPoKblyqIbZ30a181K3wUTbY7QWWxTXoynGOYokPUXQGzpf0soVrYmxo5qSbBVQUtIEw1JPiUTQKkPSMv+wSek6UnomGHY6jiM9J3BElLWyglCi5oTSQz79SMa5Tuk/AxqBl0Q90oO1YQrzgTTCnTObW1LQ+J/Bvwvbtgab2bZ9290uvtOxIBiyIBNtllZyQOgD+2w72FxLoD9F/u+ocjiF/QAAAABJRU5ErkJggg=="

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF4AAAAbCAMAAADCmciDAAABGlBMVEU2KhtENSJCMiBGNiRIOCRENCJAMiA/MCBDNCJINiRJNiRENCFAMCDj3MFMOyZOOidMOiZQPihOPCZPPCZSPilUQCpWQitTQCq7sZeUh26nm4PZ0bdSQClKOSQ2KRteSC9cRi5cRy5UQSpYRCxUQCmKfGSTh26dkXjPx6zFu6KThW52aFBTPypKOCRtXEZWQipYQixPPChQPChaSDLFu6FkUz28sphMOiidkXqekXqHemOpnYVqW0Z2ZlCHeWN0Zk9WRjBaRCxfTzqJfGR+cFmxpoyBcluViW5bRi5VQCpcRi19cFmRhG1qW0XPx6vOxauzp49kUT1gTztjUjtaRzF0ZU5KOSZVRC99cFpXRjKJemTFvaN4aVJWRTAp5r3bAAADyUlEQVR4AbSMPW4FIQyEfYWV1tAg/ksk9gqvy8v9D5QZByKhNGkyGmP7GwtJuRRzTqWkknO2NaUVgJZPMgBkMJkJG48MA8IoXpAaTvJxKn/b2qEDMD9RJvx9Ie0lUajd9rhr87XAOzkUj+No/dWkwf8koZ04qNEPGMo1FJ5pzfw4BChiNx0BBDbdOidA4w8P/8AYXcPf0VHV3on+F1W6Hrube9rfCFw1dtWuFQp1v1qVpHPs2IwsjM7Ecpt30jm/SY2ohCrexzG8V6/DD8irojxEDEMBefCdO6EhMj86JpT+nOoaAkrGkBBg07WeG74uNG6n7pvk3hvyNX/ROF1LbsMwUD8AECwPLMe8qciOPeNzvz5XLg/pvf//b2QRjZcLCsACK77U2WBPwnSrdwiNtcGqp57QEvAhBKJXYUfD2SWRpiHMR6JiIf+BdonZNSUbwnoHfb3FhW4AzuA2PaQJtrFKxQpxjjMm21JrU7F2Tc+Iuc20tNuS7ZKs/X200FeYTWXESj+eb8vH1TFamzLWV5BWOKB6e994573V8IqYvKfk2wE5zRHXfk5Ln8oX751zMTnXkgc2z4TWMeqiSzsYgB73yaqZaNBA10wa7FtYwt6d7PPGuxynqUgKZMvRl2T852HzgK2EJn6sI+zUynjXuP9kZsdGnNEP6/7MuHZATXN2KAcoOeIV0GPn+IFY+NBxfjLOuEPJhjv8XQeYlSyGjXnB6g0CIqxN4dixoh2Q0/UecYXfmUNh3u+NxBnzL8JwIaLyE+/hT3TFs4iEWXBAAELDMtkLT6EYe9HiNd1yR3fylx65L/dyS528JeZNz+gzXzwx39EPfc0j7PvIPMvCcrLHrd61NlIXUmuV+m0hckN0IbKoi0zIquBTv7+nG3mD+p1cEH0Voqxji4iiR3tW70nR14pVJVClUap9/VfXGBhXDMIw1IAhgXSFsAHr/P1HqaT6cjS96pvoSZj794Lw4UAf7LG8P/hrLpOBasm3OhoCaryOF2C8luZn2cJA7mPdvgZ58MsO6EHAIB+YIVqPULi/dn2uYe4YaAwP9c7oXcxHMtZLoDo0OrmPvphiL7DP0a24MRWNqIgJgdGHoRd0kGsAfXumP2AyTCmzpIRLHSJ/oajjYq9iaS80smitFEtp1ppS4pGYnhwWXmV7E13dAtOPz1StVjtrvSp0nvWkXSRJhezxp9I3Go1OXClZPe3Kc9q0mEd7eF0w/d2Pcm4482Uth1qcLb4Lnv/U3klmx9FayzgHhgHnCKKRMisO16L9EjQYey5kfX/rGwy00/ik34efAAAAAElFTkSuQmCC"

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "d3bd2f691615e2d8c041acfc4633d880.png";

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "72d7e3b783ee4b0c3dad22264dc4fc70.png";

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "51b760b59a1e15b6af7b153631900545.png";

/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_reflect_metadata__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_reflect_metadata___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_reflect_metadata__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_zone_js__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_zone_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_zone_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_first__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_first___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_add_operator_first__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__angular_platform_server__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__angular_platform_server___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__angular_platform_server__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__app_app_server_module__ = __webpack_require__(95);








Object(__WEBPACK_IMPORTED_MODULE_4__angular_core__["enableProdMode"])();
/* harmony default export */ __webpack_exports__["default"] = (Object(__WEBPACK_IMPORTED_MODULE_6_aspnet_prerendering__["createServerRenderer"])(function (params) {
    var providers = [
        { provide: __WEBPACK_IMPORTED_MODULE_5__angular_platform_server__["INITIAL_CONFIG"], useValue: { document: '<app></app>', url: params.url } },
        { provide: __WEBPACK_IMPORTED_MODULE_3__angular_common__["APP_BASE_HREF"], useValue: params.baseUrl },
        { provide: 'BASE_URL', useValue: params.origin + params.baseUrl },
    ];
    return Object(__WEBPACK_IMPORTED_MODULE_5__angular_platform_server__["platformDynamicServer"])(providers).bootstrapModule(__WEBPACK_IMPORTED_MODULE_7__app_app_server_module__["a" /* AppModule */]).then(function (moduleRef) {
        var appRef = moduleRef.injector.get(__WEBPACK_IMPORTED_MODULE_4__angular_core__["ApplicationRef"]);
        var state = moduleRef.injector.get(__WEBPACK_IMPORTED_MODULE_5__angular_platform_server__["PlatformState"]);
        var zone = moduleRef.injector.get(__WEBPACK_IMPORTED_MODULE_4__angular_core__["NgZone"]);
        return new Promise(function (resolve, reject) {
            zone.onError.subscribe(function (errorInfo) { return reject(errorInfo); });
            appRef.isStable.first(function (isStable) { return isStable; }).subscribe(function () {
                // Because 'onStable' fires before 'onError', we have to delay slightly before
                // completing the request in case there's an error to report
                setImmediate(function () {
                    resolve({
                        html: state.renderToString()
                    });
                    moduleRef.destroy();
                });
            });
        });
    });
}));


/***/ }),
/* 68 */
/***/ (function(module, exports) {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 § 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));
//# sourceMappingURL=Reflect.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(120);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(8);
var first_1 = __webpack_require__(28);
Observable_1.Observable.prototype.first = first_1.first;
//# sourceMappingURL=first.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(91);

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(92);

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(38);

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (exports) { factory(createExporter(root, createExporter(exports))); }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
});


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(88);

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license Angular v5.2.3
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
	 true ? factory(exports, __webpack_require__(0), __webpack_require__(30), __webpack_require__(32), __webpack_require__(31)) :
	typeof define === 'function' && define.amd ? define('@angular/platform-browser/animations', ['exports', '@angular/core', '@angular/platform-browser', '@angular/animations', '@angular/animations/browser'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}, global.ng.platformBrowser.animations = {}),global.ng.core,global.ng.platformBrowser,global.ng.animations,global.ng.animations.browser));
}(this, (function (exports,_angular_core,_angular_platformBrowser,_angular_animations,_angular_animations_browser) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * @license Angular v5.2.3
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var BrowserAnimationBuilder = /** @class */ (function (_super) {
    __extends(BrowserAnimationBuilder, _super);
    function BrowserAnimationBuilder(rootRenderer, doc) {
        var _this = _super.call(this) || this;
        _this._nextAnimationId = 0;
        var /** @type {?} */ typeData = /** @type {?} */ ({
            id: '0',
            encapsulation: _angular_core.ViewEncapsulation.None,
            styles: [],
            data: { animation: [] }
        });
        _this._renderer = /** @type {?} */ (rootRenderer.createRenderer(doc.body, typeData));
        return _this;
    }
    /**
     * @param {?} animation
     * @return {?}
     */
    BrowserAnimationBuilder.prototype.build = /**
     * @param {?} animation
     * @return {?}
     */
    function (animation) {
        var /** @type {?} */ id = this._nextAnimationId.toString();
        this._nextAnimationId++;
        var /** @type {?} */ entry = Array.isArray(animation) ? _angular_animations.sequence(animation) : animation;
        issueAnimationCommand(this._renderer, null, id, 'register', [entry]);
        return new BrowserAnimationFactory(id, this._renderer);
    };
    BrowserAnimationBuilder.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    BrowserAnimationBuilder.ctorParameters = function () { return [
        { type: _angular_core.RendererFactory2, },
        { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_platformBrowser.DOCUMENT,] },] },
    ]; };
    return BrowserAnimationBuilder;
}(_angular_animations.AnimationBuilder));
var BrowserAnimationFactory = /** @class */ (function (_super) {
    __extends(BrowserAnimationFactory, _super);
    function BrowserAnimationFactory(_id, _renderer) {
        var _this = _super.call(this) || this;
        _this._id = _id;
        _this._renderer = _renderer;
        return _this;
    }
    /**
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    BrowserAnimationFactory.prototype.create = /**
     * @param {?} element
     * @param {?=} options
     * @return {?}
     */
    function (element, options) {
        return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
    };
    return BrowserAnimationFactory;
}(_angular_animations.AnimationFactory));
var RendererAnimationPlayer = /** @class */ (function () {
    function RendererAnimationPlayer(id, element, options, _renderer) {
        this.id = id;
        this.element = element;
        this._renderer = _renderer;
        this.parentPlayer = null;
        this._started = false;
        this.totalTime = 0;
        this._command('create', options);
    }
    /**
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    RendererAnimationPlayer.prototype._listen = /**
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (eventName, callback) {
        return this._renderer.listen(this.element, "@@" + this.id + ":" + eventName, callback);
    };
    /**
     * @param {?} command
     * @param {...?} args
     * @return {?}
     */
    RendererAnimationPlayer.prototype._command = /**
     * @param {?} command
     * @param {...?} args
     * @return {?}
     */
    function (command) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return issueAnimationCommand(this._renderer, this.element, this.id, command, args);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDone = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._listen('done', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onStart = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._listen('start', fn); };
    /**
     * @param {?} fn
     * @return {?}
     */
    RendererAnimationPlayer.prototype.onDestroy = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._listen('destroy', fn); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.init = /**
     * @return {?}
     */
    function () { this._command('init'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.hasStarted = /**
     * @return {?}
     */
    function () { return this._started; };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.play = /**
     * @return {?}
     */
    function () {
        this._command('play');
        this._started = true;
    };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.pause = /**
     * @return {?}
     */
    function () { this._command('pause'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.restart = /**
     * @return {?}
     */
    function () { this._command('restart'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.finish = /**
     * @return {?}
     */
    function () { this._command('finish'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.destroy = /**
     * @return {?}
     */
    function () { this._command('destroy'); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.reset = /**
     * @return {?}
     */
    function () { this._command('reset'); };
    /**
     * @param {?} p
     * @return {?}
     */
    RendererAnimationPlayer.prototype.setPosition = /**
     * @param {?} p
     * @return {?}
     */
    function (p) { this._command('setPosition', p); };
    /**
     * @return {?}
     */
    RendererAnimationPlayer.prototype.getPosition = /**
     * @return {?}
     */
    function () { return 0; };
    return RendererAnimationPlayer;
}());
/**
 * @param {?} renderer
 * @param {?} element
 * @param {?} id
 * @param {?} command
 * @param {?} args
 * @return {?}
 */
function issueAnimationCommand(renderer, element, id, command, args) {
    return renderer.setProperty(element, "@@" + id + ":" + command, args);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ANIMATION_PREFIX = '@';
var DISABLE_ANIMATIONS_FLAG = '@.disabled';
var AnimationRendererFactory = /** @class */ (function () {
    function AnimationRendererFactory(delegate, engine, _zone) {
        this.delegate = delegate;
        this.engine = engine;
        this._zone = _zone;
        this._currentId = 0;
        this._microtaskId = 1;
        this._animationCallbacksBuffer = [];
        this._rendererCache = new Map();
        this._cdRecurDepth = 0;
        engine.onRemovalComplete = function (element, delegate) {
            // Note: if an component element has a leave animation, and the component
            // a host leave animation, the view engine will call `removeChild` for the parent
            // component renderer as well as for the child component renderer.
            // Therefore, we need to check if we already removed the element.
            if (delegate && delegate.parentNode(element)) {
                delegate.removeChild(element.parentNode, element);
            }
        };
    }
    /**
     * @param {?} hostElement
     * @param {?} type
     * @return {?}
     */
    AnimationRendererFactory.prototype.createRenderer = /**
     * @param {?} hostElement
     * @param {?} type
     * @return {?}
     */
    function (hostElement, type) {
        var _this = this;
        var /** @type {?} */ EMPTY_NAMESPACE_ID = '';
        // cache the delegates to find out which cached delegate can
        // be used by which cached renderer
        var /** @type {?} */ delegate = this.delegate.createRenderer(hostElement, type);
        if (!hostElement || !type || !type.data || !type.data['animation']) {
            var /** @type {?} */ renderer = this._rendererCache.get(delegate);
            if (!renderer) {
                renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine);
                // only cache this result when the base renderer is used
                this._rendererCache.set(delegate, renderer);
            }
            return renderer;
        }
        var /** @type {?} */ componentId = type.id;
        var /** @type {?} */ namespaceId = type.id + '-' + this._currentId;
        this._currentId++;
        this.engine.register(namespaceId, hostElement);
        var /** @type {?} */ animationTriggers = /** @type {?} */ (type.data['animation']);
        animationTriggers.forEach(function (trigger) {
            return _this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);
        });
        return new AnimationRenderer(this, namespaceId, delegate, this.engine);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.begin = /**
     * @return {?}
     */
    function () {
        this._cdRecurDepth++;
        if (this.delegate.begin) {
            this.delegate.begin();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype._scheduleCountTask = /**
     * @return {?}
     */
    function () {
        var _this = this;
        Zone.current.scheduleMicroTask('incremenet the animation microtask', function () { return _this._microtaskId++; });
    };
    /* @internal */
    /**
     * @param {?} count
     * @param {?} fn
     * @param {?} data
     * @return {?}
     */
    AnimationRendererFactory.prototype.scheduleListenerCallback = /**
     * @param {?} count
     * @param {?} fn
     * @param {?} data
     * @return {?}
     */
    function (count, fn, data) {
        var _this = this;
        if (count >= 0 && count < this._microtaskId) {
            this._zone.run(function () { return fn(data); });
            return;
        }
        if (this._animationCallbacksBuffer.length == 0) {
            Promise.resolve(null).then(function () {
                _this._zone.run(function () {
                    _this._animationCallbacksBuffer.forEach(function (tuple) {
                        var fn = tuple[0], data = tuple[1];
                        fn(data);
                    });
                    _this._animationCallbacksBuffer = [];
                });
            });
        }
        this._animationCallbacksBuffer.push([fn, data]);
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.end = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._cdRecurDepth--;
        // this is to prevent animations from running twice when an inner
        // component does CD when a parent component insted has inserted it
        if (this._cdRecurDepth == 0) {
            this._zone.runOutsideAngular(function () {
                _this._scheduleCountTask();
                _this.engine.flush(_this._microtaskId);
            });
        }
        if (this.delegate.end) {
            this.delegate.end();
        }
    };
    /**
     * @return {?}
     */
    AnimationRendererFactory.prototype.whenRenderingDone = /**
     * @return {?}
     */
    function () { return this.engine.whenRenderingDone(); };
    AnimationRendererFactory.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    AnimationRendererFactory.ctorParameters = function () { return [
        { type: _angular_core.RendererFactory2, },
        { type: _angular_animations_browser.ɵAnimationEngine, },
        { type: _angular_core.NgZone, },
    ]; };
    return AnimationRendererFactory;
}());
var BaseAnimationRenderer = /** @class */ (function () {
    function BaseAnimationRenderer(namespaceId, delegate, engine) {
        this.namespaceId = namespaceId;
        this.delegate = delegate;
        this.engine = engine;
        this.destroyNode = this.delegate.destroyNode ? function (n) { return ((delegate.destroyNode))(n); } : null;
    }
    Object.defineProperty(BaseAnimationRenderer.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () { return this.delegate.data; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BaseAnimationRenderer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.engine.destroy(this.namespaceId, this.delegate);
        this.delegate.destroy();
    };
    /**
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createElement = /**
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    function (name, namespace) {
        return this.delegate.createElement(name, namespace);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createComment = /**
     * @param {?} value
     * @return {?}
     */
    function (value) { return this.delegate.createComment(value); };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.createText = /**
     * @param {?} value
     * @return {?}
     */
    function (value) { return this.delegate.createText(value); };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.appendChild = /**
     * @param {?} parent
     * @param {?} newChild
     * @return {?}
     */
    function (parent, newChild) {
        this.delegate.appendChild(parent, newChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, false);
    };
    /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.insertBefore = /**
     * @param {?} parent
     * @param {?} newChild
     * @param {?} refChild
     * @return {?}
     */
    function (parent, newChild, refChild) {
        this.delegate.insertBefore(parent, newChild, refChild);
        this.engine.onInsert(this.namespaceId, newChild, parent, true);
    };
    /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeChild = /**
     * @param {?} parent
     * @param {?} oldChild
     * @return {?}
     */
    function (parent, oldChild) {
        this.engine.onRemove(this.namespaceId, oldChild, this.delegate);
    };
    /**
     * @param {?} selectorOrNode
     * @return {?}
     */
    BaseAnimationRenderer.prototype.selectRootElement = /**
     * @param {?} selectorOrNode
     * @return {?}
     */
    function (selectorOrNode) { return this.delegate.selectRootElement(selectorOrNode); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.parentNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return this.delegate.parentNode(node); };
    /**
     * @param {?} node
     * @return {?}
     */
    BaseAnimationRenderer.prototype.nextSibling = /**
     * @param {?} node
     * @return {?}
     */
    function (node) { return this.delegate.nextSibling(node); };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, value, namespace) {
        this.delegate.setAttribute(el, name, value, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeAttribute = /**
     * @param {?} el
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    function (el, name, namespace) {
        this.delegate.removeAttribute(el, name, namespace);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.addClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { this.delegate.addClass(el, name); };
    /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeClass = /**
     * @param {?} el
     * @param {?} name
     * @return {?}
     */
    function (el, name) { this.delegate.removeClass(el, name); };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?} value
     * @param {?=} flags
     * @return {?}
     */
    function (el, style, value, flags) {
        this.delegate.setStyle(el, style, value, flags);
    };
    /**
     * @param {?} el
     * @param {?} style
     * @param {?=} flags
     * @return {?}
     */
    BaseAnimationRenderer.prototype.removeStyle = /**
     * @param {?} el
     * @param {?} style
     * @param {?=} flags
     * @return {?}
     */
    function (el, style, flags) {
        this.delegate.removeStyle(el, style, flags);
    };
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
            this.disableAnimations(el, !!value);
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.setValue = /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    function (node, value) { this.delegate.setValue(node, value); };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    BaseAnimationRenderer.prototype.listen = /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (target, eventName, callback) {
        return this.delegate.listen(target, eventName, callback);
    };
    /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    BaseAnimationRenderer.prototype.disableAnimations = /**
     * @param {?} element
     * @param {?} value
     * @return {?}
     */
    function (element, value) {
        this.engine.disableAnimations(element, value);
    };
    return BaseAnimationRenderer;
}());
var AnimationRenderer = /** @class */ (function (_super) {
    __extends(AnimationRenderer, _super);
    function AnimationRenderer(factory, namespaceId, delegate, engine) {
        var _this = _super.call(this, namespaceId, delegate, engine) || this;
        _this.factory = factory;
        _this.namespaceId = namespaceId;
        return _this;
    }
    /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    AnimationRenderer.prototype.setProperty = /**
     * @param {?} el
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (el, name, value) {
        if (name.charAt(0) == ANIMATION_PREFIX) {
            if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {
                value = value === undefined ? true : !!value;
                this.disableAnimations(el, /** @type {?} */ (value));
            }
            else {
                this.engine.process(this.namespaceId, el, name.substr(1), value);
            }
        }
        else {
            this.delegate.setProperty(el, name, value);
        }
    };
    /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    AnimationRenderer.prototype.listen = /**
     * @param {?} target
     * @param {?} eventName
     * @param {?} callback
     * @return {?}
     */
    function (target, eventName, callback) {
        var _this = this;
        if (eventName.charAt(0) == ANIMATION_PREFIX) {
            var /** @type {?} */ element = resolveElementFromTarget(target);
            var /** @type {?} */ name_1 = eventName.substr(1);
            var /** @type {?} */ phase = '';
            // @listener.phase is for trigger animation callbacks
            // @@listener is for animation builder callbacks
            if (name_1.charAt(0) != ANIMATION_PREFIX) {
                _a = parseTriggerCallbackName(name_1), name_1 = _a[0], phase = _a[1];
            }
            return this.engine.listen(this.namespaceId, element, name_1, phase, function (event) {
                var /** @type {?} */ countId = (/** @type {?} */ (event))['_data'] || -1;
                _this.factory.scheduleListenerCallback(countId, callback, event);
            });
        }
        return this.delegate.listen(target, eventName, callback);
        var _a;
    };
    return AnimationRenderer;
}(BaseAnimationRenderer));
/**
 * @param {?} target
 * @return {?}
 */
function resolveElementFromTarget(target) {
    switch (target) {
        case 'body':
            return document.body;
        case 'document':
            return document;
        case 'window':
            return window;
        default:
            return target;
    }
}
/**
 * @param {?} triggerName
 * @return {?}
 */
function parseTriggerCallbackName(triggerName) {
    var /** @type {?} */ dotIndex = triggerName.indexOf('.');
    var /** @type {?} */ trigger = triggerName.substring(0, dotIndex);
    var /** @type {?} */ phase = triggerName.substr(dotIndex + 1);
    return [trigger, phase];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var InjectableAnimationEngine = /** @class */ (function (_super) {
    __extends(InjectableAnimationEngine, _super);
    function InjectableAnimationEngine(driver, normalizer) {
        return _super.call(this, driver, normalizer) || this;
    }
    InjectableAnimationEngine.decorators = [
        { type: _angular_core.Injectable },
    ];
    /** @nocollapse */
    InjectableAnimationEngine.ctorParameters = function () { return [
        { type: _angular_animations_browser.AnimationDriver, },
        { type: _angular_animations_browser.ɵAnimationStyleNormalizer, },
    ]; };
    return InjectableAnimationEngine;
}(_angular_animations_browser.ɵAnimationEngine));
/**
 * @return {?}
 */
function instantiateSupportedAnimationDriver() {
    if (_angular_animations_browser.ɵsupportsWebAnimations()) {
        return new _angular_animations_browser.ɵWebAnimationsDriver();
    }
    return new _angular_animations_browser.ɵNoopAnimationDriver();
}
/**
 * @return {?}
 */
function instantiateDefaultStyleNormalizer() {
    return new _angular_animations_browser.ɵWebAnimationsStyleNormalizer();
}
/**
 * @param {?} renderer
 * @param {?} engine
 * @param {?} zone
 * @return {?}
 */
function instantiateRendererFactory(renderer, engine, zone) {
    return new AnimationRendererFactory(renderer, engine, zone);
}
var SHARED_ANIMATION_PROVIDERS = [
    { provide: _angular_animations.AnimationBuilder, useClass: BrowserAnimationBuilder },
    { provide: _angular_animations_browser.ɵAnimationStyleNormalizer, useFactory: instantiateDefaultStyleNormalizer },
    { provide: _angular_animations_browser.ɵAnimationEngine, useClass: InjectableAnimationEngine }, {
        provide: _angular_core.RendererFactory2,
        useFactory: instantiateRendererFactory,
        deps: [_angular_platformBrowser.ɵDomRendererFactory2, _angular_animations_browser.ɵAnimationEngine, _angular_core.NgZone]
    }
];
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserModule.
 */
var BROWSER_ANIMATIONS_PROVIDERS = [
    { provide: _angular_animations_browser.AnimationDriver, useFactory: instantiateSupportedAnimationDriver }
].concat(SHARED_ANIMATION_PROVIDERS);
/**
 * Separate providers from the actual module so that we can do a local modification in Google3 to
 * include them in the BrowserTestingModule.
 */
var BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{ provide: _angular_animations_browser.AnimationDriver, useClass: _angular_animations_browser.ɵNoopAnimationDriver }].concat(SHARED_ANIMATION_PROVIDERS);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@experimental Animation support is experimental.
 */
var BrowserAnimationsModule = /** @class */ (function () {
    function BrowserAnimationsModule() {
    }
    BrowserAnimationsModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    exports: [_angular_platformBrowser.BrowserModule],
                    providers: BROWSER_ANIMATIONS_PROVIDERS,
                },] },
    ];
    /** @nocollapse */
    BrowserAnimationsModule.ctorParameters = function () { return []; };
    return BrowserAnimationsModule;
}());
/**
 * \@experimental Animation support is experimental.
 */
var NoopAnimationsModule = /** @class */ (function () {
    function NoopAnimationsModule() {
    }
    NoopAnimationsModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    exports: [_angular_platformBrowser.BrowserModule],
                    providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
                },] },
    ];
    /** @nocollapse */
    NoopAnimationsModule.ctorParameters = function () { return []; };
    return NoopAnimationsModule;
}());

exports.BrowserAnimationsModule = BrowserAnimationsModule;
exports.NoopAnimationsModule = NoopAnimationsModule;
exports.ɵBrowserAnimationBuilder = BrowserAnimationBuilder;
exports.ɵBrowserAnimationFactory = BrowserAnimationFactory;
exports.ɵAnimationRenderer = AnimationRenderer;
exports.ɵAnimationRendererFactory = AnimationRendererFactory;
exports.ɵa = BaseAnimationRenderer;
exports.ɵf = BROWSER_ANIMATIONS_PROVIDERS;
exports.ɵg = BROWSER_NOOP_ANIMATIONS_PROVIDERS;
exports.ɵb = InjectableAnimationEngine;
exports.ɵd = instantiateDefaultStyleNormalizer;
exports.ɵe = instantiateRendererFactory;
exports.ɵc = instantiateSupportedAnimationDriver;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=platform-browser-animations.umd.js.map


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(5);

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(35);

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(8);
// HACK: this is here for backward compatability
// TODO(benlesh): remove this in v6.
exports.toPromise = Observable_1.Observable.prototype.toPromise;
//# sourceMappingURL=toPromise.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DOMImplementation = __webpack_require__(11);
var HTMLParser = __webpack_require__(27);
var Window = __webpack_require__(25);

exports.createDOMImplementation = function() {
  return new DOMImplementation();
};

exports.createDocument = function(html, force) {
  // Previous API couldn't let you pass '' as a document, and that
  // yields a slightly different document than createHTMLDocument('')
  // does.  The new `force` parameter lets you pass '' if you want to.
  if (html || force) {
    var parser = new HTMLParser();
    parser.parse(html || '', true);
    return parser.document();
  }
  return new DOMImplementation().createHTMLDocument("");
};

exports.createWindow = function(html, address) {
  var document = exports.createDocument(html);
  if (address !== undefined) { document._address = address; }
  return new Window(document);
};

exports.impl = __webpack_require__(54);


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = FilteredElementList;

var Node = __webpack_require__(3);

//
// This file defines node list implementation that lazily traverses
// the document tree (or a subtree rooted at any element) and includes
// only those elements for which a specified filter function returns true.
// It is used to implement the
// {Document,Element}.getElementsBy{TagName,ClassName}{,NS} methods.
//

function FilteredElementList(root, filter) {
  this.root = root;
  this.filter = filter;
  this.lastModTime = root.lastModTime;
  this.done = false;
  this.cache = [];
  this.traverse();
}

FilteredElementList.prototype = {
  get length() {
    this.checkcache();
    if (!this.done) this.traverse();
    return this.cache.length;
  },

  item: function(n) {
    this.checkcache();
    if (!this.done && n >= this.cache.length) this.traverse(n);
    return this.cache[n];
  },

  checkcache: function() {
    if (this.lastModTime !== this.root.lastModTime) {
      // subtree has changed, so invalidate cache
      for (var i = this.cache.length-1; i>=0; i--) {
        this[i] = undefined;
      }
      this.cache.length = 0;
      this.done = false;
      this.lastModTime = this.root.lastModTime;
    }
  },

  // If n is specified, then traverse the tree until we've found the nth
  // item (or until we've found all items).  If n is not specified,
  // traverse until we've found all items.
  traverse: function(n) {
    // increment n so we can compare to length, and so it is never falsy
    if (n !== undefined) n++;

    var elt;
    while ((elt = this.next()) !== null) {
      this[this.cache.length] = elt; //XXX Use proxy instead
      this.cache.push(elt);
      if (n && this.cache.length === n) return;
    }

    // no next element, so we've found everything
    this.done = true;
  },

  // Return the next element under root that matches filter
  next: function() {
    var start = (this.cache.length === 0) ? this.root // Start at the root or at
      : this.cache[this.cache.length-1]; // the last element we found

    var elt;
    if (start.nodeType === Node.DOCUMENT_NODE)
      elt = start.documentElement;
    else
      elt = start.nextElement(this.root);

    while(elt) {
      if (this.filter(elt)) {
        return elt;
      }

      elt = elt.nextElement(this.root);
    }
    return null;
  }
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = TreeWalker;

var NodeFilter = __webpack_require__(14);
var NodeTraversal = __webpack_require__(49);

var mapChild = {
  first: 'firstChild',
  last: 'lastChild',
  next: 'firstChild',
  previous: 'lastChild'
};

var mapSibling = {
  first: 'nextSibling',
  last: 'previousSibling',
  next: 'nextSibling',
  previous: 'previousSibling'
};

/* Private methods and helpers */

/**
 * @spec http://www.w3.org/TR/dom/#concept-traverse-children
 * @method
 * @access private
 * @param {TreeWalker} tw
 * @param {string} type One of 'first' or 'last'.
 * @return {Node|null}
 */
function traverseChildren(tw, type) {
  var child, node, parent, result, sibling;
  node = tw.currentNode[mapChild[type]];
  while (node !== null) {
    result = tw.filter.acceptNode(node);
    if (result === NodeFilter.FILTER_ACCEPT) {
      tw.currentNode = node;
      return node;
    }
    if (result === NodeFilter.FILTER_SKIP) {
      child = node[mapChild[type]];
      if (child !== null) {
        node = child;
        continue;
      }
    }
    while (node !== null) {
      sibling = node[mapSibling[type]];
      if (sibling !== null) {
        node = sibling;
        break;
      }
      parent = node.parentNode;
      if (parent === null || parent === tw.root || parent === tw.currentNode) {
        return null;
      }
      else {
        node = parent;
      }
    }
  }
  return null;
}

/**
 * @spec http://www.w3.org/TR/dom/#concept-traverse-siblings
 * @method
 * @access private
 * @param {TreeWalker} tw
 * @param {TreeWalker} type One of 'next' or 'previous'.
 * @return {Node|nul}
 */
function traverseSiblings(tw, type) {
  var node, result, sibling;
  node = tw.currentNode;
  if (node === tw.root) {
    return null;
  }
  while (true) {
    sibling = node[mapSibling[type]];
    while (sibling !== null) {
      node = sibling;
      result = tw.filter.acceptNode(node);
      if (result === NodeFilter.FILTER_ACCEPT) {
        tw.currentNode = node;
        return node;
      }
      sibling = node[mapChild[type]];
      if (result === NodeFilter.FILTER_REJECT || sibling === null) {
        sibling = node[mapSibling[type]];
      }
    }
    node = node.parentNode;
    if (node === null || node === tw.root) {
      return null;
    }
    if (tw.filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {
      return null;
    }
  }
}


/* Public API */

/**
 * Implemented version: http://www.w3.org/TR/2015/WD-dom-20150618/#interface-treewalker
 * Latest version: http://www.w3.org/TR/dom/#interface-treewalker
 *
 * @constructor
 * @param {Node} root
 * @param {number} whatToShow [optional]
 * @param {Function|NodeFilter} filter [optional]
 * @throws Error
 */
function TreeWalker(root, whatToShow, filter) {
  var tw = this, active = false;

  if (!root || !root.nodeType) {
    throw new Error('DOMException: NOT_SUPPORTED_ERR');
  }

  tw.root = root;
  tw.whatToShow = Number(whatToShow) || 0;

  tw.currentNode = root;

  if (typeof filter !== 'function') {
    filter = null;
  }

  tw.filter = Object.create(NodeFilter.prototype);

  /**
   * @method
   * @param {Node} node
   * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
   *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
   */
  tw.filter.acceptNode = function (node) {
    /* jshint bitwise: false */
    var result;
    if (active) {
      throw new Error('DOMException: INVALID_STATE_ERR');
    }

    // Maps nodeType to whatToShow
    if (!(((1 << (node.nodeType - 1)) & tw.whatToShow))) {
      return NodeFilter.FILTER_SKIP;
    }

    if (filter === null) {
      return NodeFilter.FILTER_ACCEPT;
    }

    active = true;
    result = filter(node);
    active = false;

    return result;
  };
}

TreeWalker.prototype = {

  constructor: TreeWalker,

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-parentnode
   * @method
   * @return {Node|null}
   */
  parentNode: function () {
    var node = this.currentNode;
    while (node !== null && node !== this.root) {
      node = node.parentNode;
      if (node !== null && this.filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
    }
    return null;
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-firstchild
   * @method
   * @return {Node|null}
   */
  firstChild: function () {
    return traverseChildren(this, 'first');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-lastchild
   * @method
   * @return {Node|null}
   */
  lastChild: function () {
    return traverseChildren(this, 'last');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-previoussibling
   * @method
   * @return {Node|null}
   */
  previousSibling: function () {
    return traverseSiblings(this, 'previous');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-nextsibling
   * @method
   * @return {Node|null}
   */
  nextSibling: function () {
    return traverseSiblings(this, 'next');
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-previousnode
   * @method
   * @return {Node|null}
   */
  previousNode: function () {
    var node, result, sibling;
    node = this.currentNode;
    while (node !== this.root) {
      sibling = node.previousSibling;
      while (sibling !== null) {
        node = sibling;
        result = this.filter.acceptNode(node);
        while (result !== NodeFilter.FILTER_REJECT && node.lastChild !== null) {
          node = node.lastChild;
          result = this.filter.acceptNode(node);
        }
        if (result === NodeFilter.FILTER_ACCEPT) {
          this.currentNode = node;
          return node;
        }
        sibling = node.previousSibling;
      }
      if (node === this.root || node.parentNode === null) {
        return null;
      }
      node = node.parentNode;
      if (this.filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
    }
    return null;
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-treewalker-nextnode
   * @based on WebKit's TreeWalker::nextNode
   * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=179143#L252
   * @method
   * @return {Node|null}
   */
  nextNode: function () {
    var node, result, following;
    node = this.currentNode;
    result = NodeFilter.FILTER_ACCEPT;

    while (true) {
      while (result !== NodeFilter.FILTER_REJECT && node.firstChild !== null) {
        node = node.firstChild;
        result = this.filter.acceptNode(node);
        if (result === NodeFilter.FILTER_ACCEPT) {
          this.currentNode = node;
          return node;
        }
      }
      following = NodeTraversal.nextSkippingChildren(node, this.root);
      if (following !== null) {
        node = following;
      }
      else {
        return null;
      }
      result = this.filter.acceptNode(node);
      if (result === NodeFilter.FILTER_ACCEPT) {
        this.currentNode = node;
        return node;
      }
    }
  }
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = NodeIterator;

var NodeFilter = __webpack_require__(14);
var NodeTraversal = __webpack_require__(49);

/* Private methods and helpers */

/**
 * @based on WebKit's NodeIterator::moveToNext and NodeIterator::moveToPrevious
 * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeIterator.cpp?rev=186279#L51
 */
function move(node, stayWithin, directionIsNext) {
  if (directionIsNext) {
    return NodeTraversal.next(node, stayWithin);
  } else {
    if (node === stayWithin) {
      return null;
    }
    return NodeTraversal.previous(node, null);
  }
}

/**
 * @spec http://www.w3.org/TR/dom/#concept-nodeiterator-traverse
 * @method
 * @access private
 * @param {NodeIterator} ni
 * @param {string} direction One of 'next' or 'previous'.
 * @return {Node|null}
 */
function traverse(ni, directionIsNext) {
  var node, beforeNode;
  node = ni.referenceNode;
  beforeNode = ni.pointerBeforeReferenceNode;
  while (true) {
    if (beforeNode === directionIsNext) {
      beforeNode = !beforeNode;
    } else {
      node = move(node, ni.root, directionIsNext);
      if (node === null) {
        return null;
      }
    }
    var result = ni.filter.acceptNode(node);
    if (result === NodeFilter.FILTER_ACCEPT) {
      break;
    }
  }
  ni.referenceNode = node;
  ni.pointerBeforeReferenceNode = beforeNode;
  return node;
}

/* Public API */

/**
 * Implemented version: http://www.w3.org/TR/2015/WD-dom-20150618/#nodeiterator
 * Latest version: http://www.w3.org/TR/dom/#nodeiterator
 *
 * @constructor
 * @param {Node} root
 * @param {number} whatToShow [optional]
 * @param {Function|NodeFilter} filter [optional]
 * @throws Error
 */
function NodeIterator(root, whatToShow, filter) {
  var ni = this, active = false;

  if (!root || !root.nodeType) {
    throw new Error('DOMException: NOT_SUPPORTED_ERR');
  }

  ni.root = ni.referenceNode = root;
  ni.pointerBeforeReferenceNode = true;
  ni.whatToShow = Number(whatToShow) || 0;

  if (typeof filter !== 'function') {
    filter = null;
  }

  ni.filter = Object.create(NodeFilter.prototype);

  /**
   * @method
   * @param {Node} node
   * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
   *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
   */
  ni.filter.acceptNode = function (node) {
    /* jshint bitwise: false */
    var result;
    if (active) {
      throw new Error('DOMException: INVALID_STATE_ERR');
    }

    // Maps nodeType to whatToShow
    if (!(((1 << (node.nodeType - 1)) & ni.whatToShow))) {
      return NodeFilter.FILTER_SKIP;
    }

    if (filter === null) {
      return NodeFilter.FILTER_ACCEPT;
    }

    active = true;
    result = filter(node);
    active = false;

    return result;
  };
}

NodeIterator.prototype = {
  constructor: NodeIterator,

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-nextnode
   * @method
   * @return {Node|null}
   */
  nextNode: function () {
    return traverse(this, true);
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-previousnode
   * @method
   * @return {Node|null}
   */
  previousNode: function () {
    return traverse(this, false);
  },

  /**
   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-detach
   * @method
   * @return void
   */
  detach: function() {
    /* "The detach() method must do nothing.
     * Its functionality (disabling a NodeIterator object) was removed,
     * but the method itself is preserved for compatibility.
     */
  }
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = CustomEvent;

var Event = __webpack_require__(6);

function CustomEvent(type, dictionary) {
  // Just use the superclass constructor to initialize
  Event.call(this, type, dictionary);
}
CustomEvent.prototype = Object.create(Event.prototype, {
  constructor: { value: CustomEvent }
});


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* jshint node:true, latedef:false */
 // jshint ignore:line
/*!
Parser-Lib
Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/* Version v0.2.5+domino1, Build time: 30-January-2016 05:13:03 */
var parserlib = Object.create(null);
(function(){

/**
 * A generic base to inherit from for any object
 * that needs event handling.
 * @class EventTarget
 * @constructor
 */
function EventTarget(){

    /**
     * The array of listeners for various events.
     * @type Object
     * @property _listeners
     * @private
     */
    this._listeners = Object.create(null);
}

EventTarget.prototype = {

    //restore constructor
    constructor: EventTarget,

    /**
     * Adds a listener for a given event type.
     * @param {String} type The type of event to add a listener for.
     * @param {Function} listener The function to call when the event occurs.
     * @return {void}
     * @method addListener
     */
    addListener: function(type, listener){
        if (!this._listeners[type]){
            this._listeners[type] = [];
        }

        this._listeners[type].push(listener);
    },

    /**
     * Fires an event based on the passed-in object.
     * @param {Object|String} event An object with at least a 'type' attribute
     *      or a string indicating the event name.
     * @return {void}
     * @method fire
     */
    fire: function(event){
        if (typeof event === "string"){
            event = { type: event };
        }
        if (typeof event.target !== "undefined"){
            event.target = this;
        }

        if (typeof event.type === "undefined"){
            throw new Error("Event object missing 'type' property.");
        }

        if (this._listeners[event.type]){

            //create a copy of the array and use that so listeners can't chane
            var listeners = this._listeners[event.type].concat();
            for (var i=0, len=listeners.length; i < len; i++){
                listeners[i].call(this, event);
            }
        }
    },

    /**
     * Removes a listener for a given event type.
     * @param {String} type The type of event to remove a listener from.
     * @param {Function} listener The function to remove from the event.
     * @return {void}
     * @method removeListener
     */
    removeListener: function(type, listener){
        if (this._listeners[type]){
            var listeners = this._listeners[type];
            for (var i=0, len=listeners.length; i < len; i++){
                if (listeners[i] === listener){
                    listeners.splice(i, 1);
                    break;
                }
            }


        }
    }
};
/**
 * Convenient way to read through strings.
 * @namespace parserlib.util
 * @class StringReader
 * @constructor
 * @param {String} text The text to read.
 */
function StringReader(text){

    /**
     * The input text with line endings normalized.
     * @property _input
     * @type String
     * @private
     */
    this._input = text.replace(/(\r|\n){1,2}/g, "\n");


    /**
     * The row for the character to be read next.
     * @property _line
     * @type int
     * @private
     */
    this._line = 1;


    /**
     * The column for the character to be read next.
     * @property _col
     * @type int
     * @private
     */
    this._col = 1;

    /**
     * The index of the character in the input to be read next.
     * @property _cursor
     * @type int
     * @private
     */
    this._cursor = 0;
}

StringReader.prototype = {

    //restore constructor
    constructor: StringReader,

    //-------------------------------------------------------------------------
    // Position info
    //-------------------------------------------------------------------------

    /**
     * Returns the column of the character to be read next.
     * @return {int} The column of the character to be read next.
     * @method getCol
     */
    getCol: function(){
        return this._col;
    },

    /**
     * Returns the row of the character to be read next.
     * @return {int} The row of the character to be read next.
     * @method getLine
     */
    getLine: function(){
        return this._line ;
    },

    /**
     * Determines if you're at the end of the input.
     * @return {Boolean} True if there's no more input, false otherwise.
     * @method eof
     */
    eof: function(){
        return (this._cursor === this._input.length);
    },

    //-------------------------------------------------------------------------
    // Basic reading
    //-------------------------------------------------------------------------

    /**
     * Reads the next character without advancing the cursor.
     * @param {int} count How many characters to look ahead (default is 1).
     * @return {String} The next character or null if there is no next character.
     * @method peek
     */
    peek: function(count){
        var c = null;
        count = (typeof count === "undefined" ? 1 : count);

        //if we're not at the end of the input...
        if (this._cursor < this._input.length){

            //get character and increment cursor and column
            c = this._input.charAt(this._cursor + count - 1);
        }

        return c;
    },

    /**
     * Reads the next character from the input and adjusts the row and column
     * accordingly.
     * @return {String} The next character or null if there is no next character.
     * @method read
     */
    read: function(){
        var c = null;

        //if we're not at the end of the input...
        if (this._cursor < this._input.length){

            //if the last character was a newline, increment row count
            //and reset column count
            if (this._input.charAt(this._cursor) === "\n"){
                this._line++;
                this._col=1;
            } else {
                this._col++;
            }

            //get character and increment cursor and column
            c = this._input.charAt(this._cursor++);
        }

        return c;
    },

    //-------------------------------------------------------------------------
    // Misc
    //-------------------------------------------------------------------------

    /**
     * Saves the current location so it can be returned to later.
     * @method mark
     * @return {void}
     */
    mark: function(){
        this._bookmark = {
            cursor: this._cursor,
            line:   this._line,
            col:    this._col
        };
    },

    reset: function(){
        if (this._bookmark){
            this._cursor = this._bookmark.cursor;
            this._line = this._bookmark.line;
            this._col = this._bookmark.col;
            delete this._bookmark;
        }
    },

    //-------------------------------------------------------------------------
    // Advanced reading
    //-------------------------------------------------------------------------

    /**
     * Reads up to and including the given string. Throws an error if that
     * string is not found.
     * @param {String} pattern The string to read.
     * @return {String} The string when it is found.
     * @throws Error when the string pattern is not found.
     * @method readTo
     */
    readTo: function(pattern){

        var buffer = "",
            c;

        /*
         * First, buffer must be the same length as the pattern.
         * Then, buffer must end with the pattern or else reach the
         * end of the input.
         */
        while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length){
            c = this.read();
            if (c){
                buffer += c;
            } else {
                throw new Error("Expected \"" + pattern + "\" at line " + this._line  + ", col " + this._col + ".");
            }
        }

        return buffer;

    },

    /**
     * Reads characters while each character causes the given
     * filter function to return true. The function is passed
     * in each character and either returns true to continue
     * reading or false to stop.
     * @param {Function} filter The function to read on each character.
     * @return {String} The string made up of all characters that passed the
     *      filter check.
     * @method readWhile
     */
    readWhile: function(filter){

        var buffer = "",
            c = this.read();

        while(c !== null && filter(c)){
            buffer += c;
            c = this.read();
        }

        return buffer;

    },

    /**
     * Reads characters that match either text or a regular expression and
     * returns those characters. If a match is found, the row and column
     * are adjusted; if no match is found, the reader's state is unchanged.
     * reading or false to stop.
     * @param {String|RegExp} matchter If a string, then the literal string
     *      value is searched for. If a regular expression, then any string
     *      matching the pattern is search for.
     * @return {String} The string made up of all characters that matched or
     *      null if there was no match.
     * @method readMatch
     */
    readMatch: function(matcher){

        var source = this._input.substring(this._cursor),
            value = null;

        //if it's a string, just do a straight match
        if (typeof matcher === "string"){
            if (source.indexOf(matcher) === 0){
                value = this.readCount(matcher.length);
            }
        } else if (matcher instanceof RegExp){
            if (matcher.test(source)){
                value = this.readCount(RegExp.lastMatch.length);
            }
        }

        return value;
    },


    /**
     * Reads a given number of characters. If the end of the input is reached,
     * it reads only the remaining characters and does not throw an error.
     * @param {int} count The number of characters to read.
     * @return {String} The string made up the read characters.
     * @method readCount
     */
    readCount: function(count){
        var buffer = "";

        while(count--){
            buffer += this.read();
        }

        return buffer;
    }

};
/**
 * Type to use when a syntax error occurs.
 * @class SyntaxError
 * @namespace parserlib.util
 * @constructor
 * @param {String} message The error message.
 * @param {int} line The line at which the error occurred.
 * @param {int} col The column at which the error occurred.
 */
function SyntaxError(message, line, col){
    Error.call(this);
    this.name = this.constructor.name;

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}

//inherit from Error
SyntaxError.prototype = Object.create(Error.prototype); // jshint ignore:line
SyntaxError.prototype.constructor = SyntaxError; // jshint ignore:line
/**
 * Base type to represent a single syntactic unit.
 * @class SyntaxUnit
 * @namespace parserlib.util
 * @constructor
 * @param {String} text The text of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SyntaxUnit(text, line, col, type){


    /**
     * The column of text on which the unit resides.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line of text on which the unit resides.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.text = text;

    /**
     * The type of syntax unit.
     * @type int
     * @property type
     */
    this.type = type;
}

/**
 * Create a new syntax unit based solely on the given token.
 * Convenience method for creating a new syntax unit when
 * it represents a single token instead of multiple.
 * @param {Object} token The token object to represent.
 * @return {parserlib.util.SyntaxUnit} The object representing the token.
 * @static
 * @method fromToken
 */
SyntaxUnit.fromToken = function(token){
    return new SyntaxUnit(token.value, token.startLine, token.startCol);
};

SyntaxUnit.prototype = {

    //restore constructor
    constructor: SyntaxUnit,

    /**
     * Returns the text representation of the unit.
     * @return {String} The text representation of the unit.
     * @method valueOf
     */
    valueOf: function(){
        return this.toString();
    },

    /**
     * Returns the text representation of the unit.
     * @return {String} The text representation of the unit.
     * @method toString
     */
    toString: function(){
        return this.text;
    }

};

/**
 * Generic TokenStream providing base functionality.
 * @class TokenStreamBase
 * @namespace parserlib.util
 * @constructor
 * @param {String|StringReader} input The text to tokenize or a reader from
 *      which to read the input.
 */
function TokenStreamBase(input, tokenData){

    /**
     * The string reader for easy access to the text.
     * @type StringReader
     * @property _reader
     * @private
     */
    this._reader = input ? new StringReader(input.toString()) : null;

    /**
     * Token object for the last consumed token.
     * @type Token
     * @property _token
     * @private
     */
    this._token = null;

    /**
     * The array of token information.
     * @type Array
     * @property _tokenData
     * @private
     */
    this._tokenData = tokenData;

    /**
     * Lookahead token buffer.
     * @type Array
     * @property _lt
     * @private
     */
    this._lt = [];

    /**
     * Lookahead token buffer index.
     * @type int
     * @property _ltIndex
     * @private
     */
    this._ltIndex = 0;

    this._ltIndexCache = [];
}

/**
 * Accepts an array of token information and outputs
 * an array of token data containing key-value mappings
 * and matching functions that the TokenStream needs.
 * @param {Array} tokens An array of token descriptors.
 * @return {Array} An array of processed token data.
 * @method createTokenData
 * @static
 */
TokenStreamBase.createTokenData = function(tokens){

    var nameMap     = [],
        typeMap     = Object.create(null),
        tokenData     = tokens.concat([]),
        i            = 0,
        len            = tokenData.length+1;

    tokenData.UNKNOWN = -1;
    tokenData.unshift({name:"EOF"});

    for (; i < len; i++){
        nameMap.push(tokenData[i].name);
        tokenData[tokenData[i].name] = i;
        if (tokenData[i].text){
            typeMap[tokenData[i].text] = i;
        }
    }

    tokenData.name = function(tt){
        return nameMap[tt];
    };

    tokenData.type = function(c){
        return typeMap[c];
    };

    return tokenData;
};

TokenStreamBase.prototype = {

    //restore constructor
    constructor: TokenStreamBase,

    //-------------------------------------------------------------------------
    // Matching methods
    //-------------------------------------------------------------------------

    /**
     * Determines if the next token matches the given token type.
     * If so, that token is consumed; if not, the token is placed
     * back onto the token stream. You can pass in any number of
     * token types and this will return true if any of the token
     * types is found.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token might be. If an array is passed,
     *      it's assumed that the token can be any of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {Boolean} True if the token type matches, false if not.
     * @method match
     */
    match: function(tokenTypes, channel){

        //always convert to an array, makes things easier
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }

        var tt  = this.get(channel),
            i   = 0,
            len = tokenTypes.length;

        while(i < len){
            if (tt === tokenTypes[i++]){
                return true;
            }
        }

        //no match found, put the token back
        this.unget();
        return false;
    },

    /**
     * Determines if the next token matches the given token type.
     * If so, that token is consumed; if not, an error is thrown.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token should be. If an array is passed,
     *      it's assumed that the token must be one of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {void}
     * @method mustMatch
     */
    mustMatch: function(tokenTypes, channel){

        var token;

        //always convert to an array, makes things easier
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }

        if (!this.match.apply(this, arguments)){
            token = this.LT(1);
            throw new SyntaxError("Expected " + this._tokenData[tokenTypes[0]].name +
                " at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
        }
    },

    //-------------------------------------------------------------------------
    // Consuming methods
    //-------------------------------------------------------------------------

    /**
     * Keeps reading from the token stream until either one of the specified
     * token types is found or until the end of the input is reached.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token should be. If an array is passed,
     *      it's assumed that the token must be one of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {void}
     * @method advance
     */
    advance: function(tokenTypes, channel){

        while(this.LA(0) !== 0 && !this.match(tokenTypes, channel)){
            this.get();
        }

        return this.LA(0);
    },

    /**
     * Consumes the next token from the token stream.
     * @return {int} The token type of the token that was just consumed.
     * @method get
     */
    get: function(channel){

        var tokenInfo   = this._tokenData,
            i           =0,
            token,
            info;

        //check the lookahead buffer first
        if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length){

            i++;
            this._token = this._lt[this._ltIndex++];
            info = tokenInfo[this._token.type];

            //obey channels logic
            while((info.channel !== undefined && channel !== info.channel) &&
                    this._ltIndex < this._lt.length){
                this._token = this._lt[this._ltIndex++];
                info = tokenInfo[this._token.type];
                i++;
            }

            //here be dragons
            if ((info.channel === undefined || channel === info.channel) &&
                    this._ltIndex <= this._lt.length){
                this._ltIndexCache.push(i);
                return this._token.type;
            }
        }

        //call token retriever method
        token = this._getToken();

        //if it should be hidden, don't save a token
        if (token.type > -1 && !tokenInfo[token.type].hide){

            //apply token channel
            token.channel = tokenInfo[token.type].channel;

            //save for later
            this._token = token;
            this._lt.push(token);

            //save space that will be moved (must be done before array is truncated)
            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);

            //keep the buffer under 5 items
            if (this._lt.length > 5){
                this._lt.shift();
            }

            //also keep the shift buffer under 5 items
            if (this._ltIndexCache.length > 5){
                this._ltIndexCache.shift();
            }

            //update lookahead index
            this._ltIndex = this._lt.length;
        }

        /*
         * Skip to the next token if:
         * 1. The token type is marked as hidden.
         * 2. The token type has a channel specified and it isn't the current channel.
         */
        info = tokenInfo[token.type];
        if (info &&
                (info.hide ||
                (info.channel !== undefined && channel !== info.channel))){
            return this.get(channel);
        } else {
            //return just the type
            return token.type;
        }
    },

    /**
     * Looks ahead a certain number of tokens and returns the token type at
     * that position. This will throw an error if you lookahead past the
     * end of input, past the size of the lookahead buffer, or back past
     * the first token in the lookahead buffer.
     * @param {int} The index of the token type to retrieve. 0 for the
     *      current token, 1 for the next, -1 for the previous, etc.
     * @return {int} The token type of the token in the given position.
     * @method LA
     */
    LA: function(index){
        var total = index,
            tt;
        if (index > 0){
            //TODO: Store 5 somewhere
            if (index > 5){
                throw new Error("Too much lookahead.");
            }

            //get all those tokens
            while(total){
                tt = this.get();
                total--;
            }

            //unget all those tokens
            while(total < index){
                this.unget();
                total++;
            }
        } else if (index < 0){

            if(this._lt[this._ltIndex+index]){
                tt = this._lt[this._ltIndex+index].type;
            } else {
                throw new Error("Too much lookbehind.");
            }

        } else {
            tt = this._token.type;
        }

        return tt;

    },

    /**
     * Looks ahead a certain number of tokens and returns the token at
     * that position. This will throw an error if you lookahead past the
     * end of input, past the size of the lookahead buffer, or back past
     * the first token in the lookahead buffer.
     * @param {int} The index of the token type to retrieve. 0 for the
     *      current token, 1 for the next, -1 for the previous, etc.
     * @return {Object} The token of the token in the given position.
     * @method LA
     */
    LT: function(index){

        //lookahead first to prime the token buffer
        this.LA(index);

        //now find the token, subtract one because _ltIndex is already at the next index
        return this._lt[this._ltIndex+index-1];
    },

    /**
     * Returns the token type for the next token in the stream without
     * consuming it.
     * @return {int} The token type of the next token in the stream.
     * @method peek
     */
    peek: function(){
        return this.LA(1);
    },

    /**
     * Returns the actual token object for the last consumed token.
     * @return {Token} The token object for the last consumed token.
     * @method token
     */
    token: function(){
        return this._token;
    },

    /**
     * Returns the name of the token for the given token type.
     * @param {int} tokenType The type of token to get the name of.
     * @return {String} The name of the token or "UNKNOWN_TOKEN" for any
     *      invalid token type.
     * @method tokenName
     */
    tokenName: function(tokenType){
        if (tokenType < 0 || tokenType > this._tokenData.length){
            return "UNKNOWN_TOKEN";
        } else {
            return this._tokenData[tokenType].name;
        }
    },

    /**
     * Returns the token type value for the given token name.
     * @param {String} tokenName The name of the token whose value should be returned.
     * @return {int} The token type value for the given token name or -1
     *      for an unknown token.
     * @method tokenName
     */
    tokenType: function(tokenName){
        return this._tokenData[tokenName] || -1;
    },

    /**
     * Returns the last consumed token to the token stream.
     * @method unget
     */
    unget: function(){
        //if (this._ltIndex > -1){
        if (this._ltIndexCache.length){
            this._ltIndex -= this._ltIndexCache.pop();//--;
            this._token = this._lt[this._ltIndex - 1];
        } else {
            throw new Error("Too much lookahead.");
        }
    }

};


parserlib.util = {
__proto__   : null,
StringReader: StringReader,
SyntaxError : SyntaxError,
SyntaxUnit  : SyntaxUnit,
EventTarget : EventTarget,
TokenStreamBase : TokenStreamBase
};
})();
/*
Parser-Lib
Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/* Version v0.2.5+domino1, Build time: 30-January-2016 05:13:03 */
(function(){
var EventTarget = parserlib.util.EventTarget,
TokenStreamBase = parserlib.util.TokenStreamBase,
StringReader = parserlib.util.StringReader, // jshint ignore:line
SyntaxError = parserlib.util.SyntaxError,
SyntaxUnit  = parserlib.util.SyntaxUnit;

var Colors = {
    __proto__       :null,
    aliceblue       :"#f0f8ff",
    antiquewhite    :"#faebd7",
    aqua            :"#00ffff",
    aquamarine      :"#7fffd4",
    azure           :"#f0ffff",
    beige           :"#f5f5dc",
    bisque          :"#ffe4c4",
    black           :"#000000",
    blanchedalmond  :"#ffebcd",
    blue            :"#0000ff",
    blueviolet      :"#8a2be2",
    brown           :"#a52a2a",
    burlywood       :"#deb887",
    cadetblue       :"#5f9ea0",
    chartreuse      :"#7fff00",
    chocolate       :"#d2691e",
    coral           :"#ff7f50",
    cornflowerblue  :"#6495ed",
    cornsilk        :"#fff8dc",
    crimson         :"#dc143c",
    cyan            :"#00ffff",
    darkblue        :"#00008b",
    darkcyan        :"#008b8b",
    darkgoldenrod   :"#b8860b",
    darkgray        :"#a9a9a9",
    darkgrey        :"#a9a9a9",
    darkgreen       :"#006400",
    darkkhaki       :"#bdb76b",
    darkmagenta     :"#8b008b",
    darkolivegreen  :"#556b2f",
    darkorange      :"#ff8c00",
    darkorchid      :"#9932cc",
    darkred         :"#8b0000",
    darksalmon      :"#e9967a",
    darkseagreen    :"#8fbc8f",
    darkslateblue   :"#483d8b",
    darkslategray   :"#2f4f4f",
    darkslategrey   :"#2f4f4f",
    darkturquoise   :"#00ced1",
    darkviolet      :"#9400d3",
    deeppink        :"#ff1493",
    deepskyblue     :"#00bfff",
    dimgray         :"#696969",
    dimgrey         :"#696969",
    dodgerblue      :"#1e90ff",
    firebrick       :"#b22222",
    floralwhite     :"#fffaf0",
    forestgreen     :"#228b22",
    fuchsia         :"#ff00ff",
    gainsboro       :"#dcdcdc",
    ghostwhite      :"#f8f8ff",
    gold            :"#ffd700",
    goldenrod       :"#daa520",
    gray            :"#808080",
    grey            :"#808080",
    green           :"#008000",
    greenyellow     :"#adff2f",
    honeydew        :"#f0fff0",
    hotpink         :"#ff69b4",
    indianred       :"#cd5c5c",
    indigo          :"#4b0082",
    ivory           :"#fffff0",
    khaki           :"#f0e68c",
    lavender        :"#e6e6fa",
    lavenderblush   :"#fff0f5",
    lawngreen       :"#7cfc00",
    lemonchiffon    :"#fffacd",
    lightblue       :"#add8e6",
    lightcoral      :"#f08080",
    lightcyan       :"#e0ffff",
    lightgoldenrodyellow  :"#fafad2",
    lightgray       :"#d3d3d3",
    lightgrey       :"#d3d3d3",
    lightgreen      :"#90ee90",
    lightpink       :"#ffb6c1",
    lightsalmon     :"#ffa07a",
    lightseagreen   :"#20b2aa",
    lightskyblue    :"#87cefa",
    lightslategray  :"#778899",
    lightslategrey  :"#778899",
    lightsteelblue  :"#b0c4de",
    lightyellow     :"#ffffe0",
    lime            :"#00ff00",
    limegreen       :"#32cd32",
    linen           :"#faf0e6",
    magenta         :"#ff00ff",
    maroon          :"#800000",
    mediumaquamarine:"#66cdaa",
    mediumblue      :"#0000cd",
    mediumorchid    :"#ba55d3",
    mediumpurple    :"#9370d8",
    mediumseagreen  :"#3cb371",
    mediumslateblue :"#7b68ee",
    mediumspringgreen   :"#00fa9a",
    mediumturquoise :"#48d1cc",
    mediumvioletred :"#c71585",
    midnightblue    :"#191970",
    mintcream       :"#f5fffa",
    mistyrose       :"#ffe4e1",
    moccasin        :"#ffe4b5",
    navajowhite     :"#ffdead",
    navy            :"#000080",
    oldlace         :"#fdf5e6",
    olive           :"#808000",
    olivedrab       :"#6b8e23",
    orange          :"#ffa500",
    orangered       :"#ff4500",
    orchid          :"#da70d6",
    palegoldenrod   :"#eee8aa",
    palegreen       :"#98fb98",
    paleturquoise   :"#afeeee",
    palevioletred   :"#d87093",
    papayawhip      :"#ffefd5",
    peachpuff       :"#ffdab9",
    peru            :"#cd853f",
    pink            :"#ffc0cb",
    plum            :"#dda0dd",
    powderblue      :"#b0e0e6",
    purple          :"#800080",
    red             :"#ff0000",
    rosybrown       :"#bc8f8f",
    royalblue       :"#4169e1",
    saddlebrown     :"#8b4513",
    salmon          :"#fa8072",
    sandybrown      :"#f4a460",
    seagreen        :"#2e8b57",
    seashell        :"#fff5ee",
    sienna          :"#a0522d",
    silver          :"#c0c0c0",
    skyblue         :"#87ceeb",
    slateblue       :"#6a5acd",
    slategray       :"#708090",
    slategrey       :"#708090",
    snow            :"#fffafa",
    springgreen     :"#00ff7f",
    steelblue       :"#4682b4",
    tan             :"#d2b48c",
    teal            :"#008080",
    thistle         :"#d8bfd8",
    tomato          :"#ff6347",
    turquoise       :"#40e0d0",
    violet          :"#ee82ee",
    wheat           :"#f5deb3",
    white           :"#ffffff",
    whitesmoke      :"#f5f5f5",
    yellow          :"#ffff00",
    yellowgreen     :"#9acd32",
    //'currentColor' color keyword http://www.w3.org/TR/css3-color/#currentcolor
    currentColor        :"The value of the 'color' property.",
    //CSS2 system colors http://www.w3.org/TR/css3-color/#css2-system
    activeBorder        :"Active window border.",
    activecaption       :"Active window caption.",
    appworkspace        :"Background color of multiple document interface.",
    background          :"Desktop background.",
    buttonface          :"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonhighlight     :"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonshadow        :"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttontext          :"Text on push buttons.",
    captiontext         :"Text in caption, size box, and scrollbar arrow box.",
    graytext            :"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",
    greytext            :"Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.",
    highlight           :"Item(s) selected in a control.",
    highlighttext       :"Text of item(s) selected in a control.",
    inactiveborder      :"Inactive window border.",
    inactivecaption     :"Inactive window caption.",
    inactivecaptiontext :"Color of text in an inactive caption.",
    infobackground      :"Background color for tooltip controls.",
    infotext            :"Text color for tooltip controls.",
    menu                :"Menu background.",
    menutext            :"Text in menus.",
    scrollbar           :"Scroll bar gray area.",
    threeddarkshadow    :"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedface          :"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedhighlight     :"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedlightshadow   :"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedshadow        :"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    window              :"Window background.",
    windowframe         :"Window frame.",
    windowtext          :"Text in windows."
};
/**
 * Represents a selector combinator (whitespace, +, >).
 * @namespace parserlib.css
 * @class Combinator
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function Combinator(text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = "unknown";

    //pretty simple
    if (/^\s+$/.test(text)){
        this.type = "descendant";
    } else if (text === ">"){
        this.type = "child";
    } else if (text === "+"){
        this.type = "adjacent-sibling";
    } else if (text === "~"){
        this.type = "sibling";
    }

}

Combinator.prototype = new SyntaxUnit();
Combinator.prototype.constructor = Combinator;

/**
 * Represents a media feature, such as max-width:500.
 * @namespace parserlib.css
 * @class MediaFeature
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {SyntaxUnit} name The name of the feature.
 * @param {SyntaxUnit} value The value of the feature or null if none.
 */
function MediaFeature(name, value){

    SyntaxUnit.call(this, "(" + name + (value !== null ? ":" + value : "") + ")", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);

    /**
     * The name of the media feature
     * @type String
     * @property name
     */
    this.name = name;

    /**
     * The value for the feature or null if there is none.
     * @type SyntaxUnit
     * @property value
     */
    this.value = value;
}

MediaFeature.prototype = new SyntaxUnit();
MediaFeature.prototype.constructor = MediaFeature;

/**
 * Represents an individual media query.
 * @namespace parserlib.css
 * @class MediaQuery
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} modifier The modifier "not" or "only" (or null).
 * @param {String} mediaType The type of media (i.e., "print").
 * @param {Array} parts Array of selectors parts making up this selector.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function MediaQuery(modifier, mediaType, features, line, col){

    SyntaxUnit.call(this, (modifier ? modifier + " ": "") + (mediaType ? mediaType : "") + (mediaType && features.length > 0 ? " and " : "") + features.join(" and "), line, col, Parser.MEDIA_QUERY_TYPE);

    /**
     * The media modifier ("not" or "only")
     * @type String
     * @property modifier
     */
    this.modifier = modifier;

    /**
     * The mediaType (i.e., "print")
     * @type String
     * @property mediaType
     */
    this.mediaType = mediaType;

    /**
     * The parts that make up the selector.
     * @type Array
     * @property features
     */
    this.features = features;

}

MediaQuery.prototype = new SyntaxUnit();
MediaQuery.prototype.constructor = MediaQuery;


/**
 * A CSS3 parser.
 * @namespace parserlib.css
 * @class Parser
 * @constructor
 * @param {Object} options (Optional) Various options for the parser:
 *      starHack (true|false) to allow IE6 star hack as valid,
 *      underscoreHack (true|false) to interpret leading underscores
 *      as IE6-7 targeting for known properties, ieFilters (true|false)
 *      to indicate that IE < 8 filters should be accepted and not throw
 *      syntax errors.
 */
function Parser(options){

    //inherit event functionality
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}

//Static constants
Parser.DEFAULT_TYPE = 0;
Parser.COMBINATOR_TYPE = 1;
Parser.MEDIA_FEATURE_TYPE = 2;
Parser.MEDIA_QUERY_TYPE = 3;
Parser.PROPERTY_NAME_TYPE = 4;
Parser.PROPERTY_VALUE_TYPE = 5;
Parser.PROPERTY_VALUE_PART_TYPE = 6;
Parser.SELECTOR_TYPE = 7;
Parser.SELECTOR_PART_TYPE = 8;
Parser.SELECTOR_SUB_PART_TYPE = 9;

Parser.prototype = function(){

    var proto = new EventTarget(),  //new prototype
        prop,
        additions =  {
            __proto__: null,

            //restore constructor
            constructor: Parser,

            //instance constants - yuck
            DEFAULT_TYPE : 0,
            COMBINATOR_TYPE : 1,
            MEDIA_FEATURE_TYPE : 2,
            MEDIA_QUERY_TYPE : 3,
            PROPERTY_NAME_TYPE : 4,
            PROPERTY_VALUE_TYPE : 5,
            PROPERTY_VALUE_PART_TYPE : 6,
            SELECTOR_TYPE : 7,
            SELECTOR_PART_TYPE : 8,
            SELECTOR_SUB_PART_TYPE : 9,

            //-----------------------------------------------------------------
            // Grammar
            //-----------------------------------------------------------------

            _stylesheet: function(){

                /*
                 * stylesheet
                 *  : [ CHARSET_SYM S* STRING S* ';' ]?
                 *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*
                 *    [ namespace [S|CDO|CDC]* ]*
                 *    [ [ ruleset | media | page | font_face | keyframes ] [S|CDO|CDC]* ]*
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    count,
                    token,
                    tt;

                this.fire("startstylesheet");

                //try to read character set
                this._charset();

                this._skipCruft();

                //try to read imports - may be more than one
                while (tokenStream.peek() === Tokens.IMPORT_SYM){
                    this._import();
                    this._skipCruft();
                }

                //try to read namespaces - may be more than one
                while (tokenStream.peek() === Tokens.NAMESPACE_SYM){
                    this._namespace();
                    this._skipCruft();
                }

                //get the next token
                tt = tokenStream.peek();

                //try to read the rest
                while(tt > Tokens.EOF){

                    try {

                        switch(tt){
                            case Tokens.MEDIA_SYM:
                                this._media();
                                this._skipCruft();
                                break;
                            case Tokens.PAGE_SYM:
                                this._page();
                                this._skipCruft();
                                break;
                            case Tokens.FONT_FACE_SYM:
                                this._font_face();
                                this._skipCruft();
                                break;
                            case Tokens.KEYFRAMES_SYM:
                                this._keyframes();
                                this._skipCruft();
                                break;
                            case Tokens.VIEWPORT_SYM:
                                this._viewport();
                                this._skipCruft();
                                break;
                            case Tokens.DOCUMENT_SYM:
                                this._document();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule
                                tokenStream.get();
                                if (!this.options.strict){

                                    //fire error event
                                    this.fire({
                                        type:       "error",
                                        error:      null,
                                        message:    "Unknown @ rule: " + tokenStream.LT(0).value + ".",
                                        line:       tokenStream.LT(0).startLine,
                                        col:        tokenStream.LT(0).startCol
                                    });

                                    //skip braces
                                    count=0;
                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE){
                                        count++;    //keep track of nesting depth
                                    }

                                    while(count){
                                        tokenStream.advance([Tokens.RBRACE]);
                                        count--;
                                    }

                                } else {
                                    //not a syntax error, rethrow it
                                    throw new SyntaxError("Unknown @ rule.", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                                }
                                break;
                            case Tokens.S:
                                this._readWhitespace();
                                break;
                            default:
                                if(!this._ruleset()){

                                    //error handling for known issues
                                    switch(tt){
                                        case Tokens.CHARSET_SYM:
                                            token = tokenStream.LT(1);
                                            this._charset(false);
                                            throw new SyntaxError("@charset not allowed here.", token.startLine, token.startCol);
                                        case Tokens.IMPORT_SYM:
                                            token = tokenStream.LT(1);
                                            this._import(false);
                                            throw new SyntaxError("@import not allowed here.", token.startLine, token.startCol);
                                        case Tokens.NAMESPACE_SYM:
                                            token = tokenStream.LT(1);
                                            this._namespace(false);
                                            throw new SyntaxError("@namespace not allowed here.", token.startLine, token.startCol);
                                        default:
                                            tokenStream.get();  //get the last token
                                            this._unexpectedToken(tokenStream.token());
                                    }

                                }
                        }
                    } catch(ex) {
                        if (ex instanceof SyntaxError && !this.options.strict){
                            this.fire({
                                type:       "error",
                                error:      ex,
                                message:    ex.message,
                                line:       ex.line,
                                col:        ex.col
                            });
                        } else {
                            throw ex;
                        }
                    }

                    tt = tokenStream.peek();
                }

                if (tt !== Tokens.EOF){
                    this._unexpectedToken(tokenStream.token());
                }

                this.fire("endstylesheet");
            },

            _charset: function(emit){
                var tokenStream = this._tokenStream,
                    charset,
                    token,
                    line,
                    col;

                if (tokenStream.match(Tokens.CHARSET_SYM)){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.STRING);

                    token = tokenStream.token();
                    charset = token.value;

                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.SEMICOLON);

                    if (emit !== false){
                        this.fire({
                            type:   "charset",
                            charset:charset,
                            line:   line,
                            col:    col
                        });
                    }
                }
            },

            _import: function(emit){
                /*
                 * import
                 *   : IMPORT_SYM S*
                 *    [STRING|URI] S* media_query_list? ';' S*
                 */

                var tokenStream = this._tokenStream,
                    uri,
                    importToken,
                    mediaList   = [];

                //read import symbol
                tokenStream.mustMatch(Tokens.IMPORT_SYM);
                importToken = tokenStream.token();
                this._readWhitespace();

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);

                //grab the URI value
                uri = tokenStream.token().value.replace(/^(?:url\()?["']?([^"']+?)["']?\)?$/, "$1");

                this._readWhitespace();

                mediaList = this._media_query_list();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false){
                    this.fire({
                        type:   "import",
                        uri:    uri,
                        media:  mediaList,
                        line:   importToken.startLine,
                        col:    importToken.startCol
                    });
                }

            },

            _namespace: function(emit){
                /*
                 * namespace
                 *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* ';' S*
                 */

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    prefix,
                    uri;

                //read import symbol
                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();

                //it's a namespace prefix - no _namespace_prefix() method because it's just an IDENT
                if (tokenStream.match(Tokens.IDENT)){
                    prefix = tokenStream.token().value;
                    this._readWhitespace();
                }

                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                /*if (!tokenStream.match(Tokens.STRING)){
                    tokenStream.mustMatch(Tokens.URI);
                }*/

                //grab the URI value
                uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");

                this._readWhitespace();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();

                if (emit !== false){
                    this.fire({
                        type:   "namespace",
                        prefix: prefix,
                        uri:    uri,
                        line:   line,
                        col:    col
                    });
                }

            },

            _media: function(){
                /*
                 * media
                 *   : MEDIA_SYM S* media_query_list S* '{' S* ruleset* '}' S*
                 *   ;
                 */
                var tokenStream     = this._tokenStream,
                    line,
                    col,
                    mediaList;//       = [];

                //look for @media
                tokenStream.mustMatch(Tokens.MEDIA_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                mediaList = this._media_query_list();

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "startmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });

                while(true) {
                    if (tokenStream.peek() === Tokens.PAGE_SYM){
                        this._page();
                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM){
                        this._font_face();
                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM){
                        this._viewport();
                    } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM){
                        this._document();
                    } else if (!this._ruleset()){
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type:   "endmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });
            },


            //CSS3 Media Queries
            _media_query_list: function(){
                /*
                 * media_query_list
                 *   : S* [media_query [ ',' S* media_query ]* ]?
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    mediaList   = [];


                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN){
                    mediaList.push(this._media_query());
                }

                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    mediaList.push(this._media_query());
                }

                return mediaList;
            },

            /*
             * Note: "expression" in the grammar maps to the _media_expression
             * method.

             */
            _media_query: function(){
                /*
                 * media_query
                 *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*
                 *   | expression [ AND S* expression ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    type        = null,
                    ident       = null,
                    token       = null,
                    expressions = [];

                if (tokenStream.match(Tokens.IDENT)){
                    ident = tokenStream.token().value.toLowerCase();

                    //since there's no custom tokens for these, need to manually check
                    if (ident !== "only" && ident !== "not"){
                        tokenStream.unget();
                        ident = null;
                    } else {
                        token = tokenStream.token();
                    }
                }

                this._readWhitespace();

                if (tokenStream.peek() === Tokens.IDENT){
                    type = this._media_type();
                    if (token === null){
                        token = tokenStream.token();
                    }
                } else if (tokenStream.peek() === Tokens.LPAREN){
                    if (token === null){
                        token = tokenStream.LT(1);
                    }
                    expressions.push(this._media_expression());
                }

                if (type === null && expressions.length === 0){
                    return null;
                } else {
                    this._readWhitespace();
                    while (tokenStream.match(Tokens.IDENT)){
                        if (tokenStream.token().value.toLowerCase() !== "and"){
                            this._unexpectedToken(tokenStream.token());
                        }

                        this._readWhitespace();
                        expressions.push(this._media_expression());
                    }
                }

                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
            },

            //CSS3 Media Queries
            _media_type: function(){
                /*
                 * media_type
                 *   : IDENT
                 *   ;
                 */
                return this._media_feature();
            },

            /**
             * Note: in CSS3 Media Queries, this is called "expression".
             * Renamed here to avoid conflict with CSS3 Selectors
             * definition of "expression". Also note that "expr" in the
             * grammar now maps to "expression" from CSS3 selectors.
             * @method _media_expression
             * @private
             */
            _media_expression: function(){
                /*
                 * expression
                 *  : '(' S* media_feature S* [ ':' S* expr ]? ')' S*
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                    feature     = null,
                    token,
                    expression  = null;

                tokenStream.mustMatch(Tokens.LPAREN);

                feature = this._media_feature();
                this._readWhitespace();

                if (tokenStream.match(Tokens.COLON)){
                    this._readWhitespace();
                    token = tokenStream.LT(1);
                    expression = this._expression();
                }

                tokenStream.mustMatch(Tokens.RPAREN);
                this._readWhitespace();

                return new MediaFeature(feature, (expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null));
            },

            //CSS3 Media Queries
            _media_feature: function(){
                /*
                 * media_feature
                 *   : IDENT
                 *   ;
                 */
                var tokenStream = this._tokenStream;

                this._readWhitespace();

                tokenStream.mustMatch(Tokens.IDENT);

                return SyntaxUnit.fromToken(tokenStream.token());
            },

            //CSS3 Paged Media
            _page: function(){
                /*
                 * page:
                 *    PAGE_SYM S* IDENT? pseudo_page? S*
                 *    '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    identifier  = null,
                    pseudoPage  = null;

                //look for @page
                tokenStream.mustMatch(Tokens.PAGE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                if (tokenStream.match(Tokens.IDENT)){
                    identifier = tokenStream.token().value;

                    //The value 'auto' may not be used as a page name and MUST be treated as a syntax error.
                    if (identifier.toLowerCase() === "auto"){
                        this._unexpectedToken(tokenStream.token());
                    }
                }

                //see if there's a colon upcoming
                if (tokenStream.peek() === Tokens.COLON){
                    pseudoPage = this._pseudo_page();
                }

                this._readWhitespace();

                this.fire({
                    type:   "startpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true, true);

                this.fire({
                    type:   "endpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });

            },

            //CSS3 Paged Media
            _margin: function(){
                /*
                 * margin :
                 *    margin_sym S* '{' declaration [ ';' S* declaration? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    marginSym   = this._margin_sym();

                if (marginSym){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this.fire({
                        type: "startpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type: "endpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });
                    return true;
                } else {
                    return false;
                }
            },

            //CSS3 Paged Media
            _margin_sym: function(){

                /*
                 * margin_sym :
                 *    TOPLEFTCORNER_SYM |
                 *    TOPLEFT_SYM |
                 *    TOPCENTER_SYM |
                 *    TOPRIGHT_SYM |
                 *    TOPRIGHTCORNER_SYM |
                 *    BOTTOMLEFTCORNER_SYM |
                 *    BOTTOMLEFT_SYM |
                 *    BOTTOMCENTER_SYM |
                 *    BOTTOMRIGHT_SYM |
                 *    BOTTOMRIGHTCORNER_SYM |
                 *    LEFTTOP_SYM |
                 *    LEFTMIDDLE_SYM |
                 *    LEFTBOTTOM_SYM |
                 *    RIGHTTOP_SYM |
                 *    RIGHTMIDDLE_SYM |
                 *    RIGHTBOTTOM_SYM
                 *    ;
                 */

                var tokenStream = this._tokenStream;

                if(tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,
                        Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,
                        Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,
                        Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,
                        Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,
                        Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,
                        Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM]))
                {
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else {
                    return null;
                }

            },

            _pseudo_page: function(){
                /*
                 * pseudo_page
                 *   : ':' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream;

                tokenStream.mustMatch(Tokens.COLON);
                tokenStream.mustMatch(Tokens.IDENT);

                //TODO: CSS3 Paged Media says only "left", "center", and "right" are allowed

                return tokenStream.token().value;
            },

            _font_face: function(){
                /*
                 * font_face
                 *   : FONT_FACE_SYM S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col;

                //look for @page
                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;

                this._readWhitespace();

                this.fire({
                    type:   "startfontface",
                    line:   line,
                    col:    col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endfontface",
                    line:   line,
                    col:    col
                });
            },

            _viewport: function(){
                /*
                 * viewport
                 *   : VIEWPORT_SYM S*
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */
                 var tokenStream = this._tokenStream,
                    line,
                    col;

                    tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;

                    this._readWhitespace();

                    this.fire({
                        type:   "startviewport",
                        line:   line,
                        col:    col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:   "endviewport",
                        line:   line,
                        col:    col
                    });

            },

            _document: function(){
                /*
                 * document
                 *   : DOCUMENT_SYM S*
                 *     _document_function [ ',' S* _document_function ]* S*
                 *     '{' S* ruleset* '}'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token,
                    functions = [],
                    prefix = "";

                tokenStream.mustMatch(Tokens.DOCUMENT_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                functions.push(this._document_function());

                while(tokenStream.match(Tokens.COMMA)) {
                    this._readWhitespace();
                    functions.push(this._document_function());
                }

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();

                this.fire({
                    type:      "startdocument",
                    functions: functions,
                    prefix:    prefix,
                    line:      token.startLine,
                    col:       token.startCol
                });

                while(true) {
                    if (tokenStream.peek() === Tokens.PAGE_SYM){
                        this._page();
                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM){
                        this._font_face();
                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM){
                        this._viewport();
                    } else if (tokenStream.peek() === Tokens.MEDIA_SYM){
                        this._media();
                    } else if (!this._ruleset()){
                        break;
                    }
                }

                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();

                this.fire({
                    type:      "enddocument",
                    functions: functions,
                    prefix:    prefix,
                    line:      token.startLine,
                    col:       token.startCol
                });
            },

            _document_function: function(){
                /*
                 * document_function
                 *   : function | URI S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value;

                if (tokenStream.match(Tokens.URI)) {
                    value = tokenStream.token().value;
                    this._readWhitespace();
                } else {
                    value = this._function();
                }

                return value;
            },

            _operator: function(inFunction){

                /*
                 * operator (outside function)
                 *  : '/' S* | ',' S* | /( empty )/
                 * operator (inside function)
                 *  : '/' S* | '+' S* | '*' S* | '-' S* /( empty )/
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    token       = null;

                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||
                    (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))){
                    token =  tokenStream.token();
                    this._readWhitespace();
                }
                return token ? PropertyValuePart.fromToken(token) : null;

            },

            _combinator: function(){

                /*
                 * combinator
                 *  : PLUS S* | GREATER S* | TILDE S* | S+
                 *  ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    token;

                if(tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])){
                    token = tokenStream.token();
                    value = new Combinator(token.value, token.startLine, token.startCol);
                    this._readWhitespace();
                }

                return value;
            },

            _unary_operator: function(){

                /*
                 * unary_operator
                 *  : '-' | '+'
                 *  ;
                 */

                var tokenStream = this._tokenStream;

                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])){
                    return tokenStream.token().value;
                } else {
                    return null;
                }
            },

            _property: function(){

                /*
                 * property
                 *   : IDENT S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    hack        = null,
                    tokenValue,
                    token,
                    line,
                    col;

                //check for star hack - throws error if not allowed
                if (tokenStream.peek() === Tokens.STAR && this.options.starHack){
                    tokenStream.get();
                    token = tokenStream.token();
                    hack = token.value;
                    line = token.startLine;
                    col = token.startCol;
                }

                if(tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    tokenValue = token.value;

                    //check for underscore hack - no error if not allowed because it's valid CSS syntax
                    if (tokenValue.charAt(0) === "_" && this.options.underscoreHack){
                        hack = "_";
                        tokenValue = tokenValue.substring(1);
                    }

                    value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));
                    this._readWhitespace();
                }

                return value;
            },

            //Augmented with CSS3 Selectors
            _ruleset: function(){
                /*
                 * ruleset
                 *   : selectors_group
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    tt,
                    selectors;


                /*
                 * Error Recovery: If even a single selector fails to parse,
                 * then the entire ruleset should be thrown away.
                 */
                try {
                    selectors = this._selectors_group();
                } catch (ex){
                    if (ex instanceof SyntaxError && !this.options.strict){

                        //fire error event
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });

                        //skip over everything until closing brace
                        tt = tokenStream.advance([Tokens.RBRACE]);
                        if (tt === Tokens.RBRACE){
                            //if there's a right brace, the rule is finished so don't do anything
                        } else {
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }

                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }

                    //trigger parser to continue
                    return true;
                }

                //if it got here, all selectors parsed
                if (selectors){

                    this.fire({
                        type:       "startrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                    this._readDeclarations(true);

                    this.fire({
                        type:       "endrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });

                }

                return selectors;

            },

            //CSS3 Selectors
            _selectors_group: function(){

                /*
                 * selectors_group
                 *   : selector [ COMMA S* selector ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    selectors   = [],
                    selector;

                selector = this._selector();
                if (selector !== null){

                    selectors.push(selector);
                    while(tokenStream.match(Tokens.COMMA)){
                        this._readWhitespace();
                        selector = this._selector();
                        if (selector !== null){
                            selectors.push(selector);
                        } else {
                            this._unexpectedToken(tokenStream.LT(1));
                        }
                    }
                }

                return selectors.length ? selectors : null;
            },

            //CSS3 Selectors
            _selector: function(){
                /*
                 * selector
                 *   : simple_selector_sequence [ combinator simple_selector_sequence ]*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    selector    = [],
                    nextSelector = null,
                    combinator  = null,
                    ws          = null;

                //if there's no simple selector, then there's no selector
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null){
                    return null;
                }

                selector.push(nextSelector);

                do {

                    //look for a combinator
                    combinator = this._combinator();

                    if (combinator !== null){
                        selector.push(combinator);
                        nextSelector = this._simple_selector_sequence();

                        //there must be a next selector
                        if (nextSelector === null){
                            this._unexpectedToken(tokenStream.LT(1));
                        } else {

                            //nextSelector is an instance of SelectorPart
                            selector.push(nextSelector);
                        }
                    } else {

                        //if there's not whitespace, we're done
                        if (this._readWhitespace()){

                            //add whitespace separator
                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);

                            //combinator is not required
                            combinator = this._combinator();

                            //selector is required if there's a combinator
                            nextSelector = this._simple_selector_sequence();
                            if (nextSelector === null){
                                if (combinator !== null){
                                    this._unexpectedToken(tokenStream.LT(1));
                                }
                            } else {

                                if (combinator !== null){
                                    selector.push(combinator);
                                } else {
                                    selector.push(ws);
                                }

                                selector.push(nextSelector);
                            }
                        } else {
                            break;
                        }

                    }
                } while(true);

                return new Selector(selector, selector[0].line, selector[0].col);
            },

            //CSS3 Selectors
            _simple_selector_sequence: function(){
                /*
                 * simple_selector_sequence
                 *   : [ type_selector | universal ]
                 *     [ HASH | class | attrib | pseudo | negation ]*
                 *   | [ HASH | class | attrib | pseudo | negation ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,

                    //parts of a simple selector
                    elementName = null,
                    modifiers   = [],

                    //complete selector text
                    selectorText= "",

                    //the different parts after the element name to search for
                    components  = [
                        //HASH
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo,
                        this._negation
                    ],
                    i           = 0,
                    len         = components.length,
                    component   = null,
                    line,
                    col;


                //get starting line and column for the selector
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                elementName = this._type_selector();
                if (!elementName){
                    elementName = this._universal();
                }

                if (elementName !== null){
                    selectorText += elementName;
                }

                while(true){

                    //whitespace means we're done
                    if (tokenStream.peek() === Tokens.S){
                        break;
                    }

                    //check for each component
                    while(i < len && component === null){
                        component = components[i++].call(this);
                    }

                    if (component === null){

                        //we don't have a selector
                        if (selectorText === ""){
                            return null;
                        } else {
                            break;
                        }
                    } else {
                        i = 0;
                        modifiers.push(component);
                        selectorText += component.toString();
                        component = null;
                    }
                }


                return selectorText !== "" ?
                        new SelectorPart(elementName, modifiers, selectorText, line, col) :
                        null;
            },

            //CSS3 Selectors
            _type_selector: function(){
                /*
                 * type_selector
                 *   : [ namespace_prefix ]? element_name
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    ns          = this._namespace_prefix(),
                    elementName = this._element_name();

                if (!elementName){
                    /*
                     * Need to back out the namespace that was read due to both
                     * type_selector and universal reading namespace_prefix
                     * first. Kind of hacky, but only way I can figure out
                     * right now how to not change the grammar.
                     */
                    if (ns){
                        tokenStream.unget();
                        if (ns.length > 1){
                            tokenStream.unget();
                        }
                    }

                    return null;
                } else {
                    if (ns){
                        elementName.text = ns + elementName.text;
                        elementName.col -= ns.length;
                    }
                    return elementName;
                }
            },

            //CSS3 Selectors
            _class: function(){
                /*
                 * class
                 *   : '.' IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.DOT)){
                    tokenStream.mustMatch(Tokens.IDENT);
                    token = tokenStream.token();
                    return new SelectorSubPart("." + token.value, "class", token.startLine, token.startCol - 1);
                } else {
                    return null;
                }

            },

            //CSS3 Selectors
            _element_name: function(){
                /*
                 * element_name
                 *   : IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    return new SelectorSubPart(token.value, "elementName", token.startLine, token.startCol);

                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _namespace_prefix: function(){
                /*
                 * namespace_prefix
                 *   : [ IDENT | '*' ]? '|'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    value       = "";

                //verify that this is a namespace prefix
                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE){

                    if(tokenStream.match([Tokens.IDENT, Tokens.STAR])){
                        value += tokenStream.token().value;
                    }

                    tokenStream.mustMatch(Tokens.PIPE);
                    value += "|";

                }

                return value.length ? value : null;
            },

            //CSS3 Selectors
            _universal: function(){
                /*
                 * universal
                 *   : [ namespace_prefix ]? '*'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    value       = "",
                    ns;

                ns = this._namespace_prefix();
                if(ns){
                    value += ns;
                }

                if(tokenStream.match(Tokens.STAR)){
                    value += "*";
                }

                return value.length ? value : null;

           },

            //CSS3 Selectors
            _attrib: function(){
                /*
                 * attrib
                 *   : '[' S* [ namespace_prefix ]? IDENT S*
                 *         [ [ PREFIXMATCH |
                 *             SUFFIXMATCH |
                 *             SUBSTRINGMATCH |
                 *             '=' |
                 *             INCLUDES |
                 *             DASHMATCH ] S* [ IDENT | STRING ] S*
                 *         ]? ']'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = null,
                    ns,
                    token;

                if (tokenStream.match(Tokens.LBRACKET)){
                    token = tokenStream.token();
                    value = token.value;
                    value += this._readWhitespace();

                    ns = this._namespace_prefix();

                    if (ns){
                        value += ns;
                    }

                    tokenStream.mustMatch(Tokens.IDENT);
                    value += tokenStream.token().value;
                    value += this._readWhitespace();

                    if(tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,
                            Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])){

                        value += tokenStream.token().value;
                        value += this._readWhitespace();

                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                        value += tokenStream.token().value;
                        value += this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACKET);

                    return new SelectorSubPart(value + "]", "attribute", token.startLine, token.startCol);
                } else {
                    return null;
                }
            },

            //CSS3 Selectors
            _pseudo: function(){

                /*
                 * pseudo
                 *   : ':' ':'? [ IDENT | functional_pseudo ]
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    pseudo      = null,
                    colons      = ":",
                    line,
                    col;

                if (tokenStream.match(Tokens.COLON)){

                    if (tokenStream.match(Tokens.COLON)){
                        colons += ":";
                    }

                    if (tokenStream.match(Tokens.IDENT)){
                        pseudo = tokenStream.token().value;
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol - colons.length;
                    } else if (tokenStream.peek() === Tokens.FUNCTION){
                        line = tokenStream.LT(1).startLine;
                        col = tokenStream.LT(1).startCol - colons.length;
                        pseudo = this._functional_pseudo();
                    }

                    if (pseudo){
                        pseudo = new SelectorSubPart(colons + pseudo, "pseudo", line, col);
                    }
                }

                return pseudo;
            },

            //CSS3 Selectors
            _functional_pseudo: function(){
                /*
                 * functional_pseudo
                 *   : FUNCTION S* expression ')'
                 *   ;
                */

                var tokenStream = this._tokenStream,
                    value = null;

                if(tokenStream.match(Tokens.FUNCTION)){
                    value = tokenStream.token().value;
                    value += this._readWhitespace();
                    value += this._expression();
                    tokenStream.mustMatch(Tokens.RPAREN);
                    value += ")";
                }

                return value;
            },

            //CSS3 Selectors
            _expression: function(){
                /*
                 * expression
                 *   : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    value       = "";

                while(tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,
                        Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,
                        Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,
                        Tokens.RESOLUTION, Tokens.SLASH])){

                    value += tokenStream.token().value;
                    value += this._readWhitespace();
                }

                return value.length ? value : null;

            },

            //CSS3 Selectors
            _negation: function(){
                /*
                 * negation
                 *   : NOT S* negation_arg S* ')'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    value       = "",
                    arg,
                    subpart     = null;

                if (tokenStream.match(Tokens.NOT)){
                    value = tokenStream.token().value;
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                    value += this._readWhitespace();
                    arg = this._negation_arg();
                    value += arg;
                    value += this._readWhitespace();
                    tokenStream.match(Tokens.RPAREN);
                    value += tokenStream.token().value;

                    subpart = new SelectorSubPart(value, "not", line, col);
                    subpart.args.push(arg);
                }

                return subpart;
            },

            //CSS3 Selectors
            _negation_arg: function(){
                /*
                 * negation_arg
                 *   : type_selector | universal | HASH | class | attrib | pseudo
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    args        = [
                        this._type_selector,
                        this._universal,
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo
                    ],
                    arg         = null,
                    i           = 0,
                    len         = args.length,
                    line,
                    col,
                    part;

                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;

                while(i < len && arg === null){

                    arg = args[i].call(this);
                    i++;
                }

                //must be a negation arg
                if (arg === null){
                    this._unexpectedToken(tokenStream.LT(1));
                }

                //it's an element name
                if (arg.type === "elementName"){
                    part = new SelectorPart(arg, [], arg.toString(), line, col);
                } else {
                    part = new SelectorPart(null, [arg], arg.toString(), line, col);
                }

                return part;
            },

            _declaration: function(){

                /*
                 * declaration
                 *   : property ':' S* expr prio?
                 *   | /( empty )/
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    property    = null,
                    expr        = null,
                    prio        = null,
                    invalid     = null,
                    propertyName= "";

                property = this._property();
                if (property !== null){

                    tokenStream.mustMatch(Tokens.COLON);
                    this._readWhitespace();

                    expr = this._expr();

                    //if there's no parts for the value, it's an error
                    if (!expr || expr.length === 0){
                        this._unexpectedToken(tokenStream.LT(1));
                    }

                    prio = this._prio();

                    /*
                     * If hacks should be allowed, then only check the root
                     * property. If hacks should not be allowed, treat
                     * _property or *property as invalid properties.
                     */
                    propertyName = property.toString();
                    if (this.options.starHack && property.hack === "*" ||
                            this.options.underscoreHack && property.hack === "_") {

                        propertyName = property.text;
                    }

                    try {
                        this._validateProperty(propertyName, expr);
                    } catch (ex) {
                        invalid = ex;
                    }

                    this.fire({
                        type:       "property",
                        property:   property,
                        value:      expr,
                        important:  prio,
                        line:       property.line,
                        col:        property.col,
                        invalid:    invalid
                    });

                    return true;
                } else {
                    return false;
                }
            },

            _prio: function(){
                /*
                 * prio
                 *   : IMPORTANT_SYM S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);

                this._readWhitespace();
                return result;
            },

            _expr: function(inFunction){
                /*
                 * expr
                 *   : term [ operator term ]*
                 *   ;
                 */

                var values      = [],
					//valueParts	= [],
                    value       = null,
                    operator    = null;

                value = this._term(inFunction);
                if (value !== null){

                    values.push(value);

                    do {
                        operator = this._operator(inFunction);

                        //if there's an operator, keep building up the value parts
                        if (operator){
                            values.push(operator);
                        } /*else {
                            //if there's not an operator, you have a full value
							values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
							valueParts = [];
						}*/

                        value = this._term(inFunction);

                        if (value === null){
                            break;
                        } else {
                            values.push(value);
                        }
                    } while(true);
                }

				//cleanup
                /*if (valueParts.length){
                    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                }*/

                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
            },

            _term: function(inFunction){

                /*
                 * term
                 *   : unary_operator?
                 *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |
                 *       TIME S* | FREQ S* | function | ie_function ]
                 *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    unary       = null,
                    value       = null,
                    endChar     = null,
                    token,
                    line,
                    col;

                //returns the operator or null
                unary = this._unary_operator();
                if (unary !== null){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                }

                //exception for IE filters
                if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters){

                    value = this._ie_function();
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }

                //see if it's a simple block
                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])){

                    token = tokenStream.token();
                    endChar = token.endChar;
                    value = token.value + this._expr(inFunction).text;
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    tokenStream.mustMatch(Tokens.type(endChar));
                    value += endChar;
                    this._readWhitespace();

                //see if there's a simple match
                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
                        Tokens.ANGLE, Tokens.TIME,
                        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])){

                    value = tokenStream.token().value;
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    this._readWhitespace();
                } else {

                    //see if it's a color
                    token = this._hexcolor();
                    if (token === null){

                        //if there's no unary, get the start of the next token for line/col info
                        if (unary === null){
                            line = tokenStream.LT(1).startLine;
                            col = tokenStream.LT(1).startCol;
                        }

                        //has to be a function
                        if (value === null){

                            /*
                             * This checks for alpha(opacity=0) style of IE
                             * functions. IE_FUNCTION only presents progid: style.
                             */
                            if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters){
                                value = this._ie_function();
                            } else {
                                value = this._function();
                            }
                        }

                        /*if (value === null){
                            return null;
                            //throw new Error("Expected identifier at line " + tokenStream.token().startLine + ", character " +  tokenStream.token().startCol + ".");
                        }*/

                    } else {
                        value = token.value;
                        if (unary === null){
                            line = token.startLine;
                            col = token.startCol;
                        }
                    }

                }

                return value !== null ?
                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :
                        null;

            },

            _function: function(){

                /*
                 * function
                 *   : FUNCTION S* expr ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr        = null,
                    lt;

                if (tokenStream.match(Tokens.FUNCTION)){
                    functionText = tokenStream.token().value;
                    this._readWhitespace();
                    expr = this._expr(true);
                    functionText += expr;

                    //START: Horrible hack in case it's an IE filter
                    if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS){
                        do {

                            if (this._readWhitespace()){
                                functionText += tokenStream.token().value;
                            }

                            //might be second time in the loop
                            if (tokenStream.LA(0) === Tokens.COMMA){
                                functionText += tokenStream.token().value;
                            }

                            tokenStream.match(Tokens.IDENT);
                            functionText += tokenStream.token().value;

                            tokenStream.match(Tokens.EQUALS);
                            functionText += tokenStream.token().value;

                            //functionText += this._term();
                            lt = tokenStream.peek();
                            while(lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN){
                                tokenStream.get();
                                functionText += tokenStream.token().value;
                                lt = tokenStream.peek();
                            }
                        } while(tokenStream.match([Tokens.COMMA, Tokens.S]));
                    }

                    //END: Horrible Hack

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _ie_function: function(){

                /* (My own extension)
                 * ie_function
                 *   : IE_FUNCTION S* IDENT '=' term [S* ','? IDENT '=' term]+ ')' S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    functionText = null,
                    lt;

                //IE function can begin like a regular function, too
                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])){
                    functionText = tokenStream.token().value;

                    do {

                        if (this._readWhitespace()){
                            functionText += tokenStream.token().value;
                        }

                        //might be second time in the loop
                        if (tokenStream.LA(0) === Tokens.COMMA){
                            functionText += tokenStream.token().value;
                        }

                        tokenStream.match(Tokens.IDENT);
                        functionText += tokenStream.token().value;

                        tokenStream.match(Tokens.EQUALS);
                        functionText += tokenStream.token().value;

                        //functionText += this._term();
                        lt = tokenStream.peek();
                        while(lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN){
                            tokenStream.get();
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                        }
                    } while(tokenStream.match([Tokens.COMMA, Tokens.S]));

                    tokenStream.match(Tokens.RPAREN);
                    functionText += ")";
                    this._readWhitespace();
                }

                return functionText;
            },

            _hexcolor: function(){
                /*
                 * There is a constraint on the color that it must
                 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
                 * after the "#"; e.g., "#000" is OK, but "#abcd" is not.
                 *
                 * hexcolor
                 *   : HASH S*
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token = null,
                    color;

                if(tokenStream.match(Tokens.HASH)){

                    //need to do some validation here

                    token = tokenStream.token();
                    color = token.value;
                    if (!/#[a-f0-9]{3,6}/i.test(color)){
                        throw new SyntaxError("Expected a hex color but found '" + color + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
                    }
                    this._readWhitespace();
                }

                return token;
            },

            //-----------------------------------------------------------------
            // Animations methods
            //-----------------------------------------------------------------

            _keyframes: function(){

                /*
                 * keyframes:
                 *   : KEYFRAMES_SYM S* keyframe_name S* '{' S* keyframe_rule* '}' {
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    token,
                    tt,
                    name,
                    prefix = "";

                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }

                this._readWhitespace();
                name = this._keyframe_name();

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.LBRACE);

                this.fire({
                    type:   "startkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tt = tokenStream.peek();

                //check for key
                while(tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {
                    this._keyframe_rule();
                    this._readWhitespace();
                    tt = tokenStream.peek();
                }

                this.fire({
                    type:   "endkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });

                this._readWhitespace();
                tokenStream.mustMatch(Tokens.RBRACE);

            },

            _keyframe_name: function(){

                /*
                 * keyframe_name:
                 *   : IDENT
                 *   | STRING
                 *   ;
                 */
                var tokenStream = this._tokenStream;

                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                return SyntaxUnit.fromToken(tokenStream.token());
            },

            _keyframe_rule: function(){

                /*
                 * keyframe_rule:
                 *   : key_list S*
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var keyList = this._key_list();

                this.fire({
                    type:   "startkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

                this._readDeclarations(true);

                this.fire({
                    type:   "endkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });

            },

            _key_list: function(){

                /*
                 * key_list:
                 *   : key [ S* ',' S* key]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    keyList = [];

                //must be least one key
                keyList.push(this._key());

                this._readWhitespace();

                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    keyList.push(this._key());
                    this._readWhitespace();
                }

                return keyList;
            },

            _key: function(){
                /*
                 * There is a restriction that IDENT can be only "from" or "to".
                 *
                 * key
                 *   : PERCENTAGE
                 *   | IDENT
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    token;

                if (tokenStream.match(Tokens.PERCENTAGE)){
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();

                    if (/from|to/i.test(token.value)){
                        return SyntaxUnit.fromToken(token);
                    }

                    tokenStream.unget();
                }

                //if it gets here, there wasn't a valid token, so time to explode
                this._unexpectedToken(tokenStream.LT(1));
            },

            //-----------------------------------------------------------------
            // Helper methods
            //-----------------------------------------------------------------

            /**
             * Not part of CSS grammar, but useful for skipping over
             * combination of white space and HTML-style comments.
             * @return {void}
             * @method _skipCruft
             * @private
             */
            _skipCruft: function(){
                while(this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])){
                    //noop
                }
            },

            /**
             * Not part of CSS grammar, but this pattern occurs frequently
             * in the official CSS grammar. Split out here to eliminate
             * duplicate code.
             * @param {Boolean} checkStart Indicates if the rule should check
             *      for the left brace at the beginning.
             * @param {Boolean} readMargins Indicates if the rule should check
             *      for margin patterns.
             * @return {void}
             * @method _readDeclarations
             * @private
             */
            _readDeclarations: function(checkStart, readMargins){
                /*
                 * Reads the pattern
                 * S* '{' S* declaration [ ';' S* declaration ]* '}' S*
                 * or
                 * S* '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.
                 * A semicolon is only necessary following a declaration if there's another declaration
                 * or margin afterwards.
                 */
                var tokenStream = this._tokenStream,
                    tt;


                this._readWhitespace();

                if (checkStart){
                    tokenStream.mustMatch(Tokens.LBRACE);
                }

                this._readWhitespace();

                try {

                    while(true){

                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())){
                            //noop
                        } else if (this._declaration()){
                            if (!tokenStream.match(Tokens.SEMICOLON)){
                                break;
                            }
                        } else {
                            break;
                        }

                        //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){
                        //    break;
                        //}
                        this._readWhitespace();
                    }

                    tokenStream.mustMatch(Tokens.RBRACE);
                    this._readWhitespace();

                } catch (ex) {
                    if (ex instanceof SyntaxError && !this.options.strict){

                        //fire error event
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });

                        //see if there's another declaration
                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
                        if (tt === Tokens.SEMICOLON){
                            //if there's a semicolon, then there might be another declaration
                            this._readDeclarations(false, readMargins);
                        } else if (tt !== Tokens.RBRACE){
                            //if there's a right brace, the rule is finished so don't do anything
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }

                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }
                }

            },

            /**
             * In some cases, you can end up with two white space tokens in a
             * row. Instead of making a change in every function that looks for
             * white space, this function is used to match as much white space
             * as necessary.
             * @method _readWhitespace
             * @return {String} The white space if found, empty string if not.
             * @private
             */
            _readWhitespace: function(){

                var tokenStream = this._tokenStream,
                    ws = "";

                while(tokenStream.match(Tokens.S)){
                    ws += tokenStream.token().value;
                }

                return ws;
            },


            /**
             * Throws an error when an unexpected token is found.
             * @param {Object} token The token that was found.
             * @method _unexpectedToken
             * @return {void}
             * @private
             */
            _unexpectedToken: function(token){
                throw new SyntaxError("Unexpected token '" + token.value + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
            },

            /**
             * Helper method used for parsing subparts of a style sheet.
             * @return {void}
             * @method _verifyEnd
             * @private
             */
            _verifyEnd: function(){
                if (this._tokenStream.LA(1) !== Tokens.EOF){
                    this._unexpectedToken(this._tokenStream.LT(1));
                }
            },

            //-----------------------------------------------------------------
            // Validation methods
            //-----------------------------------------------------------------
            _validateProperty: function(property, value){
                Validation.validate(property, value);
            },

            //-----------------------------------------------------------------
            // Parsing methods
            //-----------------------------------------------------------------

            parse: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                this._stylesheet();
            },

            parseStyleSheet: function(input){
                //just passthrough
                return this.parse(input);
            },

            parseMediaQuery: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                var result = this._media_query();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a property value (everything after the semicolon).
             * @return {parserlib.css.PropertyValue} The property value.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parserPropertyValue
             */
            parsePropertyValue: function(input){

                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();

                var result = this._expr();

                //okay to have a trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a complete CSS rule, including selectors and
             * properties.
             * @param {String} input The text to parser.
             * @return {Boolean} True if the parse completed successfully, false if not.
             * @method parseRule
             */
            parseRule: function(input){
                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();

                var result = this._ruleset();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses a single CSS selector (no comma)
             * @param {String} input The text to parse as a CSS selector.
             * @return {Selector} An object representing the selector.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parseSelector
             */
            parseSelector: function(input){

                this._tokenStream = new TokenStream(input, Tokens);

                //skip any leading white space
                this._readWhitespace();

                var result = this._selector();

                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();

                //otherwise return result
                return result;
            },

            /**
             * Parses an HTML style attribute: a set of CSS declarations
             * separated by semicolons.
             * @param {String} input The text to parse as a style attribute
             * @return {void}
             * @method parseStyleAttribute
             */
            parseStyleAttribute: function(input){
                input += "}"; // for error recovery in _readDeclarations()
                this._tokenStream = new TokenStream(input, Tokens);
                this._readDeclarations();
            }
        };

    //copy over onto prototype
    for (prop in additions){
        if (Object.prototype.hasOwnProperty.call(additions, prop)){
            proto[prop] = additions[prop];
        }
    }

    return proto;
}();


/*
nth
  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*
  ;
*/
var Properties = {
    __proto__: null,

    //A
    "align-items"                   : "flex-start | flex-end | center | baseline | stretch",
    "align-content"                 : "flex-start | flex-end | center | space-between | space-around | stretch",
    "align-self"                    : "auto | flex-start | flex-end | center | baseline | stretch",
    "-webkit-align-items"           : "flex-start | flex-end | center | baseline | stretch",
    "-webkit-align-content"         : "flex-start | flex-end | center | space-between | space-around | stretch",
    "-webkit-align-self"            : "auto | flex-start | flex-end | center | baseline | stretch",
    "alignment-adjust"              : "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>",
    "alignment-baseline"            : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "animation"                     : 1,
    "animation-delay"               : { multi: "<time>", comma: true },
    "animation-direction"           : { multi: "normal | alternate", comma: true },
    "animation-duration"            : { multi: "<time>", comma: true },
    "animation-fill-mode"           : { multi: "none | forwards | backwards | both", comma: true },
    "animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "animation-name"                : { multi: "none | <ident>", comma: true },
    "animation-play-state"          : { multi: "running | paused", comma: true },
    "animation-timing-function"     : 1,

    //vendor prefixed
    "-moz-animation-delay"               : { multi: "<time>", comma: true },
    "-moz-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-moz-animation-duration"            : { multi: "<time>", comma: true },
    "-moz-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-moz-animation-name"                : { multi: "none | <ident>", comma: true },
    "-moz-animation-play-state"          : { multi: "running | paused", comma: true },

    "-ms-animation-delay"               : { multi: "<time>", comma: true },
    "-ms-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-ms-animation-duration"            : { multi: "<time>", comma: true },
    "-ms-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-ms-animation-name"                : { multi: "none | <ident>", comma: true },
    "-ms-animation-play-state"          : { multi: "running | paused", comma: true },

    "-webkit-animation-delay"               : { multi: "<time>", comma: true },
    "-webkit-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-webkit-animation-duration"            : { multi: "<time>", comma: true },
    "-webkit-animation-fill-mode"           : { multi: "none | forwards | backwards | both", comma: true },
    "-webkit-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-webkit-animation-name"                : { multi: "none | <ident>", comma: true },
    "-webkit-animation-play-state"          : { multi: "running | paused", comma: true },

    "-o-animation-delay"               : { multi: "<time>", comma: true },
    "-o-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-o-animation-duration"            : { multi: "<time>", comma: true },
    "-o-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-o-animation-name"                : { multi: "none | <ident>", comma: true },
    "-o-animation-play-state"          : { multi: "running | paused", comma: true },

    "appearance"                    : "icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit",
    "azimuth"                       : function (expression) {
        var simple      = "<angle> | leftwards | rightwards | inherit",
            direction   = "left-side | far-left | left | center-left | center | center-right | right | far-right | right-side",
            behind      = false,
            valid       = false,
            part;

        if (!ValidationTypes.isAny(expression, simple)) {
            if (ValidationTypes.isAny(expression, "behind")) {
                behind = true;
                valid = true;
            }

            if (ValidationTypes.isAny(expression, direction)) {
                valid = true;
                if (!behind) {
                    ValidationTypes.isAny(expression, "behind");
                }
            }
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'azimuth'>) but found '" + part + "'.", part.line, part.col);
            }
        }
    },

    //B
    "backface-visibility"           : "visible | hidden",
    "background"                    : 1,
    "background-attachment"         : { multi: "<attachment>", comma: true },
    "background-clip"               : { multi: "<box>", comma: true },
    "background-color"              : "<color> | inherit",
    "background-image"              : { multi: "<bg-image>", comma: true },
    "background-origin"             : { multi: "<box>", comma: true },
    "background-position"           : { multi: "<bg-position>", comma: true },
    "background-repeat"             : { multi: "<repeat-style>" },
    "background-size"               : { multi: "<bg-size>", comma: true },
    "baseline-shift"                : "baseline | sub | super | <percentage> | <length>",
    "behavior"                      : 1,
    "binding"                       : 1,
    "bleed"                         : "<length>",
    "bookmark-label"                : "<content> | <attr> | <string>",
    "bookmark-level"                : "none | <integer>",
    "bookmark-state"                : "open | closed",
    "bookmark-target"               : "none | <uri> | <attr>",
    "border"                        : "<border-width> || <border-style> || <color>",
    "border-bottom"                 : "<border-width> || <border-style> || <color>",
    "border-bottom-color"           : "<color> | inherit",
    "border-bottom-left-radius"     :  "<x-one-radius>",
    "border-bottom-right-radius"    :  "<x-one-radius>",
    "border-bottom-style"           : "<border-style>",
    "border-bottom-width"           : "<border-width>",
    "border-collapse"               : "collapse | separate | inherit",
    "border-color"                  : { multi: "<color> | inherit", max: 4 },
    "border-image"                  : 1,
    "border-image-outset"           : { multi: "<length> | <number>", max: 4 },
    "border-image-repeat"           : { multi: "stretch | repeat | round", max: 2 },
    "border-image-slice"            : function(expression) {

        var valid   = false,
            numeric = "<number> | <percentage>",
            fill    = false,
            count   = 0,
            max     = 4,
            part;

        if (ValidationTypes.isAny(expression, "fill")) {
            fill = true;
            valid = true;
        }

        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, numeric);
            if (!valid) {
                break;
            }
            count++;
        }


        if (!fill) {
            ValidationTypes.isAny(expression, "fill");
        } else {
            valid = true;
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected ([<number> | <percentage>]{1,4} && fill?) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "border-image-source"           : "<image> | none",
    "border-image-width"            : { multi: "<length> | <percentage> | <number> | auto", max: 4 },
    "border-left"                   : "<border-width> || <border-style> || <color>",
    "border-left-color"             : "<color> | inherit",
    "border-left-style"             : "<border-style>",
    "border-left-width"             : "<border-width>",
    "border-radius"                 : function(expression) {

        var valid   = false,
            simple = "<length> | <percentage> | inherit",
            slash   = false,
            count   = 0,
            max     = 8,
            part;

        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, simple);
            if (!valid) {

                if (String(expression.peek()) === "/" && count > 0 && !slash) {
                    slash = true;
                    max = count + 5;
                    expression.next();
                } else {
                    break;
                }
            }
            count++;
        }

        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'border-radius'>) but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "border-right"                  : "<border-width> || <border-style> || <color>",
    "border-right-color"            : "<color> | inherit",
    "border-right-style"            : "<border-style>",
    "border-right-width"            : "<border-width>",
    "border-spacing"                : { multi: "<length> | inherit", max: 2 },
    "border-style"                  : { multi: "<border-style>", max: 4 },
    "border-top"                    : "<border-width> || <border-style> || <color>",
    "border-top-color"              : "<color> | inherit",
    "border-top-left-radius"        : "<x-one-radius>",
    "border-top-right-radius"       : "<x-one-radius>",
    "border-top-style"              : "<border-style>",
    "border-top-width"              : "<border-width>",
    "border-width"                  : { multi: "<border-width>", max: 4 },
    "bottom"                        : "<margin-width> | inherit",
    "-moz-box-align"                : "start | end | center | baseline | stretch",
    "-moz-box-decoration-break"     : "slice |clone",
    "-moz-box-direction"            : "normal | reverse | inherit",
    "-moz-box-flex"                 : "<number>",
    "-moz-box-flex-group"           : "<integer>",
    "-moz-box-lines"                : "single | multiple",
    "-moz-box-ordinal-group"        : "<integer>",
    "-moz-box-orient"               : "horizontal | vertical | inline-axis | block-axis | inherit",
    "-moz-box-pack"                 : "start | end | center | justify",
    "-o-box-decoration-break"       : "slice | clone",
    "-webkit-box-align"             : "start | end | center | baseline | stretch",
    "-webkit-box-decoration-break"  : "slice |clone",
    "-webkit-box-direction"         : "normal | reverse | inherit",
    "-webkit-box-flex"              : "<number>",
    "-webkit-box-flex-group"        : "<integer>",
    "-webkit-box-lines"             : "single | multiple",
    "-webkit-box-ordinal-group"     : "<integer>",
    "-webkit-box-orient"            : "horizontal | vertical | inline-axis | block-axis | inherit",
    "-webkit-box-pack"              : "start | end | center | justify",
    "box-decoration-break"          : "slice | clone",
    "box-shadow"                    : function (expression) {
        var part;

        if (!ValidationTypes.isAny(expression, "none")) {
            Validation.multiProperty("<shadow>", expression, true, Infinity);
        } else {
            if (expression.hasNext()) {
                part = expression.next();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            }
        }
    },
    "box-sizing"                    : "content-box | border-box | inherit",
    "break-after"                   : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-before"                  : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-inside"                  : "auto | avoid | avoid-page | avoid-column",

    //C
    "caption-side"                  : "top | bottom | inherit",
    "clear"                         : "none | right | left | both | inherit",
    "clip"                          : 1,
    "color"                         : "<color> | inherit",
    "color-profile"                 : 1,
    "column-count"                  : "<integer> | auto",                      //http://www.w3.org/TR/css3-multicol/
    "column-fill"                   : "auto | balance",
    "column-gap"                    : "<length> | normal",
    "column-rule"                   : "<border-width> || <border-style> || <color>",
    "column-rule-color"             : "<color>",
    "column-rule-style"             : "<border-style>",
    "column-rule-width"             : "<border-width>",
    "column-span"                   : "none | all",
    "column-width"                  : "<length> | auto",
    "columns"                       : 1,
    "content"                       : 1,
    "counter-increment"             : 1,
    "counter-reset"                 : 1,
    "crop"                          : "<shape> | auto",
    "cue"                           : "cue-after | cue-before | inherit",
    "cue-after"                     : 1,
    "cue-before"                    : 1,
    "cursor"                        : 1,

    //D
    "direction"                     : "ltr | rtl | inherit",
    "display"                       : "inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex",
    "dominant-baseline"             : 1,
    "drop-initial-after-adjust"     : "central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>",
    "drop-initial-after-align"      : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-before-adjust"    : "before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>",
    "drop-initial-before-align"     : "caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-size"             : "auto | line | <length> | <percentage>",
    "drop-initial-value"            : "initial | <integer>",

    //E
    "elevation"                     : "<angle> | below | level | above | higher | lower | inherit",
    "empty-cells"                   : "show | hide | inherit",

    //F
    "filter"                        : 1,
    "fit"                           : "fill | hidden | meet | slice",
    "fit-position"                  : 1,
    "flex"                          : "<flex>",
    "flex-basis"                    : "<width>",
    "flex-direction"                : "row | row-reverse | column | column-reverse",
    "flex-flow"                     : "<flex-direction> || <flex-wrap>",
    "flex-grow"                     : "<number>",
    "flex-shrink"                   : "<number>",
    "flex-wrap"                     : "nowrap | wrap | wrap-reverse",
    "-webkit-flex"                  : "<flex>",
    "-webkit-flex-basis"            : "<width>",
    "-webkit-flex-direction"        : "row | row-reverse | column | column-reverse",
    "-webkit-flex-flow"             : "<flex-direction> || <flex-wrap>",
    "-webkit-flex-grow"             : "<number>",
    "-webkit-flex-shrink"           : "<number>",
    "-webkit-flex-wrap"             : "nowrap | wrap | wrap-reverse",
    "-ms-flex"                      : "<flex>",
    "-ms-flex-align"                : "start | end | center | stretch | baseline",
    "-ms-flex-direction"            : "row | row-reverse | column | column-reverse | inherit",
    "-ms-flex-order"                : "<number>",
    "-ms-flex-pack"                 : "start | end | center | justify",
    "-ms-flex-wrap"                 : "nowrap | wrap | wrap-reverse",
    "float"                         : "left | right | none | inherit",
    "float-offset"                  : 1,
    "font"                          : 1,
    "font-family"                   : 1,
    "font-feature-settings"         : "<feature-tag-value> | normal | inherit",
    "font-kerning"                  : "auto | normal | none | initial | inherit | unset",
    "font-size"                     : "<absolute-size> | <relative-size> | <length> | <percentage> | inherit",
    "font-size-adjust"              : "<number> | none | inherit",
    "font-stretch"                  : "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit",
    "font-style"                    : "normal | italic | oblique | inherit",
    "font-variant"                  : "normal | small-caps | inherit",
    "font-variant-caps"             : "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
    "font-variant-position"         : "normal | sub | super | inherit | initial | unset",
    "font-weight"                   : "normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit",

    //G
    "grid"                          : 1,
    "grid-area"                     : 1,
    "grid-auto-columns"             : 1,
    "grid-auto-flow"                : 1,
    "grid-auto-position"            : 1,
    "grid-auto-rows"                : 1,
    "grid-cell-stacking"            : "columns | rows | layer",
    "grid-column"                   : 1,
    "grid-columns"                  : 1,
    "grid-column-align"             : "start | end | center | stretch",
    "grid-column-sizing"            : 1,
    "grid-column-start"             : 1,
    "grid-column-end"               : 1,
    "grid-column-span"              : "<integer>",
    "grid-flow"                     : "none | rows | columns",
    "grid-layer"                    : "<integer>",
    "grid-row"                      : 1,
    "grid-rows"                     : 1,
    "grid-row-align"                : "start | end | center | stretch",
    "grid-row-start"                : 1,
    "grid-row-end"                  : 1,
    "grid-row-span"                 : "<integer>",
    "grid-row-sizing"               : 1,
    "grid-template"                 : 1,
    "grid-template-areas"           : 1,
    "grid-template-columns"         : 1,
    "grid-template-rows"            : 1,

    //H
    "hanging-punctuation"           : 1,
    "height"                        : "<margin-width> | <content-sizing> | inherit",
    "hyphenate-after"               : "<integer> | auto",
    "hyphenate-before"              : "<integer> | auto",
    "hyphenate-character"           : "<string> | auto",
    "hyphenate-lines"               : "no-limit | <integer>",
    "hyphenate-resource"            : 1,
    "hyphens"                       : "none | manual | auto",

    //I
    "icon"                          : 1,
    "image-orientation"             : "angle | auto",
    "image-rendering"               : 1,
    "image-resolution"              : 1,
    "ime-mode"                      : "auto | normal | active | inactive | disabled | inherit",
    "inline-box-align"              : "initial | last | <integer>",

    //J
    "justify-content"               : "flex-start | flex-end | center | space-between | space-around",
    "-webkit-justify-content"       : "flex-start | flex-end | center | space-between | space-around",

    //L
    "left"                          : "<margin-width> | inherit",
    "letter-spacing"                : "<length> | normal | inherit",
    "line-height"                   : "<number> | <length> | <percentage> | normal | inherit",
    "line-break"                    : "auto | loose | normal | strict",
    "line-stacking"                 : 1,
    "line-stacking-ruby"            : "exclude-ruby | include-ruby",
    "line-stacking-shift"           : "consider-shifts | disregard-shifts",
    "line-stacking-strategy"        : "inline-line-height | block-line-height | max-height | grid-height",
    "list-style"                    : 1,
    "list-style-image"              : "<uri> | none | inherit",
    "list-style-position"           : "inside | outside | inherit",
    "list-style-type"               : "disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit",

    //M
    "margin"                        : { multi: "<margin-width> | inherit", max: 4 },
    "margin-bottom"                 : "<margin-width> | inherit",
    "margin-left"                   : "<margin-width> | inherit",
    "margin-right"                  : "<margin-width> | inherit",
    "margin-top"                    : "<margin-width> | inherit",
    "mark"                          : 1,
    "mark-after"                    : 1,
    "mark-before"                   : 1,
    "marks"                         : 1,
    "marquee-direction"             : 1,
    "marquee-play-count"            : 1,
    "marquee-speed"                 : 1,
    "marquee-style"                 : 1,
    "max-height"                    : "<length> | <percentage> | <content-sizing> | none | inherit",
    "max-width"                     : "<length> | <percentage> | <content-sizing> | none | inherit",
    "min-height"                    : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
    "min-width"                     : "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
    "move-to"                       : 1,

    //N
    "nav-down"                      : 1,
    "nav-index"                     : 1,
    "nav-left"                      : 1,
    "nav-right"                     : 1,
    "nav-up"                        : 1,

    //O
    "object-fit"                    : "fill | contain | cover | none | scale-down",
    "object-position"               : "<bg-position>",
    "opacity"                       : "<number> | inherit",
    "order"                         : "<integer>",
    "-webkit-order"                 : "<integer>",
    "orphans"                       : "<integer> | inherit",
    "outline"                       : 1,
    "outline-color"                 : "<color> | invert | inherit",
    "outline-offset"                : 1,
    "outline-style"                 : "<border-style> | inherit",
    "outline-width"                 : "<border-width> | inherit",
    "overflow"                      : "visible | hidden | scroll | auto | inherit",
    "overflow-style"                : 1,
    "overflow-wrap"                 : "normal | break-word",
    "overflow-x"                    : 1,
    "overflow-y"                    : 1,

    //P
    "padding"                       : { multi: "<padding-width> | inherit", max: 4 },
    "padding-bottom"                : "<padding-width> | inherit",
    "padding-left"                  : "<padding-width> | inherit",
    "padding-right"                 : "<padding-width> | inherit",
    "padding-top"                   : "<padding-width> | inherit",
    "page"                          : 1,
    "page-break-after"              : "auto | always | avoid | left | right | inherit",
    "page-break-before"             : "auto | always | avoid | left | right | inherit",
    "page-break-inside"             : "auto | avoid | inherit",
    "page-policy"                   : 1,
    "pause"                         : 1,
    "pause-after"                   : 1,
    "pause-before"                  : 1,
    "perspective"                   : 1,
    "perspective-origin"            : 1,
    "phonemes"                      : 1,
    "pitch"                         : 1,
    "pitch-range"                   : 1,
    "play-during"                   : 1,
    "pointer-events"                : "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
    "position"                      : "static | relative | absolute | fixed | inherit",
    "presentation-level"            : 1,
    "punctuation-trim"              : 1,

    //Q
    "quotes"                        : 1,

    //R
    "rendering-intent"              : 1,
    "resize"                        : 1,
    "rest"                          : 1,
    "rest-after"                    : 1,
    "rest-before"                   : 1,
    "richness"                      : 1,
    "right"                         : "<margin-width> | inherit",
    "rotation"                      : 1,
    "rotation-point"                : 1,
    "ruby-align"                    : 1,
    "ruby-overhang"                 : 1,
    "ruby-position"                 : 1,
    "ruby-span"                     : 1,

    //S
    "size"                          : 1,
    "speak"                         : "normal | none | spell-out | inherit",
    "speak-header"                  : "once | always | inherit",
    "speak-numeral"                 : "digits | continuous | inherit",
    "speak-punctuation"             : "code | none | inherit",
    "speech-rate"                   : 1,
    "src"                           : 1,
    "stress"                        : 1,
    "string-set"                    : 1,

    "table-layout"                  : "auto | fixed | inherit",
    "tab-size"                      : "<integer> | <length>",
    "target"                        : 1,
    "target-name"                   : 1,
    "target-new"                    : 1,
    "target-position"               : 1,
    "text-align"                    : "left | right | center | justify | match-parent | start | end | inherit" ,
    "text-align-last"               : 1,
    "text-decoration"               : 1,
    "text-emphasis"                 : 1,
    "text-height"                   : 1,
    "text-indent"                   : "<length> | <percentage> | inherit",
    "text-justify"                  : "auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida",
    "text-outline"                  : 1,
    "text-overflow"                 : 1,
    "text-rendering"                : "auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit",
    "text-shadow"                   : 1,
    "text-transform"                : "capitalize | uppercase | lowercase | none | inherit",
    "text-wrap"                     : "normal | none | avoid",
    "top"                           : "<margin-width> | inherit",
    "-ms-touch-action"              : "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
    "touch-action"                  : "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
    "transform"                     : 1,
    "transform-origin"              : 1,
    "transform-style"               : 1,
    "transition"                    : 1,
    "transition-delay"              : 1,
    "transition-duration"           : 1,
    "transition-property"           : 1,
    "transition-timing-function"    : 1,

    //U
    "unicode-bidi"                  : "normal | embed | isolate | bidi-override | isolate-override | plaintext | inherit",
    "user-modify"                   : "read-only | read-write | write-only | inherit",
    "user-select"                   : "none | text | toggle | element | elements | all | inherit",

    //V
    "vertical-align"                : "auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length> | inherit",
    "visibility"                    : "visible | hidden | collapse | inherit",
    "voice-balance"                 : 1,
    "voice-duration"                : 1,
    "voice-family"                  : 1,
    "voice-pitch"                   : 1,
    "voice-pitch-range"             : 1,
    "voice-rate"                    : 1,
    "voice-stress"                  : 1,
    "voice-volume"                  : 1,
    "volume"                        : 1,

    //W
    "white-space"                   : "normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap", //http://perishablepress.com/wrapping-content/
    "white-space-collapse"          : 1,
    "widows"                        : "<integer> | inherit",
    "width"                         : "<length> | <percentage> | <content-sizing> | auto | inherit",
    "will-change"                   : { multi: "<ident>", comma: true },
    "word-break"                    : "normal | keep-all | break-all",
    "word-spacing"                  : "<length> | normal | inherit",
    "word-wrap"                     : "normal | break-word",
    "writing-mode"                  : "horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb | inherit",

    //Z
    "z-index"                       : "<integer> | auto | inherit",
    "zoom"                          : "<number> | <percentage> | normal"
};
/**
 * Represents a selector combinator (whitespace, +, >).
 * @namespace parserlib.css
 * @class PropertyName
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {String} hack The type of IE hack applied ("*", "_", or null).
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function PropertyName(text, hack, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);

    /**
     * The type of IE hack applied ("*", "_", or null).
     * @type String
     * @property hack
     */
    this.hack = hack;

}

PropertyName.prototype = new SyntaxUnit();
PropertyName.prototype.constructor = PropertyName;
PropertyName.prototype.toString = function(){
    return (this.hack ? this.hack : "") + this.text;
};
/**
 * Represents a single part of a CSS property value, meaning that it represents
 * just everything single part between ":" and ";". If there are multiple values
 * separated by commas, this type represents just one of the values.
 * @param {String[]} parts An array of value parts making up this value.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 * @namespace parserlib.css
 * @class PropertyValue
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 */
function PropertyValue(parts, line, col){

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.PROPERTY_VALUE_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

}

PropertyValue.prototype = new SyntaxUnit();
PropertyValue.prototype.constructor = PropertyValue;

/**
 * A utility class that allows for easy iteration over the various parts of a
 * property value.
 * @param {parserlib.css.PropertyValue} value The property value to iterate over.
 * @namespace parserlib.css
 * @class PropertyValueIterator
 * @constructor
 */
function PropertyValueIterator(value){

    /**
     * Iterator value
     * @type int
     * @property _i
     * @private
     */
    this._i = 0;

    /**
     * The parts that make up the value.
     * @type Array
     * @property _parts
     * @private
     */
    this._parts = value.parts;

    /**
     * Keeps track of bookmarks along the way.
     * @type Array
     * @property _marks
     * @private
     */
    this._marks = [];

    /**
     * Holds the original property value.
     * @type parserlib.css.PropertyValue
     * @property value
     */
    this.value = value;

}

/**
 * Returns the total number of parts in the value.
 * @return {int} The total number of parts in the value.
 * @method count
 */
PropertyValueIterator.prototype.count = function(){
    return this._parts.length;
};

/**
 * Indicates if the iterator is positioned at the first item.
 * @return {Boolean} True if positioned at first item, false if not.
 * @method isFirst
 */
PropertyValueIterator.prototype.isFirst = function(){
    return this._i === 0;
};

/**
 * Indicates if there are more parts of the property value.
 * @return {Boolean} True if there are more parts, false if not.
 * @method hasNext
 */
PropertyValueIterator.prototype.hasNext = function(){
    return (this._i < this._parts.length);
};

/**
 * Marks the current spot in the iteration so it can be restored to
 * later on.
 * @return {void}
 * @method mark
 */
PropertyValueIterator.prototype.mark = function(){
    this._marks.push(this._i);
};

/**
 * Returns the next part of the property value or null if there is no next
 * part. Does not move the internal counter forward.
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
 * part.
 * @method peek
 */
PropertyValueIterator.prototype.peek = function(count){
    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
};

/**
 * Returns the next part of the property value or null if there is no next
 * part.
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
 * part.
 * @method next
 */
PropertyValueIterator.prototype.next = function(){
    return this.hasNext() ? this._parts[this._i++] : null;
};

/**
 * Returns the previous part of the property value or null if there is no
 * previous part.
 * @return {parserlib.css.PropertyValuePart} The previous part of the
 * property value or null if there is no previous part.
 * @method previous
 */
PropertyValueIterator.prototype.previous = function(){
    return this._i > 0 ? this._parts[--this._i] : null;
};

/**
 * Restores the last saved bookmark.
 * @return {void}
 * @method restore
 */
PropertyValueIterator.prototype.restore = function(){
    if (this._marks.length){
        this._i = this._marks.pop();
    }
};

/**
 * Represents a single part of a CSS property value, meaning that it represents
 * just one part of the data between ":" and ";".
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 * @namespace parserlib.css
 * @class PropertyValuePart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 */
function PropertyValuePart(text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);

    /**
     * Indicates the type of value unit.
     * @type String
     * @property type
     */
    this.type = "unknown";

    //figure out what type of data it is

    var temp;

    //it is a measurement?
    if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)){  //dimension
        this.type = "dimension";
        this.value = +RegExp.$1;
        this.units = RegExp.$2;

        //try to narrow down
        switch(this.units.toLowerCase()){

            case "em":
            case "rem":
            case "ex":
            case "px":
            case "cm":
            case "mm":
            case "in":
            case "pt":
            case "pc":
            case "ch":
            case "vh":
            case "vw":
            case "vmax":
            case "vmin":
                this.type = "length";
                break;
                
            case "fr":
                this.type = "grid";
                break;

            case "deg":
            case "rad":
            case "grad":
                this.type = "angle";
                break;

            case "ms":
            case "s":
                this.type = "time";
                break;

            case "hz":
            case "khz":
                this.type = "frequency";
                break;

            case "dpi":
            case "dpcm":
                this.type = "resolution";
                break;

            //default

        }

    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)){  //percentage
        this.type = "percentage";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?\d+)$/i.test(text)){  //integer
        this.type = "integer";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)$/i.test(text)){  //number
        this.type = "number";
        this.value = +RegExp.$1;

    } else if (/^#([a-f0-9]{3,6})/i.test(text)){  //hexcolor
        this.type = "color";
        temp = RegExp.$1;
        if (temp.length === 3){
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0),16);
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1),16);
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2),16);
        } else {
            this.red    = parseInt(temp.substring(0,2),16);
            this.green  = parseInt(temp.substring(2,4),16);
            this.blue   = parseInt(temp.substring(4,6),16);
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)){ //rgb() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //rgb() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
        this.alpha  = +RegExp.$4;
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //hsl()
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
    } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //hsla() color with percentages
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;
        this.alpha  = +RegExp.$4;
    } else if (/^url\(["']?([^\)"']+)["']?\)/i.test(text)){ //URI
        this.type   = "uri";
        this.uri    = RegExp.$1;
    } else if (/^([^\(]+)\(/i.test(text)){
        this.type   = "function";
        this.name   = RegExp.$1;
        this.value  = text;
    } else if (/^"([^\n\r\f\\"]|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*"/i.test(text)){    //double-quoted string
        this.type   = "string";
        this.value  = PropertyValuePart.parseString(text);
    } else if (/^'([^\n\r\f\\']|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*'/i.test(text)){    //single-quoted string
        this.type   = "string";
        this.value  = PropertyValuePart.parseString(text);
    } else if (Colors[text.toLowerCase()]){  //named color
        this.type   = "color";
        temp        = Colors[text.toLowerCase()].substring(1);
        this.red    = parseInt(temp.substring(0,2),16);
        this.green  = parseInt(temp.substring(2,4),16);
        this.blue   = parseInt(temp.substring(4,6),16);
    } else if (/^[\,\/]$/.test(text)){
        this.type   = "operator";
        this.value  = text;
    } else if (/^[a-z\-_\u0080-\uFFFF][a-z0-9\-_\u0080-\uFFFF]*$/i.test(text)){
        this.type   = "identifier";
        this.value  = text;
    }

}

PropertyValuePart.prototype = new SyntaxUnit();
PropertyValuePart.prototype.constructor = PropertyValuePart;

/**
 * Helper method to parse a CSS string.
 */
PropertyValuePart.parseString = function(str) {
    str = str.slice(1, -1); // Strip surrounding single/double quotes
    var replacer = function(match, esc) {
        if (/^(\n|\r\n|\r|\f)$/.test(esc)) { return ''; }
        var m = /^[0-9a-f]{1,6}/i.exec(esc);
        if (m) {
            var codePoint = parseInt(m[0], 16);
            if (String.fromCodePoint) {
                return String.fromCodePoint(codePoint);
            } else {
                // XXX No support for surrogates on old JavaScript engines.
                return String.fromCharCode(codePoint);
            }
        }
        return esc;
    };
    return str.replace(/\\(\r\n|[^\r0-9a-f]|[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)/ig,
                       replacer);
};

/**
 * Helper method to serialize a CSS string.
 */
PropertyValuePart.serializeString = function(value) {
    var replacer = function(match, c) {
        if (c === '"') {
            return "\\" + c;
        }
        var cp = String.codePointAt ? String.codePointAt(0) :
            // We only escape non-surrogate chars, so using charCodeAt
            // is harmless here.
            String.charCodeAt(0);
        return "\\" + cp.toString(16) + " ";
    };
    return '"' + value.replace(/["\r\n\f]/g, replacer) + '"';
};

/**
 * Create a new syntax unit based solely on the given token.
 * Convenience method for creating a new syntax unit when
 * it represents a single token instead of multiple.
 * @param {Object} token The token object to represent.
 * @return {parserlib.css.PropertyValuePart} The object representing the token.
 * @static
 * @method fromToken
 */
PropertyValuePart.fromToken = function(token){
    return new PropertyValuePart(token.value, token.startLine, token.startCol);
};
var Pseudos = {
    __proto__:       null,
    ":first-letter": 1,
    ":first-line":   1,
    ":before":       1,
    ":after":        1
};

Pseudos.ELEMENT = 1;
Pseudos.CLASS = 2;

Pseudos.isElement = function(pseudo){
    return pseudo.indexOf("::") === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;
};
/**
 * Represents an entire single selector, including all parts but not
 * including multiple selectors (those separated by commas).
 * @namespace parserlib.css
 * @class Selector
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {Array} parts Array of selectors parts making up this selector.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function Selector(parts, line, col){

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.SELECTOR_TYPE);

    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;

    /**
     * The specificity of the selector.
     * @type parserlib.css.Specificity
     * @property specificity
     */
    this.specificity = Specificity.calculate(this);

}

Selector.prototype = new SyntaxUnit();
Selector.prototype.constructor = Selector;

/**
 * Represents a single part of a selector string, meaning a single set of
 * element name and modifiers. This does not include combinators such as
 * spaces, +, >, etc.
 * @namespace parserlib.css
 * @class SelectorPart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} elementName The element name in the selector or null
 *      if there is no element name.
 * @param {Array} modifiers Array of individual modifiers for the element.
 *      May be empty if there are none.
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SelectorPart(elementName, modifiers, text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);

    /**
     * The tag name of the element to which this part
     * of the selector affects.
     * @type String
     * @property elementName
     */
    this.elementName = elementName;

    /**
     * The parts that come after the element name, such as class names, IDs,
     * pseudo classes/elements, etc.
     * @type Array
     * @property modifiers
     */
    this.modifiers = modifiers;

}

SelectorPart.prototype = new SyntaxUnit();
SelectorPart.prototype.constructor = SelectorPart;

/**
 * Represents a selector modifier string, meaning a class name, element name,
 * element ID, pseudo rule, etc.
 * @namespace parserlib.css
 * @class SelectorSubPart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit.
 * @param {String} type The type of selector modifier.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SelectorSubPart(text, type, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = type;

    /**
     * Some subparts have arguments, this represents them.
     * @type Array
     * @property args
     */
    this.args = [];

}

SelectorSubPart.prototype = new SyntaxUnit();
SelectorSubPart.prototype.constructor = SelectorSubPart;

/**
 * Represents a selector's specificity.
 * @namespace parserlib.css
 * @class Specificity
 * @constructor
 * @param {int} a Should be 1 for inline styles, zero for stylesheet styles
 * @param {int} b Number of ID selectors
 * @param {int} c Number of classes and pseudo classes
 * @param {int} d Number of element names and pseudo elements
 */
function Specificity(a, b, c, d){
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}

Specificity.prototype = {
    constructor: Specificity,

    /**
     * Compare this specificity to another.
     * @param {Specificity} other The other specificity to compare to.
     * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.
     * @method compare
     */
    compare: function(other){
        var comps = ["a", "b", "c", "d"],
            i, len;

        for (i=0, len=comps.length; i < len; i++){
            if (this[comps[i]] < other[comps[i]]){
                return -1;
            } else if (this[comps[i]] > other[comps[i]]){
                return 1;
            }
        }

        return 0;
    },

    /**
     * Creates a numeric value for the specificity.
     * @return {int} The numeric value for the specificity.
     * @method valueOf
     */
    valueOf: function(){
        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;
    },

    /**
     * Returns a string representation for specificity.
     * @return {String} The string representation of specificity.
     * @method toString
     */
    toString: function(){
        return this.a + "," + this.b + "," + this.c + "," + this.d;
    }

};

/**
 * Calculates the specificity of the given selector.
 * @param {parserlib.css.Selector} The selector to calculate specificity for.
 * @return {parserlib.css.Specificity} The specificity of the selector.
 * @static
 * @method calculate
 */
Specificity.calculate = function(selector){

    var i, len,
        part,
        b=0, c=0, d=0;

    function updateValues(part){

        var i, j, len, num,
            elementName = part.elementName ? part.elementName.text : "",
            modifier;

        if (elementName && elementName.charAt(elementName.length-1) !== "*") {
            d++;
        }

        for (i=0, len=part.modifiers.length; i < len; i++){
            modifier = part.modifiers[i];
            switch(modifier.type){
                case "class":
                case "attribute":
                    c++;
                    break;

                case "id":
                    b++;
                    break;

                case "pseudo":
                    if (Pseudos.isElement(modifier.text)){
                        d++;
                    } else {
                        c++;
                    }
                    break;

                case "not":
                    for (j=0, num=modifier.args.length; j < num; j++){
                        updateValues(modifier.args[j]);
                    }
            }
         }
    }

    for (i=0, len=selector.parts.length; i < len; i++){
        part = selector.parts[i];

        if (part instanceof SelectorPart){
            updateValues(part);
        }
    }

    return new Specificity(0, b, c, d);
};

var h = /^[0-9a-fA-F]$/,
    //nonascii = /^[\u0080-\uFFFF]$/,
    nl = /\n|\r\n|\r|\f/;

//-----------------------------------------------------------------------------
// Helper functions
//-----------------------------------------------------------------------------


function isHexDigit(c){
    return c !== null && h.test(c);
}

function isDigit(c){
    return c !== null && /\d/.test(c);
}

function isWhitespace(c){
    return c !== null && /\s/.test(c);
}

function isNewLine(c){
    return c !== null && nl.test(c);
}

function isNameStart(c){
    return c !== null && (/[a-z_\u0080-\uFFFF\\]/i.test(c));
}

function isNameChar(c){
    return c !== null && (isNameStart(c) || /[0-9\-\\]/.test(c));
}

function isIdentStart(c){
    return c !== null && (isNameStart(c) || /\-\\/.test(c));
}

function mix(receiver, supplier){
	for (var prop in supplier){
		if (Object.prototype.hasOwnProperty.call(supplier, prop)){
			receiver[prop] = supplier[prop];
		}
	}
	return receiver;
}

//-----------------------------------------------------------------------------
// CSS Token Stream
//-----------------------------------------------------------------------------


/**
 * A token stream that produces CSS tokens.
 * @param {String|Reader} input The source of text to tokenize.
 * @constructor
 * @class TokenStream
 * @namespace parserlib.css
 */
function TokenStream(input){
	TokenStreamBase.call(this, input, Tokens);
}

TokenStream.prototype = mix(new TokenStreamBase(), {

    /**
     * Overrides the TokenStreamBase method of the same name
     * to produce CSS tokens.
     * @param {variant} channel The name of the channel to use
     *      for the next token.
     * @return {Object} A token object representing the next token.
     * @method _getToken
     * @private
     */
    _getToken: function(channel){

        var c,
            reader = this._reader,
            token   = null,
            startLine   = reader.getLine(),
            startCol    = reader.getCol();

        c = reader.read();


        while(c){
            switch(c){

                /*
                 * Potential tokens:
                 * - COMMENT
                 * - SLASH
                 * - CHAR
                 */
                case "/":

                    if(reader.peek() === "*"){
                        token = this.commentToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - DASHMATCH
                 * - INCLUDES
                 * - PREFIXMATCH
                 * - SUFFIXMATCH
                 * - SUBSTRINGMATCH
                 * - CHAR
                 */
                case "|":
                case "~":
                case "^":
                case "$":
                case "*":
                    if(reader.peek() === "="){
                        token = this.comparisonToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - STRING
                 * - INVALID
                 */
                case "\"":
                case "'":
                    token = this.stringToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - HASH
                 * - CHAR
                 */
                case "#":
                    if (isNameChar(reader.peek())){
                        token = this.hashToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - DOT
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case ".":
                    if (isDigit(reader.peek())){
                        token = this.numberToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - CDC
                 * - MINUS
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case "-":
                    if (reader.peek() === "-"){  //could be closing HTML-style comment
                        token = this.htmlCommentEndToken(c, startLine, startCol);
                    } else if (isNameStart(reader.peek())){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - IMPORTANT_SYM
                 * - CHAR
                 */
                case "!":
                    token = this.importantToken(c, startLine, startCol);
                    break;

                /*
                 * Any at-keyword or CHAR
                 */
                case "@":
                    token = this.atRuleToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - NOT
                 * - CHAR
                 */
                case ":":
                    token = this.notToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - CDO
                 * - CHAR
                 */
                case "<":
                    token = this.htmlCommentStartToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - UNICODE_RANGE
                 * - URL
                 * - CHAR
                 */
                case "U":
                case "u":
                    if (reader.peek() === "+"){
                        token = this.unicodeRangeToken(c, startLine, startCol);
                        break;
                    }
                    /* falls through */
                default:

                    /*
                     * Potential tokens:
                     * - NUMBER
                     * - DIMENSION
                     * - LENGTH
                     * - FREQ
                     * - TIME
                     * - EMS
                     * - EXS
                     * - ANGLE
                     */
                    if (isDigit(c)){
                        token = this.numberToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - S
                     */
                    if (isWhitespace(c)){
                        token = this.whitespaceToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - IDENT
                     */
                    if (isIdentStart(c)){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - CHAR
                     * - PLUS
                     */
                    {
                        token = this.charToken(c, startLine, startCol);
                    }






            }

            //make sure this token is wanted
            //TODO: check channel
            break;
        }

        if (!token && c === null){
            token = this.createToken(Tokens.EOF,null,startLine,startCol);
        }

        return token;
    },

    //-------------------------------------------------------------------------
    // Methods to create tokens
    //-------------------------------------------------------------------------

    /**
     * Produces a token based on available data and the current
     * reader position information. This method is called by other
     * private methods to create tokens and is never called directly.
     * @param {int} tt The token type.
     * @param {String} value The text value of the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @param {Object} options (Optional) Specifies a channel property
     *      to indicate that a different channel should be scanned
     *      and/or a hide property indicating that the token should
     *      be hidden.
     * @return {Object} A token object.
     * @method createToken
     */
    createToken: function(tt, value, startLine, startCol, options){
        var reader = this._reader;
        options = options || {};

        return {
            value:      value,
            type:       tt,
            channel:    options.channel,
            endChar:    options.endChar,
            hide:       options.hide || false,
            startLine:  startLine,
            startCol:   startCol,
            endLine:    reader.getLine(),
            endCol:     reader.getCol()
        };
    },

    //-------------------------------------------------------------------------
    // Methods to create specific tokens
    //-------------------------------------------------------------------------

    /**
     * Produces a token for any at-rule. If the at-rule is unknown, then
     * the token is for a single "@" character.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method atRuleToken
     */
    atRuleToken: function(first, startLine, startCol){
        var rule    = first,
            reader  = this._reader,
            tt      = Tokens.CHAR,
            ident;

        /*
         * First, mark where we are. There are only four @ rules,
         * so anything else is really just an invalid token.
         * Basically, if this doesn't match one of the known @
         * rules, just return '@' as an unknown token and allow
         * parsing to continue after that point.
         */
        reader.mark();

        //try to find the at-keyword
        ident = this.readName();
        rule = first + ident;
        tt = Tokens.type(rule.toLowerCase());

        //if it's not valid, use the first character only and reset the reader
        if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN){
            if (rule.length > 1){
                tt = Tokens.UNKNOWN_SYM;
            } else {
                tt = Tokens.CHAR;
                rule = first;
                reader.reset();
            }
        }

        return this.createToken(tt, rule, startLine, startCol);
    },

    /**
     * Produces a character token based on the given character
     * and location in the stream. If there's a special (non-standard)
     * token name, this is used; otherwise CHAR is used.
     * @param {String} c The character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method charToken
     */
    charToken: function(c, startLine, startCol){
        var tt = Tokens.type(c);
        var opts = {};

        if (tt === -1){
            tt = Tokens.CHAR;
        } else {
            opts.endChar = Tokens[tt].endChar;
        }

        return this.createToken(tt, c, startLine, startCol, opts);
    },

    /**
     * Produces a character token based on the given character
     * and location in the stream. If there's a special (non-standard)
     * token name, this is used; otherwise CHAR is used.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method commentToken
     */
    commentToken: function(first, startLine, startCol){
        var comment = this.readComment(first);

        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
    },

    /**
     * Produces a comparison token based on the given character
     * and location in the stream. The next character must be
     * read and is already known to be an equals sign.
     * @param {String} c The character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method comparisonToken
     */
    comparisonToken: function(c, startLine, startCol){
        var reader  = this._reader,
            comparison  = c + reader.read(),
            tt      = Tokens.type(comparison) || Tokens.CHAR;

        return this.createToken(tt, comparison, startLine, startCol);
    },

    /**
     * Produces a hash token based on the specified information. The
     * first character provided is the pound sign (#) and then this
     * method reads a name afterward.
     * @param {String} first The first character (#) in the hash name.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method hashToken
     */
    hashToken: function(first, startLine, startCol){
        var name    = this.readName(first);

        return this.createToken(Tokens.HASH, name, startLine, startCol);
    },

    /**
     * Produces a CDO or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method htmlCommentStartToken
     */
    htmlCommentStartToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(3);

        if (text === "<!--"){
            return this.createToken(Tokens.CDO, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces a CDC or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method htmlCommentEndToken
     */
    htmlCommentEndToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(2);

        if (text === "-->"){
            return this.createToken(Tokens.CDC, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces an IDENT or FUNCTION token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the identifier.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method identOrFunctionToken
     */
    identOrFunctionToken: function(first, startLine, startCol){
        var reader  = this._reader,
            ident   = this.readName(first),
            tt      = Tokens.IDENT,
            uriFns  = ["url(", "url-prefix(", "domain("];

        //if there's a left paren immediately after, it's a URI or function
        if (reader.peek() === "("){
            ident += reader.read();
            if (uriFns.indexOf(ident.toLowerCase()) > -1){
                tt = Tokens.URI;
                ident = this.readURI(ident);

                //didn't find a valid URL or there's no closing paren
                if (uriFns.indexOf(ident.toLowerCase()) > -1){
                    tt = Tokens.FUNCTION;
                }
            } else {
                tt = Tokens.FUNCTION;
            }
        } else if (reader.peek() === ":"){  //might be an IE function

            //IE-specific functions always being with progid:
            if (ident.toLowerCase() === "progid"){
                ident += reader.readTo("(");
                tt = Tokens.IE_FUNCTION;
            }
        }

        return this.createToken(tt, ident, startLine, startCol);
    },

    /**
     * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method importantToken
     */
    importantToken: function(first, startLine, startCol){
        var reader      = this._reader,
            important   = first,
            tt          = Tokens.CHAR,
            temp,
            c;

        reader.mark();
        c = reader.read();

        while(c){

            //there can be a comment in here
            if (c === "/"){

                //if the next character isn't a star, then this isn't a valid !important token
                if (reader.peek() !== "*"){
                    break;
                } else {
                    temp = this.readComment(c);
                    if (temp === ""){    //broken!
                        break;
                    }
                }
            } else if (isWhitespace(c)){
                important += c + this.readWhitespace();
            } else if (/i/i.test(c)){
                temp = reader.readCount(8);
                if (/mportant/i.test(temp)){
                    important += c + temp;
                    tt = Tokens.IMPORTANT_SYM;

                }
                break;  //we're done
            } else {
                break;
            }

            c = reader.read();
        }

        if (tt === Tokens.CHAR){
            reader.reset();
            return this.charToken(first, startLine, startCol);
        } else {
            return this.createToken(tt, important, startLine, startCol);
        }


    },

    /**
     * Produces a NOT or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method notToken
     */
    notToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(4);

        if (text.toLowerCase() === ":not("){
            return this.createToken(Tokens.NOT, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces a number token based on the given character
     * and location in the stream. This may return a token of
     * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,
     * or PERCENTAGE.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method numberToken
     */
    numberToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = this.readNumber(first),
            ident,
            tt      = Tokens.NUMBER,
            c       = reader.peek();

        if (isIdentStart(c)){
            ident = this.readName(reader.read());
            value += ident;

            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)){
                tt = Tokens.LENGTH;
            } else if (/^deg|^rad$|^grad$/i.test(ident)){
                tt = Tokens.ANGLE;
            } else if (/^ms$|^s$/i.test(ident)){
                tt = Tokens.TIME;
            } else if (/^hz$|^khz$/i.test(ident)){
                tt = Tokens.FREQ;
            } else if (/^dpi$|^dpcm$/i.test(ident)){
                tt = Tokens.RESOLUTION;
            } else {
                tt = Tokens.DIMENSION;
            }

        } else if (c === "%"){
            value += reader.read();
            tt = Tokens.PERCENTAGE;
        }

        return this.createToken(tt, value, startLine, startCol);
    },

    /**
     * Produces a string token based on the given character
     * and location in the stream. Since strings may be indicated
     * by single or double quotes, a failure to match starting
     * and ending quotes results in an INVALID token being generated.
     * The first character in the string is passed in and then
     * the rest are read up to and including the final quotation mark.
     * @param {String} first The first character in the string.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method stringToken
     */
    stringToken: function(first, startLine, startCol){
        var delim   = first,
            string  = first,
            reader  = this._reader,
            prev    = first,
            tt      = Tokens.STRING,
            c       = reader.read();

        while(c){
            string += c;

            //if the delimiter is found with an escapement, we're done.
            if (c === delim && prev !== "\\"){
                break;
            }

            //if there's a newline without an escapement, it's an invalid string
            if (isNewLine(reader.peek()) && c !== "\\"){
                tt = Tokens.INVALID;
                break;
            }

            //save previous and get next
            prev = c;
            c = reader.read();
        }

        //if c is null, that means we're out of input and the string was never closed
        if (c === null){
            tt = Tokens.INVALID;
        }

        return this.createToken(tt, string, startLine, startCol);
    },

    unicodeRangeToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = first,
            temp,
            tt      = Tokens.CHAR;

        //then it should be a unicode range
        if (reader.peek() === "+"){
            reader.mark();
            value += reader.read();
            value += this.readUnicodeRangePart(true);

            //ensure there's an actual unicode range here
            if (value.length === 2){
                reader.reset();
            } else {

                tt = Tokens.UNICODE_RANGE;

                //if there's a ? in the first part, there can't be a second part
                if (value.indexOf("?") === -1){

                    if (reader.peek() === "-"){
                        reader.mark();
                        temp = reader.read();
                        temp += this.readUnicodeRangePart(false);

                        //if there's not another value, back up and just take the first
                        if (temp.length === 1){
                            reader.reset();
                        } else {
                            value += temp;
                        }
                    }

                }
            }
        }

        return this.createToken(tt, value, startLine, startCol);
    },

    /**
     * Produces a S token based on the specified information. Since whitespace
     * may have multiple characters, this consumes all whitespace characters
     * into a single token.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method whitespaceToken
     */
    whitespaceToken: function(first, startLine, startCol){
        var value   = first + this.readWhitespace();
        return this.createToken(Tokens.S, value, startLine, startCol);
    },




    //-------------------------------------------------------------------------
    // Methods to read values from the string stream
    //-------------------------------------------------------------------------

    readUnicodeRangePart: function(allowQuestionMark){
        var reader  = this._reader,
            part = "",
            c       = reader.peek();

        //first read hex digits
        while(isHexDigit(c) && part.length < 6){
            reader.read();
            part += c;
            c = reader.peek();
        }

        //then read question marks if allowed
        if (allowQuestionMark){
            while(c === "?" && part.length < 6){
                reader.read();
                part += c;
                c = reader.peek();
            }
        }

        //there can't be any other characters after this point

        return part;
    },

    readWhitespace: function(){
        var reader  = this._reader,
            whitespace = "",
            c       = reader.peek();

        while(isWhitespace(c)){
            reader.read();
            whitespace += c;
            c = reader.peek();
        }

        return whitespace;
    },
    readNumber: function(first){
        var reader  = this._reader,
            number  = first,
            hasDot  = (first === "."),
            c       = reader.peek();


        while(c){
            if (isDigit(c)){
                number += reader.read();
            } else if (c === "."){
                if (hasDot){
                    break;
                } else {
                    hasDot = true;
                    number += reader.read();
                }
            } else {
                break;
            }

            c = reader.peek();
        }

        return number;
    },
    readString: function(){
        var reader  = this._reader,
            delim   = reader.read(),
            string  = delim,
            prev    = delim,
            c       = reader.peek();

        while(c){
            c = reader.read();
            string += c;

            //if the delimiter is found with an escapement, we're done.
            if (c === delim && prev !== "\\"){
                break;
            }

            //if there's a newline without an escapement, it's an invalid string
            if (isNewLine(reader.peek()) && c !== "\\"){
                string = "";
                break;
            }

            //save previous and get next
            prev = c;
            c = reader.peek();
        }

        //if c is null, that means we're out of input and the string was never closed
        if (c === null){
            string = "";
        }

        return string;
    },
    readURI: function(first){
        var reader  = this._reader,
            uri     = first,
            inner   = "",
            c       = reader.peek();

        reader.mark();

        //skip whitespace before
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }

        //it's a string
        if (c === "'" || c === "\""){
            inner = this.readString();
        } else {
            inner = this.readURL();
        }

        c = reader.peek();

        //skip whitespace after
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }

        //if there was no inner value or the next character isn't closing paren, it's not a URI
        if (inner === "" || c !== ")"){
            uri = first;
            reader.reset();
        } else {
            uri += inner + reader.read();
        }

        return uri;
    },
    readURL: function(){
        var reader  = this._reader,
            url     = "",
            c       = reader.peek();

        //TODO: Check for escape and nonascii
        while (/^[!#$%&\\*-~]$/.test(c)){
            url += reader.read();
            c = reader.peek();
        }

        return url;

    },
    readName: function(first){
        var reader  = this._reader,
            ident   = first || "",
            c       = reader.peek();

        while(true){
            if (c === "\\"){
                ident += this.readEscape(reader.read());
                c = reader.peek();
            } else if(c && isNameChar(c)){
                ident += reader.read();
                c = reader.peek();
            } else {
                break;
            }
        }

        return ident;
    },

    readEscape: function(first){
        var reader  = this._reader,
            cssEscape = first || "",
            i       = 0,
            c       = reader.peek();

        if (isHexDigit(c)){
            do {
                cssEscape += reader.read();
                c = reader.peek();
            } while(c && isHexDigit(c) && ++i < 6);
        }

        if (cssEscape.length === 3 && /\s/.test(c) ||
            cssEscape.length === 7 || cssEscape.length === 1){
                reader.read();
        } else {
            c = "";
        }

        return cssEscape + c;
    },

    readComment: function(first){
        var reader  = this._reader,
            comment = first || "",
            c       = reader.read();

        if (c === "*"){
            while(c){
                comment += c;

                //look for end of comment
                if (comment.length > 2 && c === "*" && reader.peek() === "/"){
                    comment += reader.read();
                    break;
                }

                c = reader.read();
            }

            return comment;
        } else {
            return "";
        }

    }
});

var Tokens  = [

    /*
     * The following token names are defined in CSS3 Grammar: http://www.w3.org/TR/css3-syntax/#lexical
     */

    //HTML-style comments
    { name: "CDO"},
    { name: "CDC"},

    //ignorables
    { name: "S", whitespace: true/*, channel: "ws"*/},
    { name: "COMMENT", comment: true, hide: true, channel: "comment" },

    //attribute equality
    { name: "INCLUDES", text: "~="},
    { name: "DASHMATCH", text: "|="},
    { name: "PREFIXMATCH", text: "^="},
    { name: "SUFFIXMATCH", text: "$="},
    { name: "SUBSTRINGMATCH", text: "*="},

    //identifier types
    { name: "STRING"},
    { name: "IDENT"},
    { name: "HASH"},

    //at-keywords
    { name: "IMPORT_SYM", text: "@import"},
    { name: "PAGE_SYM", text: "@page"},
    { name: "MEDIA_SYM", text: "@media"},
    { name: "FONT_FACE_SYM", text: "@font-face"},
    { name: "CHARSET_SYM", text: "@charset"},
    { name: "NAMESPACE_SYM", text: "@namespace"},
    { name: "VIEWPORT_SYM", text: ["@viewport", "@-ms-viewport", "@-o-viewport"]},
    { name: "DOCUMENT_SYM", text: ["@document", "@-moz-document"]},
    { name: "UNKNOWN_SYM" },
    //{ name: "ATKEYWORD"},

    //CSS3 animations
    { name: "KEYFRAMES_SYM", text: [ "@keyframes", "@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes" ] },

    //important symbol
    { name: "IMPORTANT_SYM"},

    //measurements
    { name: "LENGTH"},
    { name: "ANGLE"},
    { name: "TIME"},
    { name: "FREQ"},
    { name: "DIMENSION"},
    { name: "PERCENTAGE"},
    { name: "NUMBER"},

    //functions
    { name: "URI"},
    { name: "FUNCTION"},

    //Unicode ranges
    { name: "UNICODE_RANGE"},

    /*
     * The following token names are defined in CSS3 Selectors: http://www.w3.org/TR/css3-selectors/#selector-syntax
     */

    //invalid string
    { name: "INVALID"},

    //combinators
    { name: "PLUS", text: "+" },
    { name: "GREATER", text: ">"},
    { name: "COMMA", text: ","},
    { name: "TILDE", text: "~"},

    //modifier
    { name: "NOT"},

    /*
     * Defined in CSS3 Paged Media
     */
    { name: "TOPLEFTCORNER_SYM", text: "@top-left-corner"},
    { name: "TOPLEFT_SYM", text: "@top-left"},
    { name: "TOPCENTER_SYM", text: "@top-center"},
    { name: "TOPRIGHT_SYM", text: "@top-right"},
    { name: "TOPRIGHTCORNER_SYM", text: "@top-right-corner"},
    { name: "BOTTOMLEFTCORNER_SYM", text: "@bottom-left-corner"},
    { name: "BOTTOMLEFT_SYM", text: "@bottom-left"},
    { name: "BOTTOMCENTER_SYM", text: "@bottom-center"},
    { name: "BOTTOMRIGHT_SYM", text: "@bottom-right"},
    { name: "BOTTOMRIGHTCORNER_SYM", text: "@bottom-right-corner"},
    { name: "LEFTTOP_SYM", text: "@left-top"},
    { name: "LEFTMIDDLE_SYM", text: "@left-middle"},
    { name: "LEFTBOTTOM_SYM", text: "@left-bottom"},
    { name: "RIGHTTOP_SYM", text: "@right-top"},
    { name: "RIGHTMIDDLE_SYM", text: "@right-middle"},
    { name: "RIGHTBOTTOM_SYM", text: "@right-bottom"},

    /*
     * The following token names are defined in CSS3 Media Queries: http://www.w3.org/TR/css3-mediaqueries/#syntax
     */
    /*{ name: "MEDIA_ONLY", state: "media"},
    { name: "MEDIA_NOT", state: "media"},
    { name: "MEDIA_AND", state: "media"},*/
    { name: "RESOLUTION", state: "media"},

    /*
     * The following token names are not defined in any CSS specification but are used by the lexer.
     */

    //not a real token, but useful for stupid IE filters
    { name: "IE_FUNCTION" },

    //part of CSS3 grammar but not the Flex code
    { name: "CHAR" },

    //TODO: Needed?
    //Not defined as tokens, but might as well be
    {
        name: "PIPE",
        text: "|"
    },
    {
        name: "SLASH",
        text: "/"
    },
    {
        name: "MINUS",
        text: "-"
    },
    {
        name: "STAR",
        text: "*"
    },

    {
        name: "LBRACE",
        endChar: "}",
        text: "{"
    },
    {
        name: "RBRACE",
        text: "}"
    },
    {
        name: "LBRACKET",
        endChar: "]",
        text: "["
    },
    {
        name: "RBRACKET",
        text: "]"
    },
    {
        name: "EQUALS",
        text: "="
    },
    {
        name: "COLON",
        text: ":"
    },
    {
        name: "SEMICOLON",
        text: ";"
    },

    {
        name: "LPAREN",
        endChar: ")",
        text: "("
    },
    {
        name: "RPAREN",
        text: ")"
    },
    {
        name: "DOT",
        text: "."
    }
];

(function(){

    var nameMap = [],
        typeMap = Object.create(null);

    Tokens.UNKNOWN = -1;
    Tokens.unshift({name:"EOF"});
    for (var i=0, len = Tokens.length; i < len; i++){
        nameMap.push(Tokens[i].name);
        Tokens[Tokens[i].name] = i;
        if (Tokens[i].text){
            if (Tokens[i].text instanceof Array){
                for (var j=0; j < Tokens[i].text.length; j++){
                    typeMap[Tokens[i].text[j]] = i;
                }
            } else {
                typeMap[Tokens[i].text] = i;
            }
        }
    }

    Tokens.name = function(tt){
        return nameMap[tt];
    };

    Tokens.type = function(c){
        return typeMap[c] || -1;
    };

})();



//This file will likely change a lot! Very experimental!
var Validation = {

    validate: function(property, value){

        //normalize name
        var name        = property.toString().toLowerCase(),
            expression  = new PropertyValueIterator(value),
            spec        = Properties[name];

        if (!spec) {
            if (name.indexOf("-") !== 0){    //vendor prefixed are ok
                throw new ValidationError("Unknown property '" + property + "'.", property.line, property.col);
            }
        } else if (typeof spec !== "number"){

            //initialization
            if (typeof spec === "string"){
                if (spec.indexOf("||") > -1) {
                    this.groupProperty(spec, expression);
                } else {
                    this.singleProperty(spec, expression, 1);
                }

            } else if (spec.multi) {
                this.multiProperty(spec.multi, expression, spec.comma, spec.max || Infinity);
            } else if (typeof spec === "function") {
                spec(expression);
            }

        }

    },

    singleProperty: function(types, expression, max, partial) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            part;

        while (expression.hasNext() && count < max) {
            result = ValidationTypes.isAny(expression, types);
            if (!result) {
                break;
            }
            count++;
        }

        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                 throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }

    },

    multiProperty: function (types, expression, comma, max) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            part;

        while(expression.hasNext() && !result && count < max) {
            if (ValidationTypes.isAny(expression, types)) {
                count++;
                if (!expression.hasNext()) {
                    result = true;

                } else if (comma) {
                    if (String(expression.peek()) === ",") {
                        part = expression.next();
                    } else {
                        break;
                    }
                }
            } else {
                break;

            }
        }

        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                part = expression.previous();
                if (comma && String(part) === ",") {
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
                } else {
                    throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
                }
            }

        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }

    },

    groupProperty: function (types, expression, comma) {

        var result      = false,
            value       = expression.value,
            typeCount   = types.split("||").length,
            groups      = { count: 0 },
            partial     = false,
            name,
            part;

        while(expression.hasNext() && !result) {
            name = ValidationTypes.isAnyOfGroup(expression, types);
            if (name) {

                //no dupes
                if (groups[name]) {
                    break;
                } else {
                    groups[name] = 1;
                    groups.count++;
                    partial = true;

                    if (groups.count === typeCount || !expression.hasNext()) {
                        result = true;
                    }
                }
            } else {
                break;
            }
        }

        if (!result) {
            if (partial && expression.hasNext()) {
                    part = expression.peek();
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }
    }



};
/**
 * Type to use when a validation error occurs.
 * @class ValidationError
 * @namespace parserlib.util
 * @constructor
 * @param {String} message The error message.
 * @param {int} line The line at which the error occurred.
 * @param {int} col The column at which the error occurred.
 */
function ValidationError(message, line, col){

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}

//inherit from Error
ValidationError.prototype = new Error();
//This file will likely change a lot! Very experimental!
var ValidationTypes = {

    isLiteral: function (part, literals) {
        var text = part.text.toString().toLowerCase(),
            args = literals.split(" | "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found; i++){
            if (text === args[i].toLowerCase()){
                found = true;
            }
        }

        return found;
    },

    isSimple: function(type) {
        return !!this.simple[type];
    },

    isComplex: function(type) {
        return !!this.complex[type];
    },

    /**
     * Determines if the next part(s) of the given expression
     * are any of the given types.
     */
    isAny: function (expression, types) {
        var args = types.split(" | "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found && expression.hasNext(); i++){
            found = this.isType(expression, args[i]);
        }

        return found;
    },

    /**
     * Determines if the next part(s) of the given expression
     * are one of a group.
     */
    isAnyOfGroup: function(expression, types) {
        var args = types.split(" || "),
            i, len, found = false;

        for (i=0,len=args.length; i < len && !found; i++){
            found = this.isType(expression, args[i]);
        }

        return found ? args[i-1] : false;
    },

    /**
     * Determines if the next part(s) of the given expression
     * are of a given type.
     */
    isType: function (expression, type) {
        var part = expression.peek(),
            result = false;

        if (type.charAt(0) !== "<") {
            result = this.isLiteral(part, type);
            if (result) {
                expression.next();
            }
        } else if (this.simple[type]) {
            result = this.simple[type](part);
            if (result) {
                expression.next();
            }
        } else {
            result = this.complex[type](expression);
        }

        return result;
    },



    simple: {
        __proto__: null,

        "<absolute-size>": function(part){
            return ValidationTypes.isLiteral(part, "xx-small | x-small | small | medium | large | x-large | xx-large");
        },

        "<attachment>": function(part){
            return ValidationTypes.isLiteral(part, "scroll | fixed | local");
        },

        "<attr>": function(part){
            return part.type === "function" && part.name === "attr";
        },

        "<bg-image>": function(part){
            return this["<image>"](part) || this["<gradient>"](part) ||  String(part) === "none";
        },

        "<gradient>": function(part) {
            return part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?(?:repeating\-)?(?:radial\-|linear\-)?gradient/i.test(part);
        },

        "<box>": function(part){
            return ValidationTypes.isLiteral(part, "padding-box | border-box | content-box");
        },

        "<content>": function(part){
            return part.type === "function" && part.name === "content";
        },

        "<relative-size>": function(part){
            return ValidationTypes.isLiteral(part, "smaller | larger");
        },

        //any identifier
        "<ident>": function(part){
            return part.type === "identifier";
        },

        "<length>": function(part){
            if (part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?calc/i.test(part)){
                return true;
            }else{
                return part.type === "length" || part.type === "number" || part.type === "integer" || String(part) === "0";
            }
        },

        "<color>": function(part){
            return part.type === "color" || String(part) === "transparent" || String(part) === "currentColor";
        },

        "<number>": function(part){
            return part.type === "number" || this["<integer>"](part);
        },

        "<integer>": function(part){
            return part.type === "integer";
        },

        "<line>": function(part){
            return part.type === "integer";
        },

        "<angle>": function(part){
            return part.type === "angle";
        },

        "<uri>": function(part){
            return part.type === "uri";
        },

        "<image>": function(part){
            return this["<uri>"](part);
        },

        "<percentage>": function(part){
            return part.type === "percentage" || String(part) === "0";
        },

        "<border-width>": function(part){
            return this["<length>"](part) || ValidationTypes.isLiteral(part, "thin | medium | thick");
        },

        "<border-style>": function(part){
            return ValidationTypes.isLiteral(part, "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset");
        },

        "<content-sizing>": function(part){ // http://www.w3.org/TR/css3-sizing/#width-height-keywords
            return ValidationTypes.isLiteral(part, "fill-available | -moz-available | -webkit-fill-available | max-content | -moz-max-content | -webkit-max-content | min-content | -moz-min-content | -webkit-min-content | fit-content | -moz-fit-content | -webkit-fit-content");
        },

        "<margin-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part) || ValidationTypes.isLiteral(part, "auto");
        },

        "<padding-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part);
        },

        "<shape>": function(part){
            return part.type === "function" && (part.name === "rect" || part.name === "inset-rect");
        },

        "<time>": function(part) {
            return part.type === "time";
        },

        "<flex-grow>": function(part){
            return this["<number>"](part);
        },

        "<flex-shrink>": function(part){
            return this["<number>"](part);
        },

        "<width>": function(part){
            return this["<margin-width>"](part);
        },

        "<flex-basis>": function(part){
            return this["<width>"](part);
        },

        "<flex-direction>": function(part){
            return ValidationTypes.isLiteral(part, "row | row-reverse | column | column-reverse");
        },

        "<flex-wrap>": function(part){
            return ValidationTypes.isLiteral(part, "nowrap | wrap | wrap-reverse");
        },

        "<feature-tag-value>": function(part){
            return (part.type === "function" && /^[A-Z0-9]{4}$/i.test(part));
        }
    },

    complex: {
        __proto__: null,

        "<bg-position>": function(expression){
            var result  = false,
                numeric = "<percentage> | <length>",
                xDir    = "left | right",
                yDir    = "top | bottom",
                count = 0;

            while (expression.peek(count) && expression.peek(count).text !== ",") {
                count++;
            }

/*
<position> = [
  [ left | center | right | top | bottom | <percentage> | <length> ]
|
  [ left | center | right | <percentage> | <length> ]
  [ top | center | bottom | <percentage> | <length> ]
|
  [ center | [ left | right ] [ <percentage> | <length> ]? ] &&
  [ center | [ top | bottom ] [ <percentage> | <length> ]? ]
]
*/

            if (count < 3) {
                if (ValidationTypes.isAny(expression, xDir + " | center | " + numeric)) {
                        result = true;
                        ValidationTypes.isAny(expression, yDir + " | center | " + numeric);
                } else if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, xDir + " | center");
                }
            } else {
                if (ValidationTypes.isAny(expression, xDir)) {
                    if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, yDir)) {
                            result = true;
                            ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, yDir)) {
                    if (ValidationTypes.isAny(expression, xDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, xDir)) {
                                result = true;
                                ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, "center")) {
                    if (ValidationTypes.isAny(expression, xDir + " | " + yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    }
                }
            }

            return result;
        },

        "<bg-size>": function(expression){
            //<bg-size> = [ <length> | <percentage> | auto ]{1,2} | cover | contain
            var result  = false,
                numeric = "<percentage> | <length> | auto";

            if (ValidationTypes.isAny(expression, "cover | contain")) {
                result = true;
            } else if (ValidationTypes.isAny(expression, numeric)) {
                result = true;
                ValidationTypes.isAny(expression, numeric);
            }

            return result;
        },

        "<repeat-style>": function(expression){
            //repeat-x | repeat-y | [repeat | space | round | no-repeat]{1,2}
            var result  = false,
                values  = "repeat | space | round | no-repeat",
                part;

            if (expression.hasNext()){
                part = expression.next();

                if (ValidationTypes.isLiteral(part, "repeat-x | repeat-y")) {
                    result = true;
                } else if (ValidationTypes.isLiteral(part, values)) {
                    result = true;

                    if (expression.hasNext() && ValidationTypes.isLiteral(expression.peek(), values)) {
                        expression.next();
                    }
                }
            }

            return result;

        },

        "<shadow>": function(expression) {
            //inset? && [ <length>{2,4} && <color>? ]
            var result  = false,
                count   = 0,
                inset   = false,
                color   = false;

            if (expression.hasNext()) {

                if (ValidationTypes.isAny(expression, "inset")){
                    inset = true;
                }

                if (ValidationTypes.isAny(expression, "<color>")) {
                    color = true;
                }

                while (ValidationTypes.isAny(expression, "<length>") && count < 4) {
                    count++;
                }


                if (expression.hasNext()) {
                    if (!color) {
                        ValidationTypes.isAny(expression, "<color>");
                    }

                    if (!inset) {
                        ValidationTypes.isAny(expression, "inset");
                    }

                }

                result = (count >= 2 && count <= 4);

            }

            return result;
        },

        "<x-one-radius>": function(expression) {
            //[ <length> | <percentage> ] [ <length> | <percentage> ]?
            var result  = false,
                simple = "<length> | <percentage> | inherit";

            if (ValidationTypes.isAny(expression, simple)){
                result = true;
                ValidationTypes.isAny(expression, simple);
            }

            return result;
        },

        "<flex>": function(expression) {
            // http://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/#flex-property
            // none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]
            // Valid syntaxes, according to https://developer.mozilla.org/en-US/docs/Web/CSS/flex#Syntax
            // * none
            // * <flex-grow>
            // * <flex-basis>
            // * <flex-grow> <flex-basis>
            // * <flex-grow> <flex-shrink>
            // * <flex-grow> <flex-shrink> <flex-basis>
            // * inherit
            var part,
                result = false;
            if (ValidationTypes.isAny(expression, "none | inherit")) {
                result = true;
            } else {
                if (ValidationTypes.isType(expression, "<flex-grow>")) {
                    if (expression.peek()) {
                        if (ValidationTypes.isType(expression, "<flex-shrink>")) {
                            if (expression.peek()) {
                                result = ValidationTypes.isType(expression, "<flex-basis>");
                            } else {
                                result = true;
                            }
                        } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                            result = expression.peek() === null;
                        }
                    } else {
                        result = true;
                    }
                } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                    result = true;
                }
            }

            if (!result) {
                // Generate a more verbose error than "Expected <flex>..."
                part = expression.peek();
                throw new ValidationError("Expected (none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]) but found '" + expression.value.text + "'.", part.line, part.col);
            }

            return result;
        }
    }
};

parserlib.css = {
__proto__           :null,
Colors              :Colors,
Combinator          :Combinator,
Parser              :Parser,
PropertyName        :PropertyName,
PropertyValue       :PropertyValue,
PropertyValuePart   :PropertyValuePart,
MediaFeature        :MediaFeature,
MediaQuery          :MediaQuery,
Selector            :Selector,
SelectorPart        :SelectorPart,
SelectorSubPart     :SelectorSubPart,
Specificity         :Specificity,
TokenStream         :TokenStream,
Tokens              :Tokens,
ValidationError     :ValidationError
};
})();

(function(){
/* jshint forin:false */
for(var prop in parserlib){
exports[prop] = parserlib[prop];
}
})();


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var URL = __webpack_require__(22);
var URLUtils = __webpack_require__(51);

module.exports = Location;

function Location(window, href) {
  this._window = window;
  this._href = href;
}

Location.prototype = Object.create(URLUtils.prototype, {
  constructor: { value: Location },

  // Special behavior when href is set
  href: {
    get: function() { return this._href; },
    set: function(v) { this.assign(v); }
  },

  assign: { value: function(url) {
    // Resolve the new url against the current one
    // XXX:
    // This is not actually correct. It should be resolved against
    // the URL of the document of the script. For now, though, I only
    // support a single window and there is only one base url.
    // So this is good enough for now.
    var current = new URL(this._href);
    var newurl = current.resolve(url);

    // Save the new url
    this._href = newurl;

    // Start loading the new document!
    // XXX
    // This is just something hacked together.
    // The real algorithm is: http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#navigate
  }},

  replace: { value: function(url) {
    // XXX
    // Since we aren't tracking history yet, replace is the same as assign
    this.assign(url);
  }},

  reload: { value: function() {
    // XXX:
    // Actually, the spec is a lot more complicated than this
    this.assign(this.href);
  }},

  toString: { value: function() {
    return this.href;
  }}

});


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://html.spec.whatwg.org/multipage/webappapis.html#navigatorid
var NavigatorID = Object.create(null, {
  appCodeName: { value: "Mozilla" },
  appName: { value: "Netscape" },
  appVersion: { value: "4.0" },
  platform: { value: "" },
  product: { value: "Gecko" },
  productSub: { value: "20100101" },
  userAgent: { value: "" },
  vendor: { value: "" },
  vendorSub: { value: "" },
  taintEnabled: { value: function() { return false; } }
});

module.exports = NavigatorID;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://html.spec.whatwg.org/multipage/webappapis.html#windowtimers
var WindowTimers = {
  setTimeout: setTimeout,
  clearTimeout: clearTimeout,
  setInterval: setInterval,
  clearInterval: clearInterval
};

module.exports = WindowTimers;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {
  VALUE: 1, // The value of a Text, Comment or PI node changed
  ATTR: 2, // A new attribute was added or an attribute value and/or prefix changed
  REMOVE_ATTR: 3, // An attribute was removed
  REMOVE: 4, // A node was removed
  MOVE: 5, // A node was moved
  INSERT: 6 // A node (or a subtree of nodes) was inserted
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.2
(function() {
  var InvalidStateError, NetworkError, ProgressEvent, SecurityError, SyntaxError, XMLHttpRequest, XMLHttpRequestEventTarget, XMLHttpRequestUpload, http, https, os, url,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLHttpRequestEventTarget = (function() {
    function XMLHttpRequestEventTarget() {
      this.onloadstart = null;
      this.onprogress = null;
      this.onabort = null;
      this.onerror = null;
      this.onload = null;
      this.ontimeout = null;
      this.onloadend = null;
      this._listeners = {};
    }

    XMLHttpRequestEventTarget.prototype.onloadstart = null;

    XMLHttpRequestEventTarget.prototype.onprogress = null;

    XMLHttpRequestEventTarget.prototype.onabort = null;

    XMLHttpRequestEventTarget.prototype.onerror = null;

    XMLHttpRequestEventTarget.prototype.onload = null;

    XMLHttpRequestEventTarget.prototype.ontimeout = null;

    XMLHttpRequestEventTarget.prototype.onloadend = null;

    XMLHttpRequestEventTarget.prototype.addEventListener = function(eventType, listener) {
      var base;
      eventType = eventType.toLowerCase();
      (base = this._listeners)[eventType] || (base[eventType] = []);
      this._listeners[eventType].push(listener);
      return void 0;
    };

    XMLHttpRequestEventTarget.prototype.removeEventListener = function(eventType, listener) {
      var index;
      eventType = eventType.toLowerCase();
      if (this._listeners[eventType]) {
        index = this._listeners[eventType].indexOf(listener);
        if (index !== -1) {
          this._listeners[eventType].splice(index, 1);
        }
      }
      return void 0;
    };

    XMLHttpRequestEventTarget.prototype.dispatchEvent = function(event) {
      var eventType, j, len, listener, listeners;
      event.currentTarget = event.target = this;
      eventType = event.type;
      if (listeners = this._listeners[eventType]) {
        for (j = 0, len = listeners.length; j < len; j++) {
          listener = listeners[j];
          listener.call(this, event);
        }
      }
      if (listener = this["on" + eventType]) {
        listener.call(this, event);
      }
      return void 0;
    };

    return XMLHttpRequestEventTarget;

  })();

  http = __webpack_require__(91);

  https = __webpack_require__(92);

  os = __webpack_require__(93);

  url = __webpack_require__(35);

  XMLHttpRequest = (function(superClass) {
    extend(XMLHttpRequest, superClass);

    function XMLHttpRequest(options) {
      XMLHttpRequest.__super__.constructor.call(this);
      this.onreadystatechange = null;
      this._anonymous = options && options.anon;
      this.readyState = XMLHttpRequest.UNSENT;
      this.response = null;
      this.responseText = '';
      this.responseType = '';
      this.responseURL = '';
      this.status = 0;
      this.statusText = '';
      this.timeout = 0;
      this.upload = new XMLHttpRequestUpload(this);
      this._method = null;
      this._url = null;
      this._sync = false;
      this._headers = null;
      this._loweredHeaders = null;
      this._mimeOverride = null;
      this._request = null;
      this._response = null;
      this._responseParts = null;
      this._responseHeaders = null;
      this._aborting = null;
      this._error = null;
      this._loadedBytes = 0;
      this._totalBytes = 0;
      this._lengthComputable = false;
    }

    XMLHttpRequest.prototype.onreadystatechange = null;

    XMLHttpRequest.prototype.readyState = null;

    XMLHttpRequest.prototype.response = null;

    XMLHttpRequest.prototype.responseText = null;

    XMLHttpRequest.prototype.responseType = null;

    XMLHttpRequest.prototype.status = null;

    XMLHttpRequest.prototype.timeout = null;

    XMLHttpRequest.prototype.upload = null;

    XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
      var xhrUrl;
      method = method.toUpperCase();
      if (method in this._restrictedMethods) {
        throw new SecurityError("HTTP method " + method + " is not allowed in XHR");
      }
      xhrUrl = this._parseUrl(url);
      if (async === void 0) {
        async = true;
      }
      switch (this.readyState) {
        case XMLHttpRequest.UNSENT:
        case XMLHttpRequest.OPENED:
        case XMLHttpRequest.DONE:
          null;
          break;
        case XMLHttpRequest.HEADERS_RECEIVED:
        case XMLHttpRequest.LOADING:
          null;
      }
      this._method = method;
      this._url = xhrUrl;
      this._sync = !async;
      this._headers = {};
      this._loweredHeaders = {};
      this._mimeOverride = null;
      this._setReadyState(XMLHttpRequest.OPENED);
      this._request = null;
      this._response = null;
      this.status = 0;
      this.statusText = '';
      this._responseParts = [];
      this._responseHeaders = null;
      this._loadedBytes = 0;
      this._totalBytes = 0;
      this._lengthComputable = false;
      return void 0;
    };

    XMLHttpRequest.prototype.setRequestHeader = function(name, value) {
      var loweredName;
      if (this.readyState !== XMLHttpRequest.OPENED) {
        throw new InvalidStateError("XHR readyState must be OPENED");
      }
      loweredName = name.toLowerCase();
      if (this._restrictedHeaders[loweredName] || /^sec\-/.test(loweredName) || /^proxy-/.test(loweredName)) {
        console.warn("Refused to set unsafe header \"" + name + "\"");
        return void 0;
      }
      value = value.toString();
      if (loweredName in this._loweredHeaders) {
        name = this._loweredHeaders[loweredName];
        this._headers[name] = this._headers[name] + ', ' + value;
      } else {
        this._loweredHeaders[loweredName] = name;
        this._headers[name] = value;
      }
      return void 0;
    };

    XMLHttpRequest.prototype.send = function(data) {
      if (this.readyState !== XMLHttpRequest.OPENED) {
        throw new InvalidStateError("XHR readyState must be OPENED");
      }
      if (this._request) {
        throw new InvalidStateError("send() already called");
      }
      switch (this._url.protocol) {
        case 'file:':
          this._sendFile(data);
          break;
        case 'http:':
        case 'https:':
          this._sendHttp(data);
          break;
        default:
          throw new NetworkError("Unsupported protocol " + this._url.protocol);
      }
      return void 0;
    };

    XMLHttpRequest.prototype.abort = function() {
      if (!this._request) {
        return;
      }
      this._request.abort();
      this._setError();
      this._dispatchProgress('abort');
      this._dispatchProgress('loadend');
      return void 0;
    };

    XMLHttpRequest.prototype.getResponseHeader = function(name) {
      var loweredName;
      if (!this._responseHeaders) {
        return null;
      }
      loweredName = name.toLowerCase();
      if (loweredName in this._responseHeaders) {
        return this._responseHeaders[loweredName];
      } else {
        return null;
      }
    };

    XMLHttpRequest.prototype.getAllResponseHeaders = function() {
      var lines, name, value;
      if (!this._responseHeaders) {
        return '';
      }
      lines = (function() {
        var ref, results;
        ref = this._responseHeaders;
        results = [];
        for (name in ref) {
          value = ref[name];
          results.push(name + ": " + value);
        }
        return results;
      }).call(this);
      return lines.join("\r\n");
    };

    XMLHttpRequest.prototype.overrideMimeType = function(newMimeType) {
      if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {
        throw new InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
      }
      this._mimeOverride = newMimeType.toLowerCase();
      return void 0;
    };

    XMLHttpRequest.prototype.nodejsSet = function(options) {
      var baseUrl, parsedUrl;
      if ('httpAgent' in options) {
        this.nodejsHttpAgent = options.httpAgent;
      }
      if ('httpsAgent' in options) {
        this.nodejsHttpsAgent = options.httpsAgent;
      }
      if ('baseUrl' in options) {
        baseUrl = options.baseUrl;
        if (baseUrl !== null) {
          parsedUrl = url.parse(baseUrl, false, true);
          if (!parsedUrl.protocol) {
            throw new SyntaxError("baseUrl must be an absolute URL");
          }
        }
        this.nodejsBaseUrl = baseUrl;
      }
      return void 0;
    };

    XMLHttpRequest.nodejsSet = function(options) {
      XMLHttpRequest.prototype.nodejsSet(options);
      return void 0;
    };

    XMLHttpRequest.prototype.UNSENT = 0;

    XMLHttpRequest.UNSENT = 0;

    XMLHttpRequest.prototype.OPENED = 1;

    XMLHttpRequest.OPENED = 1;

    XMLHttpRequest.prototype.HEADERS_RECEIVED = 2;

    XMLHttpRequest.HEADERS_RECEIVED = 2;

    XMLHttpRequest.prototype.LOADING = 3;

    XMLHttpRequest.LOADING = 3;

    XMLHttpRequest.prototype.DONE = 4;

    XMLHttpRequest.DONE = 4;

    XMLHttpRequest.prototype.nodejsHttpAgent = http.globalAgent;

    XMLHttpRequest.prototype.nodejsHttpsAgent = https.globalAgent;

    XMLHttpRequest.prototype.nodejsBaseUrl = null;

    XMLHttpRequest.prototype._restrictedMethods = {
      CONNECT: true,
      TRACE: true,
      TRACK: true
    };

    XMLHttpRequest.prototype._restrictedHeaders = {
      'accept-charset': true,
      'accept-encoding': true,
      'access-control-request-headers': true,
      'access-control-request-method': true,
      connection: true,
      'content-length': true,
      cookie: true,
      cookie2: true,
      date: true,
      dnt: true,
      expect: true,
      host: true,
      'keep-alive': true,
      origin: true,
      referer: true,
      te: true,
      trailer: true,
      'transfer-encoding': true,
      upgrade: true,
      'user-agent': true,
      via: true
    };

    XMLHttpRequest.prototype._privateHeaders = {
      'set-cookie': true,
      'set-cookie2': true
    };

    XMLHttpRequest.prototype._userAgent = ("Mozilla/5.0 (" + (os.type()) + " " + (os.arch()) + ") ") + ("node.js/" + process.versions.node + " v8/" + process.versions.v8);

    XMLHttpRequest.prototype._setReadyState = function(newReadyState) {
      var event;
      this.readyState = newReadyState;
      event = new ProgressEvent('readystatechange');
      this.dispatchEvent(event);
      return void 0;
    };

    XMLHttpRequest.prototype._sendFile = function() {
      if (this._url.method !== 'GET') {
        throw new NetworkError('The file protocol only supports GET');
      }
      throw new Error("Protocol file: not implemented");
    };

    XMLHttpRequest.prototype._sendHttp = function(data) {
      if (this._sync) {
        throw new Error("Synchronous XHR processing not implemented");
      }
      if ((data != null) && (this._method === 'GET' || this._method === 'HEAD')) {
        console.warn("Discarding entity body for " + this._method + " requests");
        data = null;
      } else {
        data || (data = '');
      }
      this.upload._setData(data);
      this._finalizeHeaders();
      this._sendHxxpRequest();
      return void 0;
    };

    XMLHttpRequest.prototype._sendHxxpRequest = function() {
      var agent, hxxp, request;
      if (this._url.protocol === 'http:') {
        hxxp = http;
        agent = this.nodejsHttpAgent;
      } else {
        hxxp = https;
        agent = this.nodejsHttpsAgent;
      }
      request = hxxp.request({
        hostname: this._url.hostname,
        port: this._url.port,
        path: this._url.path,
        auth: this._url.auth,
        method: this._method,
        headers: this._headers,
        agent: agent
      });
      this._request = request;
      if (this.timeout) {
        request.setTimeout(this.timeout, (function(_this) {
          return function() {
            return _this._onHttpTimeout(request);
          };
        })(this));
      }
      request.on('response', (function(_this) {
        return function(response) {
          return _this._onHttpResponse(request, response);
        };
      })(this));
      request.on('error', (function(_this) {
        return function(error) {
          return _this._onHttpRequestError(request, error);
        };
      })(this));
      this.upload._startUpload(request);
      if (this._request === request) {
        this._dispatchProgress('loadstart');
      }
      return void 0;
    };

    XMLHttpRequest.prototype._finalizeHeaders = function() {
      this._headers['Connection'] = 'keep-alive';
      this._headers['Host'] = this._url.host;
      if (this._anonymous) {
        this._headers['Referer'] = 'about:blank';
      }
      this._headers['User-Agent'] = this._userAgent;
      this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
      return void 0;
    };

    XMLHttpRequest.prototype._onHttpResponse = function(request, response) {
      var lengthString;
      if (this._request !== request) {
        return;
      }
      switch (response.statusCode) {
        case 301:
        case 302:
        case 303:
        case 307:
        case 308:
          this._url = this._parseUrl(response.headers['location']);
          this._method = 'GET';
          if ('content-type' in this._loweredHeaders) {
            delete this._headers[this._loweredHeaders['content-type']];
            delete this._loweredHeaders['content-type'];
          }
          if ('Content-Type' in this._headers) {
            delete this._headers['Content-Type'];
          }
          delete this._headers['Content-Length'];
          this.upload._reset();
          this._finalizeHeaders();
          this._sendHxxpRequest();
          return;
      }
      this._response = response;
      this._response.on('data', (function(_this) {
        return function(data) {
          return _this._onHttpResponseData(response, data);
        };
      })(this));
      this._response.on('end', (function(_this) {
        return function() {
          return _this._onHttpResponseEnd(response);
        };
      })(this));
      this._response.on('close', (function(_this) {
        return function() {
          return _this._onHttpResponseClose(response);
        };
      })(this));
      this.responseURL = this._url.href.split('#')[0];
      this.status = this._response.statusCode;
      this.statusText = http.STATUS_CODES[this.status];
      this._parseResponseHeaders(response);
      if (lengthString = this._responseHeaders['content-length']) {
        this._totalBytes = parseInt(lengthString);
        this._lengthComputable = true;
      } else {
        this._lengthComputable = false;
      }
      return this._setReadyState(XMLHttpRequest.HEADERS_RECEIVED);
    };

    XMLHttpRequest.prototype._onHttpResponseData = function(response, data) {
      if (this._response !== response) {
        return;
      }
      this._responseParts.push(data);
      this._loadedBytes += data.length;
      if (this.readyState !== XMLHttpRequest.LOADING) {
        this._setReadyState(XMLHttpRequest.LOADING);
      }
      return this._dispatchProgress('progress');
    };

    XMLHttpRequest.prototype._onHttpResponseEnd = function(response) {
      if (this._response !== response) {
        return;
      }
      this._parseResponse();
      this._request = null;
      this._response = null;
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('load');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpResponseClose = function(response) {
      var request;
      if (this._response !== response) {
        return;
      }
      request = this._request;
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('error');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpTimeout = function(request) {
      if (this._request !== request) {
        return;
      }
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('timeout');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._onHttpRequestError = function(request, error) {
      if (this._request !== request) {
        return;
      }
      this._setError();
      request.abort();
      this._setReadyState(XMLHttpRequest.DONE);
      this._dispatchProgress('error');
      return this._dispatchProgress('loadend');
    };

    XMLHttpRequest.prototype._dispatchProgress = function(eventType) {
      var event;
      event = new ProgressEvent(eventType);
      event.lengthComputable = this._lengthComputable;
      event.loaded = this._loadedBytes;
      event.total = this._totalBytes;
      this.dispatchEvent(event);
      return void 0;
    };

    XMLHttpRequest.prototype._setError = function() {
      this._request = null;
      this._response = null;
      this._responseHeaders = null;
      this._responseParts = null;
      return void 0;
    };

    XMLHttpRequest.prototype._parseUrl = function(urlString) {
      var absoluteUrlString, index, password, user, xhrUrl;
      if (this.nodejsBaseUrl === null) {
        absoluteUrlString = urlString;
      } else {
        absoluteUrlString = url.resolve(this.nodejsBaseUrl, urlString);
      }
      xhrUrl = url.parse(absoluteUrlString, false, true);
      xhrUrl.hash = null;
      if (xhrUrl.auth && ((typeof user !== "undefined" && user !== null) || (typeof password !== "undefined" && password !== null))) {
        index = xhrUrl.auth.indexOf(':');
        if (index === -1) {
          if (!user) {
            user = xhrUrl.auth;
          }
        } else {
          if (!user) {
            user = xhrUrl.substring(0, index);
          }
          if (!password) {
            password = xhrUrl.substring(index + 1);
          }
        }
      }
      if (user || password) {
        xhrUrl.auth = user + ":" + password;
      }
      return xhrUrl;
    };

    XMLHttpRequest.prototype._parseResponseHeaders = function(response) {
      var loweredName, name, ref, value;
      this._responseHeaders = {};
      ref = response.headers;
      for (name in ref) {
        value = ref[name];
        loweredName = name.toLowerCase();
        if (this._privateHeaders[loweredName]) {
          continue;
        }
        if (this._mimeOverride !== null && loweredName === 'content-type') {
          value = this._mimeOverride;
        }
        this._responseHeaders[loweredName] = value;
      }
      if (this._mimeOverride !== null && !('content-type' in this._responseHeaders)) {
        this._responseHeaders['content-type'] = this._mimeOverride;
      }
      return void 0;
    };

    XMLHttpRequest.prototype._parseResponse = function() {
      var arrayBuffer, buffer, i, j, jsonError, ref, view;
      if (Buffer.concat) {
        buffer = Buffer.concat(this._responseParts);
      } else {
        buffer = this._concatBuffers(this._responseParts);
      }
      this._responseParts = null;
      switch (this.responseType) {
        case 'text':
          this._parseTextResponse(buffer);
          break;
        case 'json':
          this.responseText = null;
          try {
            this.response = JSON.parse(buffer.toString('utf-8'));
          } catch (error1) {
            jsonError = error1;
            this.response = null;
          }
          break;
        case 'buffer':
          this.responseText = null;
          this.response = buffer;
          break;
        case 'arraybuffer':
          this.responseText = null;
          arrayBuffer = new ArrayBuffer(buffer.length);
          view = new Uint8Array(arrayBuffer);
          for (i = j = 0, ref = buffer.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            view[i] = buffer[i];
          }
          this.response = arrayBuffer;
          break;
        default:
          this._parseTextResponse(buffer);
      }
      return void 0;
    };

    XMLHttpRequest.prototype._parseTextResponse = function(buffer) {
      var e;
      try {
        this.responseText = buffer.toString(this._parseResponseEncoding());
      } catch (error1) {
        e = error1;
        this.responseText = buffer.toString('binary');
      }
      this.response = this.responseText;
      return void 0;
    };

    XMLHttpRequest.prototype._parseResponseEncoding = function() {
      var contentType, encoding, match;
      encoding = null;
      if (contentType = this._responseHeaders['content-type']) {
        if (match = /\;\s*charset\=(.*)$/.exec(contentType)) {
          return match[1];
        }
      }
      return 'utf-8';
    };

    XMLHttpRequest.prototype._concatBuffers = function(buffers) {
      var buffer, j, k, len, len1, length, target;
      if (buffers.length === 0) {
        return new Buffer(0);
      }
      if (buffers.length === 1) {
        return buffers[0];
      }
      length = 0;
      for (j = 0, len = buffers.length; j < len; j++) {
        buffer = buffers[j];
        length += buffer.length;
      }
      target = new Buffer(length);
      length = 0;
      for (k = 0, len1 = buffers.length; k < len1; k++) {
        buffer = buffers[k];
        buffer.copy(target, length);
        length += buffer.length;
      }
      return target;
    };

    return XMLHttpRequest;

  })(XMLHttpRequestEventTarget);

  module.exports = XMLHttpRequest;

  XMLHttpRequest.XMLHttpRequest = XMLHttpRequest;

  SecurityError = (function(superClass) {
    extend(SecurityError, superClass);

    function SecurityError() {
      SecurityError.__super__.constructor.apply(this, arguments);
    }

    return SecurityError;

  })(Error);

  XMLHttpRequest.SecurityError = SecurityError;

  InvalidStateError = (function(superClass) {
    extend(InvalidStateError, superClass);

    function InvalidStateError() {
      InvalidStateError.__super__.constructor.apply(this, arguments);
    }

    return InvalidStateError;

  })(Error);

  InvalidStateError = (function(superClass) {
    extend(InvalidStateError, superClass);

    function InvalidStateError() {
      return InvalidStateError.__super__.constructor.apply(this, arguments);
    }

    return InvalidStateError;

  })(Error);

  XMLHttpRequest.InvalidStateError = InvalidStateError;

  NetworkError = (function(superClass) {
    extend(NetworkError, superClass);

    function NetworkError() {
      NetworkError.__super__.constructor.apply(this, arguments);
    }

    return NetworkError;

  })(Error);

  XMLHttpRequest.SyntaxError = SyntaxError;

  SyntaxError = (function(superClass) {
    extend(SyntaxError, superClass);

    function SyntaxError() {
      SyntaxError.__super__.constructor.apply(this, arguments);
    }

    return SyntaxError;

  })(Error);

  ProgressEvent = (function() {
    function ProgressEvent(type) {
      this.type = type;
      this.target = null;
      this.currentTarget = null;
      this.lengthComputable = false;
      this.loaded = 0;
      this.total = 0;
    }

    ProgressEvent.prototype.bubbles = false;

    ProgressEvent.prototype.cancelable = false;

    ProgressEvent.prototype.target = null;

    ProgressEvent.prototype.loaded = null;

    ProgressEvent.prototype.lengthComputable = null;

    ProgressEvent.prototype.total = null;

    return ProgressEvent;

  })();

  XMLHttpRequest.ProgressEvent = ProgressEvent;

  XMLHttpRequestUpload = (function(superClass) {
    extend(XMLHttpRequestUpload, superClass);

    function XMLHttpRequestUpload(request) {
      XMLHttpRequestUpload.__super__.constructor.call(this);
      this._request = request;
      this._reset();
    }

    XMLHttpRequestUpload.prototype._reset = function() {
      this._contentType = null;
      this._body = null;
      return void 0;
    };

    XMLHttpRequestUpload.prototype._setData = function(data) {
      var body, i, j, k, offset, ref, ref1, view;
      if (typeof data === 'undefined' || data === null) {
        return;
      }
      if (typeof data === 'string') {
        if (data.length !== 0) {
          this._contentType = 'text/plain;charset=UTF-8';
        }
        this._body = new Buffer(data, 'utf8');
      } else if (Buffer.isBuffer(data)) {
        this._body = data;
      } else if (data instanceof ArrayBuffer) {
        body = new Buffer(data.byteLength);
        view = new Uint8Array(data);
        for (i = j = 0, ref = data.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          body[i] = view[i];
        }
        this._body = body;
      } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
        body = new Buffer(data.byteLength);
        offset = data.byteOffset;
        view = new Uint8Array(data.buffer);
        for (i = k = 0, ref1 = data.byteLength; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          body[i] = view[i + offset];
        }
        this._body = body;
      } else {
        throw new Error("Unsupported send() data " + data);
      }
      return void 0;
    };

    XMLHttpRequestUpload.prototype._finalizeHeaders = function(headers, loweredHeaders) {
      if (this._contentType) {
        if (!('content-type' in loweredHeaders)) {
          headers['Content-Type'] = this._contentType;
        }
      }
      if (this._body) {
        headers['Content-Length'] = this._body.length.toString();
      }
      return void 0;
    };

    XMLHttpRequestUpload.prototype._startUpload = function(request) {
      if (this._body) {
        request.write(this._body);
      }
      request.end();
      return void 0;
    };

    return XMLHttpRequestUpload;

  })(XMLHttpRequestEventTarget);

  XMLHttpRequest.XMLHttpRequestUpload = XMLHttpRequestUpload;

}).call(this);


/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(78);

/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_server__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_server___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_platform_server__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app_shared_module__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_app_app_component__ = __webpack_require__(56);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




var AppModule = /** @class */ (function () {
    function AppModule() {
    }
    AppModule = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            bootstrap: [__WEBPACK_IMPORTED_MODULE_3__components_app_app_component__["a" /* AppComponent */]],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_platform_server__["ServerModule"],
                __WEBPACK_IMPORTED_MODULE_2__app_shared_module__["a" /* AppModuleShared */]
            ]
        })
    ], AppModule);
    return AppModule;
}());



/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppModuleShared; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__angular_forms__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common_http__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_common_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__angular_common_http__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_router__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__angular_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__angular_router__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_app_app_component__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_navmenu_navmenu_component__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_home_home_component__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_fetchdata_fetchdata_component__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__components_counter_counter_component__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__components_cart_cart_component__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__components_cart_checkout_checkout_component__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__components_cart_preview_preview_component__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__components_cart_reciept_receipt_component__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__components_shop_shop_component__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__components_shop_cookbooks_cookbooks_component__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__components_shop_bakingplanks_bakingplanks_component__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__components_shop_bbqplanks_bbqplanks_component__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__components_shop_nutdriver_nutdriver_component__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__components_shop_spicerubs_spicerubs_component__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__components_shop_sidemenu_component__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__services_plankcooking_service__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










//Cart




//Shop








var AppModuleShared = /** @class */ (function () {
    function AppModuleShared() {
    }
    AppModuleShared = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
            declarations: [
                __WEBPACK_IMPORTED_MODULE_5__components_app_app_component__["a" /* AppComponent */],
                __WEBPACK_IMPORTED_MODULE_6__components_navmenu_navmenu_component__["a" /* NavMenuComponent */],
                __WEBPACK_IMPORTED_MODULE_9__components_counter_counter_component__["a" /* CounterComponent */],
                __WEBPACK_IMPORTED_MODULE_8__components_fetchdata_fetchdata_component__["a" /* FetchDataComponent */],
                __WEBPACK_IMPORTED_MODULE_7__components_home_home_component__["a" /* HomeComponent */],
                __WEBPACK_IMPORTED_MODULE_10__components_cart_cart_component__["a" /* CartComponent */],
                __WEBPACK_IMPORTED_MODULE_14__components_shop_shop_component__["a" /* ShopComponent */],
                __WEBPACK_IMPORTED_MODULE_15__components_shop_cookbooks_cookbooks_component__["a" /* ShopCookbooksComponent */],
                __WEBPACK_IMPORTED_MODULE_16__components_shop_bakingplanks_bakingplanks_component__["a" /* ShopBakingPlanksComponent */],
                __WEBPACK_IMPORTED_MODULE_17__components_shop_bbqplanks_bbqplanks_component__["a" /* ShopBbqPlanksComponent */],
                __WEBPACK_IMPORTED_MODULE_18__components_shop_nutdriver_nutdriver_component__["a" /* ShopNutDriverComponent */],
                __WEBPACK_IMPORTED_MODULE_19__components_shop_spicerubs_spicerubs_component__["a" /* ShopSpiceRubsComponent */],
                __WEBPACK_IMPORTED_MODULE_20__components_shop_sidemenu_component__["a" /* SideMenuComponent */],
                __WEBPACK_IMPORTED_MODULE_11__components_cart_checkout_checkout_component__["a" /* CheckoutComponent */],
                __WEBPACK_IMPORTED_MODULE_12__components_cart_preview_preview_component__["a" /* PreviewComponent */],
                __WEBPACK_IMPORTED_MODULE_13__components_cart_reciept_receipt_component__["a" /* ReceiptComponent */]
            ],
            imports: [
                __WEBPACK_IMPORTED_MODULE_1__angular_common__["CommonModule"],
                __WEBPACK_IMPORTED_MODULE_3__angular_common_http__["HttpClientModule"],
                __WEBPACK_IMPORTED_MODULE_2__angular_forms__["FormsModule"],
                __WEBPACK_IMPORTED_MODULE_4__angular_router__["RouterModule"].forRoot([
                    { path: '', redirectTo: 'Home', pathMatch: 'full' },
                    { path: 'Home', component: __WEBPACK_IMPORTED_MODULE_7__components_home_home_component__["a" /* HomeComponent */] },
                    { path: 'counter', component: __WEBPACK_IMPORTED_MODULE_9__components_counter_counter_component__["a" /* CounterComponent */] },
                    { path: 'fetch-data', component: __WEBPACK_IMPORTED_MODULE_8__components_fetchdata_fetchdata_component__["a" /* FetchDataComponent */] },
                    { path: "cart", component: __WEBPACK_IMPORTED_MODULE_10__components_cart_cart_component__["a" /* CartComponent */] },
                    { path: "Cart", component: __WEBPACK_IMPORTED_MODULE_10__components_cart_cart_component__["a" /* CartComponent */] },
                    { path: "Cart/Checkout", component: __WEBPACK_IMPORTED_MODULE_11__components_cart_checkout_checkout_component__["a" /* CheckoutComponent */] },
                    { path: "Cart/Preview", component: __WEBPACK_IMPORTED_MODULE_12__components_cart_preview_preview_component__["a" /* PreviewComponent */] },
                    { path: "Cart/Receipt", component: __WEBPACK_IMPORTED_MODULE_13__components_cart_reciept_receipt_component__["a" /* ReceiptComponent */] },
                    { path: "shop", component: __WEBPACK_IMPORTED_MODULE_14__components_shop_shop_component__["a" /* ShopComponent */] },
                    { path: "Shop", component: __WEBPACK_IMPORTED_MODULE_14__components_shop_shop_component__["a" /* ShopComponent */] },
                    { path: "Shop/CookBooks", component: __WEBPACK_IMPORTED_MODULE_15__components_shop_cookbooks_cookbooks_component__["a" /* ShopCookbooksComponent */] },
                    { path: "Shop/BakingPlanks", component: __WEBPACK_IMPORTED_MODULE_16__components_shop_bakingplanks_bakingplanks_component__["a" /* ShopBakingPlanksComponent */] },
                    { path: "Shop/BbqPlanks", component: __WEBPACK_IMPORTED_MODULE_17__components_shop_bbqplanks_bbqplanks_component__["a" /* ShopBbqPlanksComponent */] },
                    { path: "Shop/NutDriver", component: __WEBPACK_IMPORTED_MODULE_18__components_shop_nutdriver_nutdriver_component__["a" /* ShopNutDriverComponent */] },
                    { path: "Shop/SpiceRubs", component: __WEBPACK_IMPORTED_MODULE_19__components_shop_spicerubs_spicerubs_component__["a" /* ShopSpiceRubsComponent */] },
                    { path: "Shop/SideMenu", component: __WEBPACK_IMPORTED_MODULE_20__components_shop_sidemenu_component__["a" /* SideMenuComponent */] },
                    { path: '**', redirectTo: 'Home' }
                ])
            ],
            providers: [
                __WEBPACK_IMPORTED_MODULE_21__services_plankcooking_service__["a" /* PlankCookingService */]
            ]
        })
    ], AppModuleShared);
    return AppModuleShared;
}());



/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(83);

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(1))(89);

/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = "<div class='container-fluid'>\n    <div class='row'>\n        <div class='col-xs-12 body-content'>\n            <router-outlet></router-outlet>\n        </div>\n    </div>\n</div>\n";

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(101);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, "@media (max-width: 767px) {\n    /* On small screens, the nav menu spans the full width of the screen. Leave a space for it. */\n    .body-content {\n        padding-top: 50px;\n    }\n}\n", ""]);

// exports


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NavMenuComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var NavMenuComponent = /** @class */ (function () {
    function NavMenuComponent() {
    }
    NavMenuComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'nav-menu',
            template: __webpack_require__(103),
            styles: [__webpack_require__(104)]
        })
    ], NavMenuComponent);
    return NavMenuComponent;
}());



/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = "<div class='main-nav'>\n    <div class='navbar navbar-inverse'>\n        <div class='navbar-header'>\n            <button type='button' class='navbar-toggle' data-toggle='collapse' data-target='.navbar-collapse'>\n                <span class='sr-only'>Toggle navigation</span>\n                <span class='icon-bar'></span>\n                <span class='icon-bar'></span>\n                <span class='icon-bar'></span>\n            </button>\n            <a class='navbar-brand' [routerLink]=\"['/home']\">PlankCooking</a>\n        </div>\n        <div class='clearfix'></div>\n        <div class='navbar-collapse collapse'>\n            <ul class='nav navbar-nav'>\n                <li [routerLinkActive]=\"['link-active']\">\n                    <a [routerLink]=\"['/home']\">\n                        <span class='glyphicon glyphicon-home'></span> Home\n                    </a>\n                </li>\n                <li [routerLinkActive]=\"['link-active']\">\n                    <a [routerLink]=\"['/counter']\">\n                        <span class='glyphicon glyphicon-education'></span> Counter\n                    </a>\n                </li>\n                <li [routerLinkActive]=\"['link-active']\">\n                    <a [routerLink]=\"['/fetch-data']\">\n                        <span class='glyphicon glyphicon-th-list'></span> Fetch data\n                    </a>\n                </li>\n            </ul>\n        </div>\n    </div>\n</div>\n";

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(105);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, "li .glyphicon {\n    margin-right: 10px;\n}\n\n/* Highlighting rules for nav menu items */\nli.link-active a,\nli.link-active a:hover,\nli.link-active a:focus {\n    background-color: #4189C7;\n    color: white;\n}\n\n/* Keep the nav menu independent of scrolling and on top of other items */\n.main-nav {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    z-index: 1;\n}\n\n@media (min-width: 768px) {\n    /* On small screens, convert the nav menu to a vertical sidebar */\n    .main-nav {\n        height: 100%;\n        width: calc(25% - 20px);\n    }\n    .navbar {\n        border-radius: 0px;\n        border-width: 0px;\n        height: 100%;\n    }\n    .navbar-header {\n        float: none;\n    }\n    .navbar-collapse {\n        border-top: 1px solid #444;\n        padding: 0px;\n    }\n    .navbar ul {\n        float: none;\n    }\n    .navbar li {\n        float: none;\n        font-size: 15px;\n        margin: 6px;\n    }\n    .navbar li a {\n        padding: 10px 16px;\n        border-radius: 4px;\n    }\n    .navbar a {\n        /* If a menu item's text is too long, truncate it */\n        width: 100%;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n    }\n}\n", ""]);

// exports


/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HomeComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var HomeComponent = /** @class */ (function () {
    function HomeComponent() {
    }
    HomeComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'home',
            template: __webpack_require__(107)
        })
    ], HomeComponent);
    return HomeComponent;
}());



/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = "<h1>Hello, world!</h1>\n<p>Welcome to your new single-page application, built with:</p>\n<ul>\n    <li><a href='https://get.asp.net/'>ASP.NET Core</a> and <a href='https://msdn.microsoft.com/en-us/library/67ef8sbd.aspx'>C#</a> for cross-platform server-side code</li>\n    <li><a href='https://angular.io/'>Angular</a> and <a href='http://www.typescriptlang.org/'>TypeScript</a> for client-side code</li>\n    <li><a href='https://webpack.github.io/'>Webpack</a> for building and bundling client-side resources</li>\n    <li><a href='http://getbootstrap.com/'>Bootstrap</a> for layout and styling</li>\n</ul>\n<p>To help you get started, we've also set up:</p>\n<ul>\n    <li><strong>Client-side navigation</strong>. For example, click <em>Counter</em> then <em>Back</em> to return here.</li>\n    <li><strong>Server-side prerendering</strong>. For faster initial loading and improved SEO, your Angular app is prerendered on the server. The resulting HTML is then transferred to the browser where a client-side copy of the app takes over.</li>\n    <li><strong>Webpack dev middleware</strong>. In development mode, there's no need to run the <code>webpack</code> build tool. Your client-side resources are dynamically built on demand. Updates are available as soon as you modify any file.</li>\n    <li><strong>Hot module replacement</strong>. In development mode, you don't even need to reload the page after making most changes. Within seconds of saving changes to files, your Angular app will be rebuilt and a new instance injected into the page.</li>\n    <li><strong>Efficient production builds</strong>. In production mode, development-time features are disabled, and the <code>webpack</code> build tool produces minified static CSS and JavaScript files.</li>\n</ul>\n";

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FetchDataComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_http__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


var FetchDataComponent = /** @class */ (function () {
    function FetchDataComponent(http, baseUrl) {
        var _this = this;
        this.forecasts = [];
        http.get(baseUrl + 'api/SampleData/WeatherForecasts').subscribe(function (result) {
            _this.forecasts = result.json();
        }, function (error) { return console.error(error); });
    }
    FetchDataComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'fetchdata',
            template: __webpack_require__(109)
        }),
        __param(1, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Inject"])('BASE_URL')),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_http__["Http"], String])
    ], FetchDataComponent);
    return FetchDataComponent;
}());



/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = "<h1>Weather forecast</h1>\n\n<p>This component demonstrates fetching data from the server.</p>\n\n<p *ngIf=\"!forecasts\"><em>Loading...</em></p>\n\n<table class='table' *ngIf=\"forecasts\">\n    <thead>\n        <tr>\n            <th>Date</th>\n            <th>Temp. (C)</th>\n            <th>Temp. (F)</th>\n            <th>Summary</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr *ngFor=\"let forecast of forecasts\">\n            <td>{{ forecast.dateFormatted }}</td>\n            <td>{{ forecast.temperatureC }}</td>\n            <td>{{ forecast.temperatureF }}</td>\n            <td>{{ forecast.summary }}</td>\n        </tr>\n    </tbody>\n</table>\n";

/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CounterComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var CounterComponent = /** @class */ (function () {
    function CounterComponent() {
        this.currentCount = 0;
    }
    CounterComponent.prototype.incrementCounter = function () {
        this.currentCount++;
    };
    CounterComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'counter',
            template: __webpack_require__(111)
        })
    ], CounterComponent);
    return CounterComponent;
}());



/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = "<h1>Counter</h1>\n\n<p>This is a simple example of an Angular component.</p>\n\n<p>Current count: <strong>{{ currentCount }}</strong></p>\n\n<button (click)=\"incrementCounter()\">Increment</button>\n";

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CartComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var CartComponent = /** @class */ (function () {
    function CartComponent() {
    }
    CartComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: "cart",
            template: __webpack_require__(113),
            styles: [__webpack_require__(114)]
        })
    ], CartComponent);
    return CartComponent;
}());



/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "\n    <div id=\"content\" class=\"mainContent\">\n     \n                <div class=\"hidden-xs\">\n                    <div class=\"row shoppingRow\">\n                        <div class=\"col-sm-7 col-md-8 col-lg-8 shoppingText\">\n                            <div class=\"headerStyle\">SHOPPING CART: Your shopping cart contains 1 items.</div>\n                        </div>\n                        <div class=\"col-sm-5 col-md-4 col-lg-4 textRight\"><a class=\"linkStyle\" routerLink=\"/Cart/Checkout\"><img class=\"linkImgStyle\" alt=\"Check Out\" src=\"" + __webpack_require__(15) + "\"></a> <a class=\"linkStyle\" routerLink=\"/Shop\"><img alt=\"continue shopping\" class=\"img-responsive\" src=\"" + __webpack_require__(16) + "\"></a></div>\n                      \n                    </div>\n                    <div class=\"tableStyle\">\n                        <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                            <tbody>\n                                <tr>\n                                    <td class=\"titleStyle\">Shipping to You</td>\n                                    <td class=\"tableColumnsStyle\">Price</td>\n                                    <td class=\"tableColumnsStyle\">Quantity</td>\n                                    <td class=\"tableColumnsStyle\">Total</td>\n                                </tr>\n                               \n                                <tr>\n                                    <td  class=\"productTitleStyle\">SPORT Steak Seasoning Rub</td>\n                                    <td class=\"productRows\">$5.00</td>\n                                    <td class=\"productRows\"><input class=\"quantityStyle\"></td>\n                                    <td class=\"productTotal\">\n                                        <div class=\"pricePadding\">$5.00</div>\n                                        <div class=\"removeDivStyle\"><img class=\"removeImg\" src=\"" + __webpack_require__(57) + "\"></div>\n                                    </td>\n                                </tr>\n                                \n                                <tr>\n                                    \n                                    <td class=\"tdSpace\">&nbsp;</td>\n                                    <td class=\"subTitleStyle\">Subtotal:</td>\n                                    <td class=\"priceStyle\">$5.00</td>\n                                </tr>\n                    \n                                <tr>\n                                    <td colspan=\"4\" class=\"mainLinkStyle\"><a class=\"checkOutLink\" routerLink=\"/Cart/Checkout\"><img alt=\"Check Out\" class=\"checkOutImg\" src=\"" + __webpack_require__(15) + "\"></a><a routerLink=\"/Shop\" class=\"continueLinkStyle\"><img alt=\"Continue Shopping\"  class=\"img-responsive\" src=\"" + __webpack_require__(16) + "\"></a></td>\n                                </tr>\n                            </tbody>\n                        </table>\n                    </div>\n                </div>\n                <div class=\"visible-xs\">\n                    <div class=\"row shoppingRowSmall\">\n                        <div class=\"col-xs-6 shoppingText\">\n                            <div class=\"headerStyleSmall\">SHOPPING CART: Your shopping cart contains 1 items.</div>\n                            \n                        </div>\n                        <div class=\"col-xs-6 textRight\"><a routerLink=\"/Cart/Checkout\"><img alt=\"Check Out\" class=\"img-responsive smallImgStyle\"  src=\"" + __webpack_require__(15) + "\"></a><a routerLink=\"/Shop\" class=\"smallLinkStyle\"><img alt=\"Continue Shopping\" class=\"img-responsive\" src=\"" + __webpack_require__(16) + "\"></a></div>\n                    </div>\n                    <div class=\"tableStyle\">\n                        <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                            <tbody>\n                                <tr>\n                                    <td class=\"smallTitleStyle\">Shipping to You</td>\n                                    <td class=\"tableColumnsStyle\">Price</td>\n                                    <td class=\"tableColumnsStyle\">Quantity</td>\n                                    <td class=\"tableColumnsStyle\">\n                                        Total\n                                    </td>\n                                </tr>\n                               \n                                <tr>\n                                    <td class=\"smallProductTitle\">SPORT Steak Seasoning Rub</td>\n                                    <td class=\"smallProductRow\">$5.00</td>\n                                    <td class=\"smallQtyRow\"><input class=\"quantityStyle\"></td>\n                                    <td class=\"smallProductTotal\">\n                                        <div class=\"pricePadding \">$5.00</div>\n                                        <div class=\"smallRemoveDivStyle\"><img class=\"removeImg\" src=\"" + __webpack_require__(57) + "\"></div>\n                                    </td>\n                                </tr>\n                                \n                                <tr>\n                                    \n                                    <td class=\"smallTdSpace\">&nbsp;</td>\n                                    <td class=\"smallSubTitleStyle\">Subtotal:</td>\n                                    <td class=\"smallPriceStyle\">$5.00</td>\n                                </tr>\n                                <tr>\n\n                                    <td class=\"smallMainStyle\" colspan=\"4\"><a routerLink=\"/Cart/Checkout\" class=\"smallCheckOutLink\"><img alt=\"Check Out\" src=\"" + __webpack_require__(15) + "\"></a> <a routerLink=\"/Shop\" class=\"smallContinueLinkStyle\"><img alt=\"Continue Shopping\" class=\"img-responsive\" src=\"" + __webpack_require__(16) + "\"></a></td>\n                                </tr>\n                            </tbody>\n                        </table>\n                    </div>\n                </div>\n          \n    </div>\n\n\n\n\n\n\n\n\n\n\n\n<a  [routerLink]=\"['/shop']\">Go To Shop</a>";

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(115);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".mainContent {\n    position: relative; top: 60px;\n}\n\n\n.shoppingRow {\n    height:50px; \n    background-color: #bc9a72; \n    font-family: Cambrian; \n    font-size: 16px; \n    color:#4b290c; \n    font-weight:bold;\n}\n\n.shoppingRowSmall {\n    height:80px; \n    background-color: #bc9a72; \n    font-family: Cambrian; \n    font-size: 14px; \n    color:#4b290c; \n    font-weight:bold;\n}\n\n.shoppingText {\n    text-align:left;\n}\n\n.headerStyle {\n    padding: 15px 0 0 10px;\n}\n\n.headerStyleSmall {\n    padding: 15px 0 0 5px;\n}\n\n.textRight {\n    text-align:right;\n}\n\n.linkStyle {\n    float:right; \n    padding:12px 5px 0 0;\n}\n\n.smallLinkStyle {\n    float:right; \n    padding:12px 5px 0 0;\n}\n\n\n\n.linkImgStyle {\n    cursor:pointer; \n    float:right; \n    padding:0 10px 0 5px;\n}\n\n.smallImgStyle {\n    cursor:pointer; \n    float:right; \n    padding:12px 10px 0 5px;\n}\n\n.tableStyle {\n    background-color: #e8e3c8;\n     margin: 15px 0 0 0; \n    padding: 10px;\n}\n\n\n\n.titleStyle {\n    width: 500px; \n    height: 25px; \n    text-align:left; \n    padding: 5px; \n    background-color: #d2be9d; \n    color: #4b290c; \n    font-weight: bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n    \n}\n\n.smallTitleStyle {\n    width: 500px; \n    height: 25px; \n    padding: 5px; \n    background-color: #d2be9d; \n    color: #4b290c; \n    font-weight: bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.tableColumnsStyle {\n    width: 100px; \n    height: 25px; \n    text-align: center; \n    background-color: #d2be9d; \n    color: #4b290c; \n    font-weight: bold; border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n    \n}\n\n.productTitleStyle {\n    width: 500px; \n    text-align:left; \n    padding: 5px; \n    color: #4b290c; \n    border-top: 1px dashed #929292;\n     border-left: 1px dashed #929292;\n}\n\n.smallProductTitle {\n    padding: 5px;\n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.productRows {\n    width: 100px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallProductRow {\n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n    \n}\n\n.smallQtyRow {\n    padding: 5px;\n    text-align: center;\n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.quantityStyle {\n    width:35px; \n    height:25px; \n    border: 1px solid #929292; \n    text-align:center;\n    \n                                   \n}\n\n.productTotal {\n    width: 100px; \n    text-align:center; \n    color: #4b290c; \n    border-top: 1px dashed #929292;\n     border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;    \n}\n\n.smallProductTotal {\n   text-align: center; \n   color: #4b290c; \n   border-top: 1px dashed #929292; \n   border-left: 1px dashed #929292; \n   border-right: 1px dashed #929292;\n}\n\n.pricePadding {\n    padding-top: 10px;\n}\n\n.removeDivStyle {\n    padding-top: 10px; \n    padding-bottom:5px; \n    text-align: center;\n}\n\n.smallRemoveDivStyle {\n    padding-top: 10px; \n    padding-bottom:5px;\n}\n\n.removeImg {\n    cursor:pointer;\n}\n\n.tdSpace {\n    width: 100px;\n     padding-top: 5px; \n     height: 35px; \n     color: #4b290c; \n     font-weight: bold; \n     text-align: center; \n    border-top: 1px dashed #929292;  \n}\n\n.smallTdSpace {\n    padding-top: 5px; \n    height: 35px; \n    color: #4b290c; \n    font-weight: bold; \n    text-align: center; \n    border-top: 1px dashed #929292;\n}\n\n.subTitleStyle {\n    width: 100px;\n     height: 35px; \n     color: #4b290c; \n     font-weight: bold; \n     text-align: right; \n    border-top: 1px dashed #929292;\n}\n\n.smallSubTitleStyle {\n    height: 35px; \n    color: #4b290c; \n    font-weight: bold; \n    text-align: right; \n    border-top: 1px dashed #929292;\n}\n\n.priceStyle {\n    width: 100px; \n    height: 35px; \n    color: #4b290c; \n    font-weight: bold; \n    text-align: center; \n    border-top: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.smallPriceStyle {\n    height: 35px; \n    color: #4b290c; \n    font-weight: bold; \n    text-align: center; \n    border-top: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.mainLinkStyle {\n    height: 45px; \n    border: 1px dashed #929292; \n    padding-right:5px; \n    text-align:right;\n}\n\n.smallMainStyle {\n    height: 45px; \n    border: 1px dashed #929292; \n    text-align: right; \n    padding-right:5px;\n}\n\n.checkOutLink {\n    float:right; \n    padding:12px 5px 0 0;\n}\n\n.smallCheckOutLink {\n    float:right; \n    padding:0 0 0 5px;\n}\n\n.checkOutImg {\n    cursor:pointer; \n    float:right; \n    padding:0 0 0 5px;\n}\n\n.continueLinkStyle {\n    float:right; \n    padding:10px 5px 0 0;\n}\n\n.smallContinueLinkStyle {\n    float:right; \n    padding: 0 5px 0 0;\n}", ""]);

// exports


/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CheckoutComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var CheckoutComponent = /** @class */ (function () {
    function CheckoutComponent() {
    }
    CheckoutComponent.prototype.ngOnInit = function () { };
    CheckoutComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'checkout',
            template: __webpack_require__(117),
            styles: [__webpack_require__(118)]
        }),
        __metadata("design:paramtypes", [])
    ], CheckoutComponent);
    return CheckoutComponent;
}());



/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = "\n        <div class=\"container\">\n        \n        <div id=\"content\" class=\"mainContent\">\n          \n                  \n                    <form name=\"checkoutForm\" class=\"hidden-xs\">\n                        <div class=\"mainFormDiv\">\n                            <div class=\"titleDiv\"> <span>Enter Billing &amp; Shipping Information &gt; Step 2 of 4</span></div>\n\n                            <div class=\"tablePadding\">\n                                <table border=\"0\" cellpadding=\"5\" cellspacing=\"5\" width=\"100%\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"addressStyle\">Billing Address</td>\n                                            <td class=\"addressStyle\"><span class=\"shippingAddressPadding\">Shipping Address</span> <input type=\"checkbox\"> Same as Billing Address</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"outerTd\" valign=\"top\">\n                                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n                                                    <tbody>\n                                                        <tr>\n                                                            <td class=\"alignRight\">First Name:</td>\n                                                            <td><input name=\"billingFirstName\" maxlength=\"100\" class=\"textBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Last Name:</td>\n                                                            <td><input name=\"billingLastName\" maxlength=\"100\" class=\"textBox\" /></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Address:</td>\n                                                            <td><input name=\"billingAddress1\" maxlength=\"250\" class=\"textBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Address 2:</td>\n                                                            <td><input name=\"billingAddress2\" maxlength=\"250\" class=\"textBox\" placeholder=\"Optional\" /></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">City:</td>\n                                                            <td><input name=\"billingCity\" maxlength=\"100\" class=\"textBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">State:</td>\n                                                            <td>\n                                                                <select class=\"textBox\" name=\"billingState\">\n                                                                    <option value=\"?\">Select</option>\n                                                                    <option value=\"AL\">Alabama</option>\n                                                                    <option value=\"AK\">Alaska</option>\n                                                                    <option value=\"AZ\">Arizona</option>\n                                                                    <option value=\"AR\">Arkansas</option>\n                                                                    <option value=\"CA\">California</option>\n                                                                    <option value=\"CO\">Colorado</option>\n                                                                    <option value=\"CT\">Connecticut</option>\n                                                                    <option value=\"DE\">Delaware</option>\n                                                                    <option value=\"DC\">Dist of Columbia</option>\n                                                                    <option value=\"FL\">Florida</option>\n                                                                    <option value=\"GA\">Georgia</option>\n                                                                    <option value=\"HI\">Hawaii</option>\n                                                                    <option value=\"ID\">Idaho</option>\n                                                                    <option value=\"IL\">Illinois</option>\n                                                                    <option value=\"IN\">Indiana</option>\n                                                                    <option value=\"IA\">Iowa</option>\n                                                                    <option value=\"KS\">Kansas</option>\n                                                                    <option value=\"KY\">Kentucky</option>\n                                                                    <option value=\"LA\">Louisiana</option>\n                                                                    <option value=\"ME\">Maine</option>\n                                                                    <option value=\"MD\">Maryland</option>\n                                                                    <option value=\"MA\">Massachusetts</option>\n                                                                    <option value=\"MI\">Michigan</option>\n                                                                    <option value=\"MN\">Minnesota</option>\n                                                                    <option value=\"MS\">Mississippi</option>\n                                                                    <option value=\"MO\">Missouri</option>\n                                                                    <option value=\"MT\">Montana</option>\n                                                                    <option value=\"NE\">Nebraska</option>\n                                                                    <option value=\"NV\">Nevada</option>\n                                                                    <option value=\"NH\">New Hampshire</option>\n                                                                    <option value=\"NJ\">New Jersey</option>\n                                                                    <option value=\"NM\">New Mexico</option>\n                                                                    <option value=\"NY\">New York</option>\n                                                                    <option value=\"NC\">North Carolina</option>\n                                                                    <option value=\"ND\">North Dakota</option>\n                                                                    <option value=\"OH\">Ohio</option>\n                                                                    <option value=\"OK\">Oklahoma</option>\n                                                                    <option value=\"OR\">Oregon</option>\n                                                                    <option value=\"PA\">Pennsylvania</option>\n                                                                    <option value=\"RI\">Rhode Island</option>\n                                                                    <option value=\"SC\">South Carolina</option>\n                                                                    <option value=\"SD\">South Dakota</option>\n                                                                    <option value=\"TN\">Tennessee</option>\n                                                                    <option value=\"TX\">Texas</option>\n                                                                    <option value=\"UT\">Utah</option>\n                                                                    <option value=\"VT\">Vermont</option>\n                                                                    <option value=\"VA\">Virginia</option>\n                                                                    <option value=\"WA\">Washington</option>\n                                                                    <option value=\"WV\">West Virginia</option>\n                                                                    <option value=\"WI\">Wisconsin</option>\n                                                                    <option value=\"WY\">Wyoming</option>\n                                                                </select>\n                                                            </td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Zip / Postal:</td>\n                                                            <td><input name=\"billingPostalCode\" maxlength=\"20\" class=\"textBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Phone:</td>\n                                                            <td><input name=\"billingPhone\" maxlength=\"20\" class=\"textBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Email:</td>\n                                                            <td><input name=\"billingEmail\" maxlength=\"250\" class=\"textBox\" /></td>\n                                                        </tr>\n                                                    </tbody>\n                                                </table>\n                                            </td>\n                                            <td class=\"outerShippingTd\" valign=\"top\">\n                                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n                                                    <tbody>\n                                                        <tr>\n                                                            <td class=\"alignRight\">First Name:</td>\n                                                            <td><input name=\"shippingFirstName\" maxlength=\"100\" class=\"textBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Last Name:</td>\n                                                            <td><input name=\"shippingLastName\" maxlength=\"100\" class=\"textBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Address:</td>\n                                                            <td><input name=\"shippingAddress1\" maxlength=\"250\" class=\"textBox\" /></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Address 2:</td>\n                                                            <td><input maxlength=\"250\" class=\"textBox\" placeholder=\"Optional\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">City:</td>\n                                                            <td><input name=\"shippingFirstName\" maxlength=\"100\" class=\"textBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">State:</td>\n                                                            <td>\n                                                                <select class=\"textBox\" name=\"shippingState\">\n                                                                    <option value=\"?\">Select</option>\n                                                                    <option value=\"AL\">Alabama</option>\n                                                                    <option value=\"AK\">Alaska</option>\n                                                                    <option value=\"AZ\">Arizona</option>\n                                                                    <option value=\"AR\">Arkansas</option>\n                                                                    <option value=\"CA\">California</option>\n                                                                    <option value=\"CO\">Colorado</option>\n                                                                    <option value=\"CT\">Connecticut</option>\n                                                                    <option value=\"DE\">Delaware</option>\n                                                                    <option value=\"DC\">Dist of Columbia</option>\n                                                                    <option value=\"FL\">Florida</option>\n                                                                    <option value=\"GA\">Georgia</option>\n                                                                    <option value=\"HI\">Hawaii</option>\n                                                                    <option value=\"ID\">Idaho</option>\n                                                                    <option value=\"IL\">Illinois</option>\n                                                                    <option value=\"IN\">Indiana</option>\n                                                                    <option value=\"IA\">Iowa</option>\n                                                                    <option value=\"KS\">Kansas</option>\n                                                                    <option value=\"KY\">Kentucky</option>\n                                                                    <option value=\"LA\">Louisiana</option>\n                                                                    <option value=\"ME\">Maine</option>\n                                                                    <option value=\"MD\">Maryland</option>\n                                                                    <option value=\"MA\">Massachusetts</option>\n                                                                    <option value=\"MI\">Michigan</option>\n                                                                    <option value=\"MN\">Minnesota</option>\n                                                                    <option value=\"MS\">Mississippi</option>\n                                                                    <option value=\"MO\">Missouri</option>\n                                                                    <option value=\"MT\">Montana</option>\n                                                                    <option value=\"NE\">Nebraska</option>\n                                                                    <option value=\"NV\">Nevada</option>\n                                                                    <option value=\"NH\">New Hampshire</option>\n                                                                    <option value=\"NJ\">New Jersey</option>\n                                                                    <option value=\"NM\">New Mexico</option>\n                                                                    <option value=\"NY\">New York</option>\n                                                                    <option value=\"NC\">North Carolina</option>\n                                                                    <option value=\"ND\">North Dakota</option>\n                                                                    <option value=\"OH\">Ohio</option>\n                                                                    <option value=\"OK\">Oklahoma</option>\n                                                                    <option value=\"OR\">Oregon</option>\n                                                                    <option value=\"PA\">Pennsylvania</option>\n                                                                    <option value=\"RI\">Rhode Island</option>\n                                                                    <option value=\"SC\">South Carolina</option>\n                                                                    <option value=\"SD\">South Dakota</option>\n                                                                    <option value=\"TN\">Tennessee</option>\n                                                                    <option value=\"TX\">Texas</option>\n                                                                    <option value=\"UT\">Utah</option>\n                                                                    <option value=\"VT\">Vermont</option>\n                                                                    <option value=\"VA\">Virginia</option>\n                                                                    <option value=\"WA\">Washington</option>\n                                                                    <option value=\"WV\">West Virginia</option>\n                                                                    <option value=\"WI\">Wisconsin</option>\n                                                                    <option value=\"WY\">Wyoming</option>\n                                                                </select>\n                                                            </td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Zip / Postal:</td>\n                                                            <td><input class=\"textBox\" maxlength=\"20\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Phone:</td>\n                                                            <td><input class=\"textBox\" maxlength=\"20\" placeholder=\"Optional\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Email:</td>\n                                                            <td><input class=\"textBox\" maxlength=\"250\" placeholder=\"Optional\"></td>\n                                                        </tr>\n                                                    </tbody>\n                                                </table>\n                                            </td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </div>\n                            <div class=\"shipping2YouMain\">\n                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"shipping2YouTitle\">Shipping to You</td>\n                                            <td class=\"tdPriceQuantityTotalHeader\">Price</td>\n                                            <td class=\"tdPriceQuantityTotalHeader\">Quantity</td>\n                                            <td class=\"tdPriceQuantityTotalHeader\">Total</td>\n                                        </tr>\n\n                                        <tr>\n                                            <td class=\"productHeader\">SPORT Steak Seasoning Rub</td>\n                                            <td class=\"productPriceTotal\">$5.00</td>\n                                            <td class=\"productQuantity\">1</td>\n                                            <td class=\"productPriceTotal\">$5.00</td>\n                                        </tr>\n\n                                        <tr>\n                                            <td colspan=\"2\" class=\"subTotalSpace\">&nbsp;</td>\n                                            <td class=\"subTotalHeader\">Subtotal:</td>\n                                            <td class=\"subTotalPrice\"><span id=\"cart-total\">$5.00</span></td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </div>\n                            <div class=\"shipping2YouMain\">\n                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"commentsStyle\">Comments or Additional Information</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"textAreaStyle\"><textarea cols=\"35\" rows=\"3\"></textarea></td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </div>\n                            <div class=\"buttonStyle\"> <a routerLink=\"/Cart\"> <input type=\"image\" src=\"/images/Back_button.png\"></a> <a routerLink=\"/Cart/Preview\"><input type=\"image\" src=\"/images/Checkout_button.png\"></a></div>\n                        </div>\n                    </form>\n                  \n                  \n                    <form name=\"checkoutForm\" class=\"visible-xs\">\n                        <div class=\"smallMainFormDiv\">\n                            <div class=\"smallTopPadding\">\n                                <table border=\"0\" cellpadding=\"5\" cellspacing=\"5\" width=\"100%\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"smallAddressStyle\">Billing Address</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"smallOuterTd\" valign=\"top\">\n                                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                                    <tbody>\n                                                        <tr>\n                                                            <td class=\"alignRight\">First Name:</td>\n                                                            <td><input name=\"billingFirstName\" maxlength=\"100\" class=\"smallTextBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Last Name:</td>\n                                                            <td><input name=\"billingLastName\" maxlength=\"100\"  class=\"smallTextBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Address:</td>\n                                                            <td><input name=\"billingAddress1\" maxlength=\"250\" class=\"smallTextBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Address 2:</td>\n                                                            <td><input name=\"billingAddress2\" maxlength=\"250\" class=\"smallTextBox\" placeholder=\"Optional\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">City:</td>\n                                                            <td><input name=\"billingCity\" maxlength=\"100\"  class=\"smallTextBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">State:</td>\n                                                            <td>\n                                                                <select class=\"smallTextBox\" name=\"billingState\">\n                                                                    <option value=\"?\">Select</option>\n                                                                    <option value=\"AL\">Alabama</option>\n                                                                    <option value=\"AK\">Alaska</option>\n                                                                    <option value=\"AZ\">Arizona</option>\n                                                                    <option value=\"AR\">Arkansas</option>\n                                                                    <option value=\"CA\">California</option>\n                                                                    <option value=\"CO\">Colorado</option>\n                                                                    <option value=\"CT\">Connecticut</option>\n                                                                    <option value=\"DE\">Delaware</option>\n                                                                    <option value=\"DC\">Dist of Columbia</option>\n                                                                    <option value=\"FL\">Florida</option>\n                                                                    <option value=\"GA\">Georgia</option>\n                                                                    <option value=\"HI\">Hawaii</option>\n                                                                    <option value=\"ID\">Idaho</option>\n                                                                    <option value=\"IL\">Illinois</option>\n                                                                    <option value=\"IN\">Indiana</option>\n                                                                    <option value=\"IA\">Iowa</option>\n                                                                    <option value=\"KS\">Kansas</option>\n                                                                    <option value=\"KY\">Kentucky</option>\n                                                                    <option value=\"LA\">Louisiana</option>\n                                                                    <option value=\"ME\">Maine</option>\n                                                                    <option value=\"MD\">Maryland</option>\n                                                                    <option value=\"MA\">Massachusetts</option>\n                                                                    <option value=\"MI\">Michigan</option>\n                                                                    <option value=\"MN\">Minnesota</option>\n                                                                    <option value=\"MS\">Mississippi</option>\n                                                                    <option value=\"MO\">Missouri</option>\n                                                                    <option value=\"MT\">Montana</option>\n                                                                    <option value=\"NE\">Nebraska</option>\n                                                                    <option value=\"NV\">Nevada</option>\n                                                                    <option value=\"NH\">New Hampshire</option>\n                                                                    <option value=\"NJ\">New Jersey</option>\n                                                                    <option value=\"NM\">New Mexico</option>\n                                                                    <option value=\"NY\">New York</option>\n                                                                    <option value=\"NC\">North Carolina</option>\n                                                                    <option value=\"ND\">North Dakota</option>\n                                                                    <option value=\"OH\">Ohio</option>\n                                                                    <option value=\"OK\">Oklahoma</option>\n                                                                    <option value=\"OR\">Oregon</option>\n                                                                    <option value=\"PA\">Pennsylvania</option>\n                                                                    <option value=\"RI\">Rhode Island</option>\n                                                                    <option value=\"SC\">South Carolina</option>\n                                                                    <option value=\"SD\">South Dakota</option>\n                                                                    <option value=\"TN\">Tennessee</option>\n                                                                    <option value=\"TX\">Texas</option>\n                                                                    <option value=\"UT\">Utah</option>\n                                                                    <option value=\"VT\">Vermont</option>\n                                                                    <option value=\"VA\">Virginia</option>\n                                                                    <option value=\"WA\">Washington</option>\n                                                                    <option value=\"WV\">West Virginia</option>\n                                                                    <option value=\"WI\">Wisconsin</option>\n                                                                    <option value=\"WY\">Wyoming</option>\n                                                                </select>\n                                                            </td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Zip / Postal:</td>\n                                                            <td><input name=\"billingPostalCode\" maxlength=\"20\" class=\"smallTextBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Phone:</td>\n                                                            <td><input name=\"billingPhone\" maxlength=\"20\" class=\"smallTextBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Email:</td>\n                                                            <td><input name=\"billingEmail\" maxlength=\"250\"  class=\"smallTextBox\"></td>\n                                                        </tr>\n                                                    </tbody>\n                                                </table>\n                                            </td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                                <table border=\"0\" cellpadding=\"5\" cellspacing=\"5\" width=\"100%\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"smallShipping2YouTitle\"><span class=\"smallShippingPadding\">Shipping Address</span> <input type=\"checkbox\"> Same as Billing Address</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"smallOuterShippingTd\" valign=\"top\">\n                                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                                    <tbody>\n                                                        <tr>\n                                                            <td class=\"alignRight\">First Name:</td>\n                                                            <td><input name=\"shippingFirstName\" maxlength=\"100\"  class=\"smallTextBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Last Name:</td>\n                                                            <td><input name=\"shippingLastName\" maxlength=\"100\"  class=\"smallTextBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Address:</td>\n                                                            <td><input name=\"shippingAddress1\" maxlength=\"250\" class=\"smallTextBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Address 2:</td>\n                                                            <td><input maxlength=\"250\" class=\"smallTextBox\" placeholder=\"Optional\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">City:</td>\n                                                            <td><input name=\"shippingFirstName\" maxlength=\"100\" class=\"smallTextBox\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">State:</td>\n                                                            <td>\n                                                                <select class=\"smallTextBox\" name=\"shippingState\">\n                                                                    <option value=\"?\">Select</option>\n                                                                    <option value=\"AL\">Alabama</option>\n                                                                    <option value=\"AK\">Alaska</option>\n                                                                    <option value=\"AZ\">Arizona</option>\n                                                                    <option value=\"AR\">Arkansas</option>\n                                                                    <option value=\"CA\">California</option>\n                                                                    <option value=\"CO\">Colorado</option>\n                                                                    <option value=\"CT\">Connecticut</option>\n                                                                    <option value=\"DE\">Delaware</option>\n                                                                    <option value=\"DC\">Dist of Columbia</option>\n                                                                    <option value=\"FL\">Florida</option>\n                                                                    <option value=\"GA\">Georgia</option>\n                                                                    <option value=\"HI\">Hawaii</option>\n                                                                    <option value=\"ID\">Idaho</option>\n                                                                    <option value=\"IL\">Illinois</option>\n                                                                    <option value=\"IN\">Indiana</option>\n                                                                    <option value=\"IA\">Iowa</option>\n                                                                    <option value=\"KS\">Kansas</option>\n                                                                    <option value=\"KY\">Kentucky</option>\n                                                                    <option value=\"LA\">Louisiana</option>\n                                                                    <option value=\"ME\">Maine</option>\n                                                                    <option value=\"MD\">Maryland</option>\n                                                                    <option value=\"MA\">Massachusetts</option>\n                                                                    <option value=\"MI\">Michigan</option>\n                                                                    <option value=\"MN\">Minnesota</option>\n                                                                    <option value=\"MS\">Mississippi</option>\n                                                                    <option value=\"MO\">Missouri</option>\n                                                                    <option value=\"MT\">Montana</option>\n                                                                    <option value=\"NE\">Nebraska</option>\n                                                                    <option value=\"NV\">Nevada</option>\n                                                                    <option value=\"NH\">New Hampshire</option>\n                                                                    <option value=\"NJ\">New Jersey</option>\n                                                                    <option value=\"NM\">New Mexico</option>\n                                                                    <option value=\"NY\">New York</option>\n                                                                    <option value=\"NC\">North Carolina</option>\n                                                                    <option value=\"ND\">North Dakota</option>\n                                                                    <option value=\"OH\">Ohio</option>\n                                                                    <option value=\"OK\">Oklahoma</option>\n                                                                    <option value=\"OR\">Oregon</option>\n                                                                    <option value=\"PA\">Pennsylvania</option>\n                                                                    <option value=\"RI\">Rhode Island</option>\n                                                                    <option value=\"SC\">South Carolina</option>\n                                                                    <option value=\"SD\">South Dakota</option>\n                                                                    <option value=\"TN\">Tennessee</option>\n                                                                    <option value=\"TX\">Texas</option>\n                                                                    <option value=\"UT\">Utah</option>\n                                                                    <option value=\"VT\">Vermont</option>\n                                                                    <option value=\"VA\">Virginia</option>\n                                                                    <option value=\"WA\">Washington</option>\n                                                                    <option value=\"WV\">West Virginia</option>\n                                                                    <option value=\"WI\">Wisconsin</option>\n                                                                    <option value=\"WY\">Wyoming</option>\n                                                                </select>\n                                                            </td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Zip / Postal:</td>\n                                                            <td><input class=\"smallTextBox\" maxlength=\"20\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Phone:</td>\n                                                            <td><input class=\"smallTextBox\" maxlength=\"20\" placeholder=\"Optional\"></td>\n                                                        </tr>\n                                                        <tr>\n                                                            <td class=\"alignRight\">Email:</td>\n                                                            <td><input class=\"smallTextBox\" maxlength=\"250\" placeholder=\"Optional\"></td>\n                                                        </tr>\n                                                    </tbody>\n                                                </table>\n                                            </td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </div>\n                            <div class=\"shipping2YouMain \">\n                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"smallShippingTitle\">Shipping to You</td>\n                                            <td class=\"smallTdPriceQuantityHeader\">Price</td>\n                                            <td class=\"smallTdPriceQuantityHeader\">Quantity</td>\n                                            <td class=\"smallTotalHeader\">Total</td>\n                                        </tr>\n                                       \n                                        <tr>\n                                            <td class=\"smallProductHeader\">SPORT Steak Seasoning Rub</td>\n                                            <td class=\"smallProductPrice\" >$5.00</td>\n                                            <td class=\"smallProductQuantity\" >1</td>\n                                            <td class=\"smallProductTotal\">$5.00</td>\n                                        </tr>\n                                       \n                                        <tr>\n                                            <td colspan=\"2\" class=\"smallSubTotalSpace\">&nbsp;</td>\n                                            <td class=\"smallSubToalHeader\">Subtotal:</td>\n                                            <td class=\"smallSubTotalPrice\"><span id=\"cart-total\" >$5.00</span></td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </div>\n                            <div class=\"shipping2YouMain\">\n                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"smallCommentsStyle\">Comments or Additional Information</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"smallTextAreaStyle\"><textarea cols=\"35\" rows=\"3\"></textarea></td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </div>\n                            <div class=\"smallButtonStyle\"> <a routerLink=\"/Cart\"> <input type=\"image\" src=\"/images/Back_button.png\"></a> <a routerLink=\"/Cart/Preview\"><input type=\"image\" src=\"/images/Checkout_button.png\"></a></div>\n                        </div>\n                    </form>\n    </div>\n    </div>\n\n\n";

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(119);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".mainContent {\n    position: relative; \n    top: -10px;\n}\n\n.mainFormDiv {\n    background-color:#e8e3c8; \n    margin: 5px 0 0 15px; \n    padding:10px;\n}\n\n.smallMainFormDiv {\n    background-color:#e8e3c8; \n    margin: 5px 0 0 0px; \n    padding:10px 0 10px 0;\n}\n\n.smallTopPadding {\n    padding-top:5px;\n}\n\n.titleDiv {\n    height: 40px;\n    text-align:left;\n    padding-top: 9px;\n    padding-left: 15px;\n    background-color: #bc9a72;\n    color:#4b290c;\n    font-family: Cambria;\n    font-size: 16px;\n    font-weight:bold;\n}\n\n.tablePadding {\n    padding-top:5px;\n}\n\n.addressStyle {\n    width:430px; \n    height:25px; \n    text-align:left; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292;\n    border-left: 1px dashed #929292;\n}\n\n.smallAddressStyle {\n    height:25px; \n    text-align:left; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.shippingAddressPadding {\n    padding-right:10px;\n}\n\n.outerTd {\n    width:430px; \n    padding:5px; \n    color:#4b290c; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallOuterTd {\n    padding:5px;  \n    text-align:left; \n    color:#4b290c; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.outerShippingTd {\n    width:430px; \n    padding:5px; \n    text-align:left; \n    color:#4b290c; \n    border: 1px dashed #929292;\n}\n\n.smallOuterShippingTd {\n    padding:5px;  \n    text-align:left; \n    color:#4b290c; \n    border: 1px dashed #929292;\n}\n\n.alignRight {\n    text-align:right;\n}\n\n.textBox {\n    width:225px; \n    margin:5px;\n}\n\n.smallTextBox {\n    width:100%; \n    margin:5px;\n}\n\n.shipping2YouMain {\n    padding-top:25px;\n}\n\n.shipping2YouTitle {\n    width:500px; \n    height:25px; \n    text-align:left; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallShipping2YouTitle {\n    height:25px; \n    text-align:left; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border: 1px dashed #929292;\n}\n\n.smallShippingTitle {\n    height:25px; \n    text-align:left; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallShippingPadding {\n    padding-right:10px;\n}\n\n.tdPriceQuantityTotalHeader {\n    width:100px; \n    height:25px; \n    text-align:center; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallTdPriceQuantityHeader {\n    height:25px; \n    text-align:center; \n    background-color:#d2be9d;\n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallTotalHeader {\n    height:25px; \n    text-align:center; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.productHeader {\n    width: 500px; \n    text-align:left; \n    padding: 5px; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallProductHeader {\n    padding: 5px; \n    text-align:left; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.productPriceTotal {\n    width: 100px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallProductPrice {\n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallProductTotal {\n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n\n.productQuantity {\n    width: 100px; \n    padding: 5px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallProductQuantity {\n    padding: 5px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292;\n    border-left: 1px dashed #929292;\n}\n\n.subTotalSpace {\n    border-left: 1px dashed #929292; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292; \n    text-align: right;\n}\n\n.smallSubTotalSpace {\n    border-left: 1px dashed #929292; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292; \n    text-align: right;\n}\n\n.subTotalHeader {\n    width: 100px; \n    height: 35px; \n    color: #4b290c; \n    font-weight: bold; \n    text-align: right; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292;\n}\n\n.smallSubToalHeader {\n    height: 35px; \n    color: #4b290c; \n    font-weight: bold; \n    text-align: right; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292;\n}\n\n.subTotalPrice {\n    width: 100px; \n    height: 35px; \n    color: #4b290c; \n    font-weight: bold; \n    text-align: center; \n    border-right: 1px dashed #929292; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292;\n}\n\n.smallSubTotalPrice {  \n    height: 35px; \n    color: #4b290c; \n    font-weight: bold; \n    text-align: center; \n    border-right: 1px dashed #929292; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292;\n}\n\n\n\n.commentsStyle {\n    height:25px; \n    text-align:left; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.smallCommentsStyle {\n    height:25px; \n    text-align:left; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.textAreaStyle {\n    padding:5px; \n    text-align:left; \n    color:#4b290c; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.smallTextAreaStyle {\n    padding:5px; \n    text-align:left; \n    color:#4b290c; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.buttonStyle {\n    margin-top:25px; \n    padding:10px; \n    border: 1px dashed #929292; \n    text-align:right;\n}\n\n.smallButtonStyle {\n    margin-top:25px; \n    padding:10px; \n    border: 1px dashed #929292; \n    text-align:right;\n}", ""]);

// exports


/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PreviewComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var PreviewComponent = /** @class */ (function () {
    function PreviewComponent() {
    }
    PreviewComponent.prototype.ngOnInit = function () { };
    PreviewComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'preview',
            template: __webpack_require__(121),
            styles: [__webpack_require__(122)]
        }),
        __metadata("design:paramtypes", [])
    ], PreviewComponent);
    return PreviewComponent;
}());



/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "\n    <div id=\"content\" class=\"mainContent\">\n\n        <div class=\"hidden-xs hidden-sm headerDiv\">\n            <div class=\"headerStyle\"><span>Preview Order &amp; Enter Payment Information &gt; Step 3 of 4</span></div>\n        </div>\n        <div class=\"hidden-xs hidden-sm tableMainDiv\">\n            <div class=\"paddingPreview\">\n                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                    <tbody>\n                        <tr>\n                            <td class=\"billingAddress\">Billing Address</td>\n                            <td class=\"shippingAddress\">Shipping Address</td>\n                        </tr>\n                        <tr>\n                            <td class=\"billingStyle\" valign=\"top\">\n                                <table border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"alignRight\">Name:</td>\n                                            <td>Jason Stanley</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\" valign=\"top\">Address:</td>\n                                            <td>5307 N Adams St <br>Spokane, WA 99205<br></td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\">Phone:</td>\n                                            <td>5092902353</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\">Email:</td>\n                                            <td>jasonstanl3y@gmail.com</td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </td>\n                            <td class=\"shippingStyle\" valign=\"top\">\n                                <table border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"alignRight\">Name:</td>\n                                            <td class=\"alignCenter\">Jason Stanley</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\" valign=\"top\">Address:</td>\n                                            <td class=\"alignCenter\">5307 N Adams St <br>Spokane, WA 99205<br></td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\">Phone:</td>\n                                            <td class=\"alignCenter\">5092902353</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\">Email:</td>\n                                            <td class=\"alignCenter\">jasonstanl3y@gmail.com</td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n            <div class=\"paddingTop\">\n                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                    <tbody>\n                        <tr>\n                            <td class=\"shipping2YouStyle\">Shipping to You</td>\n                            <td class=\"priceQuantityStyleHeader\">Price</td>\n                            <td class=\"priceQuantityStyleHeader\">Quantity</td>\n                            <td class=\"totalStyleHeader\">Total</td>\n                        </tr>\n\n                        <tr>\n                            <td class=\"productStyle\">\n                                SPORT Steak Seasoning Rub\n                            </td>\n                            <td class=\"priceStyle\">\n                                $5.00\n                            </td>\n                            <td class=\"quantityStyle\">\n                                1\n                            </td>\n                            <td class=\"totalStyle\">\n                                $5.00\n                            </td>\n                        </tr>\n\n                        <tr>\n                            <td colspan=\"2\" class=\"subTotalSpace\">&nbsp;</td>\n                            <td class=\"subTotalHeader\">Subtotal:</td>\n                            <td class=\"subTotalPrice\">$5.00</td>\n                        </tr>\n                        <tr>\n                            <td colspan=\"2\" class=\"taxSpace\">&nbsp;</td>\n                            <td class=\"taxHeader\">Tax:</td>\n                            <td class=\"taxAmount\">$0.00</td>\n                        </tr>\n                        <tr>\n                            <td class=\"shippingHandlingStyle\" colspan=\"3\" align=\"right\" valign=\"top\">\n                                *Shipping &amp; Handling:\n                                <select>\n                                    <option label=\"Select\" value=\"object:137\" selected=\"selected\">Select</option>\n                                    <option label=\"U.S.P.S. Parcel (3 - 8 days)\" value=\"object:138\">U.S.P.S. Parcel (3 - 8 days)</option>\n                                    <option label=\"U.S.P.S. Priority (2 - 4 days)\" value=\"object:139\">U.S.P.S. Priority (2 - 4 days)</option>\n                                </select>\n                            </td>\n                            <td class=\"shippingHandlingPrice\" valign=\"top\">$0.00</td>\n                        </tr>\n                        <tr>\n                            <td colspan=\"2\" class=\"totalSpace\">&nbsp;</td>\n                            <td class=\"totalHeader\">Total:</td>\n                            <td id=\"tdTotalPrice\" class=\"totalPrice\">$5.00</td>\n                        </tr>\n                        <tr>\n                            <td colspan=\"4\" class=\"noteStyle\">*Shipping durations are estimates and not a guarantee</td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n           \n            <div class=\"paddingTop\">\n                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                    <tbody>\n                        <tr>\n                            <td class=\"payInfoHeader\">Payment Information</td>\n                        </tr>\n                        <tr>\n                            <td class=\"payInfoTd\">\n                                <div class=\"redColor\"></div>\n                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"alignRight\">Card Type:</td>\n                                            <td>\n                                                <select class=\"selectCardStyle\">\n                                                    <option label=\"Select\" value=\"object:141\" selected=\"selected\">Select</option>\n                                                    <option label=\"Visa\" value=\"object:142\">Visa</option>\n                                                    <option label=\"MasterCard\" value=\"object:143\">MasterCard</option>\n                                                    <option label=\"Discover\" value=\"object:144\">Discover</option>\n                                                    <option label=\"American Express\" value=\"object:145\">American Express</option>\n                                                </select>\n                                            </td>\n                                            <td colspan=\"2\">&nbsp;</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\">Card Number:</td>\n                                            <td class=\"cardTd\"><input class=\"cardInputStyle\" placeholder=\"Card Number\"></td>\n                                            <td class=\"alignRight\">Expiration:</td>\n                                            <td>\n                                                <select class=\"expirationSelect\">\n                                                    <option label=\"Select\" value=\"object:148\" selected=\"selected\">Select</option>\n                                                    <option label=\"January\" value=\"object:149\">January</option>\n                                                    <option label=\"February\" value=\"object:150\">February</option>\n                                                    <option label=\"March\" value=\"object:151\">March</option>\n                                                    <option label=\"April\" value=\"object:152\">April</option>\n                                                    <option label=\"May\" value=\"object:153\">May</option>\n                                                    <option label=\"June\" value=\"object:154\">June</option>\n                                                    <option label=\"July\" value=\"object:155\">July</option>\n                                                    <option label=\"August\" value=\"object:156\">August</option>\n                                                    <option label=\"September\" value=\"object:157\">September</option>\n                                                    <option label=\"October\" value=\"object:158\">October</option>\n                                                    <option label=\"November\" value=\"object:159\">November</option>\n                                                    <option label=\"December\" value=\"object:160\">December</option>\n                                                </select>\n                                                <select class=\"expirationSelect\">\n                                                    <option label=\"Select\" value=\"object:162\" selected=\"selected\">Select</option>\n                                                    <option label=\"2017\" value=\"object:163\">2017</option>\n                                                    <option label=\"2018\" value=\"object:164\">2018</option>\n                                                    <option label=\"2019\" value=\"object:165\">2019</option>\n                                                    <option label=\"2020\" value=\"object:166\">2020</option>\n                                                    <option label=\"2021\" value=\"object:167\">2021</option>\n                                                    <option label=\"2022\" value=\"object:168\">2022</option>\n                                                    <option label=\"2023\" value=\"object:169\">2023</option>\n                                                    <option label=\"2024\" value=\"object:170\">2024</option>\n                                                    <option label=\"2025\" value=\"object:171\">2025</option>\n                                                    <option label=\"2026\" value=\"object:172\">2026</option>\n                                                    <option label=\"2027\" value=\"object:173\">2027</option>\n                                                </select>\n                                            </td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </td>\n                        </tr>\n                        <tr>\n                            <td class=\"linkSpacing\">&nbsp;<a routerLink=\"/Cart/Checkout\"><img alt=\"Back\" class=\"pointer\" src=\"" + __webpack_require__(58) + "\"></a> <a routerLink=\"/Cart/Receipt\"><img alt=\"Purchase\" class=\"pointer\" src=\"" + __webpack_require__(59) + "\"></a></td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n        </div>\n        <div class=\"visible-xs visible-sm smallMainContent\">\n            <div class=\"smallHeaderStyle\"><span>Step 3 of 4</span></div>\n        </div>\n        <div class=\"visible-xs visible-sm tableSmallDiv\">\n            <div class=\"paddingPreview\">\n                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                    <tbody>\n                        <tr>\n                            <td class=\"smallBillingAddress\">Billing Address</td>\n                        </tr>\n                        <tr>\n                            <td class=\"smallBillingStyle\" valign=\"top\">\n                                <table border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"alignRight\">Name:</td>\n                                            <td class=\"smallAlignLeftWithPadding\">Jason Stanley</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\" valign=\"top\">Address:</td>\n                                            <td class=\"smallAlignLeftWithPadding\">5307 N Adams St <br>Spokane, WA 99205<br></td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\">Phone:</td>\n                                            <td class=\"smallAlignLeftWithPadding\">5098445698</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\">Email:</td>\n                                            <td class=\"smallAlignLeftWithPadding\">jasonstanl3y@gmail.com</td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </td>\n                        </tr>\n                        <tr>\n                            <td class=\"smallShippingHeader\">Shipping Address</td>\n                        </tr>\n                        <tr>\n                            <td class=\"smallShippingStyle\" valign=\"top\">\n                                <table border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"alignRight\">Name:</td>\n                                            <td style=\"text-align:left; padding:0 0 0 5px\">Jason Stanley</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\" valign=\"top\">Address:</td>\n                                            <td class=\"smallAlignLeftWithPadding\">5307 N Adams St <br>Spokane, WA 99205<br></td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\">Phone:</td>\n                                            <td class=\"smallAlignLeftWithPadding\">5098445698</td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\">Email:</td>\n                                            <td class=\"smallAlignLeftWithPadding\">jasonstanl3y@gmail.com</td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n            <div class=\"paddingTop\">\n                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                    <tbody>\n                        <tr>\n                            <td class=\"smallShipping2YouStyle\">Shipping to You</td>\n                            <td class=\"smallPriceQuantityHeader\">Price</td>\n                            <td class=\"smallPriceQuantityHeader\">Quantity</td>\n                            <td class=\"smallTotalStyleHeader\">Total</td>\n                        </tr>\n\n                        <tr>\n                            <td class=\"smallProductStyle\">SPORT Steak Seasoning Rub</td>\n                            <td class=\"smallPriceStyle\">$5.00</td>\n                            <td class=\"smallQuantityStyle\">1</td>\n                            <td class=\"smallTotalStyle\">$5.00</td>\n                        </tr>\n\n                        <tr>\n                            <td colspan=\"2\" class=\"smallSubTotalSpace\">&nbsp;</td>\n                            <td class=\"smallSubTotalHeader\">Subtotal:</td>\n                            <td class=\"smallSubTotalPrice\">$5.00</td>\n                        </tr>\n                        <tr>\n                            <td colspan=\"2\" class=\"taxSpace\">&nbsp;</td>\n                            <td class=\"smallTaxHeader\">Tax:</td>\n                            <td class=\"smallTaxAmount\">$0.00</td>\n                        </tr>\n                        <tr>\n                            <td class=\"shippingHandlingStyle\" colspan=\"3\" align=\"right\" valign=\"top\">\n                                *Shipping &amp; Handling:\n                                <select>\n                                    <option label=\"Select\" value=\"object:137\" selected=\"selected\">Select</option>\n                                    <option label=\"U.S.P.S. Parcel (3 - 8 days)\" value=\"object:138\">U.S.P.S. Parcel (3 - 8 days)</option>\n                                    <option label=\"U.S.P.S. Priority (2 - 4 days)\" value=\"object:139\">U.S.P.S. Priority (2 - 4 days)</option>\n                                </select>\n                            </td>\n                            <td class=\"smallShippingHandlingPrice\" valign=\"top\">$0.00</td>\n                        </tr>\n                        <tr>\n                            <td colspan=\"2\" class=\"totalSpace\">&nbsp;</td>\n                            <td class=\"smallTotalHeader\">Total:</td>\n                            <td id=\"tdTotalPrice\" class=\"smallTotalPrice\">$5.00</td>\n                        </tr>\n                        <tr>\n                            <td colspan=\"4\" class=\"smallNoteStyle\">*Shipping durations are estimates and not a guarantee</td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n           \n            <div class=\"paddingTop\">\n                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                    <tbody>\n                        <tr>\n                            <td class=\"smallPayInfoHeader\">Payment Information</td>\n                        </tr>\n                        <tr>\n                            <td class=\"smallPayInfoTd\">\n                                <div class=\"redColor\"></div>\n                                <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n                                    <tbody>\n                                        <tr>\n                                            <td class=\"alignRight\">Card Type:</td>\n                                            <td class=\"alignLeft\">\n                                                <select class=\"smallSelectCardStyle\">\n                                                    <option label=\"Select\" value=\"object:141\" selected=\"selected\">Select</option>\n                                                    <option label=\"Visa\" value=\"object:142\">Visa</option>\n                                                    <option label=\"MasterCard\" value=\"object:143\">MasterCard</option>\n                                                    <option label=\"Discover\" value=\"object:144\">Discover</option>\n                                                    <option label=\"American Express\" value=\"object:145\">American Express</option>\n                                                </select>\n                                            </td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\">Card Number:</td>\n                                            <td class=\"smallCardTd\"><input class=\"smallCardInputStyle\" placeholder=\"Card Number\"></td>\n                                        </tr>\n                                        <tr>\n                                            <td class=\"alignRight\">Expiration:</td>\n                                            <td class=\"alignLeft\">\n                                                <select class=\"expirationSelect\">\n                                                    <option label=\"Select\" value=\"object:148\" selected=\"selected\">Select</option>\n                                                    <option label=\"January\" value=\"object:149\">January</option>\n                                                    <option label=\"February\" value=\"object:150\">February</option>\n                                                    <option label=\"March\" value=\"object:151\">March</option>\n                                                    <option label=\"April\" value=\"object:152\">April</option>\n                                                    <option label=\"May\" value=\"object:153\">May</option>\n                                                    <option label=\"June\" value=\"object:154\">June</option>\n                                                    <option label=\"July\" value=\"object:155\">July</option>\n                                                    <option label=\"August\" value=\"object:156\">August</option>\n                                                    <option label=\"September\" value=\"object:157\">September</option>\n                                                    <option label=\"October\" value=\"object:158\">October</option>\n                                                    <option label=\"November\" value=\"object:159\">November</option>\n                                                    <option label=\"December\" value=\"object:160\">December</option>\n                                                </select>\n                                                <select class=\"expirationSelect\">\n                                                    <option label=\"Select\" value=\"object:162\" selected=\"selected\">Select</option>\n                                                    <option label=\"2017\" value=\"object:163\">2017</option>\n                                                    <option label=\"2018\" value=\"object:164\">2018</option>\n                                                    <option label=\"2019\" value=\"object:165\">2019</option>\n                                                    <option label=\"2020\" value=\"object:166\">2020</option>\n                                                    <option label=\"2021\" value=\"object:167\">2021</option>\n                                                    <option label=\"2022\" value=\"object:168\">2022</option>\n                                                    <option label=\"2023\" value=\"object:169\">2023</option>\n                                                    <option label=\"2024\" value=\"object:170\">2024</option>\n                                                    <option label=\"2025\" value=\"object:171\">2025</option>\n                                                    <option label=\"2026\" value=\"object:172\">2026</option>\n                                                    <option label=\"2027\" value=\"object:173\">2027</option>\n                                                </select>\n                                            </td>\n                                        </tr>\n                                    </tbody>\n                                </table>\n                            </td>\n                        </tr>\n                        <tr>\n                            <td class=\"linkSpacing\"><a routerLink=\"/Cart/Checkout\"><img alt=\"Back\" class=\"pointer\" src=\"" + __webpack_require__(58) + "\"></a> <a routerLink=\"/Cart/Receipt\"><img alt=\"Purchase\" class=\"pointer\" src=\"" + __webpack_require__(59) + "\"></a></td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n        </div>\n    </div>\n";

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(123);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".mainContent {\n    position: relative; \n    top: -10px;\n}\n\n.smallMainContent {\n    margin: 0px 0 0 0px;\n}\n\n.headerDiv {\n    margin: 15px 0 0 15px;\n}\n\n.headerStyle {\n    height: 40px; \n    padding-top: 9px; \n    padding-left: 15px; \n    background-color: #bc9a72; \n    color:#4b290c; \n    font-family: Cambria; \n    font-size: 16px; \n    font-weight:bold;\n}\n\n.smallHeaderStyle {\n    height: 50px; \n    padding-top: 9px; \n    padding-left: 5px; \n    background-color: #bc9a72; \n    color:#4b290c; \n    font-family: Cambria; \n    font-size: 14px; \n    font-weight:bold;\n}\n\n.tableMainDiv {\n    background-color:#e8e3c8; \n    margin: 5px 0 0 15px; \n    padding:10px;\n}\n\n.tableSmallDiv {\n    background-color:#e8e3c8; \n    margin: 5px 0 0 0px; \n    padding:10px;\n}\n\n.paddingPreview {\n    padding-top:5px;\n}\n\n.billingAddress {\n    width:430px; \n    height:25px;\n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallBillingAddress {\n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.shippingAddress {\n    width:430px; \n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border: 1px dashed #929292;\n}\n\n.billingStyle {\n    width:430px; \n    padding:5px; \n    color:#4b290c; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallBillingStyle {\n    padding:5px; \n    color:#4b290c; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.alignRight {\n    text-align:right;\n}\n\n.smallAlignLeftWithPadding {\n    text-align:left; \n    padding:0 0 0 5px;\n}\n\n.shippingStyle {\n    width:430px; \n    text-align:left; \n    color:#4b290c; \n    border: 1px dashed #929292;\n}\n\n.smallShippingHeader {\n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border: 1px dashed #929292;\n}\n\n.smallShippingStyle {\n    text-align:left; \n    color:#4b290c; \n    border: 1px dashed #929292;\n}\n\n.alignCenter {\n    text-align:center;\n}\n\n.paddingTop {\n    padding-top:25px;\n}\n\n.shipping2YouStyle {\n    width:500px; \n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallShipping2YouStyle {\n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.priceQuantityStyleHeader {\n    width:100px; \n    height:25px; \n    text-align:center; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallPriceQuantityHeader {\n    height:25px; \n    text-align:center; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.totalStyleHeader {\n    width:100px; \n    height:25px; \n    text-align:center; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.smallTotalStyleHeader {\n    height:25px; \n    text-align:center; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.productStyle {\n    width: 500px; \n    padding: 5px; \n    color: #4b290c; \n    border-top: 1px dashed #929292;\n    border-left: 1px dashed #929292;\n}\n\n.smallProductStyle {\n    padding: 5px; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.priceStyle {\n    width: 100px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292;\n    border-left: 1px dashed #929292;\n}\n\n.smallPriceStyle {\n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.quantityStyle {\n    width: 100px; \n    padding: 5px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292;\n    border-left: 1px dashed #929292;\n}\n\n.smallQuantityStyle {\n    padding: 5px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.totalStyle {\n    width: 100px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292;\n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.smallTotalStyle {\n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n\n.subTotalSpace {\n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallSubTotalSpace {\n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.subTotalHeader {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    text-align:right; \n    border-top: 1px dashed #929292;\n}\n\n.smallSubTotalHeader {\n    height:35px; \n    color:#4b290c; \n    text-align:right; \n    border-top: 1px dashed #929292;\n}\n\n.subTotalPrice {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    text-align:center; \n    border-top: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.smallSubTotalPrice {\n    height:35px; \n    color:#4b290c; \n    text-align:center; \n    border-top: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.taxSpace {\n    border-left: 1px dashed #929292;\n}\n\n.taxHeader {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    text-align:right;\n}\n\n.smallTaxHeader {\n    height:35px; \n    color:#4b290c; \n    text-align:right;\n}\n\n.taxAmount {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    text-align:center; \n    border-right: 1px dashed #929292;\n}\n\n.smallTaxAmount {\n    height:35px; \n    color:#4b290c; \n    text-align:center; \n    border-right: 1px dashed #929292;\n}\n\n.shippingHandlingStyle {\n    border-left: 1px dashed #929292; \n    color:#4b290c;\n}\n\n.shippingHandlingPrice {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    text-align:center; \n    border-right: 1px dashed #929292;\n}\n\n.smallShippingHandlingPrice {\n    height:35px; \n    color:#4b290c; \n    text-align:center; \n    border-right: 1px dashed #929292;\n}\n\n.totalSpace {\n    border-left: 1px dashed #929292; \n    border-bottom: 1px dashed #929292;\n}\n\n.totalHeader {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    font-weight:bold; \n    text-align:right; \n    border-bottom: 1px dashed #929292;\n}\n\n.smallTotalHeader {\n    height:35px; \n    color:#4b290c; \n    font-weight:bold; \n    text-align:right; \n    border-bottom: 1px dashed #929292;\n}\n\n.totalPrice {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    font-weight:bold; \n    text-align:center; \n    border-right: 1px dashed #929292; \n    border-bottom: 1px dashed #929292;\n}\n\n.smallTotalPrice {\n    height:35px; \n    color:#4b290c; \n    font-weight:bold; \n    text-align:center; \n    border-right: 1px dashed #929292; \n    border-bottom: 1px dashed #929292;\n}\n\n.noteStyle {\n    text-align:right; \n    color:#4b290c; \n    font-style:italic; \n    padding-top:2px; \n    padding-right:3px;\n}\n\n.smallNoteStyle {\n    text-align:right; \n    color:#4b290c; \n    font-style:italic; \n    padding-top:2px; \n    padding-right:3px;\n}\n\n.payInfoHeader {\n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.smallPayInfoHeader {\n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.payInfoTd {\n    padding:5px; \n    color:#4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.smallPayInfoTd {\n    padding:5px; \n    color:#4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.redColor {\n    color:red;\n}\n\n.alignLeft {\n    text-align:left;\n}\n\n.selectCardStyle {\n    width:320px;\n    margin:5px;\n}\n\n.smallSelectCardStyle {\n    margin:5px;\n}\n\n.cardTd {\n    padding-right:10px;\n}\n\n.smallCardTd {\n    text-align:left; \n    padding-right:10px;\n}\n\n.cardInputStyle {\n    width:320px; \n    margin:5px;\n}\n\n.smallCardInputStyle {\n    margin:5px;\n}\n\n.expirationSelect {\n    width:100px;\n}\n\n.linkSpacing {\n    height:45px; \n    padding:10px; \n    border: 1px dashed #929292; \n    text-align:right; \n    padding-right:5px;\n}\n\n\n\n.pointer {\n    cursor:pointer;\n}", ""]);

// exports


/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReceiptComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var ReceiptComponent = /** @class */ (function () {
    function ReceiptComponent() {
    }
    ReceiptComponent.prototype.ngOnInit = function () { };
    ReceiptComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'receipt',
            template: __webpack_require__(125),
            styles: [__webpack_require__(126)]
        }),
        __metadata("design:paramtypes", [])
    ], ReceiptComponent);
    return ReceiptComponent;
}());



/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = "\n                <div id=\"content\" class=\"mainContent\">\n                   \n                        \n                            <div class=\"hidden-xs hidden-sm headerDiv\">\n                                <div class=\"headerStyle\"><span>Order Receipt &gt; Step 4 of 4</span></div>\n                            </div>\n                            <div class=\"hidden-xs hidden-sm mainDiv\">\n                                <div class=\"topPadding\">\n                                    <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                        <tbody>\n                                            <tr>\n                                                <td class=\"billingAddressHeader\">Billing Address</td>\n                                                <td class=\"shippingAddressHeader\">Shipping Address</td>\n                                            </tr>\n                                            <tr>\n                                                <td class=\"billingAddressTd\" valign=\"top\">\n                                                    <table border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">\n                                                        <tbody>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Name:</td>\n                                                                <td>Jason Stanley</td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\" valign=\"top\">Address:</td>\n                                                                <td>5307 N Adams St <br>Spokane, WA 99205<br></td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Phone:</td>\n                                                                <td>5092902353</td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Email:</td>\n                                                                <td>jasonstanl3y@gmail.com</td>\n                                                            </tr>\n                                                        </tbody>\n                                                    </table>\n                                                </td>\n                                                <td class=\"shippingAddressTd\" valign=\"top\">\n                                                    <table border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">\n                                                        <tbody>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Name:</td>\n                                                                <td class=\"alignCenter\">Jason Stanley</td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\" valign=\"top\">Address:</td>\n                                                                <td class=\"alignCenter\">5307 N Adams St <br>Spokane, WA 99205<br></td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Phone:</td>\n                                                                <td class=\"alignCenter\">5092902353</td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Email:</td>\n                                                                <td class=\"alignCenter\">jasonstanl3y@gmail.com</td>\n                                                            </tr>\n                                                        </tbody>\n                                                    </table>\n                                                </td>\n                                            </tr>\n                                        </tbody>\n                                    </table>\n                                </div>\n                                <div class=\"topPaddingLarger\">\n                                    <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                        <tbody>\n                                            <tr>\n                                                <td class=\"shippingToYouHeader\">Shipping to You</td>\n                                                <td class=\"priceQuantityStyle\">Price</td>\n                                                <td class=\"priceQuantityStyle\">Quantity</td>\n                                                <td class=\"totalHeaderStyle\">Total</td>\n                                            </tr>\n                                            \n                                            <tr class=\"ng-scope\">\n                                                <td class=\"productStyle\">\n                                                    SPORT Steak Seasoning Rub\n                                                </td>\n                                                <td class=\"priceStyle\">\n                                                    $5.00\n                                                </td>\n                                                <td class=\"quantityStyle\">\n                                                    1\n                                                </td>\n                                                <td class=\"totalPriceStyle\">\n                                                    $5.00\n                                                </td>\n                                            </tr>\n                                            \n                                            <tr>\n                                                <td colspan=\"2\" class=\"subTotalSpace\">&nbsp;</td>\n                                                <td class=\"subTotalHeader\">Subtotal:</td>\n                                                <td class=\"subTotalPrice\" >$5.00</td>\n                                            </tr>\n                                         \n                                            <tr>\n                                                <td class=\"shippingHandlingStyle\" colspan=\"3\" align=\"right\" valign=\"top\">\n                                                    *Shipping &amp; Handling:\n\n                                                    <p>U.S.P.S. Parcel (3 - 8 days)</p>\n\n\n                                                </td>\n                                                <td class=\"shippingHandlingPrice\" valign=\"top\" >$3.00</td>\n                                            </tr>\n                                            <tr>\n                                                <td colspan=\"2\" class=\"totalSpace\">&nbsp;</td>\n                                                <td class=\"totalHeader\">Total:</td>\n                                                <td id=\"tdTotalPrice\" class=\"totalPrice\" >$5.00</td>\n                                            </tr>\n                                            <tr>\n                                                <td colspan=\"4\" class=\"noteStyle\">*Shipping durations are estimates and not a guarantee</td>\n                                            </tr>\n                                        </tbody>\n                                    </table>\n                                </div>\n                              \n                                <div class=\"topPaddingLarger\">\n                                    <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                        <tbody>\n                                            <tr>\n                                                <td class=\"payInfo\">Payment Information</td>\n                                            </tr>\n                                            <tr>\n                                                <td class=\"cardTd\">\n                                                    <div class=\"redColor\"></div>\n                                                    <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n                                                        <tbody>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Confirmation Code: 92111-852221</td>\n                                                                <td colspan=\"2\">&nbsp;</td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Card Number: Visa 111111111111111</td>\n\n                                                                <td colspan=\"2\">&nbsp;</td>\n                                                            </tr>\n\n\n                                                        </tbody>\n                                                    </table>\n\n                                                </td>\n                                            \n                                            </tr>\n\n                                            <tr>\n                                                <td class=\"bottomTdStyle\"></td>\n                                            </tr>\n\n                                        </tbody>\n                                    </table>\n                                </div>\n                            </div>\n                            <div class=\"visible-xs visible-sm smallHeaderDiv topPaddingLarger\">\n                                <div class=\"smallHeaderStyle\"><span>Order Receipt &gt; Step 4 of 4</span></div>\n                            </div>\n                            <div class=\"visible-xs visible-sm smallMainDiv\">\n                                <div class=\"topPadding\">\n                                    <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                        <tbody>\n                                            <tr>\n                                                <td class=\"smallBillingAddressHeader\">Billing Address</td>\n                                            </tr>\n                                            <tr>\n                                                <td class=\"smallBillingAddressTd\" valign=\"top\">\n                                                    <table border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">\n                                                        <tbody>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Name:</td>\n                                                                <td class=\"smallAlignLeftPadding\">Jason Stanley</td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\" valign=\"top\">Address:</td>\n                                                                <td class=\"smallAlignLeftPadding\">5307 N Adams St <br>Spokane, WA 99205<br></td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Phone:</td>\n                                                                <td class=\"smallAlignLeftPadding\">5098445698</td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Email:</td>\n                                                                <td class=\"smallAlignLeftPadding\">jasonstanl3y@gmail.com</td>\n                                                            </tr>\n                                                        </tbody>\n                                                    </table>\n                                                </td>\n                                            </tr>\n                                            <tr>\n                                                <td class=\"smallShippingAddressHeader\">Shipping Address</td>\n                                            </tr>\n                                            <tr>\n                                                <td class=\"smallShippingAddressTd\" valign=\"top\">\n                                                    <table border=\"0\" cellpadding=\"2\" cellspacing=\"2\" width=\"100%\">\n                                                        <tbody>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Name:</td>\n                                                                <td class=\"smallAlignLeftPadding\">Jason Stanley</td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\" valign=\"top\">Address:</td>\n                                                                <td class=\"smallAlignLeftPadding\">5307 N Adams St <br>Spokane, WA 99205<br></td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Phone:</td>\n                                                                <td class=\"smallAlignLeftPadding\">5098445698</td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Email:</td>\n                                                                <td class=\"smallAlignLeftPadding\">jasonstanl3y@gmail.com</td>\n                                                            </tr>\n                                                        </tbody>\n                                                    </table>\n                                                </td>\n                                            </tr>\n                                        </tbody>\n                                    </table>\n                                </div>\n                                <div class=\"topPaddingLarger\">\n                                    <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                        <tbody>\n                                            <tr>\n                                                <td class=\"smallShippingToYouHeader\">Shipping to You</td>\n                                                <td class=\"smallPriceQuantityStyle\">Price</td>\n                                                <td class=\"smallPriceQuantityStyle\">Quantity</td>\n                                                <td class=\"smallTotalHeaderStyle\">Total</td>\n                                            </tr>\n                                           \n                                            <tr>\n                                                <td class=\"smallProductStyle\">SPORT Steak Seasoning Rub</td>\n                                                <td class=\"smallPriceStyle\">$5.00</td>\n                                                <td class=\"smallQuantityStyle\">1</td>\n                                                <td class=\"smallTotalPriceStyle\">$5.00</td>\n                                            </tr>\n                                           \n                                            <tr>\n                                                <td colspan=\"2\" class=\"subTotalSpace\">&nbsp;</td>\n                                                <td class=\"smallSubTotalHeader\">Subtotal:</td>\n                                                <td class=\"smallSubTotalPrice\">$5.00</td>\n                                            </tr>\n                                      \n                                            <tr>\n                                                <td class=\"shippingHandlingStyle\" colspan=\"3\" align=\"right\" valign=\"top\">\n                                                    *Shipping &amp; Handling:\n\n                                                    <p>U.S.P.S. Parcel (3 - 8 days)</p>\n\n                                                </td>\n                                                <td class=\"smallShippingHandlingPrice\" valign=\"top\" >$3.00</td>\n                                            </tr>\n                                            <tr>\n                                                <td colspan=\"2\" class=\"totalSpace\">&nbsp;</td>\n                                                <td class=\"smallTotalHeader\">Total:</td>\n                                                <td id=\"tdTotalPrice\" class=\"smallTotalPrice\" >$5.00</td>\n                                            </tr>\n                                            <tr>\n                                                <td colspan=\"4\" class=\"noteStyle\">*Shipping durations are estimates and not a guarantee</td>\n                                            </tr>\n                                        </tbody>\n                                    </table>\n                                </div>\n                               \n                                <div class=\"topPaddingLarger\">\n                                    <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                        <tbody>\n                                            <tr>\n                                                <td class=\"payInfo\">Payment Information</td>\n                                            </tr>\n                                            <tr>\n                                                <td class=\"cardTd\">\n                                                    <div class=\"redColor\"></div>\n                                                    <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n                                                        <tbody>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Confirmation Code: 92111-852221</td>\n                                                                <td colspan=\"2\">&nbsp;</td>\n                                                            </tr>\n                                                            <tr>\n                                                                <td class=\"alignRight\">Card Number: Visa 111111111111111</td>\n                                                                <td colspan=\"2\">&nbsp;</td>\n                                                            </tr>\n                                                        </tbody>\n                                                    </table>\n                                                </td>\n                                            </tr>\n\n                                        </tbody>\n                                    </table>\n                                </div>\n                            </div>\n\n                </div>\n     ";

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(127);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".mainContent {\n    position: relative; \n    top: -10px;\n}\n\n.headerDiv {\n    margin: 15px 0 0 15px;\n}\n\n.smallHeaderDiv {\n    margin: 0px 0 0 0px;\n}\n\n.headerStyle {\n    height: 40px; \n    padding-top: 9px; \n    padding-left: 15px; \n    background-color: #bc9a72; \n    color:#4b290c; \n    font-family: Cambria; \n    font-size: 16px; \n    font-weight:bold;\n}\n\n.smallHeaderStyle {\n    height: 50px; \n    padding-top: 9px; \n    padding-left: 5px; \n    background-color: #bc9a72; \n    color:#4b290c; \n    font-family: Cambria; \n    font-size: 14px; \n    font-weight:bold;\n}\n\n.mainDiv {\n    background-color:#e8e3c8; \n    margin: 5px 0 0 15px; \n    padding:10px;\n}\n\n.smallMainDiv {\n    background-color:#e8e3c8; \n    margin: 5px 0 0 0px; \n    padding:10px;\n}\n\n.topPadding {\n    padding-top:5px;\n}\n.topPaddingLarger {\n    padding-top:25px;\n}\n\n.smallTopPadding {\n    padding-top: 35px;\n}\n\n.billingAddressHeader {\n    width:430px; \n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallBillingAddressHeader {\n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n.shippingAddressHeader {\n    width:430px; \n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border: 1px dashed #929292;\n}\n\n.smallShippingAddressHeader {\n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border: 1px dashed #929292;\n}\n\n.billingAddressTd {\n    width:430px; \n    padding:5px; \n    color:#4b290c; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallBillingAddressTd {\n    padding:5px; \n    color:#4b290c; \n    border-top: 1px dashed #929292; \n    border-bottom: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.alignRight {\n    text-align:right;\n}\n\n.alignCenter {\n    text-align: center;\n}\n\n.smallAlignLeftPadding {\n    text-align:left; \n    padding:0 0 0 5px;         \n}\n\n.shippingAddressTd {\n    width:430px; \n    text-align:left; \n    color:#4b290c; \n    border: 1px dashed #929292;\n}\n\n.smallShippingAddressTd {\n    text-align:left; color:#4b290c; \n    border: 1px dashed #929292;\n}\n\n.shippingToYouHeader {\n    width:500px; \n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallShippingToYouHeader {\n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.priceQuantityStyle {\n    width:100px; \n    height:25px; \n    text-align:center; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.smallPriceQuantityStyle {\n    height:25px; \n    text-align:center; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.totalHeaderStyle {\n    width:100px; \n    height:25px; \n    text-align:center; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.smallTotalHeaderStyle {\n    height:25px; \n    text-align:center; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n\n.productStyle {\n    width: 500px; \n    padding: 5px; \n    color: #4b290c; \n    border-top: 1px dashed #929292;\n    border-left: 1px dashed #929292;\n}\n\n.smallProductStyle {\n    padding: 5px; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.priceStyle {\n    width: 100px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292;\n    border-left: 1px dashed #929292;\n}\n\n.smallPriceStyle {\n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.quantityStyle {\n    width: 100px; \n    padding: 5px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292;\n    border-left: 1px dashed #929292;\n}\n\n.smallQuantityStyle {\n    padding: 5px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n.totalPriceStyle {\n    width: 100px; \n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292;\n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.smallTotalPriceStyle {\n    text-align: center; \n    color: #4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.subTotalSpace {\n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292;\n}\n\n\n\n.subTotalHeader {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    text-align:right; \n    border-top: 1px dashed #929292;\n}\n\n.smallSubTotalHeader {\n    height:35px; \n    color:#4b290c; \n    text-align:right; \n    border-top: 1px dashed #929292;\n}\n\n.subTotalPrice {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    text-align:center; \n    border-top: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.smallSubTotalPrice {\n    height:35px; \n    color:#4b290c; \n    text-align:center; \n    border-top: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n.shippingHandlingStyle {\n    border-left: 1px dashed #929292; \n    color:#4b290c;\n}\n\n\n.shippingHandlingPrice {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    text-align:center; \n    border-right: 1px dashed #929292;\n}\n\n.smallShippingHandlingPrice {\n    height:35px; \n    color:#4b290c; \n    text-align:center; \n    border-right: 1px dashed #929292;\n}\n\n.totalSpace {\n    border-left: 1px dashed #929292; \n    border-bottom: 1px dashed #929292;\n}\n\n.totalHeader {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    font-weight:bold; \n    text-align:right; \n    border-bottom: 1px dashed #929292;\n}\n\n.smallTotalHeader {\n    height:35px; \n    color:#4b290c; \n    font-weight:bold; \n    text-align:right; \n    border-bottom: 1px dashed #929292;\n}\n\n.totalPrice {\n    width:100px; \n    height:35px; \n    color:#4b290c; \n    font-weight:bold; \n    text-align:center; \n    border-right: 1px dashed #929292; \n    border-bottom: 1px dashed #929292;\n}\n\n.smallTotalPrice {\n    height:35px; \n    color:#4b290c; \n    font-weight:bold; \n    text-align:center; \n    border-right: 1px dashed #929292; \n    border-bottom: 1px dashed #929292;\n}\n\n.noteStyle {\n    text-align:right; \n    color:#4b290c; \n    font-style:italic; \n    padding-top:2px; \n    padding-right:3px;\n}\n\n\n\n.payInfo {\n    height:25px; \n    padding:5px; \n    background-color:#d2be9d; \n    color:#4b290c; \n    font-weight:bold; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n\n\n.cardTd {\n    padding:5px; \n    color:#4b290c; \n    border-top: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292;\n}\n\n\n.redColor {\n    color:red;\n}\n\n.bottomTdStyle {\n    height:45px; \n    padding:10px; \n    border-bottom: 1px dashed #929292; \n    border-left: 1px dashed #929292; \n    border-right: 1px dashed #929292; \n    text-align:right; \n    padding-right:5px;\n}", ""]);

// exports


/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShopComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var ShopComponent = /** @class */ (function () {
    function ShopComponent() {
    }
    ShopComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: "shop",
            template: __webpack_require__(129),
            styles: [__webpack_require__(130)]
        })
    ], ShopComponent);
    return ShopComponent;
}());



/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "\n    <side-menu></side-menu>\n\n    <div class=\"visible-xs visible-sm clearfix col-md-3 divMainLinksDrop\">\n\n\n        <div class=\"btn-group\">\n            <button class=\"btn btn-custom btn-lg dropdown-toggle\" type=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\" style=\"width:280px; background-color:#22190f; color:#f8f3dc;\">\n                <span class=\"shopTitleDropStyle\">Shop</span> <span class=\"caret\"></span>\n            </button>\n\n\n\n            <ul class=\"dropdown-menu dropDownMenuWidth\">\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/SpiceRubs\" target=\"_self\">SPICE RUBS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/CookBooks\" target=\"_self\">COOKBOOKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BakingPlanks\" target=\"_self\">BAKING PLANKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BbqPlanks\" target=\"_self\">BBQ PLANKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/NutDriver\" target=\"_self\">NUT DRIVER</a></li>\n            </ul>\n        </div>\n    </div>\n\n\n\n<div class=\"container-fluid\">\n\n    <div class=\"row\">\n        <div class=\"col-md-9\">\n\n            <div class=\"hidden-xs middleBackground\">\n                <div class=\"dotted_line_top dottedLineClass\">\n                    <div id=\"content_title\" class=\"dotted_line_bottom dotted_line_right productsTitleClass\">PLANKCOOKING PRODUCTS</div>\n                </div>\n                <div class=\"divCubes\">\n                    <table border=\"0\" cellpadding=\"25\" cellspacing=\"25\" align=\"center\">\n                        <tbody>\n                            \n                       \n                            <tr>\n                                <td><a routerLink=\"/Shop/SpiceRubs\"><img alt=\"Spice Rubs\" class=\"cubesImages\" src=\"" + __webpack_require__(60) + "\"></a></td>\n                                <td><a routerLink=\"/Shop/CookBooks\"><img alt=\"Cookbooks\" class=\"cubesImages\" src=\"" + __webpack_require__(61) + "\"></a></td>\n                            </tr>\n                            <tr>\n                                <td><a routerLink=\"/Shop/BakingPlanks\"><img alt=\"Baking Planks\" class=\"cubesImages\" src=\"" + __webpack_require__(62) + "\"></a></td>\n                                <td><a routerLink=\"/Shop/BbqPlanks\"><img alt=\"BBQ Planks\" class=\"cubesImages\" src=\"" + __webpack_require__(63) + "\"></a></td>\n                            </tr>\n                        </tbody>\n                    </table>\n                </div>\n                <div class=\"bottomBackground\">&nbsp;</div>\n            </div>\n            <div class=\"visible-xs\">\n                <div class=\"smallDivMain\">\n                    <div class=\"dotted_line_top dottedLineSmallClass\"><div id=\"content_title\" class=\"dotted_line_bottom dotted_line_right productsTitleClass\">PLANKCOOKING PRODUCTS</div></div>\n                    <div class=\"divSmallImageLinks\">\n                        <table border=\"0\" cellpadding=\"5\" cellspacing=\"5\" align=\"center\">\n                            <tbody>\n                                <tr><td><a routerLink=\"/Shop/SpiceRubs\"><img alt=\"Spice Rubs\" class=\"cubesImages\" src=\"" + __webpack_require__(60) + "\" class=\"img-responsive\"></a></td><td><a routerLink=\"/Shop/CookBooks\"><img alt=\"Cookbooks\" src=\"" + __webpack_require__(61) + "\" class=\"cubesImages img-responsive\"></a></td></tr>\n                                <tr><td><a routerLink=\"/Shop/BakingPlanks\"><img alt=\"Baking Planks\" class=\"cubesImages\" src=\"" + __webpack_require__(62) + "\" class=\"img-responsive\"></a></td><td><a routerLink=\"/Shop/BbqPlanks\"><img alt=\"BBQ Planks\" src=\"" + __webpack_require__(63) + "\" class=\"cubesImages img-responsive\"></a></td></tr>\n                            </tbody>\n                        </table>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n    </div>\n\n<a [routerLink]=\"['/cart']\">Go To Cart</a>\n<br />\n<br />\n<a [routerLink]=\"['/Shop/CookBooks']\">Go To Cookbooks</a>\n\n";

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(131);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".dropDownLinkStyle {\n    height:30px;\n}\n\n.divMainLinksDrop {\n    text-align:center; \n    margin:0 0 30px 0;\n}\n\n.shopTitleDropStyle {\n    font-size:24px;\n}\n\n.dropDownMenuWidth {\n    width:280px;\n}\n.dottedLineClass {\n    margin: 0px 25px 0 25px;\n}\n\n.dottedLineSmallClass {\n    margin:10px 0px 0 0px;\n}\n\n.productsTitleClass {\n    width:250px;\n}\n\n\n\n.divCubes {\n     margin:15px 25px 25px 100px;\n     position:relative;\n}\n.divSmallImageLinks {\n    margin-top:15px; \n    position:relative;\n\n}\n\n.cubesImages {\n    border:none;\n}\n\n.middleBackground {\n    position:relative; \n    left:40px; top:0px; \n    width:625px; \n    padding-top:30px; \n    background-image: url(/images/PaperBackground_Middle.png); \n    background-repeat:repeat-y;\n}\n\n.bottomBackground {\n    width:626px; \n    height:35px; \n    background-image: url(/images/PaperBackground_Bottom.png); \n    background-repeat:no-repeat;\n}\n\n.smallDivMain {\n    display:inline-block;\n}\n", ""]);

// exports


/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShopCookbooksComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_plankcooking_service__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var ShopCookbooksComponent = /** @class */ (function () {
    function ShopCookbooksComponent(plankCookingService) {
        this.plankCookingService = plankCookingService;
        this.products = [];
    }
    ShopCookbooksComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.plankCookingService.getCookBooks().subscribe(function (products) {
            _this.products = products;
        });
    };
    ShopCookbooksComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: "shop-cookbooks",
            template: __webpack_require__(133),
            styles: [__webpack_require__(134)]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__services_plankcooking_service__["a" /* PlankCookingService */]])
    ], ShopCookbooksComponent);
    return ShopCookbooksComponent;
}());



/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "\n<side-menu></side-menu>\n\n   \n    <div class=\"visible-xs visible-sm clearfix col-md-3 mainClass\">\n\n        <div class=\"btn-group\">\n            <button class=\"btn btn-custom btn-lg dropdown-toggle dropDownStyle\" type=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                <span class=\"shopTitleDropStyle\">Shop</span> <span class=\"caret\"></span>\n            </button>\n\n            <ul class=\"dropdown-menu menuStyle\">\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/SpiceRubs\" target=\"_self\">SPICE RUBS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/CookBooks\" target=\"_self\">COOKBOOKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BakingPlanks\" target=\"_self\">BAKING PLANKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BbqPlanks\" target=\"_self\">BBQ PLANKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/NutDriver\" target=\"_self\">NUT DRIVER</a></li>\n            </ul>\n        </div>\n\n\n    </div>\n\n    <div class=\"container-fluid\">\n        <div class=\"row\">\n            <div class=\"col-md-9\">\n\n\n                <div class=\"hidden-xs containerStyle\">\n                    <div\n                    class=\"backgroundImageStyle\"><img alt=\"BBQ Planks\"  src=\"" + __webpack_require__(17) + "\" class=\"img-responsive headerStyle\"></div>\n                    <div class=\"backgroundMiddle\">\n                        <div class=\"positionStyle\">\n\n                            <div class=\"hidden-xs\">\n\n                                    <div *ngFor=\"let product of products\" class=\"hidden-xs\">\n                                        <div class=\"dotted_line_top productTitle\" >\n                                            <div class=\"contentTitles dotted_line_bottom dotted_line_right productWidth\">{{product.name}}</div>\n                                        </div>\n                                        <div class=\"product\">\n                                            <table cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                                <tbody>\n                                                    <tr>\n                                                        <td class=\"descriptionStyle\" valign=\"top\" align=\"left\">{{product.description}} </td>\n                                                        <td valign=\"top\" align=\"center\">\n                                                            <div>Price: {{product.price.toFixed(2)}} </div>\n                                                            <div class=\"heightTextBoxStyle\">\n                                                                <div class=\"textBox\">Quantity: <input class=\"textBox_Quantity\"></div>\n                                                                <div class=\"textBox\"><input type=\"image\" class=\"img-responsive\" alt=\"Add To Cart\" src=\"/images/AddToCart_button.png\"></div>\n                                                            </div>\n\n                                                            <div class=\"imgStyle\"><img class=\"cartImagePath\" src=\"{{product.imagePath}}\" alt=\"Product\"></div>\n                                                        </td>\n                                                    </tr>\n                                                </tbody>\n                                            </table>\n                                        </div>\n                                    </div>\n                                \n\n                            </div>\n                        </div>\n                        <div class=\"backgroundBottom\">&nbsp;</div>\n                    </div>\n\n                </div>\n\n                <div class=\"visible-xs\">\n                   <div class=\"smallSizeHeader\"><img alt=\"Cookbook Covers\" src=\"" + __webpack_require__(17) + "\" class=\"img-responsive\"></div>\n               <div *ngFor=\"let product of products\">\n                    <div class=\"dotted_line_top mainClassSmall\">\n                        <div class=\"contentTitles dotted_line_bottom dotted_line_right \">{{product.name}}</div>\n                    </div>\n                   \n                        <table cellpadding=\"0\" cellspacing=\"0\">\n                            <tbody>\n                                <tr>\n                                    <td class=\"smallDescriptionStyle\" valign=\"top\" align=\"left\">{{product.description}}</td>\n                                    <td valign=\"top\" align=\"center\">\n                                        <div>Price: ${{product.price.toFixed(2)}}<br>{{product.priceDescription}}</div>\n                                        <div class=\"cartTextSmallHeight\">\n                                            <div>Quantity: <input class=\"textBox_Quantity\"></div>\n                                            <div><input type=\"image\" class=\"cartBtnSmallPadding\" alt=\"Add To Cart\" src=\"/images/AddToCart_button.png\"></div>\n                                        </div>\n\n                                        <div class=\"imgStyle\"><img class=\"smallImgStyle\" src=\"{{product.imagePath}}\" alt=\"Product\"></div>\n                                    </td>\n                                </tr>\n                            </tbody>\n                        </table>\n                 </div>\n                </div>\n\n            </div>\n        </div>\n\n\n    </div>\n\n\n\n\n\n";

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(135);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".dropDownLinkStyle {\n    height:30px;\n}\n\n.mainClass {\n    text-align:center; \n    margin:0 0 30px 0;\n}\n\n.dropDownStyle {\n    width:280px; \n    background-color:#22190f; \n    color:#f8f3dc;\n}\n\n.shopTitleDropStyle {\n    font-size:24px;\n}\n\n.menuStyle {\n    width:280px;\n}\n\n.containerStyle {\n    position:relative; \n    left:40px;\n}\n\n.backgroundImageStyle {\n    position:relative; \n    height:364px; \n    width:650px; \n    background-image:url(/images/Photo_Background.png);\n}\n\n.headerStyle {\n    position:relative; \n    top:20px; \n    left:26px;\n}\n\n.backgroundMiddle {\n    position: relative; \n    top: -25px; \n    left: 11px; \n    width: 626px; \n    background-image: url(/images/PaperBackground_Middle.png); \n    background-repeat:repeat-y;\n}\n\n.positionStyle {\n    position:relative; \n    top:5px; \n    left:31px\n}\n\n.productTitle {\n    margin: 10px 0 10px 0; \n    width:570px; \n    text-align:left;\n}\n\n.productWidth {\n    width:350px;\n}\n\n.product {\n    width:570px;\n}\n\n.descriptionStyle {\n    width:350px; \n    padding-right:15px;\n}\n\n.heightTextBoxStyle {\n    height:38px;\n}\n\n.textBox {\n    width:100px;\n}\n\n.textBox_Quantity {\n    width:25px; \n    color:black; \n    text-align:center;\n}\n\n.imgStyle {\n    padding-top:25px; \n    text-align:center;\n}\n\n.cartImagePath {\n    border:none;\n }\n\n .backgroundBottom {\n    width: 626px; \n    height: 35px; \n    background-image: url(/images/PaperBackground_Bottom.png);\n    background-repeat: no-repeat;\n}\n\n.smallSizeHeader {\n    display:inline-block;\n}\n\n.mainClassSmall {\n    margin: 10px 0 10px 0;\n     text-align:left;\n}\n\n.smallDescriptionStyle {\n    padding-right:15px;\n}\n\n.cartBtnSmallPadding {\n    padding:3px 5px 0 0\n}\n\n.cartTextSmallHeight {\n    height:38px;\n}\n\n.smallImgStyle {\n    border:none\n}", ""]);

// exports


/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShopBakingPlanksComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_plankcooking_service__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var ShopBakingPlanksComponent = /** @class */ (function () {
    function ShopBakingPlanksComponent(plankCookingService) {
        this.plankCookingService = plankCookingService;
        this.products = [];
    }
    ShopBakingPlanksComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.plankCookingService.getBakingPlanks().subscribe(function (products) {
            _this.products = products;
        });
    };
    ShopBakingPlanksComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'shop-bakingplanks',
            template: __webpack_require__(137),
            styles: [__webpack_require__(138)]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__services_plankcooking_service__["a" /* PlankCookingService */]])
    ], ShopBakingPlanksComponent);
    return ShopBakingPlanksComponent;
}());



/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "<side-menu></side-menu>\n    <div class=\"visible-xs visible-sm clearfix col-md-3 mainClass\">\n\n        <div class=\"btn-group\">\n            <button class=\"btn btn-custom btn-lg dropdown-toggle dropDownStyle\" type=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                <span class=\"shopTitleDropStyle\">Shop</span> <span class=\"caret\"></span>\n            </button>\n\n            <ul class=\"dropdown-menu\" style=\"width:280px;\">\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/SpiceRubs\" target=\"_self\">SPICE RUBS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/CookBooks\" target=\"_self\">COOKBOOKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BakingPlanks\" target=\"_self\">BAKING PLANKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BbqPlanks\" target=\"_self\">BBQ PLANKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/NutDriver\" target=\"_self\">NUT DRIVER</a></li>\n            </ul>\n        </div>\n\n\n    </div>\n\n    <div class=\"container-fluid\">\n        <div class=\"row\">\n\n            <div class=\"col-md-9\">\n\n                <div class=\"hidden-xs containerStyle\">\n                    <div class=\"backgroundImageStyle\"><img class=\"headerStyle\" alt=\"Baking Planks\" src=\"" + __webpack_require__(64) + "\"></div>\n                    <div class=\"backgroundMiddle\">\n\n                        <div class=\"positionStyle\">\n\n                            <div class=\"descriptionStyle\">Cedar and Alder planks impart a subtle yet full flavored aroma to anything roasted on them. Our planks are made from clear kiln dried Western Red Cedar and Alder. Cedar roasting planks come in two sizes. Alder planks are available in one size only.</div>\n                           <div *ngFor=\"let product of products\">\n                                <div class=\"dotted_line_top productTitle\">\n                                    <div class=\"contentTitles dotted_line_bottom dotted_line_right productWidth\">{{product.name}}</div>\n                                </div>\n                                <div class=\"productStyle\">\n                                    <div>{{product.description}}</div>\n\n\n                                    <div class=\"tableStyle\">\n                                        <table cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                            <tbody>\n                                                <tr>\n                                                    <td class=\"productNameStyle\" valign=\"top\">\n                                                        {{product.name}}\n                                                        <div class=\"productImagePath\"><img class=\"imgPath\" alt=\"No Picture of {{product.name}}\" src=\"{{product.imagePath}}\"></div>\n                                                    </td>\n                                                    <td valign=\"top\" class=\"priceStyle\">\n                                                        <div>Price: ${{product.price.toFixed(2)}} </div>\n                                                        <div class=\"heightTextBoxStyle\">\n                                                            <div class=\"textBox\">Quantity: <input class=\"textBox_Quantity\"></div>\n                                                            <div class=\"textBox\"><input class=\"imgAddToCart\" type=\"image\" alt=\"Add To Cart\" src=\"/images/AddToCart_button.png\"></div>\n                                                        </div>\n                                                    </td>\n                                                </tr>\n                                            </tbody>\n                                        </table>\n                                    </div>\n\n                                </div>\n                                </div>\n\n\n                            \n                        </div>\n                        <div class=\"backgroundBottom\">&nbsp;</div>\n                    </div>\n\n                </div>\n\n                <div class=\"visible-xs mainClassSmall\">\n\n                    <div class=\"smallSizeHeader\"><img alt=\"Baking Planks\" src=\"" + __webpack_require__(64) + "\" class=\"img-responsive\"></div>\n                    \n                        <div class=\"smallSizePosition\">\n                            <div style=\"padding-top: 10px; padding-bottom: 5px\">Cedar and Alder planks impart a subtle yet full flavored aroma to anything roasted on them. Our planks are made from clear kiln dried Western Red Cedar and Alder. Cedar roasting planks come in two sizes. Alder planks are available in one size only.</div>\n                          <div *ngFor=\"let product of products\">\n                            <div class=\"dotted_line_top dottedLineClass\">\n                                <div class=\"contentTitles dotted_line_bottom dotted_line_right\">{{product.name}}</div>\n                            </div>\n                        \n                                <div>{{product.description}}.</div>\n\n\n                                <div class=\"tableStyle\">\n                                    <table cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                        <tbody>\n                                            <tr>\n                                                <td class=\"productNameStyle\" valign=\"top\">\n                                                    {{product.name}}\n                                                    <div class=\"productImagePath\"><img alt=\"Product\" style=\"border:none\" src=\"{{product.imagePath}}\"></div>\n                                                </td>\n                                                <td valign=\"top\" class=\"priceStyle\">\n                                                    <div>Price: ${{product.price.toFixed(2)}} </div>\n                                                    <div class=\"heightTextBoxStyle\">\n                                                        <div class=\"textBox\">Quantity: <input class=\"textBox_Quantity\"></div>\n                                                        <div class=\"textBox\"><input class=\"imgAddToCart\" type=\"image\" alt=\"Add To Cart\" src=\"/images/AddToCart_button.png\"></div>\n                                                    </div>\n\n                                                </td>\n                                            </tr>\n                                        </tbody>\n                                    </table>\n                                \n                                </div>\n\n                                \n                            </div>\n                        </div>\n                        \n                    </div>\n\n                </div>\n            </div>\n        </div>";

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(139);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".mainClass {\n    text-align:center; \n    margin:0 0 30px 0;\n}\n\n.shopTitleDropStyle {\n    font-size:24px;\n}\n\n.dropDownStyle {\n    width:280px; \n    background-color:#22190f; \n    color:#f8f3dc;\n}\n\n.dropDownLinkStyle {\n    height:30px;\n}\n\n.containerStyle {\n    position:relative; \n    left:40px;\n}\n\n.backgroundImageStyle {\n    position:relative; \n    height:364px; \n    width:650px; \n    background-image:url(/images/Photo_Background.png);\n}\n\n.headerStyle {\n    position:relative; \n    top:20px; \n    left:0;\n}\n\n.backgroundMiddle {\n    position: relative; \n    top: -25px; \n    left: 11px; \n    width: 626px; \n    background-image: url(/images/PaperBackground_Middle.png); \n    background-repeat:repeat-y;\n}\n\n.positionStyle {\n    position: relative; \n    top: 5px; \n    left: 31px; \n    text-align:left;\n}\n\n.descriptionStyle {\n    width: 570px; \n    padding-top: 10px; \n    padding-bottom: 5px;\n}\n\n.productTitle {\n    margin: 10px 0 10px 0; \n    width:570px; \n}\n\n.productWidth {\n    width:350px;\n}\n\n.productStyle {\n    width:570px;\n}\n\n.tableStyle {\n    padding-top: 20px; \n    width:100%;\n}\n\n.productNameStyle {\n    width:75%; \n    padding-right:15px; \n    text-align:left;\n}\n\n.productImagePath {\n    padding-top:5px;\n    text-align:left;\n}\n\n.imgPath {\n    border: none;\n}\n\n.priceStyle {\n    text-align:left;\n}\n\n.heightTextBoxStyle {\n    height:38px;\n}\n\n.textBox {\n    float:left;\n     width:100px;\n}\n\n.textBox_Quantity {\n    width:25px; \n    color:black; \n    text-align:center;\n}\n\n.imgAddToCart {\n    padding-right:5px;\n}\n\n.backgroundBottom {\n    width: 626px; \n    height: 35px; \n    background-image: url(/images/PaperBackground_Bottom.png);\n    background-repeat: no-repeat;\n}\n\n.mainClassSmall {\n    width:100%;\n}\n\n.smallSizeHeader {\n    display:inline-block;\n}\n\n.smallSizePosition {\n    position: relative; \n    top: 5px; \n    left: 0px; \n    text-align:left;\n}\n\n.dottedLineClass {\n    margin: 10px 0 10px 0;\n}\n\n", ""]);

// exports


/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShopBbqPlanksComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_plankcooking_service__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var ShopBbqPlanksComponent = /** @class */ (function () {
    function ShopBbqPlanksComponent(plankCookingService) {
        this.plankCookingService = plankCookingService;
        this.products = [];
    }
    ShopBbqPlanksComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.plankCookingService.getBbqPlanks().subscribe(function (products) {
            _this.products = products;
        });
    };
    ShopBbqPlanksComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'shop-bbqplanks',
            template: __webpack_require__(141),
            styles: [__webpack_require__(142)]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__services_plankcooking_service__["a" /* PlankCookingService */]])
    ], ShopBbqPlanksComponent);
    return ShopBbqPlanksComponent;
}());



/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "<side-menu></side-menu>\n\n\n  \n    <div class=\"visible-xs visible-sm clearfix col-md-3 mainDropDownClass\">\n\n        <div class=\"btn-group\">\n            <button class=\"btn btn-custom btn-lg dropdown-toggle dropDownStyle\" type=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                <span class=\"shopTitleDropStyle\">Shop</span> <span class=\"caret\"></span>\n            </button>\n\n            <ul class=\"dropdown-menu\" style=\"width:280px;\">\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/SpiceRubs\" target=\"_self\">SPICE RUBS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/CookBooks\" target=\"_self\">COOKBOOKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BakingPlanks\" target=\"_self\">BAKING PLANKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BbqPlanks\" target=\"_self\">BBQ PLANKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/NutDriver\" target=\"_self\">NUT DRIVER</a></li>\n            </ul>\n        </div>\n\n\n    </div>\n\n    <div class=\"container-fluid\">\n        <div class=\"row\">\n            <div class=\"col-md-9\">\n\n\n                <div class=\"hidden-xs containerStyle\">\n                    <div class=\"backgroundImageStyle\"><img alt=\"BBQ Planks\" src=\"" + __webpack_require__(65) + "\" class=\"img-responsive headerStyle\"></div>\n                    <div class=\"backgroundMiddle\">\n                        <div *ngFor=\"let product of products\" class=\"positionStyle\">\n\n                                        <div class=\"dotted_line_top productTitle\">\n                                            <div class=\"contentTitles dotted_line_bottom dotted_line_right productWidth\">{{product.name}}</div>\n                                        </div>\n                                        <div class=\"product\">\n                                            <table cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                                                <tbody>\n                                                    <tr>\n                                                        <td class=\"descriptionStyle\" valign=\"top\" align=\"left\">{{product.description}} </td>\n                                                        <td valign=\"top\" align=\"center\">\n                                                            <div>Price: ${{product.price.toFixed(2)}}</div>\n                                                            <div class=\"heightTextBoxStyle\">\n                                                                <div class=\"textBox\">Quantity: <input class=\"textBox_Quantity\"></div>\n                                                                <div class=\"textBox\"><input type=\"image\" class=\"img-responsive cartBtnPadding\" alt=\"Add To Cart\" src=\"/images/AddToCart_button.png\"></div>\n                                                            </div>\n\n                                                            <div class=\"imgStyle\"><img class=\"smallImgStyle\" src=\"{{product.imagePath}}\" alt=\"Product\"></div>\n                                                        </td>\n                                                    </tr>\n                                                </tbody>\n                                            </table>\n                                        </div>\n\n                            </div>\n               \n                        <div class=\"backgroundBottom\">&nbsp;</div>\n                    </div>\n\n                </div>\n\n                <div class=\"visible-xs\">\n                    <div class=\"smallSizeHeader\"><img alt=\"BBQ Planks\" src=\"" + __webpack_require__(65) + "\" class=\"img-responsive\"></div>\n                    <div *ngFor=\"let product of products\">\n                    <div class=\"dotted_line_top mainClassSmall\">\n                        <div class=\"contentTitles dotted_line_bottom dotted_line_right \">{{product.name}}</div>\n                    </div>\n            \n                        <table cellpadding=\"0\" cellspacing=\"0\">\n                            <tbody>\n                                <tr>\n                                    <td class=\"smallDescriptionStyle\" valign=\"top\" align=\"left\">{{product.description}}. </td>\n                                    <td valign=\"top\" align=\"center\">\n                                        <div>Price: ${{product.price.toFixed(2)}}<br></div>\n                                        <div class=\"cartTextSmallHeight\">\n                                            <div>Quantity: <input class=\"textBox_Quantity\"></div>\n                                            <div><input class=\"smallAddToCartImg\" type=\"image\" class=\"img-responsive\" alt=\"Add To Cart\" src=\"/images/AddToCart_button.png\"></div>\n                                        </div>\n\n                                        <div class=\"imgStyle\"><img class=\"smallImgStyle\" src=\"{{product.imagePath}}\" alt=\"Product\"></div>\n                                    </td>\n                                </tr>\n                            </tbody>\n                        </table>\n                    </div>\n                </div>\n          \n\n            </div>\n        </div>\n\n\n    </div>\n\n";

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(143);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".mainDropDownClass {\n    text-align:center; \n    margin:0 0 30px 0;\n}\n\n.dropDownStyle {\n    width:280px; \n    background-color:#22190f; \n    color:#f8f3dc;\n}\n\n.shopTitleDropStyle {\n    font-size:24px;\n}\n\n.dropDownLinkStyle {\n    height:30px;\n}\n\n.containerStyle {\n    position:relative; \n    left:40px;\n}\n\n.backgroundImageStyle {\n    position:relative; \n    height:364px; \n    width:650px; \n    background-image:url(/images/Photo_Background.png);\n}\n\n.headerStyle {\n    position:relative; \n    top:20px; \n    left:26px;\n}\n\n.backgroundMiddle {\n    position: relative; \n    top: -25px; \n    left: 11px; \n    width: 626px; \n    background-image: url(/images/PaperBackground_Middle.png); \n    background-repeat:repeat-y;\n}\n\n.positionStyle {\n    position:relative; \n    top:5px; \n    left:31px\n}\n\n.productTitle {\n    margin: 10px 0 10px 0; \n    width:570px; \n    text-align:left;\n}\n\n.productWidth {\n    width:350px;\n}\n\n.product {\n    width:570px;\n}\n\n.descriptionStyle {\n    width:350px; \n    padding-right:15px;\n}\n\n.heightTextBoxStyle {\n    height:38px;\n}\n\n.textBox {\n    width:100px;\n}\n\n.textBox_Quantity {\n    width:25px; \n    color:black; \n    text-align:center;\n}\n\n.cartBtnPadding {\n   padding:5px 5px 0 0;\n}\n\n.imgStyle {\n    padding-top:25px; \n    text-align:center;\n}\n\n.smallImgStyle {\n    border:none;\n}\n\n.backgroundBottom {\n    width: 626px; \n    height: 35px; \n    background-image: url(/images/PaperBackground_Bottom.png);\n    background-repeat: no-repeat;\n}\n\n.smallSizeHeader {\n    display:inline-block;\n}\n\n.mainClassSmall {\n    margin: 10px 0 10px 0;\n     text-align:left;\n}\n\n.smallDescriptionStyle {\n    padding-right:15px;\n}\n\n.cartTextSmallHeight {\n    height:38px;\n}\n\n.smallAddToCartImg {\n    padding:3px 5px 0 0;\n}", ""]);

// exports


/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShopNutDriverComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_plankcooking_service__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var ShopNutDriverComponent = /** @class */ (function () {
    function ShopNutDriverComponent(plankCookingService) {
        this.plankCookingService = plankCookingService;
        this.products = [];
    }
    ShopNutDriverComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.plankCookingService.getNutdriver().subscribe(function (products) {
            _this.products = products;
        });
    };
    ShopNutDriverComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'shop-nutdriver',
            template: __webpack_require__(145),
            styles: [__webpack_require__(146)]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__services_plankcooking_service__["a" /* PlankCookingService */]])
    ], ShopNutDriverComponent);
    return ShopNutDriverComponent;
}());



/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "<side-menu></side-menu>\n\n\n  \n<div class=\"visible-xs visible-sm clearfix col-md-3 mainClass\">\n\n    <div class=\"btn-group\">\n        <button class=\"btn btn-custom btn-lg dropdown-toggle dropDownStyle\" type=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            <span class=\"shopTitleDropStyle\">Shop</span> <span class=\"caret\"></span>\n        </button>\n\n        <ul class=\"dropdown-menu menuStyle\">\n            <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/SpiceRubs\" target=\"_self\">SPICE RUBS</a></li>\n            <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/CookBooks\" target=\"_self\">COOKBOOKS</a></li>\n            <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BakingPlanks\" target=\"_self\">BAKING PLANKS</a></li>\n            <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BbqPlanks\" target=\"_self\">BBQ PLANKS</a></li>\n            <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/NutDriver\" target=\"_self\">NUT DRIVER</a></li>\n        </ul>\n    </div>\n\n\n</div>\n   \n    <div class=\"container-fluid\">\n        <div class=\"row\">\n            <div class=\"col-md-9\">\n\n                <div class=\"hidden-xs containerStyle\">\n\n                    <div class=\"backgroundImageStyle\"><img class=\"img-responsive headerStyle\" alt=\"Nut Driver\" src=\"" + __webpack_require__(17) + "\"></div>\n\n                    <div  *ngFor=\"let product of products\" class=\"backgroundMiddle\">\n                        <div class=\"positionStyle\">\n\n\n\n                                <div class=\"dotted_line_top productTitle\">\n                                    <div class=\"contentTitles dotted_line_bottom dotted_line_right productWidth\">{{product.name}}</div>\n                                </div>\n                                <div class=\"product\">\n                                    <table>\n                                        <tbody>\n                                            <tr>\n                                                <td class=\"descriptionStyle\" valign=\"top\" align=\"left\">{{product.description}}</td>\n                                                <td valign=\"top\" align=\"center\">\n                                                    <div>Price: ${{product.price.toFixed(2)}} </div>\n                                                    <div class=\"heightTextBoxStyle\">\n                                                        <div class=\"textBox\">Quantity: <input class=\"textBox_Quantity\"></div>\n                                                        <div class=\"textBox\"><input type=\"image\" class=\"img-responsive cartBtnPadding\" alt=\"Add To Cart\" src=\"/images/AddToCart_button.png\"></div>\n                                                    </div>\n\n                                                    <div class=\"imgStyle\"><img class=\"img-responsive smallImgStyle\" src=\"{{product.imagePath}}\" alt=\"Product\"></div>\n                                                </td>\n                                            </tr>\n                                        </tbody>\n                                    </table>\n                                </div>\n\n                    \n\n\n                        </div>\n                        <div class=\"hidden-xs backgroundBottom\">&nbsp;</div>\n                    </div>\n\n                </div>\n\n                <div class=\"visible-xs\">\n                    <div class=\"smallSizeHeader\"><img alt=\"Cookbook Covers\" src=\"" + __webpack_require__(17) + "\" class=\"img-responsive\"></div>\n                   <div *ngFor=\"let product of products\">\n                    <div class=\"dotted_line_top mainClassSmall\">\n\n                        <div class=\"contentTitles dotted_line_bottom dotted_line_right\">{{product.name}}</div>\n                    </div>\n                   \n                        <table cellpadding=\"0\" cellspacing=\"0\">\n                            <tbody>\n                                <tr>\n                                    <td class=\"smallDescriptionStyle\" valign=\"top\" align=\"left\">{{product.description}}</td>\n                                    <td valign=\"top\" align=\"center\">\n                                        <div>Price: ${{product.price.toFixed(2)}}<br></div>\n                                        <div class=\"cartTextSmallHeight\">\n                                            <div>Quantity: <input class=\"textBox_Quantity\"></div>\n                                            <div><input type=\"image\" class=\"img-responsive cartBtnPadding\" alt=\"Add To Cart\" src=\"/images/AddToCart_button.png\"></div>\n                                        </div>\n\n                                        <div class=\"imgStyle\"><img class=\"smallImgStyle\" src=\"{{product.imagePath}}\" alt=\"Product\"></div>\n                                    </td>\n                                </tr>\n                            </tbody>\n                        </table>\n                    </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n\n\n\n\n\n\n\n";

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(147);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".dropDownLinkStyle {\n    height:30px;\n}\n\n.mainClass {\n    text-align:center; \n    margin:0 0 30px 0;\n}\n\n.dropDownStyle {\n    width:280px; \n    background-color:#22190f; \n    color:#f8f3dc;\n}\n\n.shopTitleDropStyle {\n    font-size:24px;\n}\n\n.menuStyle {\n    width:280px;\n}\n\n.containerStyle {\n    position:relative; \n    left:40px;\n}\n\n.backgroundImageStyle {\n    position:relative; \n    height:364px; \n    width:650px; \n    background-image:url(/images/Photo_Background.png);\n}\n\n.headerStyle {\n    position:relative; \n    top:20px; \n    left:26px;\n}\n\n.backgroundMiddle {\n    position: relative; \n    top: -25px; \n    left: 11px; \n    width: 626px; \n    background-image: url(/images/PaperBackground_Middle.png); \n    background-repeat:repeat-y;\n}\n\n.positionStyle {\n    position:relative; \n    top:5px; \n    left:31px\n}\n\n.productTitle {\n    margin: 10px 0 10px 0; \n    width:570px; \n    text-align:left;\n}\n\n.productWidth {\n    width:350px;\n}\n\n.product {\n    width:570px;\n}\n\n.descriptionStyle {\n    width:350px; \n    padding-right:15px;\n}\n\n.heightTextBoxStyle {\n    height:38px;\n}\n\n.textBox {\n    width:100px;\n}\n\n.textBox_Quantity {\n    width:25px; \n    color:black; \n    text-align:center;\n}\n\n.cartBtnPadding {\n    padding:5px 5px 0 0\n}\n\n.imgStyle {\n    padding-top:25px; \n    text-align:center;\n}\n\n.smallImgStyle {\n    border:none\n}\n\n.backgroundBottom {\n    width: 626px; \n    height: 35px; \n    background-image: url(/images/PaperBackground_Bottom.png);\n    background-repeat: no-repeat;\n}\n\n.smallSizeHeader {\n    display:inline-block;\n}\n\n.mainClassSmall {\n    margin: 10px 0 10px 0;\n     text-align:left;\n}\n\n.smallDescriptionStyle {\n    padding-right:15px;\n}\n\n.cartTextSmallHeight {\n    height:38px;\n}\n\n.textBox_Quantity {\n    width:25px; \n    color:black; \n    text-align:center;\n}\n\n.cartBtnPadding {\n    padding:5px 5px 0 0\n}", ""]);

// exports


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShopSpiceRubsComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__services_plankcooking_service__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_common_http__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_common_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__angular_common_http__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var ShopSpiceRubsComponent = /** @class */ (function () {
    function ShopSpiceRubsComponent(plankCookingService, http) {
        this.plankCookingService = plankCookingService;
        this.http = http;
        this.products = [];
        this.quantity = [];
    }
    ShopSpiceRubsComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.plankCookingService.getSpiceRubs().subscribe(function (products) {
            _this.products = products;
        });
    };
    ShopSpiceRubsComponent.prototype.addProduct = function (qty) {
        console.log("the qty = " + qty);
        var httpOptions = {
            headers: new __WEBPACK_IMPORTED_MODULE_2__angular_common_http__["HttpHeaders"]({ 'Content-Type': 'application/json' })
        };
        return this.http.post('api/v1/plankcooking/add/spicerubs', qty, httpOptions);
    };
    ShopSpiceRubsComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'shop-spicerubs',
            template: __webpack_require__(149),
            styles: [__webpack_require__(150)]
        }),
        __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__services_plankcooking_service__["a" /* PlankCookingService */], __WEBPACK_IMPORTED_MODULE_2__angular_common_http__["HttpClient"]])
    ], ShopSpiceRubsComponent);
    return ShopSpiceRubsComponent;
}());



/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "<side-menu></side-menu>\n   \n    <div class=\"visible-xs visible-sm clearfix col-md-3 mainClass\">\n\n        <div class=\"btn-group\">\n            <button class=\"btn btn-custom btn-lg dropdown-toggle dropDownStyle\" type=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                <span class=\"shopTitleDropStyle\">Shop</span> <span class=\"caret\"></span>\n            </button>\n\n            <ul class=\"dropdown-menu menuStyle\">\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/SpiceRubs\" target=\"_self\">SPICE RUBS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/CookBooks\" target=\"_self\">COOKBOOKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BakingPlanks\" target=\"_self\">BAKING PLANKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/BbqPlanks\" target=\"_self\">BBQ PLANKS</a></li>\n                <li class=\"dropDownLinkStyle\"><a routerLink=\"/Shop/NutDriver\" target=\"_self\">NUT DRIVER</a></li>\n            </ul>\n        </div>\n\n\n    </div>\n\n    <div class=\"container-fluid\">\n        <div class=\"row\">\n            <div class=\"col-md-9\">\n\n                <div class=\"hidden-xs containerStyle\">\n                    <div class=\"backgroundImageStyle\"><img  src=\"" + __webpack_require__(66) + "\" class=\"img-responsive headerStyle\"></div>\n                    <div class=\"backgroundMiddle\">\n                        <div class=\"positionStyle\">\n                            <div class=\"largeViewTitle\">Chef Howie created 3 Chefs In A Tub spice rubs and seasoning blends to bring professional flavor to home cooking. Very easy to use. Just season cook and serve. Made with all natural ingredients, dried herbs and mushrooms, spices, lemon, garlic, onion, brown sugar and kosher salt, no MSG or other chemical additives.</div>\n\n                            <div class=\"hidden-xs\">\n\n                              \n                                    <div *ngFor=\"let product of products\" class=\"hidden-xs\">\n                                        \n                                        <div class=\"dotted_line_top productTitle\">\n                                            \n                                            <div class=\"contentTitles dotted_line_bottom dotted_line_right productWidth\" >{{product.name}}</div>\n                                        </div>\n                                        <div class=\"product\">\n                                            <table>\n                                                <tbody>\n                                                    \n                                                    <tr>\n                                                        <td class=\"descriptionStyle\" valign=\"top\" align=\"left\">{{product.description}} </td>\n                                                        <td valign=\"top\" align=\"center\">\n\n                                                            <div>${{product.price.toFixed(2)}} {{product.priceDescription}}</div>\n\n                                                            <div class=\"heightTextBoxStyle\">\n                                                                <div class=\"textBox\">Quantity: <input #qty class=\"textBox_Quantity\" /></div>\n                                                                <div class=\"textBox\"><input (click)=\"addProduct(qty.value, product.name)\" type=\"image\" class=\"img-responsive cartBtnPadding\" alt=\"Add To Cart\" src=\"/images/AddToCart_button.png\" ></div>\n                                                            </div>\n\n                                                            <div class=\"imgStyle\"><img class=\"cartImagePath\" src=\"{{product.imagePath}}\" alt=\"Product\"></div>\n                                                        </td>\n                                                    </tr>\n\n\n                                                </tbody>\n                                            </table>\n                                        </div>\n                                    </div>\n\n\n                            </div>\n                            </div>\n                            <div class=\"backgroundBottom\">&nbsp;</div>\n                        </div>\n                        \n                    </div>\n                </div>\n                <div class=\"visible-xs\">\n                    <div class=\"smallSizeHeader\"><img  src=\"" + __webpack_require__(66) + "\" class=\"img-responsive\"></div>\n                        <div *ngFor=\"let product of products\">\n                        <div  class=\"dotted_line_top mainClassSmall\">\n\n                            <div class=\"contentTitles dotted_line_bottom dotted_line_right\">{{product.name}}</div>\n                        </div>\n                        \n                            <table cellpadding=\"0\" cellspacing=\"0\">\n\n                                <tbody>\n                                    <tr>\n                                        <td class=\"smallDescriptionStyle\" valign=\"top\" align=\"left\">{{product.description}} </td>\n                                        <td valign=\"top\" align=\"center\">\n                                            <div>Price: ${{product.price.toFixed(2)}}<br>{{product.priceDescription}}</div>\n                                            <div class=\"cartTextSmallHeight\">\n                                                <div>Quantity: <input  class=\"textBox_Quantity\"></div>\n                                                <div><input  type=\"image\" class=\"img-responsive cartBtnSmallPadding\" alt=\"Add To Cart\" src=\"/images/AddToCart_button.png\"></div>\n                                            </div>\n\n                                            <div class=\"imgStyle\"><img class=\"smallImgStyle\" src=\"{{product.imagePath}}\" alt=\"Product\" ></div>\n                                        </td>\n                                    </tr>\n\n                                </tbody>\n\n                            </table>\n                            </div>\n                        </div>\n                \n            </div>\n            </div>\n\n   \n\n\n";

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(151);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".dropDownLinkStyle {\n    height:30px;\n}\n\n.shopTitleDropStyle {\n    font-size:24px;\n}\n\n.mainClass {\n    text-align:center; \n    margin:0 0 30px 0;\n}\n\n.dropDownStyle {\n    width:280px; \n    background-color:#22190f; \n    color:#f8f3dc;\n}\n\n.menuStyle {\n    width:280px;\n}\n\n.containerStyle {\n    position:relative; \n    left:40px;\n}\n\n.backgroundImageStyle {\n    position:relative; \n    height:364px; \n    width:650px; \n    background-image:url(/images/Photo_Background.png);\n}\n\n.headerStyle {\n    position:relative; \n    top:20px; \n    left:26px;\n}\n\n.backgroundMiddle {\n    position: relative; \n    top: -25px; \n    left: 11px; \n    width: 626px; \n    background-image: url(/images/PaperBackground_Middle.png); \n    background-repeat:repeat-y;\n}\n\n.positionStyle {\n    position:relative; \n    top:5px; \n    left:31px\n}\n\n.largeViewTitle {\n    width:570px; \n    padding-top:10px; \n    padding-bottom:5px; \n    text-align:left;\n}\n\n.productTitle {\n    margin: 10px 0 10px 0; \n    width:570px; \n    text-align:left;\n}\n\n.productWidth {\n    width:350px;\n}\n.smallDescriptionStyle {\n    padding-right:15px;\n}\n.descriptionStyle {\n    width:350px; \n    padding-right:15px;\n}\n\n.textBox {\n    width:100px;\n}\n\n.textBox_Quantity {\n    width:25px; \n    color:black; \n    text-align:center;\n}\n\n.heightTextBoxStyle {\n    height:38px;\n}\n\n.imgStyle {\n    padding-top:25px; \n    text-align:center;\n}\n.smallImgStyle {\n    border:none\n}\n\n.backgroundBottom {\n    width: 626px; \n    height: 35px; \n    background-image: url(/images/PaperBackground_Bottom.png);\n    background-repeat: no-repeat;\n}\n\n.cartImagePath {\n   border:none;\n}\n\n.cartBtnPadding {\n    padding:5px 5px 0 0\n}\n\n.cartBtnSmallPadding {\n    padding:3px 5px 0 0\n}\n\n.smallSizeHeader {\n    display:inline-block;\n}\n\n.mainClassSmall {\n    margin: 10px 0 10px 0;\n     text-align:left;\n}\n\n.cartTextSmallHeight {\n    height:38px;\n}\n\n", ""]);

// exports


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SideMenuComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var SideMenuComponent = /** @class */ (function () {
    function SideMenuComponent() {
    }
    SideMenuComponent.prototype.ngOnInit = function () { };
    SideMenuComponent = __decorate([
        Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
            selector: 'side-menu',
            template: __webpack_require__(153),
            styles: [__webpack_require__(155)]
        }),
        __metadata("design:paramtypes", [])
    ], SideMenuComponent);
    return SideMenuComponent;
}());



/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "\n\n<div class=\"hidden-xs hidden-sm col-md-3\">\n\n\n    <div class=\"mainDiv\">\n\n        <div>\n            <img alt=\"Page Title\" class=\"menuHeader\" src=\"" + __webpack_require__(154) + "\" />\n\n            <div class=\"mainLinksDiv\">\n\n                <div class=\"dotted_line dottedLineClass\"></div>\n\n                <div>\n                    <a routerLink=\"/Shop/SpiceRubs\">\n                        <span class=\"leftMenuTitle\">SPICE RUBS</span>\n                    </a>\n                </div>\n                <div class=\"dotted_line dottedLineClass\"></div>\n                <div>\n                    <a routerLink=\"/Shop/CookBooks\">\n                        <span class=\"leftMenuTitle\">COOKBOOKS</span>\n                    </a>\n                </div>\n                <div class=\"dotted_line dottedLineClass\"></div>\n                <div>\n                    <a routerLink=\"/Shop/BakingPlanks\">\n                        <span class=\"leftMenuTitle\">BAKING PLANKS</span>\n                    </a>\n                </div>\n                <div  class=\"dotted_line dottedLineClass\"></div>\n                <div>\n                    <a routerLink=\"/Shop/BbqPlanks\">\n                        <span class=\"leftMenuTitle\">BBQ PLANKS</span>\n                    </a>\n                </div>\n                <div class=\"dotted_line dottedLineClass\"></div>\n                <div>\n                    <a routerLink=\"/Shop/NutDriver\">\n                        <span class=\"leftMenuTitle\">NUT DRIVER</span>\n                    </a>\n                </div>\n                <div class=\"dotted_line dottedLineClass\"></div>\n            </div>\n        </div>\n\n    </div>\n\n</div>";

/***/ }),
/* 154 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOwAAABBCAMAAADlj7gWAAADAFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMaXEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUCAIgFgohFwsiGAwfFQkfFAgdEgceEwggFQkfFAkjGQ0hFgoeFAgeEwcgFQocEQYiFwshFgsfFQoiFwweFAkgFgshFwwdEwgkGg4bEAYcEQciGA0jGAseEgccEAYcEgcjGQwdEwcgFgkjGQ4dEQYdEgYiGAsjGg4dEggaDwQfEwgkGw8hFwq8mnIKAwAjGA0kGQ0ZDgQdEQcXDAQfFQgWCwQfFgobDwUaDwaZfV0QCAMbEAUkGg8aDgUQBgESCQMTCQMkGg1TRDIlGg8NBQIgFAgbEQYiFwoVCgMhFgklGg0WCgMVDAUIAgAlGw+vkGqqi2eniWUPCAMlGw0NBAERCAMhFQkiGQyfgmC1lG4ZDwUZDQQUCwQeEwm7mXEQCgQRCgUXDQUOBgISBwIOBQG5l3AcEgYYDQQgFwogFQgaEAUjFwoZEAciFgq2lW6lhmO6mHGegWAeFAc7LyGsjWguIxaxkGsGAQALBQIcEghKPCwoHRF5YkhzXkWCak+jhWMqHxEeFQgfEwcfFAo+MSJYSDWNc1VAMyReSzWWe1qbf160k22pimaRd1hCMiGzk21HOScvIhRENCOGblFaSDNQQTB9Z0xsVz9dTDgvJBeafl2cgF84KhqTeFmhhGFqVT2Zfl10X0aihWIyJhcTDAYtIxZgTDVvW0JRQjGOdVZIOiqIcFJbSjViTjeQdldPPixLPCs5KxxQPysrIBNcSjY2KRppUzo7Lh9GNiUhGAwUCQNiUDuYfFyUeVptWUF1YEdNPy6BaEw7Lh5qVj6FbE91X0VVRTMnHA9xXEN7ZUuSdleLcVQxJBa3lm8fFgkfFQuZfVtxWkBlUThCNSZ+ZUlYRjGJb1FmUz53YEU0KBiUp7wrAAAAJnRSTlOFAQNtb0oEBywWKQYAEws+HX9OEQhaNBgMZDwfaiQPQigSR0kUV+L+PPQAABVVSURBVHgB5M+HdcUgDABAAbbAEu69F+tn/xHzX8ZQboODGI2xiMxeLWZEa0yMEL/VbjpukUwpkfuYum83grG+aMd1vygoRde+jm3hrQGDRV7RsJzPm6r0PucyUJUXaMB2bRXKpp83l+i0zX1ThqrtLOA0UvlxNShWu09J44SAxzo07kc51wzrgcD3vvS19mzdL/vNwHKdM2jPwnxewuCFnk1/dntIPPgsvE5/1r0h+8umif5skv7v7C/fY4waMQxE0ePE6gyBVG7iwlUgjfAiBIsKyQYRgmJvMYoaI5AtG9Y3sA60p9BRMt4D5DHwP6/6oxONLgoHIKIGpQTMXoDzw5eLqAIEBTAjj8cckDNnPzzxfhmGaVn8um0y0UQ3oeSv3mTOijHO+TdnC79ertOSs1/lut7Zffq8M+59p3KXOyejlFHLLoLWKSWaEE2PkaaRUjoeFBs9GdGhHLEcp0sxCtwMMQLuDMKFAMIJ3PnPs1WxV+9Fse8vFSGkxCsLQuq6rNu+IR91i9Faa6y92dsTe2Js3xvT1Ma0zdvrhf9wztkfYWW02zaOheHH4SEPeSSKIgUHHWcqObbW8sKGgSQdY7OoURS58HoD9G6RXEzmYnMzQdLJTR6hj7WPsj+NLqYYdLzHInVIycD//YekflqGL/Fqvr2PMc7jJE4mg2XmsGIZ5iY+Pv7n79XZ2dnPPz8/PD48ZGLwfsTtl9v3MPg94g/aEf++vb399OnjLSz+5dPH9w8PD7+hPdvdjll2O9ndPN28fL672e+f7m7uXtbVEdhSkx5RItz0W1LoR2iEqdTqUZu8T9Tq6fQa0OPxxfi6nF5clG15XSIrywuwuu3lT4/3l8vLD7HiwYbtlUVM5hG8nQMsey+hWA3DxHkR2fFuFb58We12X3Z898K8u7l7unvafU/7/mm/f7lp288vn/f7fbtH6lNx9nw6CyHYuLWOCyfCcbB2u42WC3sEllSheuOJ6I0mOqkUmaIh5VWzVgrESrwoAC8WZWpbVBoln17oaYnyU9JwQ1zcXt5/+HB1tQ0sHOw2c9po5zGEDjNW2N91YYcKrzhfQO26AHnDJIb8ru2q4P5Ee2WYpRYxAj2qpkYR7BKffJ84FrWktW49V4UZ7KwSPgaLKpYlLcqy1CXySmllSC+IdKsJCYJ875X0qUetk8bUGoTwwGw2SjG7Ybt8fHy838bBtxf7DYchhGjDgBZwATjwanB2Muneze2ks4Cbu9AF0AbGbyX9n2ofhlk1cJXf2xjFrLg2jIHxvkm+cs41EEXQ40OhPAQdgT0v9cX4625F87nIiyny8fh6XF5PF1i71+O/ljqRT9OphgcLn/SaFut+jTlYbpeX98vlVTCS2pT6EOPAhwgIZmjrBjswKj6ZzydbLO75djkfYsRw3jl2rDxgafRd7WyUUQU4jRH/WqmwcY4DputGiVgb6vznXHnGnyjJ0T2rz8uR1inzIlSlRml0GJUXZdnqDPuv8RgHUZkW2LzldJp02V5f4ylSajzHGMOsMgfJfs3bywjC4NhWLgvgA7Zwl9dw4AJji2rnSk/iSrhQTVaZfP27dkQwXuHPsmZWYnyOhHvlleFgLZALIyuskSI7VTPCp5T8sWVMBL1EigjpGyJjaITbCOiASmiaNBw5b0s9GuGcxnxq1A8njUaMiKiYwX0luIzgUnbLUjMzRlXtpXKScRn673j1tE8eLDd3GGZ0QS6YOrDW/9PujWHue0WeVeJXVfOmVxlWfFXXAth5Nx/gm7PAhs01zLEOzh6FJaWU2fQ95DbojKlmJwfpmR8sqgEOkvJcT9tpiUVQot5knv95mugQTW2LjUDc66/cvQKsCgzmQjbgBxgzlDAq4X4MXReCW3EXUOQVI2fHCMN4nREdFonF7mTGsOBKTNWLYTi4MX2P3hOLuvndKCngXK2+NepoZdeEWKzVegThQK9PfjCkjAIsAhOU8iuJFpT0QtSCEKY4s70pBGoqg5OEX2EUiyiPKVMJ8MBiXRUQznGMzi2Xne3CPIZVd9rZaLto7dziaeBgRGBOmFnHNi6jzbAchuCqKtgZMypdmEJtlGfYsuLCfTUKI/y+Ner/fGcRf2lJL1L5FqNSq+btFHNlqcfYl2UOje8ONjAeLsj7fFInZDny+u0Jy32qDyucvOqVeCIxigdb8MwinmM8XZ6CbpjHOT451iJ/FxDMLElqT4cdn5eCs/FXh5MeCCjnJte9F/RVxWCvgrPzb41yfzDqCCzKqUlRJj50I9DS3wincQlQdK0uz3OqGxohn2ZzRue4T9FAn5FBftjbiZRP1DMBXxOGzFn/GmrcEE8tzqRJvAJ0jPnz+iNcgNhCkgdtXTce0dTipbIxqEJE/FrlnryhHqaaygA2gNSC033XqKPLGJQjqujNSOUNekAmA+Qc4xbPkGM0cv84obrJnqCVLaqNOxJSmDhMo7xeQa8QeWpSm6jJNhCJw26SzgkquQqWOxQWsPl6h0csUgjK5owqMHIsxlosAyeJEGYmgFWGPZliE0xROZv3Rvd9o47Aks40+r98mPtvE9kVx/+bnpnjubn29QRPZsbjGGqybjdGwUoFS9SoqGqDFNGoih31B2KqWqpoCEUqCUqIRB6hq/J+P1ggsLBAtFDe70e7Xfa93Ue37/f3DGp/CMhHvhln5irM5zy+51yYKWS8I9kZgiYTCwEQ4Yg4s5/TWB68gF123o6DnWwJpTenEGXEEaBzkz0978/vnFxD1tgbPT09b4yl3n6/Bza5FNKsF22bxL2d234AuJ/LBrFfH93GWmsImKNdXIxErdk0f2fZsh8PO02pTEpB4l5jCTAzRMvVLNs19r3MUQ1gScAoIz99j4JUQGKZgIFOsggrg+WiGxK5kLBXJWU7n0+MCGZcqMshTVZ0d2b377qvzZ6YfcLWzUPd3d2Hbmbu3eiGzf6eTWnbw/fw/N0TVyf7EOOT2CC278vP9oicQcahNkprfOG01oj9yg0b1hYYTaJJp5kYkAg6xkVCR9MuK9XE+gVHNYDVbLLGMFiIPY/IY369iygg1yK5eIwHjAs2MXsEQ3LCWjCscIZdCakrdyl1/cTlvYvs+b9WBt7RLfa9Wrl2z4Wdrw+95RGrRzP7Bv7SpA/vG/ny4WLMyX0HyrXjrB5PjJyaE+1WaDagkaEDL22gxIr9bG5jWpEoPbHihEvS04mBLTM2RL9poaMapXHA8qawDMJLXQxkKcoQN9kKQxtYLRZ74ok/doGeEFvZSRDb2DcuZNOQ5NYH4+P3XK3pzQtvLWV6MFAe+CUeN/17S+W+q9TUpQu1aYOeeWxg4vZdBEPvKB+8h1e9MHThftoYB4FqQv0BmNGW09/EASqB/SYt0xLDNMJKEmjClCFhVSIBZoGjGh4EUsCyw/+XZov1G7nkrdetENShLRIWBPJNntqvhqEIthii6Qo1TKMxqHdHqzPzWUNsXNf3+wbLg/1aGf7oSPWpNs7d/UOVB9qgsB5/VZmdglxdLF+exzt+Ua/sjbU1rbTrpjRBjgwnYIz0TThxtzECnXATLBPL82FN5hVpPgsc1SiyUo4egoUAAgbAARQqCOJqhRPCdTaeiB6jUjEwouPKrthkty29CEKM7d4no7Wz7+3629wajwrZbN/W8tY+Y3wD2ONt2kxX6ruVQKnjldFzT9bnEt3ly39QztH99cpxYUNclGYM9EQgFnmV9GWFW6xMok2aKr9m0kS4gfTFfu2gyy5wVCOB8ii0ALuc4q4DC8EfEHHWy1LGE1LJcaGXKGMJNLRJfmLFn+d27PbolurFGzNndvb7QTi1tTxy6dOenn+dr1WfZh330NBXnzmtzQjCPBL88E+/ne4uH/x815mPx4f+7siMa5DZml1ysirrKBT7Isx1KYL6aqMNhFYbfiVjvYLAM0vJKpwV0Z8WOKoBrOtSi4VYrlsXxgz2ppACRDbwIJ8FnzwYBQH7cWkj4qEUsrRmG+FEoHEWTLYLanvU//0r++r1A9Wzszf77ejB1nJt5Gx392BltHrUsvou1g+cLhVaS9o5tqNcPY6DS3e5NrB/cPyL+80F/NbqlGSsKvlOa6k5l8ut/O3KXMlYlqtd1r7W2QKUFNx+QP5PEkvUkhWtuVwrvLfAUQ1gPYqlyUoW85KYYadVWO9bFpiCLr8wPLw9sBBUMcISXq/Lp2Teei5qOAjlF4O3WExG7VbWC8IrHwyNVnbvtJMC+x/8zeI/Abv0W9Gh+pEZzNnoU08A+zQRwx5e4TTnvg5GhQ/OMKCBAqPCC7lh/Bfd19YO90qvIMOe76MITAEBcNlg94qcuKT5BUc1gkUMgxDCkwdoXLDkW10xLqLa+71VvoWnoSiWbQV5iFNocSmQZM8AFTNHJ+bmZPuaKNm5Z2dLHmPI/GD94N6kwI4cWx1F0Se16lEMY6eHtlzrw1Cdcu8gjY9B05DGj5QMf2mnGSbT4/+QFWu9XPf25latx21FiCnUShM52sO8pKWAv/FyRzWq2RQmYVHf+LguZ/ckfkHiIqK+H/i9BRMnsIdlBShf8IUZX3vWYnEALN+JvOj7EW1eND09ZkXJ0P5HbeJWsgjYrQ86+vuj00eq1zs6og8r9f17ksTqV7MTo9NKsxaBEoZ4Ako7G5vx4tBW+eYkjBI5Xu5KRNuUNvhA8UlBoplZ5CktwC86qgFsTEIUWC4Hm8ACJA+LPM76RhGeuL5h12PZ6LFm8nyyXbxDrpSRVmSJnzLb125YZl0bODX5djE5dXWicjiK5tB65qLVHdHMkeqdYtQR3RoaPzWWyUw9PDc08kAr9YuL5R2PNLMrx1mNyUBBvJjlHOsYwKq2NmWMMiqbdSSyGkrkuoaJXYq1+OWOagALl6Ec2EXhsxdPTibL+KYBZoLQ70JehpuIJImJ2Rj820Zjh7+9d30usBZBsUutq777sx/aydO1g7uv7vr0o/OVkx39ey4hWS/tyc+9s29L5cauqaiYfHxg5NSZXc/OTwy+aWf02DOU7ufXFTjVkibAazaiM4bxYYILhBB3nDZgy0ExK9MwuOF8xn71ckc1SmNGKwQnSxC7qItlEA7z+WI7DnaImVVM2sViZ1GOQO0iw4EXE8v7eNs3by7hHdZvz7b+KepI3hk/eeXP584OTh/u6O84M4hxcXBvNHZ7oj40fmIqal8dfXhrYHD/jo/3JpELdPPcgfKWkWeAgLZozA7ABqZF5AqNS5TBYhiBHNg6zmUnjRLdiAIt/Zcv89tx0/ji+Nv8BhCsgYAZwAPjxshFCl456oaNds2FLfV3s8pFtLeWuvVFlaobVXmBXkZ5qvZR+jmQu6499o4Ra5853+8czp8zwHuJqIsl3kKMkT8Qhl3bddW+PXYuvugotU233S/bY9sdJcTgxKSahRc0AC7+YHjuzWIpZT2HBfv9vuIXW7C65aLtwrZ6fOyO1TLcyt39vnMX3om8Oc8Inrer1xsq+l0aUL2iraQFV2rOA0WWr2YRauX0HOmmORIdZXgeFywuRu7b2xeJugAW9ylxk61st/twz8CnbPcA5W5bgX/b7SWaLnm7QJW3LKjjODXxQ1Nsrq2iwJfcAz6greP3j+F96SZtte8Wi3ZbVduu24Z51y6+6SzBm2J1tu9XdvecXr0KPIyTAmYGi28jNbtX0kJTUUZ9zHJSKIOb2XHw/WOOQ+pkzhB1qVPhLk6FKskLbjDXv902PJZHV3WVS9xtx/zRmep0yYh1KReZ9KDgNmVF3NjG+qbMjSHqhuNX+em+4pLo5ZSz0i0J4h1mjisrv502p9MmAO2OzvpA+wK96aFStMy8H8EmFWWkGWR+U+uEYmTSAwUr5HIv25BO1C8TdQms0hJjlzmKuN3RvUE062DY0yYumSeouZLJRQWlY7xl4zdNYBrf0KHDyWkPEjj8wVRyqJNxoz67rqRjN2i8dLM8T06nk/0y2E1wu6uHpz59TQOZ7hra0oWRDmqGxY5lVanE2aMHiQj76UxEVmSp4Nd1f5aoC2DvtXoTVo6S3toSYTkb4miUWyxYcGK0dKSIZUrAO9Z4OCnjN2sT455MwKT4mTK6qjB4V+XhgsdiGS6X1WOFCMQjRvKVYGO/fLzrh9Ww2w19TW77CrBSr80SOh0ULYnOHOx1WgvUDFBHU28IWcB3kpM99PZloj5fAGsKDqigD2Hbx1bkkSJQ1yoHfKKexFyVgJD4A0hgM6T5FeMb+Gt8+2DNbP7u/1MhxOPrlTfOsgJ46WTCHfVjSK0PmsKvh98+frh77vtD3+/oveFSIYuOytQ/SBThxEk0akdAZlOd+fdSBDk8tjdc6tlmNYxEBf8lyr0AlqhK9yWsctFoSoEX2QhQxtQ/VqKBF+N8ecm4osWp4jVg03odx+avjSnoxb0L+W50A1+JEUFKTH903kYDo9hsbu3u/T+/cpLbHw7PT9f1od/VqeCV7ooZU3kUnmdiSZMLliMmPJR8ohYncDkPXlAPdX2GqOwi2NgjuLpso6RhIzDJLWS5ez7GUBcYgnqD4foPa8EIPhxD0AQzoj0uyivW8S/PBb/JZzNXwUpBp0gXsvhI1KgWWbsdhsP7u/eYcb0ang71dX+9SmuiiC9oeccspqU5ycjQn3YhqsznkMib+z9Q4Bkc+XCWqMtJBTpRDgBM1uMx0brEjHl7EtDWsTGpNTGv5lTEErZBbaSi4qVlw7/S2Uua5//dBVdq1nBjDIgJZRnSvFjBYwBVhgBR99buDofVLrVP7G69Wt3iZ1J/5ZPzJsguUP6KrZVdVcyUqEhV6MUMYGDTZ91dIOpyk5w2lPa+Yrd8MI2luxakcfwdVxFfaRjRQoBmYeFHsXYO+xotCIvkFz//9Cl445CNiRulg2VgWosCsUElO1YnbK+V0mx1a9nd6/TWByw1qQ1i0Ra+CxKKeSSgpvMG+AYwB3nssSeTwtCGw3miLh5s5Qv9VZ5GAEwuHz2LIvbNOm1iTBR9x2SUKA9A5unxcABLmB8b8W+J8p5nPv7+aTPqSEN2ZDrexOmDTR9QqSHXsemq5vCDKw4HOJrlCrDwYI1HDh+wxuQSIk6nRbyD+ES2dRrRdIUxWnueqAtgEaoLkcF3QXuvM83erZsG7RozOl+EY9seSwlCQnfEWaIXZXIjcmQANpI20cOHD6kn/NOBo2Lxbe3bPxFk/bVN/xCwu5VglU3mZBqsAOW/HF3RNZPEvkBjpI5V3Bhv59OJolAKWjYjid5KMnyeqH/bt2MCAAAAgGD9WwsyEfz2ByXEau+idKVSvzF1kktGwNIflOuhxBZl8ShlKfnZAJ7CZMLtEFtBAAAAAElFTkSuQmCC"

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(156);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".mainDiv {\n    text-align:center; \n    width:100%;\n}\n\n.menuHeader {\n    padding-top:5px;\n}\n\n.mainLinksDiv {\n    text-align:center; \n    max-width:225px; \n    margin: 0 auto;\n}\n\n.dottedLineClass {\n    margin:10px 0px 10px 10px;\n}", ""]);

// exports


/***/ })
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDNhZGIyMTg4OTcxZDFiZDc3MjkiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2J1bmRsZXMvY29yZS51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9leHRlcm5hbCBcIi4vdmVuZG9yXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTm9kZS5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL3NlcnZpY2VzL3BsYW5rY29va2luZy5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0V2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0VsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL09ic2VydmFibGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2J1bmRsZXMvY29tbW9uLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9idW5kbGVzL2NvbW1vbi1odHRwLnVtZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9ET01JbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Ob2RlTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9DaGFyYWN0ZXJEYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL05vZGVGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vd3d3cm9vdC9pbWFnZXMvQ2hlY2tvdXRfYnV0dG9uLnBuZyIsIndlYnBhY2s6Ly8vLi93d3dyb290L2ltYWdlcy9Db250aW51ZVNob3BwaW5nX2J1dHRvbi5wbmciLCJ3ZWJwYWNrOi8vLy4vd3d3cm9vdC9pbWFnZXMvQ29va2Jvb2tzX0hlYWRlci5wbmciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIveG1sbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvc2VsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0NoaWxkTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9VUkwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvaHRtbGVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvQ1NTU3R5bGVEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9XaW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRG9jdW1lbnRUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0hUTUxQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2ZpcnN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tc2VydmVyL2J1bmRsZXMvcGxhdGZvcm0tc2VydmVyLnVtZC5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnVuZGxlcy9hbmltYXRpb25zLWJyb3dzZXIudW1kLmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvYW5pbWF0aW9ucy9idW5kbGVzL2FuaW1hdGlvbnMudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZmlsdGVyLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2h0dHAvYnVuZGxlcy9odHRwLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwidXJsXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRXZlbnRUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTW91c2VFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9VSUV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0RPTUV4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvYXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9ET01Ub2tlbkxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL1RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTGVhZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Db21tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0RvY3VtZW50RnJhZ21lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvUHJvY2Vzc2luZ0luc3RydWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL05vZGVUcmF2ZXJzYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL1VSTFV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2RlZmluZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvc2xvcHB5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2ltcGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvc3ZnLmpzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9hcHAvYXBwLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi93d3dyb290L2ltYWdlcy9SZW1vdmVfQnV0dG9uLnBuZyIsIndlYnBhY2s6Ly8vLi93d3dyb290L2ltYWdlcy9CYWNrX2J1dHRvbi5wbmciLCJ3ZWJwYWNrOi8vLy4vd3d3cm9vdC9pbWFnZXMvUHVyY2hhc2VfYnV0dG9uLnBuZyIsIndlYnBhY2s6Ly8vLi93d3dyb290L2ltYWdlcy9TcGljZVJ1YnNfY3ViZS5wbmciLCJ3ZWJwYWNrOi8vLy4vd3d3cm9vdC9pbWFnZXMvQ29va2Jvb2tzX2N1YmUucG5nIiwid2VicGFjazovLy8uL3d3d3Jvb3QvaW1hZ2VzL0Jha2luZ1BsYW5rc19jdWJlLnBuZyIsIndlYnBhY2s6Ly8vLi93d3dyb290L2ltYWdlcy9CQlFfUGxhbmtzX2N1YmUucG5nIiwid2VicGFjazovLy8uL3d3d3Jvb3QvaW1hZ2VzL0Jha2luZ1BsYW5rc19IZWFkZXIucG5nIiwid2VicGFjazovLy8uL3d3d3Jvb3QvaW1hZ2VzL0JCUVBsYW5rc19IZWFkZXIucG5nIiwid2VicGFjazovLy8uL3d3d3Jvb3QvaW1hZ2VzL1NwaWNlUnVic19IZWFkZXIucG5nIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9ib290LnNlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvem9uZS5qcy9kaXN0L3pvbmUtbm9kZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3IiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2ZpcnN0LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL29mLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvY29uY2F0TWFwLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWFwLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9idW5kbGVzL3BsYXRmb3JtLWJyb3dzZXItYW5pbWF0aW9ucy51bWQuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvYnVuZGxlcy9jb21waWxlci51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3RvUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9GaWx0ZXJlZEVsZW1lbnRMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL1RyZWVXYWxrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTm9kZUl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0N1c3RvbUV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2Nzc3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Mb2NhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9OYXZpZ2F0b3JJRC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9XaW5kb3dUaW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTXV0YXRpb25Db25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3hocjIvbGliL3hocjIuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiaHR0cFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwib3NcIiIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2FzcG5ldC1wcmVyZW5kZXJpbmcvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvYXBwLnNlcnZlci5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9hcHAuc2hhcmVkLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2Zvcm1zL2J1bmRsZXMvZm9ybXMudW1kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvciIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3JvdXRlci9idW5kbGVzL3JvdXRlci51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9hcHAvYXBwLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9hcHAvYXBwLmNvbXBvbmVudC5jc3M/N2IwNSIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvYXBwL2FwcC5jb21wb25lbnQuY3NzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9uYXZtZW51L25hdm1lbnUuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9uYXZtZW51L25hdm1lbnUuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL25hdm1lbnUvbmF2bWVudS5jb21wb25lbnQuY3NzP2I2MzYiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL25hdm1lbnUvbmF2bWVudS5jb21wb25lbnQuY3NzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9ob21lL2hvbWUuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9ob21lL2hvbWUuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2ZldGNoZGF0YS9mZXRjaGRhdGEuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9mZXRjaGRhdGEvZmV0Y2hkYXRhLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jb3VudGVyL2NvdW50ZXIuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jb3VudGVyL2NvdW50ZXIuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2NhcnQvY2FydC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2NhcnQvY2FydC5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY2FydC9jYXJ0LmNvbXBvbmVudC5jc3M/NWJjYSIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY2FydC9jYXJ0LmNvbXBvbmVudC5jc3MiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2NhcnQvY2hlY2tvdXQvY2hlY2tvdXQuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L2NoZWNrb3V0L2NoZWNrb3V0LmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L2NoZWNrb3V0L2NoZWNrb3V0LmNvbXBvbmVudC5jc3M/ZmNkZiIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY2FydC9jaGVja291dC9jaGVja291dC5jb21wb25lbnQuY3NzIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L3ByZXZpZXcvcHJldmlldy5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2NhcnQvcHJldmlldy9wcmV2aWV3LmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L3ByZXZpZXcvcHJldmlldy5jb21wb25lbnQuY3NzPzg4ZTgiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2NhcnQvcHJldmlldy9wcmV2aWV3LmNvbXBvbmVudC5jc3MiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2NhcnQvcmVjaWVwdC9yZWNlaXB0LmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY2FydC9yZWNpZXB0L3JlY2VpcHQuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2NhcnQvcmVjaWVwdC9yZWNlaXB0LmNvbXBvbmVudC5jc3M/NTMzYSIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY2FydC9yZWNpZXB0L3JlY2VpcHQuY29tcG9uZW50LmNzcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9zaG9wLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9zaG9wLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL3Nob3AuY29tcG9uZW50LmNzcz9kYTk4Iiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL3Nob3AuY29tcG9uZW50LmNzcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9jb29rYm9va3MvY29va2Jvb2tzLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9jb29rYm9va3MvY29va2Jvb2tzLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL2Nvb2tib29rcy9jb29rYm9va3MuY29tcG9uZW50LmNzcz83ZjcyIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL2Nvb2tib29rcy9jb29rYm9va3MuY29tcG9uZW50LmNzcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9iYWtpbmdwbGFua3MvYmFraW5ncGxhbmtzLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9iYWtpbmdwbGFua3MvYmFraW5ncGxhbmtzLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL2Jha2luZ3BsYW5rcy9iYWtpbmdwbGFua3MuY29tcG9uZW50LmNzcz9jOGFlIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL2Jha2luZ3BsYW5rcy9iYWtpbmdwbGFua3MuY29tcG9uZW50LmNzcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9iYnFwbGFua3MvYmJxcGxhbmtzLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9iYnFwbGFua3MvYmJxcGxhbmtzLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL2JicXBsYW5rcy9iYnFwbGFua3MuY29tcG9uZW50LmNzcz80ZWVhIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL2JicXBsYW5rcy9iYnFwbGFua3MuY29tcG9uZW50LmNzcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9udXRkcml2ZXIvbnV0ZHJpdmVyLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9udXRkcml2ZXIvbnV0ZHJpdmVyLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL251dGRyaXZlci9udXRkcml2ZXIuY29tcG9uZW50LmNzcz85OWFiIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL251dGRyaXZlci9udXRkcml2ZXIuY29tcG9uZW50LmNzcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9zcGljZXJ1YnMvc3BpY2VydWJzLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9zcGljZXJ1YnMvc3BpY2VydWJzLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL3NwaWNlcnVicy9zcGljZXJ1YnMuY29tcG9uZW50LmNzcz85ZjRmIiwid2VicGFjazovLy8uL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL3NwaWNlcnVicy9zcGljZXJ1YnMuY29tcG9uZW50LmNzcyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9zaWRlbWVudS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3Nob3Avc2lkZW1lbnUuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vd3d3cm9vdC9pbWFnZXMvU2hvcF9NZW51SGVhZGVyLnBuZyIsIndlYnBhY2s6Ly8vLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9zaWRlbWVudS5jb21wb25lbnQuY3NzP2FmNjgiLCJ3ZWJwYWNrOi8vLy4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3Nob3Avc2lkZW1lbnUuY29tcG9uZW50LmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7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Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsSUFBSTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMkJBQTJCLDBDQUEwQztBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDLEdBQUc7QUFDSDtBQUNBOzs7Ozs7OztBQzk0QkE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEMsa0NBQWtDO0FBQ2xDLG1EQUFtRCx3QkFBd0IsRUFBRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QyxrQ0FBa0M7QUFDbEMsbURBQW1ELHdCQUF3QixFQUFFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDLGtDQUFrQztBQUNsQyxtREFBbUQsd0JBQXdCLEVBQUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7Ozs7Ozs7O0FDaEdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLHNCQUFzQixFQUFFO0FBQ2xEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiw4QkFBOEI7QUFDOUIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7OztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BEO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixXQUFXLHNCQUFzQjtBQUNqQyxZQUFZO0FBQ1osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2Q0FBNkM7QUFDeEQsV0FBVyw2Q0FBNkM7QUFDeEQsWUFBWSw2Q0FBNkM7QUFDekQsWUFBWSw2Q0FBNkM7QUFDekQsY0FBYyw2Q0FBNkM7QUFDM0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnRUFBZ0U7QUFDM0U7QUFDQTtBQUNBLGlCQUFpQiwrREFBK0Q7QUFDaEYsa0JBQWtCLDhJQUE4STtBQUNoSztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQztBQUNyRDtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBLGFBQWEsa0VBQWtFO0FBQy9FO0FBQ0EsY0FBYywrS0FBK0s7QUFDN0wsZUFBZSwrTEFBK0w7QUFDOU07QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXFDO0FBQ3JDO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSyxFQUFFO0FBQ1Asc0JBQXNCO0FBQ3RCO0FBQ0EsS0FBSyxFQUFFO0FBQ1AsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQTZDO0FBQ2hFLGtCQUFrQiw2Q0FBNkM7QUFDL0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pELGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0JBQStCO0FBQ3BELFdBQVcsc0RBQXNEO0FBQ2pFLGdCQUFnQixzREFBc0Q7QUFDdEU7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGlCQUFpQixxREFBcUQ7QUFDdEUsa0JBQWtCLDhJQUE4STtBQUNoSyxnQkFBZ0IsaUtBQWlLO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQThEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0E7QUFDQSxhQUFhLDZDQUE2QztBQUMxRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNB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QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUoscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTs7QUFFSix3QkFBd0I7QUFDeEI7QUFDQSxJQUFJOztBQUVKLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7QUNsVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsMkJBQTJCO0FBQ3BDLFlBQVksaUJBQWlCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osY0FBYyxpQ0FBa0M7O0FBRWhEO0FBQ0EsV0FBVyxrQkFBa0IsYUFBYSxHQUFHO0FBQzdDLFNBQVMsa0JBQWtCLGFBQWEsR0FBRztBQUMzQyxXQUFXLGtCQUFrQixhQUFhLEdBQUc7O0FBRTdDO0FBQ0EsV0FBVyxrQkFBa0IsYUFBYSxHQUFHO0FBQzdDLFFBQVEsa0JBQWtCLGFBQWEsR0FBRzs7QUFFMUM7QUFDQSxXQUFXLFdBQVc7QUFDdEIsaUJBQWlCLGNBQWM7QUFDL0IsV0FBVyxjQUFjOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7Ozs7Ozs7O0FDN0RBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0Isa0JBQWtCLEdBQUc7QUFDcEQ7QUFDQSxxQkFBcUIsYUFBYSxFQUFFO0FBQ3BDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFVBQVU7QUFDVjtBQUNBLElBQUk7O0FBRUosWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7Ozs7QUNyQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QVMsSUFBSSxVQUFVLEdBQUcsT0FBTyxPQUFPLFFBQVEsSUFBSSxNQUFNLElBQUksR0FBRyxhQUFhLEdBQUcsaUJBQWlCLE1BQU0sTUFBTSxPQUFPLE1BQU0saUJBQWlCLE9BQU8sT0FBTyxLQUFLLGFBQWEsS0FBSyxRQUFRLFVBQVUsS0FBSyxVQUFVLE1BQU0sSUFBSSxPQUFPLEdBQUcsYUFBYSxLQUFLLFdBQVcsR0FBRyxPQUFPLFVBQVUsSUFBSSxRQUFRLFFBQVEsTUFBTSxPQUFPLFdBQVcsR0FBRyxVQUFVLEdBQUcsWUFBWSxRQUFRLE1BQU0sSUFBSSxJQUFJLE9BQU8sS0FBSyxNQUFNLFFBQVEsU0FBUyxPQUFPLE9BQU8sVUFBVSxLQUFLLFdBQVcsSUFBSSxNQUFNLE9BQU8sS0FBSyxRQUFRLE1BQU0sUUFBUSxlQUFlLFlBQVksWUFBWSxnQkFBZ0IsT0FBTyxlQUFlLFNBQVMsS0FBSyxhQUFhLEdBQUcsS0FBSyxNQUFNLFVBQVUsT0FBTyxHQUFHLFdBQVcsS0FBSyxTQUFTLFFBQVEsUUFBUSxlQUFlLElBQUksV0FBVyxPQUFPLFdBQVcsT0FBTyxHQUFHLFFBQVEsR0FBRyxNQUFNLEdBQUcsU0FBUyxHQUFHLE9BQU8sTUFBTSxPQUFPLEtBQUssUUFBUSxRQUFRLEdBQUcsTUFBTSxLQUFLLFdBQVcsUUFBUSxLQUFLLEdBQUcsYUFBYSxHQUFHLEdBQUcsU0FBUyxJQUFJLFVBQVUsSUFBSSxZQUFZLElBQUksTUFBTSxPQUFPLEtBQUssR0FBRyxlQUFlLE1BQU0sU0FBUyxZQUFZLE1BQU0sV0FBVyxLQUFLLE9BQU8sSUFBSSxVQUFVLFVBQVUsS0FBSyxTQUFTLEtBQUssSUFBSSxRQUFRLEdBQUcsVUFBVSxLQUFLLFNBQVMsS0FBSyxjQUFjLFdBQVcscUJBQXFCLElBQUksT0FBTyxVQUFVLFFBQVEsS0FBSyxJQUFJLE9BQU8sTUFBTSxRQUFRLEtBQUssS0FBSyxNQUFNLFFBQVEsU0FBUyxNQUFNLEdBQUcsWUFBWSxtQkFBbUIsSUFBSSxHQUFHLElBQUksR0FBRyxHQUFHLFFBQVEsR0FBRyxRQUFRLElBQUksR0FBRyxLQUFLLE9BQU8sR0FBRyxLQUFLLEtBQUssTUFBTSxNQUFNLFdBQVcsR0FBRyxXQUFXLFFBQVEsR0FBRyxJQUFJLFFBQVEsU0FBUyxHQUFHLE1BQU0sTUFBTSxHQUFHLE1BQU0sR0FBRyxPQUFPLE9BQU8sSUFBSSxRQUFRLE1BQU0sR0FBRyxRQUFRLElBQUksT0FBTyxNQUFNLEdBQUcsT0FBTyxLQUFLLE1BQU0sR0FBRyxHQUFHLEdBQUcsUUFBUSxPQUFPLE1BQU0sT0FBTyxNQUFNLEdBQUcsT0FBTyxNQUFNLE1BQU0sUUFBUSxPQUFPLEdBQUcsR0FBRyxRQUFRLE9BQU8sSUFBSSxNQUFNLE1BQU0sT0FBTyxlQUFlLElBQUksTUFBTSxXQUFXLE9BQU8sT0FBTyxLQUFLLGdCQUFnQixJQUFJLFdBQVcsVUFBVSxJQUFJLE1BQU0sU0FBUyxNQUFNLEtBQUssR0FBRyxRQUFRLE1BQU0sYUFBYSxLQUFLLE9BQU8sTUFBTSxLQUFLLFlBQVksT0FBTyxVQUFVLE1BQU0sZ0JBQWdCLFlBQVksS0FBSyxNQUFNLFNBQVMsTUFBTSxNQUFNLFdBQVcsTUFBTSxhQUFhLE9BQU8sS0FBSyxJQUFJLFNBQVMsS0FBSyxTQUFTLEdBQUcsUUFBUSxPQUFPLFNBQVMsSUFBSSxPQUFPLEtBQUssT0FBTyxZQUFZLE9BQU8sTUFBTSxNQUFNLEtBQUssS0FBSyxLQUFLLE9BQU8sTUFBTSxRQUFRLEtBQUssT0FBTyxNQUFNLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxVQUFVLEtBQUssSUFBSSxJQUFJLE9BQU8sT0FBTyxTQUFTLE9BQU8sR0FBRyxLQUFLLE1BQU0sR0FBRyxJQUFJLFFBQVEsTUFBTSxVQUFVLElBQUksZ0JBQWdCLEdBQUcsS0FBSyxNQUFNLEtBQUssUUFBUSxNQUFNLE9BQU8sY0FBYyxHQUFHLFdBQVcsR0FBRyxLQUFLLE9BQU8sS0FBSyxLQUFLLEtBQUssS0FBSyxjQUFjLElBQUksTUFBTSxPQUFPLE1BQU0sR0FBRyxNQUFNLFVBQVUsUUFBUSxNQUFNLE1BQU0sT0FBTyxHQUFHLElBQUksSUFBSSxLQUFLLFFBQVEsTUFBTSxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJLE9BQU8sS0FBSyxNQUFNLEdBQUcsWUFBWSxLQUFLLFlBQVksR0FBRyxRQUFRLFFBQVEsR0FBRyxjQUFjLFNBQVMsSUFBSSxLQUFLLEdBQUcsU0FBUyxRQUFRLEdBQUcsV0FBVyxPQUFPLEtBQUssT0FBTyxlQUFlLE1BQU0saUJBQWlCLElBQUksYUFBYSxrQkFBa0IsR0FBRyxXQUFXLFlBQVksYUFBYSxJQUFJLE1BQU0sR0FBRyxPQUFPLE9BQU8sSUFBSSxRQUFRLE1BQU0sR0FBRyxRQUFRLElBQUksYUFBYSxLQUFLLFVBQVUsTUFBTSxNQUFNLEtBQUssYUFBYSxNQUFNLEdBQUcsT0FBTyxHQUFHLGFBQWEsTUFBTSxHQUFHLE9BQU8sTUFBTSxNQUFNLEtBQUssUUFBUSxNQUFNLEtBQUssV0FBVyxTQUFTLE1BQU0sU0FBUyxPQUFPLE1BQU0sT0FBTyxNQUFNLEdBQUcsT0FBTyxhQUFhLElBQUksTUFBTSxtQkFBbUIsWUFBWSxTQUFTLFlBQVksaUJBQWlCLE9BQU8sU0FBUyxHQUFHLEtBQUssUUFBUSxTQUFTLEtBQUssT0FBTyxNQUFNLEdBQUcsVUFBVSxJQUFJLFVBQVUsUUFBUSxRQUFRLEdBQUcsSUFBSSxLQUFLLFdBQVcsSUFBSSxHQUFHLE9BQU8sR0FBRyxHQUFHLFFBQVEsT0FBTyxHQUFHLFFBQVEsT0FBTyxPQUFPLElBQUksTUFBTSxNQUFNLE1BQU0sTUFBTSxPQUFPLFNBQVMsTUFBTSxHQUFHLEdBQUcsZ0JBQWdCLE1BQU0sY0FBYyxJQUFJLFlBQVksUUFBUSxRQUFRLE1BQU0sS0FBSyxRQUFRLFFBQVEsTUFBTSxNQUFNLElBQUksUUFBUSxXQUFXLEdBQUcsT0FBTyxjQUFjLElBQUksSUFBSSxTQUFTLE9BQU8sS0FBSyxLQUFLLEtBQUssVUFBVSxHQUFHLE1BQU0sR0FBRyxXQUFXLElBQUksUUFBUSxVQUFVLElBQUksSUFBSSxRQUFRLE1BQU0sT0FBTyxRQUFRLEtBQUssYUFBYSxNQUFNLEdBQUcsbUJBQW1CLFlBQVksSUFBSSxNQUFNLEdBQUcsY0FBYyxVQUFVLE1BQU0sVUFBVSxNQUFNLElBQUksTUFBTSxHQUFHLElBQUksSUFBSSxNQUFNLFNBQVMsT0FBTyxHQUFHLFdBQVcsU0FBUyxHQUFHLGFBQWEsS0FBSyxPQUFPLFFBQVEsS0FBSyxLQUFLLEdBQUcsT0FBTyxNQUFNLEtBQUssU0FBUyxNQUFNLElBQUksT0FBTyxNQUFNLFNBQVMsSUFBSSxVQUFVLEdBQUcsTUFBTSxPQUFPLE1BQU0sTUFBTSxHQUFHLE9BQU8sSUFBSSxNQUFNLE1BQU0sR0FBRyxXQUFXLEtBQUssS0FBSyxPQUFPLE1BQU0sR0FBRyxJQUFJLE1BQU0sU0FBUyxHQUFHLEtBQUssSUFBSSxNQUFNLFlBQVksWUFBWSxPQUFPLEdBQUcsT0FBTyxPQUFPLEdBQUcsT0FBTyxNQUFNLE9BQU8sR0FBRyxRQUFRLFFBQVEsTUFBTSxPQUFPLEdBQUcsS0FBSyxPQUFPLEdBQUcsR0FBRyxTQUFTLE9BQU8sR0FBRyxHQUFHLGdCQUFnQixPQUFPLElBQUksR0FBRyxRQUFRLE1BQU0sS0FBSyxNQUFNLE1BQU0sSUFBSSxhQUFhLFFBQVEsR0FBRyxHQUFHLFlBQVksUUFBUSxHQUFHLFlBQVksS0FBSyxHQUFHLEdBQUcsYUFBYSxVQUFVLFFBQVEsTUFBTSxHQUFHLE9BQU8sS0FBSyxVQUFVLElBQUksV0FBVyxHQUFHLEdBQUcsUUFBUSxPQUFPLEdBQUcsVUFBVSxJQUFJLE9BQU8sR0FBRyxHQUFHLFFBQVEsT0FBTyxHQUFHLGFBQWEsTUFBTSxLQUFLLG1CQUFtQixJQUFJLFdBQVcsSUFBSSxTQUFTLE1BQU0sS0FBSyxJQUFJLFlBQVksTUFBTSxJQUFJLE1BQU0sT0FBTyxHQUFHLFFBQVEsU0FBUyxHQUFHLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxVQUFVLFNBQVMsTUFBTSxJQUFJLFFBQVEsU0FBUyxVQUFVLEtBQUssWUFBWSxHQUFHLEtBQUssVUFBVSxNQUFNLElBQUksSUFBSSxNQUFNLE9BQU8sU0FBUyxHQUFHLFNBQVMsTUFBTSxJQUFJLFVBQVUsR0FBRyxNQUFNLFNBQVMsUUFBUSxNQUFNLE1BQU0sR0FBRyxVQUFVLEtBQUssVUFBVSxHQUFHLEtBQUssT0FBTyxRQUFRLEtBQUssS0FBSyxPQUFPLEtBQUssTUFBTSxPQUFPLElBQUksSUFBSSxJQUFJLFFBQVEsSUFBSSxPQUFPLEdBQUcsU0FBUyxNQUFNLEtBQUssV0FBVyxTQUFTLElBQUksT0FBTyxPQUFPLFlBQVksTUFBTSxNQUFNLFVBQVUsR0FBRyxJQUFJLEtBQUssVUFBVSxLQUFLLEtBQUssR0FBRyxNQUFNLEtBQUssVUFBVSxHQUFHLE9BQU8sS0FBSyxPQUFPLFNBQVMsR0FBRyxpQkFBaUIsR0FBRyxLQUFLLFFBQVEsTUFBTSxHQUFHLEtBQUssT0FBTyxHQUFHLElBQUksSUFBSSxNQUFNLEtBQUssS0FBSyxZQUFZLElBQUksS0FBSyxRQUFRLEdBQUcsSUFBSSxLQUFLLE1BQU0sTUFBTSxRQUFRLFNBQVMsSUFBSSxZQUFZLEtBQUssS0FBSyxNQUFNLFVBQVUsR0FBRyxRQUFRLElBQUksS0FBSyxRQUFRLFVBQVUsTUFBTSxNQUFNLE9BQU8sSUFBSSxPQUFPLE1BQU0sU0FBUyxHQUFHLFFBQVEsU0FBUyxLQUFLLEtBQUssT0FBTyxLQUFLLGtCQUFrQixLQUFLLFNBQVMsSUFBSSxLQUFLLGdCQUFnQixJQUFJLE1BQU0sT0FBTyxLQUFLLFdBQVcsS0FBSyxNQUFNLFFBQVEsT0FBTyxHQUFHLEdBQUcsSUFBSSxNQUFNLFFBQVEsSUFBSSxNQUFNLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSSxHQUFHLFVBQVUsT0FBTyxNQUFNLFlBQVksS0FBSyxZQUFZLEdBQUcsUUFBUSxRQUFRLEdBQUcsY0FBYyxTQUFTLElBQUksS0FBSyxHQUFHLFNBQVMsT0FBTyxRQUFRLEdBQUcsS0FBSyxZQUFZLEtBQUssTUFBTSxHQUFHLEtBQUssR0FBRyxZQUFZLE1BQU0sR0FBRyxhQUFhLE1BQU0sR0FBRyxRQUFRLEdBQUcsc0JBQXNCLE1BQU0saUJBQWlCLElBQUksZ0JBQWdCLFVBQVUsY0FBYyxZQUFZLFlBQVksS0FBSyxZQUFZLFVBQVUsS0FBSyxHQUFHLFdBQVcsTUFBTSxPQUFPLFlBQVksSUFBSSxNQUFNLFFBQVEsR0FBRyxLQUFLLFFBQVEsWUFBWSxJQUFJLFNBQVMsT0FBTyxVQUFVLElBQUksR0FBRyxPQUFPLE9BQU8sR0FBRyxhQUFhLE1BQU0sT0FBTyxHQUFHLEdBQUcsTUFBTSxVQUFVLEdBQUcsWUFBWSxNQUFNLE1BQU0sR0FBRyxPQUFPLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxPQUFPLElBQUksS0FBSyxTQUFTLEtBQUssR0FBRyxTQUFTLEdBQUcsR0FBRyxVQUFVLFNBQVMsTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLFdBQVcsR0FBRyxLQUFLLFFBQVEsS0FBSyxVQUFVLFNBQVMsR0FBRyxZQUFZLFVBQVUsSUFBSSxjQUFjLEdBQUcsR0FBRyxPQUFPLEtBQUssTUFBTSxHQUFHLE9BQU8sR0FBRyxPQUFPLEdBQUcsS0FBSyxNQUFNLE1BQU0sUUFBUSxvQkFBb0IsS0FBSyxTQUFTLE9BQU8sSUFBSSxPQUFPLE1BQU0sR0FBRyxhQUFhLE1BQU0sTUFBTSxJQUFJLE1BQU0sY0FBYyxLQUFLLElBQUksZ0JBQWdCLEdBQUcsUUFBUSxHQUFHLGFBQWEsR0FBRyxRQUFRLElBQUksUUFBUSxHQUFHLFFBQVEsSUFBSSxTQUFTLFFBQVEsR0FBRyxJQUFJLFFBQVEsUUFBUSxNQUFNLE1BQU0sTUFBTSxZQUFZLEdBQUcsc0JBQXNCLEtBQUssS0FBSyxZQUFZLEdBQUcsS0FBSyxNQUFNLEtBQUssT0FBTyxPQUFPLEdBQUcsT0FBTyxNQUFNLFdBQVcsT0FBTyxHQUFHLFNBQVMsR0FBRyxNQUFNLE9BQU8sR0FBRyxVQUFVLFFBQVEsU0FBUyxJQUFJLFlBQVksS0FBSyxLQUFLLE1BQU0sSUFBSSxJQUFJLE9BQU8sSUFBSSxJQUFJLEdBQUcsR0FBRyxRQUFRLEtBQUssT0FBTyxLQUFLLFVBQVUsSUFBSSxPQUFPLE1BQU0sT0FBTyxHQUFHLE9BQU8sV0FBVyxPQUFPLEdBQUcsU0FBUyxHQUFHLE1B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LHNEQUFzRDtBQUN0RCwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUIsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MscUNBQXFDO0FBQ3JDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHFDQUFxQztBQUNyQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHFDQUFxQztBQUNyQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwwQkFBMEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsSUFBSTtBQUNmLFdBQVcsSUFBSTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsSUFBSTtBQUNmLFdBQVcsSUFBSTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQix1QkFBdUI7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLDRDQUE0QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLDZDQUE2QztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLDJDQUEyQztBQUM1RTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLEtBQUs7Ozs7QUFJTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVULDJDQUEyQztBQUMzQztBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDhCQUE4QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFhLENBQUM7SUFITCxpQkFBaUI7UUFON0IsZ0VBQVMsQ0FBQztZQUNQLFFBQVEsRUFBRSxXQUFXO1lBQ3JCLFFBQVEsRUFBRSxtQkFBTyxDQUFDLEdBQTJCLENBQUM7WUFDOUMsTUFBTSxFQUFFLENBQUMsbUJBQU8sQ0FBQyxHQUEwQixDQUFDLENBQUM7U0FDaEQsQ0FBQzs7T0FFVyxpQkFBaUIsQ0FJN0I7SUFBRCx3QkFBQztDQUFBO0FBSjZCOzs7Ozs7O0FDUjlCLGt0RDs7Ozs7O0FDQUEsaUNBQWlDLHd4UTs7Ozs7OztBQ0NqQzs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7Ozs7Ozs7QUNQQTtBQUNBOzs7QUFHQTtBQUNBLG1DQUFvQyx3QkFBd0Isa0JBQWtCLEdBQUcsaUJBQWlCLHNCQUFzQixHQUFHLG1CQUFtQix3QkFBd0IsdUJBQXVCLHNCQUFzQixHQUFHLHNCQUFzQixnQ0FBZ0MsR0FBRzs7QUFFL1EiLCJmaWxlIjoibWFpbi1zZXJ2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJkaXN0L1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDY3KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAwM2FkYjIxODg5NzFkMWJkNzcyOSIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMSkpKDMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2J1bmRsZXMvY29yZS51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vdmVuZG9yXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiLi92ZW5kb3JcIlxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBET01FeGNlcHRpb24gPSByZXF1aXJlKCcuL0RPTUV4Y2VwdGlvbicpO1xudmFyIEVSUiA9IERPTUV4Y2VwdGlvbjtcbnZhciBpc0FwaVdyaXRhYmxlID0gcmVxdWlyZShcIi4vY29uZmlnXCIpLmlzQXBpV3JpdGFibGU7XG5cbmV4cG9ydHMuTkFNRVNQQUNFID0ge1xuICBIVE1MOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsXG4gIFhNTDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsXG4gIFhNTE5TOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nLFxuICBNQVRITUw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJyxcbiAgU1ZHOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBYTElOSzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXG59O1xuXG4vL1xuLy8gU2hvcnRjdXQgZnVuY3Rpb25zIGZvciB0aHJvd2luZyBlcnJvcnMgb2YgdmFyaW91cyB0eXBlcy5cbi8vXG5leHBvcnRzLkluZGV4U2l6ZUVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLklOREVYX1NJWkVfRVJSKTsgfTtcbmV4cG9ydHMuSGllcmFyY2h5UmVxdWVzdEVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLkhJRVJBUkNIWV9SRVFVRVNUX0VSUik7IH07XG5leHBvcnRzLldyb25nRG9jdW1lbnRFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5XUk9OR19ET0NVTUVOVF9FUlIpOyB9O1xuZXhwb3J0cy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuSU5WQUxJRF9DSEFSQUNURVJfRVJSKTsgfTtcbmV4cG9ydHMuTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSKTsgfTtcbmV4cG9ydHMuTm90Rm91bmRFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5OT1RfRk9VTkRfRVJSKTsgfTtcbmV4cG9ydHMuTm90U3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuTk9UX1NVUFBPUlRFRF9FUlIpOyB9O1xuZXhwb3J0cy5JbnZhbGlkU3RhdGVFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5JTlZBTElEX1NUQVRFX0VSUik7IH07XG5leHBvcnRzLlN5bnRheEVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLlNZTlRBWF9FUlIpOyB9O1xuZXhwb3J0cy5JbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSKTsgfTtcbmV4cG9ydHMuTmFtZXNwYWNlRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuTkFNRVNQQUNFX0VSUik7IH07XG5leHBvcnRzLkludmFsaWRBY2Nlc3NFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5JTlZBTElEX0FDQ0VTU19FUlIpOyB9O1xuZXhwb3J0cy5UeXBlTWlzbWF0Y2hFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5UWVBFX01JU01BVENIX0VSUik7IH07XG5leHBvcnRzLlNlY3VyaXR5RXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuU0VDVVJJVFlfRVJSKTsgfTtcbmV4cG9ydHMuTmV0d29ya0Vycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLk5FVFdPUktfRVJSKTsgfTtcbmV4cG9ydHMuQWJvcnRFcnJvciA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKEVSUi5BQk9SVF9FUlIpOyB9O1xuZXhwb3J0cy5VcmxNaXNtYXRjaEVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLlVSTF9NSVNNQVRDSF9FUlIpOyB9O1xuZXhwb3J0cy5RdW90YUV4Y2VlZGVkRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuUVVPVEFfRVhDRUVERURfRVJSKTsgfTtcbmV4cG9ydHMuVGltZW91dEVycm9yID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBET01FeGNlcHRpb24oRVJSLlRJTUVPVVRfRVJSKTsgfTtcbmV4cG9ydHMuSW52YWxpZE5vZGVUeXBlRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuSU5WQUxJRF9OT0RFX1RZUEVfRVJSKTsgfTtcbmV4cG9ydHMuRGF0YUNsb25lRXJyb3IgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihFUlIuREFUQV9DTE9ORV9FUlIpOyB9O1xuXG5leHBvcnRzLm55aSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJOb3RZZXRJbXBsZW1lbnRlZFwiKTtcbn07XG5cbmV4cG9ydHMuYXNzZXJ0ID0gZnVuY3Rpb24oZXhwciwgbXNnKSB7XG4gIGlmICghZXhwcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBmYWlsZWQ6IFwiICsgKG1zZyB8fCBcIlwiKSArIFwiXFxuXCIgKyBuZXcgRXJyb3IoKS5zdGFjayk7XG4gIH1cbn07XG5cbmV4cG9ydHMuZXhwb3NlID0gZnVuY3Rpb24oc3JjLCBjKSB7XG4gIGZvciAodmFyIG4gaW4gc3JjKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGMucHJvdG90eXBlLCBuLCB7IHZhbHVlOiBzcmNbbl0sIHdyaXRhYmxlOiBpc0FwaVdyaXRhYmxlIH0pO1xuICB9XG59O1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24oYSwgYikge1xuICBmb3IgKHZhciBuIGluIGIpIHtcbiAgICBhW25dID0gYltuXTtcbiAgfVxufTtcblxuLy8gQ29tcGFyZSB0d28gbm9kZXMgYmFzZWQgb24gdGhlaXIgZG9jdW1lbnQgb3JkZXIuIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWRcbi8vIHRvIGJlIHBhc3NlZCB0byBzb3J0KCkuIEFzc3VtZXMgdGhhdCB0aGUgYXJyYXkgYmVpbmcgc29ydGVkIGRvZXMgbm90XG4vLyBjb250YWluIGR1cGxpY2F0ZXMuICBBbmQgdGhhdCBhbGwgbm9kZXMgYXJlIGNvbm5lY3RlZCBhbmQgY29tcGFyYWJsZS5cbi8vIENsZXZlciBjb2RlIGJ5IHBwayB2aWEgamVyZXNpZy5cbmV4cG9ydHMuZG9jdW1lbnRPcmRlciA9IGZ1bmN0aW9uKG4sbSkge1xuICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgcmV0dXJuIDMgLSAobi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihtKSAmIDYpO1xufTtcblxuZXhwb3J0cy50b0FTQ0lJTG93ZXJDYXNlID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bQS1aXSsvZywgZnVuY3Rpb24odCkgeyByZXR1cm4gdC50b0xvd2VyQ2FzZSgpOyB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuXG52YXIgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL0V2ZW50VGFyZ2V0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgTkFNRVNQQUNFID0gdXRpbHMuTkFNRVNQQUNFO1xuXG4vLyBBbGwgbm9kZXMgaGF2ZSBhIG5vZGVUeXBlIGFuZCBhbiBvd25lckRvY3VtZW50LlxuLy8gT25jZSBpbnNlcnRlZCwgdGhleSBhbHNvIGhhdmUgYSBwYXJlbnROb2RlLlxuLy8gVGhpcyBpcyBhbiBhYnN0cmFjdCBjbGFzczsgYWxsIG5vZGVzIGluIGEgZG9jdW1lbnQgYXJlIGluc3RhbmNlc1xuLy8gb2YgYSBzdWJ0eXBlLCBzbyBhbGwgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgYnkgbW9yZSBzcGVjaWZpY1xuLy8gY29uc3RydWN0b3JzLlxuZnVuY3Rpb24gTm9kZSgpIHtcbn1cblxudmFyIEVMRU1FTlRfTk9ERSAgICAgICAgICAgICAgICA9IE5vZGUuRUxFTUVOVF9OT0RFID0gMTtcbnZhciBBVFRSSUJVVEVfTk9ERSAgICAgICAgICAgICAgPSBOb2RlLkFUVFJJQlVURV9OT0RFID0gMjtcbnZhciBURVhUX05PREUgICAgICAgICAgICAgICAgICAgPSBOb2RlLlRFWFRfTk9ERSA9IDM7XG52YXIgQ0RBVEFfU0VDVElPTl9OT0RFICAgICAgICAgID0gTm9kZS5DREFUQV9TRUNUSU9OX05PREUgPSA0O1xudmFyIEVOVElUWV9SRUZFUkVOQ0VfTk9ERSAgICAgICA9IE5vZGUuRU5USVRZX1JFRkVSRU5DRV9OT0RFID0gNTtcbnZhciBFTlRJVFlfTk9ERSAgICAgICAgICAgICAgICAgPSBOb2RlLkVOVElUWV9OT0RFID0gNjtcbnZhciBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREUgPSBOb2RlLlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSA9IDc7XG52YXIgQ09NTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gTm9kZS5DT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgICAgICAgICAgICAgICA9IE5vZGUuRE9DVU1FTlRfTk9ERSA9IDk7XG52YXIgRE9DVU1FTlRfVFlQRV9OT0RFICAgICAgICAgID0gTm9kZS5ET0NVTUVOVF9UWVBFX05PREUgPSAxMDtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFICAgICAgPSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcbnZhciBOT1RBVElPTl9OT0RFICAgICAgICAgICAgICAgPSBOb2RlLk5PVEFUSU9OX05PREUgPSAxMjtcblxudmFyIERPQ1VNRU5UX1BPU0lUSU9OX0RJU0NPTk5FQ1RFRCAgICAgICAgICAgID0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9ESVNDT05ORUNURUQgPSAweDAxO1xudmFyIERPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyAgICAgICAgICAgICAgID0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcgPSAweDAyO1xudmFyIERPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyAgICAgICAgICAgICAgID0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgPSAweDA0O1xudmFyIERPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TICAgICAgICAgICAgICAgID0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyA9IDB4MDg7XG52YXIgRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZICAgICAgICAgICAgPSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSA9IDB4MTA7XG52YXIgRE9DVU1FTlRfUE9TSVRJT05fSU1QTEVNRU5UQVRJT05fU1BFQ0lGSUMgPSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0lNUExFTUVOVEFUSU9OX1NQRUNJRklDID0gMHgyMDtcblxudmFyIGhhc1Jhd0NvbnRlbnQgPSB7XG4gIFNUWUxFOiB0cnVlLFxuICBTQ1JJUFQ6IHRydWUsXG4gIFhNUDogdHJ1ZSxcbiAgSUZSQU1FOiB0cnVlLFxuICBOT0VNQkVEOiB0cnVlLFxuICBOT0ZSQU1FUzogdHJ1ZSxcbiAgUExBSU5URVhUOiB0cnVlXG59O1xuXG52YXIgZW1wdHlFbGVtZW50cyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYmFzZWZvbnQ6IHRydWUsXG4gIGJnc291bmQ6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBmcmFtZTogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZVxufTtcblxudmFyIGV4dHJhTmV3TGluZSA9IHtcbiAgLyogUmVtb3ZlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzk0NFxuICBwcmU6IHRydWUsXG4gIHRleHRhcmVhOiB0cnVlLFxuICBsaXN0aW5nOiB0cnVlXG4gICovXG59O1xuXG5Ob2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XG5cbiAgLy8gTm9kZSB0aGF0IGFyZSBub3QgaW5zZXJ0ZWQgaW50byB0aGUgdHJlZSBpbmhlcml0IGEgbnVsbCBwYXJlbnRcbiAgcGFyZW50Tm9kZTogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcblxuICAvLyBYWFg6IHRoZSBiYXNlVVJJIGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGJ5IGRvbSBjb3JlLCBidXRcbiAgLy8gYSBjb3JyZWN0IGltcGxlbWVudGF0aW9uIG9mIGl0IHJlcXVpcmVzIEhUTUwgZmVhdHVyZXMsIHNvXG4gIC8vIHdlJ2xsIGNvbWUgYmFjayB0byB0aGlzIGxhdGVyLlxuICBiYXNlVVJJOiB7IGdldDogdXRpbHMubnlpIH0sXG5cbiAgcGFyZW50RWxlbWVudDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZT09PUVMRU1FTlRfTk9ERSkgPyB0aGlzLnBhcmVudE5vZGUgOiBudWxsO1xuICB9fSxcblxuICBoYXNDaGlsZE5vZGVzOiB7IHZhbHVlOiBmdW5jdGlvbigpIHsgIC8vIE92ZXJyaWRkZW4gaW4gbGVhZi5qc1xuICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoID4gMDtcbiAgfX0sXG5cbiAgZmlyc3RDaGlsZDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwID8gbnVsbCA6IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgfX0sXG5cbiAgbGFzdENoaWxkOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgPyBudWxsIDogdGhpcy5jaGlsZE5vZGVzW3RoaXMuY2hpbGROb2Rlcy5sZW5ndGgtMV07XG4gIH19LFxuXG4gIHByZXZpb3VzU2libGluZzogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnROb2RlKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc2licyA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzLCBpID0gdGhpcy5pbmRleDtcbiAgICByZXR1cm4gaSA9PT0gMCA/IG51bGwgOiBzaWJzW2ktMV07XG4gIH19LFxuXG4gIG5leHRTaWJsaW5nOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudE5vZGUpIHJldHVybiBudWxsO1xuICAgIHZhciBzaWJzID0gdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXMsIGkgPSB0aGlzLmluZGV4O1xuICAgIHJldHVybiBpKzEgPT09IHNpYnMubGVuZ3RoID8gbnVsbCA6IHNpYnNbaSsxXTtcbiAgfX0sXG5cblxuICBfY291bnRDaGlsZHJlbk9mVHlwZTogeyB2YWx1ZTogZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBzdW0gPSAwLCBub2RlcyA9IHRoaXMuY2hpbGROb2RlcywgbGVuZ3RoID0gbm9kZXMubGVuZ3RoLCBpO1xuICAgIGZvciAoaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobm9kZXNbaV0ubm9kZVR5cGUgPT09IHR5cGUpIHN1bSsrO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9fSxcblxuICBfZW5zdXJlSW5zZXJ0VmFsaWQ6IHsgdmFsdWU6IGZ1bmN0aW9uIF9lbnN1cmVJbnNlcnRWYWxpZChub2RlLCBjaGlsZCwgaXNQcmVpbnNlcnQpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcywgaTtcbiAgICBpZiAoIW5vZGUubm9kZVR5cGUpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIG5vZGUnKTtcbiAgICAvLyAxLiBJZiBwYXJlbnQgaXMgbm90IGEgRG9jdW1lbnQsIERvY3VtZW50RnJhZ21lbnQsIG9yIEVsZW1lbnRcbiAgICAvLyBub2RlLCB0aHJvdyBhIEhpZXJhcmNoeVJlcXVlc3RFcnJvci5cbiAgICBzd2l0Y2ggKHBhcmVudC5ub2RlVHlwZSkge1xuICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcbiAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgY2FzZSBFTEVNRU5UX05PREU6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICB9XG4gICAgLy8gMi4gSWYgbm9kZSBpcyBhIGhvc3QtaW5jbHVkaW5nIGluY2x1c2l2ZSBhbmNlc3RvciBvZiBwYXJlbnQsXG4gICAgLy8gdGhyb3cgYSBIaWVyYXJjaHlSZXF1ZXN0RXJyb3IuXG4gICAgaWYgKG5vZGUuaXNBbmNlc3RvcihwYXJlbnQpKSB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAvLyAzLiBJZiBjaGlsZCBpcyBub3QgbnVsbCBhbmQgaXRzIHBhcmVudCBpcyBub3QgcGFyZW50LCB0aGVuXG4gICAgLy8gdGhyb3cgYSBOb3RGb3VuZEVycm9yLiAocmVwbGFjZUNoaWxkIG9taXRzIHRoZSAnY2hpbGQgaXMgbm90IG51bGwnXG4gICAgLy8gYW5kIHRocm93cyBhIFR5cGVFcnJvciBoZXJlIGlmIGNoaWxkIGlzIG51bGwuKVxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCB8fCAhaXNQcmVpbnNlcnQpIHtcbiAgICAgIGlmIChjaGlsZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHV0aWxzLk5vdEZvdW5kRXJyb3IoKTtcbiAgICB9XG4gICAgLy8gNC4gSWYgbm9kZSBpcyBub3QgYSBEb2N1bWVudEZyYWdtZW50LCBEb2N1bWVudFR5cGUsIEVsZW1lbnQsXG4gICAgLy8gVGV4dCwgUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBvciBDb21tZW50IG5vZGUsIHRocm93IGFcbiAgICAvLyBIaWVyYXJjaHlSZXF1ZXN0RXJyb3IuXG4gICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgIGNhc2UgRE9DVU1FTlRfVFlQRV9OT0RFOlxuICAgIGNhc2UgRUxFTUVOVF9OT0RFOlxuICAgIGNhc2UgVEVYVF9OT0RFOlxuICAgIGNhc2UgUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFOlxuICAgIGNhc2UgQ09NTUVOVF9OT0RFOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgfVxuICAgIC8vIDUuIElmIGVpdGhlciBub2RlIGlzIGEgVGV4dCBub2RlIGFuZCBwYXJlbnQgaXMgYSBkb2N1bWVudCwgb3JcbiAgICAvLyBub2RlIGlzIGEgZG9jdHlwZSBhbmQgcGFyZW50IGlzIG5vdCBhIGRvY3VtZW50LCB0aHJvdyBhXG4gICAgLy8gSGllcmFyY2h5UmVxdWVzdEVycm9yLlxuICAgIC8vIDYuIElmIHBhcmVudCBpcyBhIGRvY3VtZW50LCBhbmQgYW55IG9mIHRoZSBzdGF0ZW1lbnRzIGJlbG93LCBzd2l0Y2hlZFxuICAgIC8vIG9uIG5vZGUsIGFyZSB0cnVlLCB0aHJvdyBhIEhpZXJhcmNoeVJlcXVlc3RFcnJvci5cbiAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgVEVYVF9OT0RFOlxuICAgICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgIC8vIDZhMS4gSWYgbm9kZSBoYXMgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGNoaWxkIG9yIGhhcyBhIFRleHRcbiAgICAgICAgLy8gbm9kZSBjaGlsZC5cbiAgICAgICAgaWYgKG5vZGUuX2NvdW50Q2hpbGRyZW5PZlR5cGUoVEVYVF9OT0RFKSA+IDApXG4gICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgIHN3aXRjaCAobm9kZS5fY291bnRDaGlsZHJlbk9mVHlwZShFTEVNRU5UX05PREUpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8vIDZhMi4gT3RoZXJ3aXNlLCBpZiBub2RlIGhhcyBvbmUgZWxlbWVudCBjaGlsZCBhbmQgZWl0aGVyXG4gICAgICAgICAgLy8gcGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkLCBjaGlsZCBpcyBhIGRvY3R5cGUsIG9yIGNoaWxkXG4gICAgICAgICAgLy8gaXMgbm90IG51bGwgYW5kIGEgZG9jdHlwZSBpcyBmb2xsb3dpbmcgY2hpbGQuIFtwcmVpbnNlcnRdXG4gICAgICAgICAgLy8gNmEyLiBPdGhlcndpc2UsIGlmIG5vZGUgaGFzIG9uZSBlbGVtZW50IGNoaWxkIGFuZCBlaXRoZXJcbiAgICAgICAgICAvLyBwYXJlbnQgaGFzIGFuIGVsZW1lbnQgY2hpbGQgdGhhdCBpcyBub3QgY2hpbGQgb3IgYVxuICAgICAgICAgIC8vIGRvY3R5cGUgaXMgZm9sbG93aW5nIGNoaWxkLiBbcmVwbGFjZVdpdGhdXG4gICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsIC8qIGFsd2F5cyB0cnVlIGhlcmUgZm9yIHJlcGxhY2VXaXRoICovKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVpbnNlcnQgJiYgY2hpbGQubm9kZVR5cGUgPT09IERPQ1VNRU5UX1RZUEVfTk9ERSlcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgICAgICBmb3IgKGk9cGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkTm9kZXNbaV0gPT09IGNoaWxkKSBicmVhaztcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFX05PREUpXG4gICAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgPSBwYXJlbnQuX2NvdW50Q2hpbGRyZW5PZlR5cGUoRUxFTUVOVF9OT0RFKTtcbiAgICAgICAgICBpZiAoaXNQcmVpbnNlcnQpIHtcbiAgICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkXCJcbiAgICAgICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkIHRoYXQgaXMgbm90IGNoaWxkXCJcbiAgICAgICAgICAgIGlmIChpID4gMSB8fCAoaSA9PT0gMSAmJiBjaGlsZC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFKSlcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyA2YTEsIGNvbnRpbnVlZC4gKG1vcmUgdGhhbiBvbmUgRWxlbWVudCBjaGlsZClcbiAgICAgICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRUxFTUVOVF9OT0RFOlxuICAgICAgICAvLyA2Yi4gcGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkLCBjaGlsZCBpcyBhIGRvY3R5cGUsIG9yXG4gICAgICAgIC8vIGNoaWxkIGlzIG5vdCBudWxsIGFuZCBhIGRvY3R5cGUgaXMgZm9sbG93aW5nIGNoaWxkLiBbcHJlaW5zZXJ0XVxuICAgICAgICAvLyA2Yi4gcGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkIHRoYXQgaXMgbm90IGNoaWxkIG9yIGFcbiAgICAgICAgLy8gZG9jdHlwZSBpcyBmb2xsb3dpbmcgY2hpbGQuIFtyZXBsYWNlV2l0aF1cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsIC8qIGFsd2F5cyB0cnVlIGhlcmUgZm9yIHJlcGxhY2VXaXRoICovKSB7XG4gICAgICAgICAgaWYgKGlzUHJlaW5zZXJ0ICYmIGNoaWxkLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFX05PREUpXG4gICAgICAgICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAgICAgICBmb3IgKGk9cGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldID09PSBjaGlsZCkgYnJlYWs7XG4gICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUgPT09IERPQ1VNRU5UX1RZUEVfTk9ERSlcbiAgICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkgPSBwYXJlbnQuX2NvdW50Q2hpbGRyZW5PZlR5cGUoRUxFTUVOVF9OT0RFKTtcbiAgICAgICAgaWYgKGlzUHJlaW5zZXJ0KSB7XG4gICAgICAgICAgLy8gXCJwYXJlbnQgaGFzIGFuIGVsZW1lbnQgY2hpbGRcIlxuICAgICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBlbGVtZW50IGNoaWxkIHRoYXQgaXMgbm90IGNoaWxkXCJcbiAgICAgICAgICBpZiAoaSA+IDEgfHwgKGkgPT09IDEgJiYgY2hpbGQubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSkpXG4gICAgICAgICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRE9DVU1FTlRfVFlQRV9OT0RFOlxuICAgICAgICAvLyA2Yy4gcGFyZW50IGhhcyBhIGRvY3R5cGUgY2hpbGQsIGNoaWxkIGlzIG5vbi1udWxsIGFuZCBhblxuICAgICAgICAvLyBlbGVtZW50IGlzIHByZWNlZGluZyBjaGlsZCwgb3IgY2hpbGQgaXMgbnVsbCBhbmQgcGFyZW50IGhhc1xuICAgICAgICAvLyBhbiBlbGVtZW50IGNoaWxkLiBbcHJlaW5zZXJ0XVxuICAgICAgICAvLyA2Yy4gcGFyZW50IGhhcyBhIGRvY3R5cGUgY2hpbGQgdGhhdCBpcyBub3QgY2hpbGQsIG9yIGFuXG4gICAgICAgIC8vIGVsZW1lbnQgaXMgcHJlY2VkaW5nIGNoaWxkLiBbcmVwbGFjZVdpdGhdXG4gICAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwYXJlbnQuX2NvdW50Q2hpbGRyZW5PZlR5cGUoRUxFTUVOVF9OT0RFKSlcbiAgICAgICAgICAgIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNoaWxkIGlzIGFsd2F5cyBub24tbnVsbCBmb3IgW3JlcGxhY2VXaXRoXSBjYXNlXG4gICAgICAgICAgZm9yIChpPTA7IGk8cGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGROb2Rlc1tpXSA9PT0gY2hpbGQpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpXG4gICAgICAgICAgICAgIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpID0gcGFyZW50Ll9jb3VudENoaWxkcmVuT2ZUeXBlKERPQ1VNRU5UX1RZUEVfTk9ERSk7XG4gICAgICAgIGlmIChpc1ByZWluc2VydCkge1xuICAgICAgICAgIC8vIFwicGFyZW50IGhhcyBhbiBkb2N0eXBlIGNoaWxkXCJcbiAgICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICB1dGlscy5IaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBcInBhcmVudCBoYXMgYW4gZG9jdHlwZSBjaGlsZCB0aGF0IGlzIG5vdCBjaGlsZFwiXG4gICAgICAgICAgaWYgKGkgPiAxIHx8IChpID09PSAxICYmIGNoaWxkLm5vZGVUeXBlICE9PSBET0NVTUVOVF9UWVBFX05PREUpKVxuICAgICAgICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDUsIGNvbnRpbnVlZDogKHBhcmVudCBpcyBub3QgYSBkb2N1bWVudClcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9UWVBFX05PREUpIHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcigpO1xuICAgIH1cbiAgfX0sXG5cbiAgaW5zZXJ0QmVmb3JlOiB7IHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUobm9kZSwgY2hpbGQpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAvLyAxLiBFbnN1cmUgcHJlLWluc2VydGlvbiB2YWxpZGl0eVxuICAgIHBhcmVudC5fZW5zdXJlSW5zZXJ0VmFsaWQobm9kZSwgY2hpbGQsIHRydWUpO1xuICAgIC8vIDIuIExldCByZWZlcmVuY2UgY2hpbGQgYmUgY2hpbGQuXG4gICAgdmFyIHJlZkNoaWxkID0gY2hpbGQ7XG4gICAgLy8gMy4gSWYgcmVmZXJlbmNlIGNoaWxkIGlzIG5vZGUsIHNldCBpdCB0byBub2RlJ3MgbmV4dCBzaWJsaW5nXG4gICAgaWYgKHJlZkNoaWxkID09PSBub2RlKSB7IHJlZkNoaWxkID0gbm9kZS5uZXh0U2libGluZzsgfVxuICAgIC8vIDQuIEFkb3B0IG5vZGUgaW50byBwYXJlbnQncyBub2RlIGRvY3VtZW50LlxuICAgIHBhcmVudC5kb2MuYWRvcHROb2RlKG5vZGUpO1xuICAgIC8vIDUuIEluc2VydCBub2RlIGludG8gcGFyZW50IGJlZm9yZSByZWZlcmVuY2UgY2hpbGQuXG4gICAgaWYgKHJlZkNoaWxkID09PSBudWxsKSB7XG4gICAgICBwYXJlbnQuX2FwcGVuZENoaWxkKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmluc2VydChwYXJlbnQsIHJlZkNoaWxkLmluZGV4KTtcbiAgICB9XG4gICAgLy8gNi4gUmV0dXJuIG5vZGVcbiAgICByZXR1cm4gbm9kZTtcbiAgfX0sXG5cblxuICBhcHBlbmRDaGlsZDogeyB2YWx1ZTogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAvLyBUaGlzIGludm9rZXMgX2FwcGVuZENoaWxkIGFmdGVyIGRvaW5nIHZhbGlkaXR5IGNoZWNrcy5cbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY2hpbGQsIG51bGwpO1xuICB9fSxcblxuICBfYXBwZW5kQ2hpbGQ6IHsgdmFsdWU6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgY2hpbGQuaW5zZXJ0KHRoaXMsIHRoaXMuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfX0sXG5cbiAgcmVtb3ZlQ2hpbGQ6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgaWYgKCFjaGlsZC5ub2RlVHlwZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgbm9kZScpO1xuICAgIGlmIChjaGlsZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHV0aWxzLk5vdEZvdW5kRXJyb3IoKTtcbiAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH19LFxuXG4gIC8vIFRvIHJlcGxhY2UgYSBgY2hpbGRgIHdpdGggYG5vZGVgIHdpdGhpbiBhIGBwYXJlbnRgICh0aGlzKVxuICByZXBsYWNlQ2hpbGQ6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VDaGlsZChub2RlLCBjaGlsZCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIC8vIEVuc3VyZSB2YWxpZGl0eSAoc2xpZ2h0IGRpZmZlcmVuY2VzIGZyb20gcHJlLWluc2VydGlvbiBjaGVjaylcbiAgICBwYXJlbnQuX2Vuc3VyZUluc2VydFZhbGlkKG5vZGUsIGNoaWxkLCBmYWxzZSk7XG4gICAgLy8gQWRvcHQgbm9kZSBpbnRvIHBhcmVudCdzIG5vZGUgZG9jdW1lbnQuXG4gICAgaWYgKG5vZGUuZG9jICE9PSBwYXJlbnQuZG9jKSB7XG4gICAgICAvLyBYWFggYWRvcHROb2RlIGhhcyBzaWRlLWVmZmVjdCBvZiByZW1vdmluZyBub2RlIGZyb20gaXRzIHBhcmVudFxuICAgICAgLy8gYW5kIGdlbmVyYXRpbmcgYSBtdXRhdGlvbiBldmVudCwgdGh1cyBjYXVzaW5nIHRoZSBfaW5zZXJ0T3JSZXBsYWNlXG4gICAgICAvLyB0byBnZW5lcmF0ZSB0d28gZGVsZXRlcyBhbmQgYW4gaW5zZXJ0IGluc3RlYWQgb2YgYSAnbW92ZSdcbiAgICAgIC8vIGV2ZW50LiAgSXQgbG9va3MgbGlrZSB0aGUgbmV3IE11dGF0aW9uT2JzZXJ2ZXIgc3R1ZmYgYXZvaWRzXG4gICAgICAvLyB0aGlzIHByb2JsZW0sIGJ1dCBmb3Igbm93IGxldCdzIG9ubHkgYWRvcHQgKGllLCByZW1vdmUgYG5vZGVgXG4gICAgICAvLyBmcm9tIGl0cyBwYXJlbnQpIGhlcmUgaWYgd2UgbmVlZCB0by5cbiAgICAgIHBhcmVudC5kb2MuYWRvcHROb2RlKG5vZGUpO1xuICAgIH1cbiAgICAvLyBEbyB0aGUgcmVwbGFjZS5cbiAgICBub2RlLl9pbnNlcnRPclJlcGxhY2UocGFyZW50LCBjaGlsZC5pbmRleCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9fSxcblxuICAvLyBTZWU6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9jb21wYXJpbmctZG9jdW1lbnQtcG9zaXRpb24vXG4gIGNvbnRhaW5zOiB7IHZhbHVlOiBmdW5jdGlvbiBjb250YWlucyhub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHRoaXMgPT09IG5vZGUpIHsgcmV0dXJuIHRydWU7IC8qIGluY2x1c2l2ZSBkZXNjZW5kYW50ICovIH1cbiAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgICByZXR1cm4gKHRoaXMuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJlxuICAgICAgICAgICAgRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKSAhPT0gMDtcbiAgfX0sXG5cbiAgY29tcGFyZURvY3VtZW50UG9zaXRpb246IHsgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoYXQpe1xuICAgIC8vIEJhc2ljIGFsZ29yaXRobSBmb3IgZmluZGluZyB0aGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdHdvIG5vZGVzLlxuICAgIC8vIE1ha2UgYSBsaXN0IHRoZSBhbmNlc3RvcnMgb2YgZWFjaCBub2RlLCBzdGFydGluZyB3aXRoIHRoZVxuICAgIC8vIGRvY3VtZW50IGVsZW1lbnQgYW5kIHByb2NlZWRpbmcgZG93biB0byB0aGUgbm9kZXMgdGhlbXNlbHZlcy5cbiAgICAvLyBUaGVuLCBsb29wIHRocm91Z2ggdGhlIGxpc3RzLCBsb29raW5nIGZvciB0aGUgZmlyc3QgZWxlbWVudFxuICAgIC8vIHRoYXQgZGlmZmVycy4gIFRoZSBvcmRlciBvZiB0aG9zZSB0d28gZWxlbWVudHMgZ2l2ZSB0aGVcbiAgICAvLyBvcmRlciBvZiB0aGVpciBkZXNjZW5kYW50IG5vZGVzLiAgT3IsIGlmIG9uZSBsaXN0IGlzIGEgcHJlZml4XG4gICAgLy8gb2YgdGhlIG90aGVyIG9uZSwgdGhlbiB0aGF0IG5vZGUgY29udGFpbnMgdGhlIG90aGVyLlxuXG4gICAgaWYgKHRoaXMgPT09IHRoYXQpIHJldHVybiAwO1xuXG4gICAgLy8gSWYgdGhleSdyZSBub3Qgb3duZWQgYnkgdGhlIHNhbWUgZG9jdW1lbnQgb3IgaWYgb25lIGlzIHJvb3RlZFxuICAgIC8vIGFuZCBvbmUgaXMgbm90LCB0aGVuIHRoZXkncmUgZGlzY29ubmVjdGVkLlxuICAgIGlmICh0aGlzLmRvYyAhPT0gdGhhdC5kb2MgfHxcbiAgICAgIHRoaXMucm9vdGVkICE9PSB0aGF0LnJvb3RlZClcbiAgICAgIHJldHVybiAoRE9DVU1FTlRfUE9TSVRJT05fRElTQ09OTkVDVEVEICtcbiAgICAgICAgICBET0NVTUVOVF9QT1NJVElPTl9JTVBMRU1FTlRBVElPTl9TUEVDSUZJQyk7XG5cbiAgICAvLyBHZXQgYXJyYXlzIG9mIGFuY2VzdG9ycyBmb3IgdGhpcyBhbmQgdGhhdFxuICAgIHZhciB0aGVzZSA9IFtdLCB0aG9zZSA9IFtdO1xuICAgIGZvcih2YXIgbiA9IHRoaXM7IG4gIT09IG51bGw7IG4gPSBuLnBhcmVudE5vZGUpIHRoZXNlLnB1c2gobik7XG4gICAgZm9yKG4gPSB0aGF0OyBuICE9PSBudWxsOyBuID0gbi5wYXJlbnROb2RlKSB0aG9zZS5wdXNoKG4pO1xuICAgIHRoZXNlLnJldmVyc2UoKTsgIC8vIFNvIHdlIHN0YXJ0IHdpdGggdGhlIG91dGVybW9zdFxuICAgIHRob3NlLnJldmVyc2UoKTtcblxuICAgIGlmICh0aGVzZVswXSAhPT0gdGhvc2VbMF0pIC8vIE5vIGNvbW1vbiBhbmNlc3RvclxuICAgICAgcmV0dXJuIChET0NVTUVOVF9QT1NJVElPTl9ESVNDT05ORUNURUQgK1xuICAgICAgICAgIERPQ1VNRU5UX1BPU0lUSU9OX0lNUExFTUVOVEFUSU9OX1NQRUNJRklDKTtcblxuICAgIG4gPSBNYXRoLm1pbih0aGVzZS5sZW5ndGgsIHRob3NlLmxlbmd0aCk7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKHRoZXNlW2ldICE9PSB0aG9zZVtpXSkge1xuICAgICAgICAvLyBXZSBmb3VuZCB0d28gZGlmZmVyZW50IGFuY2VzdG9ycywgc28gY29tcGFyZVxuICAgICAgICAvLyB0aGVpciBwb3NpdGlvbnNcbiAgICAgICAgaWYgKHRoZXNlW2ldLmluZGV4IDwgdGhvc2VbaV0uaW5kZXgpXG4gICAgICAgICAgcmV0dXJuIERPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ2V0IHRvIGhlcmUsIHRoZW4gb25lIG9mIHRoZSBub2RlcyAodGhlIG9uZSB3aXRoIHRoZVxuICAgIC8vIHNob3J0ZXIgbGlzdCBvZiBhbmNlc3RvcnMpIGNvbnRhaW5zIHRoZSBvdGhlciBvbmUuXG4gICAgaWYgKHRoZXNlLmxlbmd0aCA8IHRob3NlLmxlbmd0aClcbiAgICAgIHJldHVybiAoRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HICtcbiAgICAgICAgICBET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAoRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HICtcbiAgICAgICAgICBET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUyk7XG4gIH19LFxuXG4gIGlzU2FtZU5vZGU6IHt2YWx1ZSA6IGZ1bmN0aW9uIGlzU2FtZU5vZGUobm9kZSkge1xuICAgIHJldHVybiB0aGlzID09PSBub2RlO1xuICB9fSxcblxuXG4gIC8vIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIGdlbmVyaWMgcGFydHMgb2Ygbm9kZSBlcXVhbGl0eSB0ZXN0aW5nXG4gIC8vIGFuZCBkZWZlcnMgdG8gdGhlIChub24tcmVjdXJzaXZlKSB0eXBlLXNwZWNpZmljIGlzRXF1YWwoKSBtZXRob2RcbiAgLy8gZGVmaW5lZCBieSBzdWJjbGFzc2VzXG4gIGlzRXF1YWxOb2RlOiB7IHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsTm9kZShub2RlKSB7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IHRoaXMubm9kZVR5cGUpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGZvciBzYW1lIG51bWJlciBvZiBjaGlsZHJlblxuICAgIC8vIENoZWNrIGZvciBjaGlsZHJlbiB0aGlzIHdheSBiZWNhdXNlIGl0IGlzIG1vcmUgZWZmaWNpZW50XG4gICAgLy8gZm9yIGNoaWxkbGVzcyBsZWFmIG5vZGVzLlxuICAgIHZhciBuOyAvLyBudW1iZXIgb2YgY2hpbGQgbm9kZXNcbiAgICBpZiAoIXRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgbiA9IDA7XG4gICAgICBpZiAobm9kZS5maXJzdENoaWxkKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbiA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAhPT0gbikgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHR5cGUtc3BlY2lmaWMgcHJvcGVydGllcyBmb3IgZXF1YWxpdHlcbiAgICBpZiAoIXRoaXMuaXNFcXVhbChub2RlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gTm93IGNoZWNrIGNoaWxkcmVuIGZvciBlcXVhbGl0eVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBjMSA9IHRoaXMuY2hpbGROb2Rlc1tpXSwgYzIgPSBub2RlLmNoaWxkTm9kZXNbaV07XG4gICAgICBpZiAoIWMxLmlzRXF1YWxOb2RlKGMyKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9fSxcblxuICAvLyBUaGlzIG1ldGhvZCBkZWxlZ2F0ZXMgc2hhbGxvdyBjbG9uaW5nIHRvIGEgY2xvbmUoKSBtZXRob2RcbiAgLy8gdGhhdCBlYWNoIGNvbmNyZXRlIHN1YmNsYXNzIG11c3QgaW1wbGVtZW50XG4gIGNsb25lTm9kZTogeyB2YWx1ZTogZnVuY3Rpb24oZGVlcCkge1xuICAgIC8vIENsb25lIHRoaXMgbm9kZVxuICAgIHZhciBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcblxuICAgIC8vIEhhbmRsZSB0aGUgcmVjdXJzaXZlIGNhc2UgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKGRlZXAgJiYgdGhpcy5maXJzdENoaWxkKSB7XG4gICAgICBmb3IodmFyIGkgPSAwLCBuID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBjbG9uZS5fYXBwZW5kQ2hpbGQodGhpcy5jaGlsZE5vZGVzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9fSxcblxuICBsb29rdXBQcmVmaXg6IHsgdmFsdWU6IGZ1bmN0aW9uIGxvb2t1cFByZWZpeChucykge1xuICAgIHZhciBlO1xuICAgIGlmIChucyA9PT0gJycpIHJldHVybiBudWxsO1xuICAgIHN3aXRjaCh0aGlzLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBFTEVNRU5UX05PREU6XG4gICAgICByZXR1cm4gdGhpcy5sb2NhdGVOYW1lc3BhY2VQcmVmaXgobnMpO1xuICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcbiAgICAgIGUgPSB0aGlzLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHJldHVybiBlID8gZS5sb2NhdGVOYW1lc3BhY2VQcmVmaXgobnMpIDogbnVsbDtcbiAgICBjYXNlIERPQ1VNRU5UX1RZUEVfTk9ERTpcbiAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgZSA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICAgIHJldHVybiBlID8gZS5sb2NhdGVOYW1lc3BhY2VQcmVmaXgobnMpIDogbnVsbDtcbiAgICB9XG4gIH19LFxuXG5cbiAgbG9va3VwTmFtZXNwYWNlVVJJOiB7dmFsdWU6IGZ1bmN0aW9uIGxvb2t1cE5hbWVzcGFjZVVSSShwcmVmaXgpIHtcbiAgICB2YXIgZTtcbiAgICBzd2l0Y2godGhpcy5ub2RlVHlwZSkge1xuICAgIGNhc2UgRUxFTUVOVF9OT0RFOlxuICAgICAgcmV0dXJuIHRoaXMubG9jYXRlTmFtZXNwYWNlKHByZWZpeCk7XG4gICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgICAgZSA9IHRoaXMuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgcmV0dXJuIGUgPyBlLmxvY2F0ZU5hbWVzcGFjZShwcmVmaXgpIDogbnVsbDtcbiAgICBjYXNlIERPQ1VNRU5UX1RZUEVfTk9ERTpcbiAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgZSA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICAgIHJldHVybiBlID8gZS5sb2NhdGVOYW1lc3BhY2UocHJlZml4KSA6IG51bGw7XG4gICAgfVxuICB9fSxcblxuICBpc0RlZmF1bHROYW1lc3BhY2U6IHsgdmFsdWU6IGZ1bmN0aW9uIGlzRGVmYXVsdE5hbWVzcGFjZShucykge1xuICAgIHZhciBkZWZhdWx0bnMgPSB0aGlzLmxvb2t1cE5hbWVzcGFjZVVSSShudWxsKTtcbiAgICBpZiAoZGVmYXVsdG5zID09PSBudWxsKSBkZWZhdWx0bnMgPSAnJztcbiAgICByZXR1cm4gbnMgPT09IGRlZmF1bHRucztcbiAgfX0sXG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzIGZvciBub2Rlcy4gIE5vdCBwYXJ0IG9mIHRoZSBET01cblxuICAvLyBSZXR1cm4gdGhlIGluZGV4IG9mIHRoaXMgbm9kZSBpbiBpdHMgcGFyZW50LlxuICAvLyBUaHJvdyBpZiBubyBwYXJlbnQsIG9yIGlmIHRoaXMgbm9kZSBpcyBub3QgYSBjaGlsZCBvZiBpdHMgcGFyZW50XG4gIGluZGV4OiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgdXRpbHMuYXNzZXJ0KHRoaXMucGFyZW50Tm9kZSk7XG4gICAgdmFyIGtpZHMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2RlcztcbiAgICBpZiAodGhpcy5faW5kZXggPT09IHVuZGVmaW5lZCB8fCBraWRzW3RoaXMuX2luZGV4XSAhPT0gdGhpcykge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBhbiBPKE5eMikgYmxvd3VwIGlmIG5vbmUgb2YgdGhlXG4gICAgICAvLyBraWRzIGhhdmUgZGVmaW5lZCBpbmRpY2VzIHlldCBhbmQgd2UncmUgdHJhdmVyc2luZyB2aWFcbiAgICAgIC8vIG5leHRTaWJsaW5nIG9yIHByZXZTaWJsaW5nXG4gICAgICBmb3IgKHZhciBpPTA7IGk8a2lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBraWRzW2ldLl9pbmRleCA9IGk7XG4gICAgICB9XG4gICAgICB1dGlscy5hc3NlcnQoa2lkc1t0aGlzLl9pbmRleF0gPT09IHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gIH19LFxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoaXMgbm9kZSBpcyBlcXVhbCB0byBvciBpcyBhbiBhbmNlc3RvciBvZiB0aGF0IG5vZGVcbiAgLy8gTm90ZSB0aGF0IG5vZGVzIGFyZSBjb25zaWRlcmVkIHRvIGJlIGFuY2VzdG9ycyBvZiB0aGVtc2VsdmVzXG4gIGlzQW5jZXN0b3I6IHsgdmFsdWU6IGZ1bmN0aW9uKHRoYXQpIHtcbiAgICAvLyBJZiB0aGV5IGJlbG9uZyB0byBkaWZmZXJlbnQgZG9jdW1lbnRzLCB0aGVuIHRoZXkncmUgdW5yZWxhdGVkLlxuICAgIGlmICh0aGlzLmRvYyAhPT0gdGhhdC5kb2MpIHJldHVybiBmYWxzZTtcbiAgICAvLyBJZiBvbmUgaXMgcm9vdGVkIGFuZCBvbmUgaXNuJ3QgdGhlbiB0aGV5J3JlIG5vdCByZWxhdGVkXG4gICAgaWYgKHRoaXMucm9vdGVkICE9PSB0aGF0LnJvb3RlZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gT3RoZXJ3aXNlIGNoZWNrIGJ5IHRyYXZlcnNpbmcgdGhlIHBhcmVudE5vZGUgY2hhaW5cbiAgICBmb3IodmFyIGUgPSB0aGF0OyBlOyBlID0gZS5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoZSA9PT0gdGhpcykgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfX0sXG5cbiAgLy8gRE9NSU5PIENoYW5nZWQgdGhlIGJlaGF2aW9yIHRvIGNvbmZvcm0gd2l0aCB0aGUgc3BlY3MuIFNlZTpcbiAgLy8gaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9kL3RvcGljL21vemlsbGEuZGV2LnBsYXRmb3JtLzc3c0lZY3BkRG1jL2Rpc2N1c3Npb25cbiAgZW5zdXJlU2FtZURvYzogeyB2YWx1ZTogZnVuY3Rpb24odGhhdCkge1xuICAgIGlmICh0aGF0Lm93bmVyRG9jdW1lbnQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQub3duZXJEb2N1bWVudCA9IHRoaXMuZG9jO1xuICAgIH1cbiAgICBlbHNlIGlmKHRoYXQub3duZXJEb2N1bWVudCAhPT0gdGhpcy5kb2MpIHtcbiAgICAgIHV0aWxzLldyb25nRG9jdW1lbnRFcnJvcigpO1xuICAgIH1cbiAgfX0sXG5cbiAgLy8gUmVtb3ZlIGFsbCBvZiB0aGlzIG5vZGUncyBjaGlsZHJlbi4gIFRoaXMgaXMgYSBtaW5vclxuICAvLyBvcHRpbWl6YXRpb24gdGhhdCBvbmx5IGNhbGxzIG1vZGlmeSgpIG9uY2UuXG4gIHJlbW92ZUNoaWxkcmVuOiB7IHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbigpIHtcbiAgICB2YXIgbiA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciByb290ID0gdGhpcy5yb290ZWQgPyB0aGlzLm93bmVyRG9jdW1lbnQgOiBudWxsO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAocm9vdCkgcm9vdC5tdXRhdGVSZW1vdmUodGhpcy5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzW2ldLnBhcmVudE5vZGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCA9IDA7IC8vIEZvcmdldCBhbGwgY2hpbGRyZW5cbiAgICAgIHRoaXMubW9kaWZ5KCk7ICAgICAgICAgICAgICAvLyBVcGRhdGUgbGFzdCBtb2RpZmllZCB0eXBlIG9uY2Ugb25seVxuICAgIH1cbiAgfX0sXG5cbiAgLy8gSW5zZXJ0IHRoaXMgbm9kZSBhcyBhIGNoaWxkIG9mIHBhcmVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LFxuICAvLyBmaXJpbmcgbXV0YXRpb24gZXZlbnRzIGFzIG5lY2Vzc2FyeVxuICBpbnNlcnQ6IHsgdmFsdWU6IGZ1bmN0aW9uIGluc2VydChwYXJlbnQsIGluZGV4KSB7XG4gICAgdGhpcy5faW5zZXJ0T3JSZXBsYWNlKHBhcmVudCwgaW5kZXgsIGZhbHNlKTtcbiAgfX0sXG5cbiAgLy8gSW5zZXJ0IHRoaXMgbm9kZSBhcyBhIGNoaWxkIG9mIHBhcmVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LFxuICAvLyBvciByZXBsYWNlIHRoZSBzcGVjaWZpZWQgY2hpbGQgd2l0aCB0aGlzIG5vZGUsIGZpcmluZyBtdXRhdGlvbiBldmVudHMgYXNcbiAgLy8gbmVjZXNzYXJ5XG4gIF9pbnNlcnRPclJlcGxhY2U6IHsgdmFsdWU6IGZ1bmN0aW9uIF9pbnNlcnRPclJlcGxhY2UocGFyZW50LCBpbmRleCwgaXNSZXBsYWNlKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcztcbiAgICB2YXIga2lkcyA9IHBhcmVudC5jaGlsZE5vZGVzO1xuXG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIGNoaWxkLnJvb3RlZCkge1xuICAgICAgdXRpbHMuSGllcmFyY2h5UmVxdWVzdEVycm9yKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgYSBjaGlsZCBvZiB0aGUgc3BlY2lmaWVkIHBhcmVudCwgdGhlblxuICAgIC8vIHRoZSBpbmRleCBtYXkgaGF2ZSB0byBiZSBhZGp1c3RlZC5cbiAgICBpZiAoY2hpbGQucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gY2hpbGQuaW5kZXg7XG4gICAgICAvLyBJZiB3ZSdyZSBub3QgbW92aW5nIHRoZSBub2RlLCB3ZSdyZSBkb25lIG5vd1xuICAgICAgLy8gWFhYOiBvciBkbyBET00gbXV0YXRpb24gZXZlbnRzIHN0aWxsIGhhdmUgdG8gYmUgZmlyZWQ/XG4gICAgICBpZiAoY3VycmVudEluZGV4ID09PSBpbmRleCkgcmV0dXJuO1xuXG4gICAgICAvLyBJZiB0aGUgY2hpbGQgaXMgYmVmb3JlIHRoZSBzcG90IGl0IGlzIHRvIGJlIGluc2VydGVkIGF0LFxuICAgICAgLy8gdGhlbiB3aGVuIGl0IGlzIHJlbW92ZWQsIHRoZSBpbmRleCBvZiB0aGF0IHNwb3Qgd2lsbCBiZVxuICAgICAgLy8gcmVkdWNlZC5cbiAgICAgIGlmIChjdXJyZW50SW5kZXggPCBpbmRleCkgaW5kZXgtLTtcbiAgICB9XG5cbiAgICAvLyBEZWxldGUgdGhlIG9sZCBjaGlsZFxuICAgIGlmIChpc1JlcGxhY2UpIHtcbiAgICAgIHZhciBvbGRDaGlsZCA9IHBhcmVudC5jaGlsZE5vZGVzW2luZGV4XTtcbiAgICAgIGlmIChvbGRDaGlsZC5yb290ZWQpIG9sZENoaWxkLmRvYy5tdXRhdGVSZW1vdmUob2xkQ2hpbGQpO1xuICAgICAgb2xkQ2hpbGQucGFyZW50Tm9kZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCB0aGUgY2hpbGQgYW5kIHRoZSBwYXJlbnQgYXJlIHJvb3RlZCwgdGhlbiB3ZSB3YW50IHRvXG4gICAgLy8gdHJhbnNwbGFudCB0aGUgY2hpbGQgd2l0aG91dCB1cHJvb3RpbmcgYW5kIHJlcm9vdGluZyBpdC5cbiAgICBpZiAoY2hpbGQucm9vdGVkICYmIHBhcmVudC5yb290ZWQpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgY2hpbGQgZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgdHJlZVxuICAgICAgLy8gd2l0aG91dCBjYWxsaW5nIHJlbW92ZSgpLCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIHVwcm9vdCBpdC5cbiAgICAgIHZhciBjdXJwYXIgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgICAgY3VycGFyLmNoaWxkTm9kZXMuc3BsaWNlKGNoaWxkLmluZGV4LCAxKTtcbiAgICAgIGN1cnBhci5tb2RpZnkoKTtcblxuICAgICAgLy8gQW5kIGluc2VydCBpdCBhcyBhIGNoaWxkIG9mIGl0cyBuZXcgcGFyZW50XG4gICAgICBjaGlsZC5wYXJlbnROb2RlID0gcGFyZW50O1xuICAgICAgaWYgKGlzUmVwbGFjZSkge1xuICAgICAgICBraWRzW2luZGV4XSA9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2lkcy5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLl9pbmRleCA9IGluZGV4O1xuICAgICAgcGFyZW50Lm1vZGlmeSgpO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBhIG1vdmUgbXV0YXRpb24gZXZlbnRcbiAgICAgIHBhcmVudC5kb2MubXV0YXRlTW92ZShjaGlsZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgIHZhciBzcGxpY2VBcmdzID0gW2luZGV4LCBpc1JlcGxhY2UgPyAxIDogMF07XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBmcmFnQ2hpbGQgPSBjaGlsZC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgIHNwbGljZUFyZ3MucHVzaChmcmFnQ2hpbGQpO1xuICAgICAgICAgIGZyYWdDaGlsZC5wYXJlbnROb2RlID0gcGFyZW50O1xuICAgICAgICAgIGZyYWdDaGlsZC5faW5kZXggPSBpbmRleCArIGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBub2RlcyBmcm9tIHRoZSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAgICBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIEFkZCBhbGwgbm9kZXMgdG8gdGhlIG5ldyBwYXJlbnQsIG92ZXJ3cml0aW5nIHRoZSBvbGQgY2hpbGRcbiAgICAgICAga2lkcy5zcGxpY2UuYXBwbHkoa2lkcywgc3BsaWNlQXJncyk7XG4gICAgICAgIC8vIENhbGwgdGhlIG11dGF0aW9uIGhhbmRsZXJzXG4gICAgICAgIC8vIFVzZSBzcGxpY2VBcmdzIHNpbmNlIHRoZSBvcmlnaW5hbCBhcnJheSBoYXMgYmVlbiBkZXN0cm95ZWQuIFRoZVxuICAgICAgICAvLyBsaXZlbmVzcyBndWFyYW50ZWUgcmVxdWlyZXMgdXMgdG8gY2xvbmUgdGhlIGFycmF5IHNvIHRoYXRcbiAgICAgICAgLy8gcmVmZXJlbmNlcyB0byB0aGUgY2hpbGROb2RlcyBvZiB0aGUgRG9jdW1lbnRGcmFnbWVudCB3aWxsIGJlIGVtcHR5XG4gICAgICAgIC8vIHdoZW4gdGhlIGluc2VydGlvbiBoYW5kbGVycyBhcmUgY2FsbGVkLlxuICAgICAgICBpZiAocGFyZW50LnJvb3RlZCkge1xuICAgICAgICAgIHBhcmVudC5tb2RpZnkoKTtcbiAgICAgICAgICBmb3IgKGkgPSAyOyBpIDwgc3BsaWNlQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFyZW50LmRvYy5tdXRhdGVJbnNlcnQoc3BsaWNlQXJnc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoaWxkIGFscmVhZHkgaGFzIGEgcGFyZW50LCBpdCBuZWVkcyB0byBiZVxuICAgICAgICAvLyByZW1vdmVkIGZyb20gdGhhdCBwYXJlbnQsIHdoaWNoIG1heSBhbHNvIHVwcm9vdCBpdFxuICAgICAgICBpZiAoY2hpbGQucGFyZW50Tm9kZSkgY2hpbGQucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gTm93IGluc2VydCB0aGUgY2hpbGQgaW50byB0aGUgcGFyZW50J3MgYXJyYXkgb2YgY2hpbGRyZW5cbiAgICAgICAgY2hpbGQucGFyZW50Tm9kZSA9IHBhcmVudDtcbiAgICAgICAgaWYgKGlzUmVwbGFjZSkge1xuICAgICAgICAgIGtpZHNbaW5kZXhdID0gY2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2lkcy5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5faW5kZXggPSBpbmRleDtcblxuICAgICAgICAvLyBBbmQgcm9vdCB0aGUgY2hpbGQgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmIChwYXJlbnQucm9vdGVkKSB7XG4gICAgICAgICAgcGFyZW50Lm1vZGlmeSgpO1xuICAgICAgICAgIHBhcmVudC5kb2MubXV0YXRlSW5zZXJ0KGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfX0sXG5cblxuICAvLyBSZXR1cm4gdGhlIGxhc3RNb2RUaW1lIHZhbHVlIGZvciB0aGlzIG5vZGUuIChGb3IgdXNlIGFzIGFcbiAgLy8gY2FjaGUgaW52YWxpZGF0aW9uIG1lY2hhbmlzbS4gSWYgdGhlIG5vZGUgZG9lcyBub3QgYWxyZWFkeVxuICAvLyBoYXZlIG9uZSwgaW5pdGlhbGl6ZSBpdCBmcm9tIHRoZSBvd25lciBkb2N1bWVudCdzIG1vZGNsb2NrXG4gIC8vIHByb3BlcnR5LiAoTm90ZSB0aGF0IG1vZGNsb2NrIGRvZXMgbm90IHJldHVybiB0aGUgYWN0dWFsXG4gIC8vIHRpbWU7IGl0IGlzIHNpbXBseSBhIGNvdW50ZXIgaW5jcmVtZW50ZWQgb24gZWFjaCBkb2N1bWVudFxuICAvLyBtb2RpZmljYXRpb24pXG4gIGxhc3RNb2RUaW1lOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9sYXN0TW9kVGltZSkge1xuICAgICAgdGhpcy5fbGFzdE1vZFRpbWUgPSB0aGlzLmRvYy5tb2RjbG9jaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xhc3RNb2RUaW1lO1xuICB9fSxcblxuICAvLyBJbmNyZW1lbnQgdGhlIG93bmVyIGRvY3VtZW50J3MgbW9kY2xvY2sgYW5kIHVzZSB0aGUgbmV3XG4gIC8vIHZhbHVlIHRvIHVwZGF0ZSB0aGUgbGFzdE1vZFRpbWUgdmFsdWUgZm9yIHRoaXMgbm9kZSBhbmRcbiAgLy8gYWxsIG9mIGl0cyBhbmNlc3RvcnMuIE5vZGVzIHRoYXQgaGF2ZSBuZXZlciBoYWQgdGhlaXJcbiAgLy8gbGFzdE1vZFRpbWUgdmFsdWUgcXVlcmllZCBkbyBub3QgbmVlZCB0byBoYXZlIGFcbiAgLy8gbGFzdE1vZFRpbWUgcHJvcGVydHkgc2V0IG9uIHRoZW0gc2luY2UgdGhlcmUgaXMgbm9cbiAgLy8gcHJldmlvdXNseSBxdWVyaWVkIHZhbHVlIHRvIGV2ZXIgY29tcGFyZSB0aGUgbmV3IHZhbHVlXG4gIC8vIGFnYWluc3QsIHNvIG9ubHkgdXBkYXRlIG5vZGVzIHRoYXQgYWxyZWFkeSBoYXZlIGFcbiAgLy8gX2xhc3RNb2RUaW1lIHByb3BlcnR5LlxuICBtb2RpZnk6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRvYy5tb2RjbG9jaykgeyAvLyBTa2lwIHdoaWxlIGRvYy5tb2RjbG9jayA9PSAwXG4gICAgICB2YXIgdGltZSA9ICsrdGhpcy5kb2MubW9kY2xvY2s7XG4gICAgICBmb3IodmFyIG4gPSB0aGlzOyBuOyBuID0gbi5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIGlmIChuLl9sYXN0TW9kVGltZSkge1xuICAgICAgICAgIG4uX2xhc3RNb2RUaW1lID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfX0sXG5cbiAgLy8gVGhpcyBhdHRyaWJ1dGUgaXMgbm90IHBhcnQgb2YgdGhlIERPTSBidXQgaXMgcXVpdGUgaGVscGZ1bC5cbiAgLy8gSXQgcmV0dXJucyB0aGUgZG9jdW1lbnQgd2l0aCB3aGljaCBhIG5vZGUgaXMgYXNzb2NpYXRlZC4gIFVzdWFsbHlcbiAgLy8gdGhpcyBpcyB0aGUgb3duZXJEb2N1bWVudC4gQnV0IG93bmVyRG9jdW1lbnQgaXMgbnVsbCBmb3IgdGhlXG4gIC8vIGRvY3VtZW50IG9iamVjdCBpdHNlbGYsIHNvIHRoaXMgaXMgYSBoYW5keSB3YXkgdG8gZ2V0IHRoZSBkb2N1bWVudFxuICAvLyByZWdhcmRsZXNzIG9mIHRoZSBub2RlIHR5cGVcbiAgZG9jOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzO1xuICB9fSxcblxuXG4gIC8vIElmIHRoZSBub2RlIGhhcyBhIG5pZCAobm9kZSBpZCksIHRoZW4gaXQgaXMgcm9vdGVkIGluIGEgZG9jdW1lbnRcbiAgcm9vdGVkOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fbmlkO1xuICB9fSxcblxuICBub3JtYWxpemU6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGk9MDsgaSA8IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZE5vZGVzW2ldO1xuXG4gICAgICBpZiAoY2hpbGQubm9ybWFsaXplKSB7XG4gICAgICAgIGNoaWxkLm5vcm1hbGl6ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGQubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGQubm9kZVZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICBpLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSkge1xuICAgICAgICB2YXIgcHJldkNoaWxkID0gdGhpcy5jaGlsZE5vZGVzW2ktMV07XG5cbiAgICAgICAgaWYgKHByZXZDaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGNoaWxkIGFuZCBkZWNyZW1lbnQgaVxuICAgICAgICAgIHByZXZDaGlsZC5hcHBlbmREYXRhKGNoaWxkLm5vZGVWYWx1ZSk7XG5cbiAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH19LFxuXG4gIC8vIENvbnZlcnQgdGhlIGNoaWxkcmVuIG9mIGEgbm9kZSB0byBhbiBIVE1MIHN0cmluZy5cbiAgLy8gVGhpcyBpcyB1c2VkIGJ5IHRoZSBpbm5lckhUTUwgZ2V0dGVyXG4gIC8vIFRoZSBzZXJpYWxpemF0aW9uIHNwZWMgaXMgYXQ6XG4gIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1lbmQuaHRtbCNzZXJpYWxpemluZy1odG1sLWZyYWdtZW50c1xuICBzZXJpYWxpemU6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzID0gJyc7XG4gICAgZm9yKHZhciBpID0gMCwgbiA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBraWQgPSB0aGlzLmNoaWxkTm9kZXNbaV07XG4gICAgICBzd2l0Y2goa2lkLm5vZGVUeXBlKSB7XG4gICAgICBjYXNlIDE6IC8vRUxFTUVOVF9OT0RFXG4gICAgICAgIHZhciBucyA9IGtpZC5uYW1lc3BhY2VVUkk7XG4gICAgICAgIHZhciBodG1sID0gbnMgPT09IE5BTUVTUEFDRS5IVE1MO1xuICAgICAgICB2YXIgdGFnbmFtZSA9IChodG1sIHx8IG5zID09PSBOQU1FU1BBQ0UuU1ZHIHx8IG5zID09PSBOQU1FU1BBQ0UuTUFUSE1MKSA/IGtpZC5sb2NhbE5hbWUgOiBraWQudGFnTmFtZTtcblxuICAgICAgICBzICs9ICc8JyArIHRhZ25hbWU7XG5cbiAgICAgICAgZm9yKHZhciBqID0gMCwgayA9IGtpZC5fbnVtYXR0cnM7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICB2YXIgYSA9IGtpZC5fYXR0cihqKTtcbiAgICAgICAgICBzICs9ICcgJyArIGF0dHJuYW1lKGEpO1xuICAgICAgICAgIGlmIChhLnZhbHVlICE9PSB1bmRlZmluZWQpIHMgKz0gJz1cIicgKyBlc2NhcGVBdHRyKGEudmFsdWUpICsgJ1wiJztcbiAgICAgICAgfVxuICAgICAgICBzICs9ICc+JztcblxuICAgICAgICBpZiAoIShodG1sICYmIGVtcHR5RWxlbWVudHNbdGFnbmFtZV0pKSB7XG4gICAgICAgICAgdmFyIHNzID0ga2lkLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgIGlmIChodG1sICYmIGV4dHJhTmV3TGluZVt0YWduYW1lXSAmJiBzcy5jaGFyQXQoMCk9PT0nXFxuJykgcyArPSAnXFxuJztcbiAgICAgICAgICAvLyBTZXJpYWxpemUgY2hpbGRyZW4gYW5kIGFkZCBlbmQgdGFnIGZvciBhbGwgb3RoZXJzXG4gICAgICAgICAgcyArPSBzcztcbiAgICAgICAgICBzICs9ICc8LycgKyB0YWduYW1lICsgJz4nO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOiAvL1RFWFRfTk9ERVxuICAgICAgY2FzZSA0OiAvL0NEQVRBX1NFQ1RJT05fTk9ERVxuICAgICAgICB2YXIgcGFyZW50dGFnO1xuICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmXG4gICAgICAgICAgdGhpcy5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5IVE1MKVxuICAgICAgICAgIHBhcmVudHRhZyA9IHRoaXMudGFnTmFtZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHBhcmVudHRhZyA9ICcnO1xuXG4gICAgICAgIGlmIChoYXNSYXdDb250ZW50W3BhcmVudHRhZ10gfHxcbiAgICAgICAgICAgIChwYXJlbnR0YWc9PT0nTk9TQ1JJUFQnICYmIHRoaXMub3duZXJEb2N1bWVudC5fc2NyaXB0aW5nX2VuYWJsZWQpKSB7XG4gICAgICAgICAgcyArPSBraWQuZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzICs9IGVzY2FwZShraWQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDg6IC8vQ09NTUVOVF9OT0RFXG4gICAgICAgIHMgKz0gJzwhLS0nICsga2lkLmRhdGEgKyAnLS0+JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDc6IC8vUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFXG4gICAgICAgIHMgKz0gJzw/JyArIGtpZC50YXJnZXQgKyAnICcgKyBraWQuZGF0YSArICc/Pic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDogLy9ET0NVTUVOVF9UWVBFX05PREVcbiAgICAgICAgcyArPSAnPCFET0NUWVBFICcgKyBraWQubmFtZTtcblxuICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICAvLyBMYXRlc3QgSFRNTCBzZXJpYWxpemF0aW9uIHNwZWMgb21pdHMgdGhlIHB1YmxpYy9zeXN0ZW0gSURcbiAgICAgICAgICBpZiAoa2lkLnB1YmxpY0lEKSB7XG4gICAgICAgICAgICBzICs9ICcgUFVCTElDIFwiJyArIGtpZC5wdWJsaWNJZCArICdcIic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtpZC5zeXN0ZW1JZCkge1xuICAgICAgICAgICAgcyArPSAnIFwiJyArIGtpZC5zeXN0ZW1JZCArICdcIic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcyArPSAnPic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdXRpbHMuSW52YWxpZFN0YXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHM7XG4gIH19LFxuXG4gIC8vIG1pcnJvciBub2RlIHR5cGUgcHJvcGVydGllcyBpbiB0aGUgcHJvdG90eXBlLCBzbyB0aGV5IGFyZSBwcmVzZW50XG4gIC8vIGluIGluc3RhbmNlcyBvZiBOb2RlIChhbmQgc3ViY2xhc3NlcylcbiAgRUxFTUVOVF9OT0RFOiAgICAgICAgICAgICAgICB7IHZhbHVlOiBFTEVNRU5UX05PREUgfSxcbiAgQVRUUklCVVRFX05PREU6ICAgICAgICAgICAgICB7IHZhbHVlOiBBVFRSSUJVVEVfTk9ERSB9LFxuICBURVhUX05PREU6ICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6IFRFWFRfTk9ERSB9LFxuICBDREFUQV9TRUNUSU9OX05PREU6ICAgICAgICAgIHsgdmFsdWU6IENEQVRBX1NFQ1RJT05fTk9ERSB9LFxuICBFTlRJVFlfUkVGRVJFTkNFX05PREU6ICAgICAgIHsgdmFsdWU6IEVOVElUWV9SRUZFUkVOQ0VfTk9ERSB9LFxuICBFTlRJVFlfTk9ERTogICAgICAgICAgICAgICAgIHsgdmFsdWU6IEVOVElUWV9OT0RFIH0sXG4gIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERTogeyB2YWx1ZTogUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFIH0sXG4gIENPTU1FTlRfTk9ERTogICAgICAgICAgICAgICAgeyB2YWx1ZTogQ09NTUVOVF9OT0RFIH0sXG4gIERPQ1VNRU5UX05PREU6ICAgICAgICAgICAgICAgeyB2YWx1ZTogRE9DVU1FTlRfTk9ERSB9LFxuICBET0NVTUVOVF9UWVBFX05PREU6ICAgICAgICAgIHsgdmFsdWU6IERPQ1VNRU5UX1RZUEVfTk9ERSB9LFxuICBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOiAgICAgIHsgdmFsdWU6IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfSxcbiAgTk9UQVRJT05fTk9ERTogICAgICAgICAgICAgICB7IHZhbHVlOiBOT1RBVElPTl9OT0RFIH1cbn0pO1xuXG5mdW5jdGlvbiBlc2NhcGUocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bJjw+XFx1MDBBMF0vZywgZnVuY3Rpb24oYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAnJic6IHJldHVybiAnJmFtcDsnO1xuICAgIGNhc2UgJzwnOiByZXR1cm4gJyZsdDsnO1xuICAgIGNhc2UgJz4nOiByZXR1cm4gJyZndDsnO1xuICAgIGNhc2UgJ1xcdTAwQTAnOiByZXR1cm4gJyZuYnNwOyc7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlQXR0cihzKSB7XG4gIHZhciB0b0VzY2FwZSA9IC9bJlwiXFx1MDBBMF0vZztcbiAgaWYgKCF0b0VzY2FwZS50ZXN0KHMpKSB7XG4gICAgICAvLyBub3RoaW5nIHRvIGRvLCBmYXN0IHBhdGhcbiAgICAgIHJldHVybiBzO1xuICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHMucmVwbGFjZSh0b0VzY2FwZSwgZnVuY3Rpb24oYykge1xuICAgICAgICBzd2l0Y2goYykge1xuICAgICAgICBjYXNlICcmJzogcmV0dXJuICcmYW1wOyc7XG4gICAgICAgIGNhc2UgJ1wiJzogcmV0dXJuICcmcXVvdDsnO1xuICAgICAgICBjYXNlICdcXHUwMEEwJzogcmV0dXJuICcmbmJzcDsnO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRybmFtZShhKSB7XG4gIHZhciBucyA9IGEubmFtZXNwYWNlVVJJO1xuICBpZiAoIW5zKVxuICAgIHJldHVybiBhLmxvY2FsTmFtZTtcbiAgaWYgKG5zID09PSBOQU1FU1BBQ0UuWE1MKVxuICAgIHJldHVybiAneG1sOicgKyBhLmxvY2FsTmFtZTtcbiAgaWYgKG5zID09PSBOQU1FU1BBQ0UuWExJTkspXG4gICAgcmV0dXJuICd4bGluazonICsgYS5sb2NhbE5hbWU7XG5cbiAgaWYgKG5zID09PSBOQU1FU1BBQ0UuWE1MTlMpIHtcbiAgICBpZiAoYS5sb2NhbE5hbWUgPT09ICd4bWxucycpIHJldHVybiAneG1sbnMnO1xuICAgIGVsc2UgcmV0dXJuICd4bWxuczonICsgYS5sb2NhbE5hbWU7XG4gIH1cbiAgcmV0dXJuIGEubmFtZTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKSgzMyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBXZWJzaXRlIH0gZnJvbSAnLi4vbW9kZWxzL1dlYnNpdGUnO1xuaW1wb3J0IHsgUHJvZHVjdCB9IGZyb20gJy4uL21vZGVscy9Qcm9kdWN0JztcbmltcG9ydCB7IENhdGVnb3J5IH0gZnJvbSAnLi4vbW9kZWxzL0NhdGVnb3J5JztcbmltcG9ydCB7IE9yZGVyQ2FydCB9IGZyb20gJy4uL21vZGVscy9PcmRlckNhcnQnO1xuaW1wb3J0IHsgT3JkZXJJdGVtIH0gZnJvbSAnLi4vbW9kZWxzL09yZGVySXRlbSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IEh0dHBDbGllbnQsIEh0dHBIZWFkZXJzIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuXG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBQbGFua0Nvb2tpbmdTZXJ2aWNlIHtcblxuICAgIHByb2R1Y3RzOlByb2R1Y3RbXTtcblxuICAgIGdldFByb2R1Y3RzKCk6T2JzZXJ2YWJsZTxQcm9kdWN0W10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5nZXQ8UHJvZHVjdFtdPignYXBpL3YxL3BsYW5rY29va2luZycpXG4gICAgfVxuXG4gICAgZ2V0U3BpY2VSdWJzKCk6T2JzZXJ2YWJsZTxQcm9kdWN0W10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5nZXQ8UHJvZHVjdFtdPignYXBpL3YxL3BsYW5rY29va2luZy9zcGljZXJ1YnMnKVxuICAgIH1cblxuICAgIGdldEJha2luZ1BsYW5rcygpOk9ic2VydmFibGU8UHJvZHVjdFtdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQuZ2V0PFByb2R1Y3RbXT4oJ2FwaS92MS9wbGFua2Nvb2tpbmcvYmFraW5ncGxhbmtzJylcbiAgICB9XG5cbiAgICBnZXRDb29rQm9va3MoKTpPYnNlcnZhYmxlPFByb2R1Y3RbXT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwQ2xpZW50LmdldDxQcm9kdWN0W10+KCdhcGkvdjEvcGxhbmtjb29raW5nL2Nvb2tib29rcycpXG4gICAgfVxuXG4gICAgZ2V0QmJxUGxhbmtzKCk6T2JzZXJ2YWJsZTxQcm9kdWN0W10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5nZXQ8UHJvZHVjdFtdPignYXBpL3YxL3BsYW5rY29va2luZy9iYnFwbGFua3MnKVxuICAgIH1cblxuICAgIGdldE51dGRyaXZlcigpOk9ic2VydmFibGU8UHJvZHVjdFtdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQuZ2V0PFByb2R1Y3RbXT4oJ2FwaS92MS9wbGFua2Nvb2tpbmcvbnV0ZHJpdmVyJylcbiAgICB9XG5cbiAgICBhZGRRdWFudGl0eSAocXVhbnRpdHk6IE9yZGVySXRlbSk6IE9ic2VydmFibGU8T3JkZXJJdGVtPiB7XG4gICAgICAgIGNvbnNvbGUubG9nKHF1YW50aXR5KTtcbiAgICAgICAgY29uc29sZS5sb2cocXVhbnRpdHkub3JkZXJJdGVtSUQpO1xuICAgICAgICAgY29uc3QgaHR0cE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgaGVhZGVyczogbmV3IEh0dHBIZWFkZXJzKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9KVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwQ2xpZW50LnBvc3Q8T3JkZXJJdGVtPignYXBpL3YxL3BsYW5rY29va2luZy9hZGQvc3BpY2VydWJzJywgcXVhbnRpdHksIGh0dHBPcHRpb25zKVxuICAgICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cENsaWVudDogSHR0cENsaWVudCkgeyBcbiAgICAgICAgdGhpcy5wcm9kdWN0cyA9IFtdO1xuICAgIH1cblxuICAgIGdldFByb2R1Y3QocHJvZHVjdElEOm51bWJlcik6UHJvZHVjdCB7XG4gICAgICAgIGxldCBwcm9kdWN0ID0gdGhpcy5wcm9kdWN0cy5maW5kKHMgPT4gcy5wcm9kdWN0SUQgPT0gcHJvZHVjdElEKTtcblxuICAgICAgICBpZihwcm9kdWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9kdWN0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByb2R1Y3RJRDowLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5SUQ6IDAsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgICAgICAgICBwcmljZTogMCxcbiAgICAgICAgICAgICAgICBwcmljZURlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICAgICAgICAgIHNvcnRPcmRlcjogMCxcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG91bmNlczogMCxcbiAgICAgICAgICAgICAgICBpbWFnZVBhdGg6IFwiXCIsXG4gICAgICAgICAgICAgICAgaGFuZGxpbmdDb3N0OiAwLFxuICAgICAgICAgICAgICAgIHRheEV4ZW1wdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc0tVOiBcIlwiXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9zZXJ2aWNlcy9wbGFua2Nvb2tpbmcuc2VydmljZS50cyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbkV2ZW50LkFUX1RBUkdFVCA9IDI7XG5FdmVudC5CVUJCTElOR19QSEFTRSA9IDM7XG5cbmZ1bmN0aW9uIEV2ZW50KHR5cGUsIGRpY3Rpb25hcnkpIHtcbiAgLy8gSW5pdGlhbGl6ZSBiYXNpYyBldmVudCBwcm9wZXJ0aWVzXG4gIHRoaXMudHlwZSA9ICcnO1xuICB0aGlzLnRhcmdldCA9IG51bGw7XG4gIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIHRoaXMuZXZlbnRQaGFzZSA9IEV2ZW50LkFUX1RBUkdFVDtcbiAgdGhpcy5idWJibGVzID0gZmFsc2U7XG4gIHRoaXMuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICB0aGlzLmlzVHJ1c3RlZCA9IGZhbHNlO1xuICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgdGhpcy50aW1lU3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gIC8vIEluaXRpYWxpemUgaW50ZXJuYWwgZmxhZ3NcbiAgLy8gWFhYOiBXb3VsZCBpdCBiZSBiZXR0ZXIgdG8gaW5oZXJpdCB0aGVzZSBkZWZhdWx0cyBmcm9tIHRoZSBwcm90b3R5cGU/XG4gIHRoaXMuX3Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuICB0aGlzLl9pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB0aGlzLl9kaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIC8vIE5vdyBpbml0aWFsaXplIGJhc2VkIG9uIHRoZSBjb25zdHJ1Y3RvciBhcmd1bWVudHMgKGlmIGFueSlcbiAgaWYgKHR5cGUpIHRoaXMudHlwZSA9IHR5cGU7XG4gIGlmIChkaWN0aW9uYXJ5KSB7XG4gICAgZm9yKHZhciBwIGluIGRpY3Rpb25hcnkpIHtcbiAgICAgIHRoaXNbcF0gPSBkaWN0aW9uYXJ5W3BdO1xuICAgIH1cbiAgfVxufVxuXG5FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEV2ZW50IH0sXG4gIHN0b3BQcm9wYWdhdGlvbjogeyB2YWx1ZTogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuX3Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH19LFxuXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogeyB2YWx1ZTogZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuX3Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gICAgdGhpcy5faW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgfX0sXG5cbiAgcHJldmVudERlZmF1bHQ6IHsgdmFsdWU6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGFibGUpIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gIH19LFxuXG4gIGluaXRFdmVudDogeyB2YWx1ZTogZnVuY3Rpb24gaW5pdEV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2Rpc3BhdGNoaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLl9wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzVHJ1c3RlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5idWJibGVzID0gYnViYmxlcztcbiAgICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICB9fSxcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50O1xuXG52YXIgeG1sID0gcmVxdWlyZSgnLi94bWxuYW1lcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIE5BTUVTUEFDRSA9IHV0aWxzLk5BTUVTUEFDRTtcbnZhciBhdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIE5vZGVMaXN0ID0gcmVxdWlyZSgnLi9Ob2RlTGlzdCcpO1xudmFyIEZpbHRlcmVkRWxlbWVudExpc3QgPSByZXF1aXJlKCcuL0ZpbHRlcmVkRWxlbWVudExpc3QnKTtcbnZhciBET01Ub2tlbkxpc3QgPSByZXF1aXJlKCcuL0RPTVRva2VuTGlzdCcpO1xudmFyIHNlbGVjdCA9IHJlcXVpcmUoJy4vc2VsZWN0Jyk7XG52YXIgQ2hpbGROb2RlID0gcmVxdWlyZSgnLi9DaGlsZE5vZGUnKTtcbnZhciBOb25Eb2N1bWVudFR5cGVDaGlsZE5vZGUgPSByZXF1aXJlKCcuL05vbkRvY3VtZW50VHlwZUNoaWxkTm9kZScpO1xuXG5mdW5jdGlvbiBFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBuYW1lc3BhY2VVUkksIHByZWZpeCkge1xuICB0aGlzLm5vZGVUeXBlID0gTm9kZS5FTEVNRU5UX05PREU7XG4gIHRoaXMub3duZXJEb2N1bWVudCA9IGRvYztcbiAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE5hbWU7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gbmFtZXNwYWNlVVJJO1xuICB0aGlzLnByZWZpeCA9IHByZWZpeDtcblxuICB0aGlzLnRhZ05hbWUgPSAocHJlZml4ICE9PSBudWxsKSA/IHByZWZpeCArICc6JyArIGxvY2FsTmFtZSA6IGxvY2FsTmFtZTtcblxuICBpZiAobmFtZXNwYWNlVVJJICE9PSBOQU1FU1BBQ0UuSFRNTCB8fCAoIW5hbWVzcGFjZVVSSSAmJiAhZG9jLmlzSFRNTCkpIHRoaXMuaXNIVE1MID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuaXNIVE1MKSB0aGlzLnRhZ05hbWUgPSB0aGlzLnRhZ05hbWUudG9VcHBlckNhc2UoKTtcblxuICB0aGlzLmNoaWxkTm9kZXMgPSBuZXcgTm9kZUxpc3QoKTtcblxuICAvLyBUaGVzZSBwcm9wZXJ0aWVzIG1haW50YWluIHRoZSBzZXQgb2YgYXR0cmlidXRlc1xuICB0aGlzLl9hdHRyc0J5UU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvLyBUaGUgcW5hbWUtPkF0dHIgbWFwXG4gIHRoaXMuX2F0dHJzQnlMTmFtZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIFRoZSBuc3xsbmFtZS0+QXR0ciBtYXBcbiAgdGhpcy5fYXR0cktleXMgPSBbXTsgICAgIC8vIGF0dHIgaW5kZXggLT4gbnN8bG5hbWVcblxuICB0aGlzLl9pbmRleCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlR2V0VGV4dChub2RlLCBhKSB7XG4gIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgIGEucHVzaChub2RlLl9kYXRhKTtcbiAgfVxuICBlbHNlIHtcbiAgICBmb3IodmFyIGkgPSAwLCBuID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgIGkgPCBuOyBpKyspXG4gICAgICByZWN1cnNpdmVHZXRUZXh0KG5vZGUuY2hpbGROb2Rlc1tpXSwgYSk7XG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlLCB7XG4gIG5vZGVOYW1lOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRhZ05hbWU7IH19LFxuICBub2RlVmFsdWU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKCkge31cbiAgfSxcbiAgdGV4dENvbnRlbnQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN0cmluZ3MgPSBbXTtcbiAgICAgIHJlY3Vyc2l2ZUdldFRleHQodGhpcywgc3RyaW5ncyk7XG4gICAgICByZXR1cm4gc3RyaW5ncy5qb2luKCcnKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24obmV3dGV4dCkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZHJlbigpO1xuICAgICAgaWYgKG5ld3RleHQgIT09IG51bGwgJiYgbmV3dGV4dCAhPT0gJycpIHtcbiAgICAgICAgdGhpcy5fYXBwZW5kQ2hpbGQodGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld3RleHQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGlubmVySFRNTDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgICB9LFxuICAgIHNldDogdXRpbHMubnlpXG4gIH0sXG4gIG91dGVySFRNTDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBcInRoZSBhdHRyaWJ1dGUgbXVzdCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIHRoZSBIVE1MIGZyYWdtZW50XG4gICAgICAvLyBzZXJpYWxpemF0aW9uIGFsZ29yaXRobSBvbiBhIGZpY3Rpb25hbCBub2RlIHdob3NlIG9ubHkgY2hpbGQgaXNcbiAgICAgIC8vIHRoZSBjb250ZXh0IG9iamVjdFwiXG4gICAgICB2YXIgZmljdGlvbmFsID0ge1xuICAgICAgICBjaGlsZE5vZGVzOiBbIHRoaXMgXSxcbiAgICAgICAgbm9kZVR5cGU6IDBcbiAgICAgIH07XG4gICAgICByZXR1cm4gTm9kZS5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwoZmljdGlvbmFsKTtcbiAgICB9LFxuICAgIHNldDogdXRpbHMubnlpXG4gIH0sXG5cbiAgY2hpbGRyZW46IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbiA9IG5ldyBDaGlsZHJlbkNvbGxlY3Rpb24odGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgfX0sXG5cbiAgYXR0cmlidXRlczogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5fYXR0cmlidXRlcyA9IG5ldyBBdHRyaWJ1dGVzQXJyYXkodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hdHRyaWJ1dGVzO1xuICB9fSxcblxuXG4gIGZpcnN0RWxlbWVudENoaWxkOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtpZHMgPSB0aGlzLmNoaWxkTm9kZXM7XG4gICAgZm9yKHZhciBpID0gMCwgbiA9IGtpZHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAoa2lkc1tpXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHJldHVybiBraWRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfX0sXG5cbiAgbGFzdEVsZW1lbnRDaGlsZDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBraWRzID0gdGhpcy5jaGlsZE5vZGVzO1xuICAgIGZvcih2YXIgaSA9IGtpZHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoa2lkc1tpXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHJldHVybiBraWRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfX0sXG5cbiAgY2hpbGRFbGVtZW50Q291bnQ6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIH19LFxuXG5cbiAgLy8gUmV0dXJuIHRoZSBuZXh0IGVsZW1lbnQsIGluIHNvdXJjZSBvcmRlciwgYWZ0ZXIgdGhpcyBvbmUgb3JcbiAgLy8gbnVsbCBpZiB0aGVyZSBhcmUgbm8gbW9yZS4gIElmIHJvb3QgZWxlbWVudCBpcyBzcGVjaWZpZWQsXG4gIC8vIHRoZW4gZG9uJ3QgdHJhdmVyc2UgYmV5b25kIGl0cyBzdWJ0cmVlLlxuICAvL1xuICAvLyBUaGlzIGlzIG5vdCBhIERPTSBtZXRob2QsIGJ1dCBpcyBjb252ZW5pZW50IGZvclxuICAvLyBsYXp5IHRyYXZlcnNhbHMgb2YgdGhlIHRyZWUuXG4gIG5leHRFbGVtZW50OiB7IHZhbHVlOiBmdW5jdGlvbihyb290KSB7XG4gICAgaWYgKCFyb290KSByb290ID0gdGhpcy5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgbmV4dCA9IHRoaXMuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgaWYgKCFuZXh0KSB7XG4gICAgICAvLyBkb24ndCB1c2Ugc2libGluZyBpZiB3ZSdyZSBhdCByb290XG4gICAgICBpZiAodGhpcz09PXJvb3QpIHJldHVybiBudWxsO1xuICAgICAgbmV4dCA9IHRoaXMubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICBpZiAobmV4dCkgcmV0dXJuIG5leHQ7XG5cbiAgICAvLyBJZiB3ZSBjYW4ndCBnbyBkb3duIG9yIGFjcm9zcywgdGhlbiB3ZSBoYXZlIHRvIGdvIHVwXG4gICAgLy8gYW5kIGFjcm9zcyB0byB0aGUgcGFyZW50IHNpYmxpbmcgb3IgYW5vdGhlciBhbmNlc3RvcidzXG4gICAgLy8gc2libGluZy4gIEJlIGNhcmVmdWwsIHRob3VnaDogaWYgd2UgcmVhY2ggdGhlIHJvb3RcbiAgICAvLyBlbGVtZW50LCBvciBpZiB3ZSByZWFjaCB0aGUgZG9jdW1lbnRFbGVtZW50LCB0aGVuXG4gICAgLy8gdGhlIHRyYXZlcnNhbCBlbmRzLlxuICAgIGZvcih2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnRFbGVtZW50O1xuICAgICAgcGFyZW50ICYmIHBhcmVudCAhPT0gcm9vdDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50KSB7XG5cbiAgICAgIG5leHQgPSBwYXJlbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgaWYgKG5leHQpIHJldHVybiBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9fSxcblxuICAvLyBYWFg6XG4gIC8vIFRlc3RzIGFyZSBjdXJyZW50bHkgZmFpbGluZyBmb3IgdGhpcyBmdW5jdGlvbi5cbiAgLy8gQXdhaXRpbmcgcmVzb2x1dGlvbiBvZjpcbiAgLy8gaHR0cDovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvd3d3LWRvbS8yMDExSnVsU2VwLzAwMTYuaHRtbFxuICBnZXRFbGVtZW50c0J5VGFnTmFtZTogeyB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVRhZ05hbWUobG5hbWUpIHtcbiAgICB2YXIgZmlsdGVyO1xuICAgIGlmICghbG5hbWUpIHJldHVybiBuZXcgTm9kZUxpc3QoKTtcbiAgICBpZiAobG5hbWUgPT09ICcqJylcbiAgICAgIGZpbHRlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICBlbHNlIGlmICh0aGlzLmlzSFRNTClcbiAgICAgIGZpbHRlciA9IGh0bWxMb2NhbE5hbWVFbGVtZW50RmlsdGVyKGxuYW1lKTtcbiAgICBlbHNlXG4gICAgICBmaWx0ZXIgPSBsb2NhbE5hbWVFbGVtZW50RmlsdGVyKGxuYW1lKTtcblxuICAgIHJldHVybiBuZXcgRmlsdGVyZWRFbGVtZW50TGlzdCh0aGlzLCBmaWx0ZXIpO1xuICB9fSxcblxuICBnZXRFbGVtZW50c0J5VGFnTmFtZU5TOiB7IHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50c0J5VGFnTmFtZU5TKG5zLCBsbmFtZSl7XG4gICAgdmFyIGZpbHRlcjtcbiAgICBpZiAobnMgPT09ICcqJyAmJiBsbmFtZSA9PT0gJyonKVxuICAgICAgZmlsdGVyID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIGVsc2UgaWYgKG5zID09PSAnKicpXG4gICAgICBmaWx0ZXIgPSBsb2NhbE5hbWVFbGVtZW50RmlsdGVyKGxuYW1lKTtcbiAgICBlbHNlIGlmIChsbmFtZSA9PT0gJyonKVxuICAgICAgZmlsdGVyID0gbmFtZXNwYWNlRWxlbWVudEZpbHRlcihucyk7XG4gICAgZWxzZVxuICAgICAgZmlsdGVyID0gbmFtZXNwYWNlTG9jYWxOYW1lRWxlbWVudEZpbHRlcihucywgbG5hbWUpO1xuXG4gICAgcmV0dXJuIG5ldyBGaWx0ZXJlZEVsZW1lbnRMaXN0KHRoaXMsIGZpbHRlcik7XG4gIH19LFxuXG4gIGdldEVsZW1lbnRzQnlDbGFzc05hbWU6IHsgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlDbGFzc05hbWUobmFtZXMpe1xuICAgIG5hbWVzID0gU3RyaW5nKG5hbWVzKS50cmltKCk7XG4gICAgaWYgKG5hbWVzID09PSAnJykge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBOb2RlTGlzdCgpOyAvLyBFbXB0eSBub2RlIGxpc3RcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIG5hbWVzID0gbmFtZXMuc3BsaXQoL1xccysvKTsgIC8vIFNwbGl0IG9uIHNwYWNlc1xuICAgIHJldHVybiBuZXcgRmlsdGVyZWRFbGVtZW50TGlzdCh0aGlzLCBjbGFzc05hbWVzRWxlbWVudEZpbHRlcihuYW1lcykpO1xuICB9fSxcblxuICBnZXRFbGVtZW50c0J5TmFtZTogeyB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHNCeU5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyZWRFbGVtZW50TGlzdCh0aGlzLCBlbGVtZW50TmFtZUZpbHRlcihTdHJpbmcobmFtZSkpKTtcbiAgfX0sXG5cbiAgLy8gT3ZlcndyaXR0ZW4gaW4gdGhlIGNvbnN0cnVjdG9yIGlmIG5vdCBpbiB0aGUgSFRNTCBuYW1lc3BhY2VcbiAgaXNIVE1MOiB7IHZhbHVlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyB1c2VkIGJ5IHRoZSBwdWJsaWMgQVBJIG1ldGhvZHMgYWJvdmVcbiAgY2xvbmU6IHsgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHZhciBlO1xuXG4gICAgLy8gWFhYOlxuICAgIC8vIE1vZGlmeSB0aGlzIHRvIHVzZSB0aGUgY29uc3RydWN0b3IgZGlyZWN0bHkgb3JcbiAgICAvLyBhdm9pZCBlcnJvciBjaGVja2luZyBpbiBzb21lIG90aGVyIHdheS4gSW4gY2FzZSB3ZSB0cnlcbiAgICAvLyB0byBjbG9uZSBhbiBpbnZhbGlkIG5vZGUgdGhhdCB0aGUgcGFyc2VyIGluc2VydGVkLlxuICAgIC8vXG4gICAgaWYgKHRoaXMubmFtZXNwYWNlVVJJICE9PSBOQU1FU1BBQ0UuSFRNTCB8fCB0aGlzLnByZWZpeClcbiAgICAgIGUgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMubmFtZXNwYWNlVVJJLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdOYW1lKTtcbiAgICBlbHNlXG4gICAgICBlID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5sb2NhbE5hbWUpO1xuXG4gICAgZm9yKHZhciBpID0gMCwgbiA9IHRoaXMuX2F0dHJLZXlzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgdmFyIGxuYW1lID0gdGhpcy5fYXR0cktleXNbaV07XG4gICAgICB2YXIgYSA9IHRoaXMuX2F0dHJzQnlMTmFtZVtsbmFtZV07XG4gICAgICB2YXIgYiA9IG5ldyBBdHRyKGUsIGEubG9jYWxOYW1lLCBhLnByZWZpeCwgYS5uYW1lc3BhY2VVUkkpO1xuICAgICAgYi5kYXRhID0gYS5kYXRhO1xuICAgICAgZS5fYXR0cnNCeUxOYW1lW2xuYW1lXSA9IGI7XG4gICAgICBlLl9hZGRRTmFtZShiKTtcbiAgICB9XG4gICAgZS5fYXR0cktleXMgPSB0aGlzLl9hdHRyS2V5cy5jb25jYXQoKTtcblxuICAgIHJldHVybiBlO1xuICB9fSxcblxuICBpc0VxdWFsOiB7IHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsKHRoYXQpIHtcbiAgICBpZiAodGhpcy5sb2NhbE5hbWUgIT09IHRoYXQubG9jYWxOYW1lIHx8XG4gICAgICB0aGlzLm5hbWVzcGFjZVVSSSAhPT0gdGhhdC5uYW1lc3BhY2VVUkkgfHxcbiAgICAgIHRoaXMucHJlZml4ICE9PSB0aGF0LnByZWZpeCB8fFxuICAgICAgdGhpcy5fbnVtYXR0cnMgIT09IHRoYXQuX251bWF0dHJzKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ29tcGFyZSB0aGUgc2V0cyBvZiBhdHRyaWJ1dGVzLCBpZ25vcmluZyBvcmRlclxuICAgIC8vIGFuZCBpZ25vcmluZyBhdHRyaWJ1dGUgcHJlZml4ZXMuXG4gICAgZm9yKHZhciBpID0gMCwgbiA9IHRoaXMuX251bWF0dHJzOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIgYSA9IHRoaXMuX2F0dHIoaSk7XG4gICAgICBpZiAoIXRoYXQuaGFzQXR0cmlidXRlTlMoYS5uYW1lc3BhY2VVUkksIGEubG9jYWxOYW1lKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRoYXQuZ2V0QXR0cmlidXRlTlMoYS5uYW1lc3BhY2VVUkksYS5sb2NhbE5hbWUpICE9PSBhLnZhbHVlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH19LFxuXG4gIC8vIFRoaXMgaXMgdGhlICdsb2NhdGUgYSBuYW1lc3BhY2UgcHJlZml4JyBhbGdvcml0aG0gZnJvbSB0aGVcbiAgLy8gRE9NQ29yZSBzcGVjaWZpY2F0aW9uLiAgSXQgaXMgdXNlZCBieSBOb2RlLmxvb2t1cFByZWZpeCgpXG4gIGxvY2F0ZU5hbWVzcGFjZVByZWZpeDogeyB2YWx1ZTogZnVuY3Rpb24gbG9jYXRlTmFtZXNwYWNlUHJlZml4KG5zKSB7XG4gICAgaWYgKHRoaXMubmFtZXNwYWNlVVJJID09PSBucyAmJiB0aGlzLnByZWZpeCAhPT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLnByZWZpeDtcblxuICAgIGZvcih2YXIgaSA9IDAsIG4gPSB0aGlzLl9udW1hdHRyczsgaSA8IG47IGkrKykge1xuICAgICAgdmFyIGEgPSB0aGlzLl9hdHRyKGkpO1xuICAgICAgaWYgKGEucHJlZml4ID09PSAneG1sbnMnICYmIGEudmFsdWUgPT09IG5zKVxuICAgICAgICByZXR1cm4gYS5sb2NhbE5hbWU7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICByZXR1cm4gcGFyZW50ID8gcGFyZW50LmxvY2F0ZU5hbWVzcGFjZVByZWZpeChucykgOiBudWxsO1xuICB9fSxcblxuICAvLyBUaGlzIGlzIHRoZSAnbG9jYXRlIGEgbmFtZXNwYWNlJyBhbGdvcml0aG0gZm9yIEVsZW1lbnQgbm9kZXNcbiAgLy8gZnJvbSB0aGUgRE9NIENvcmUgc3BlYy4gIEl0IGlzIHVzZWQgYnkgTm9kZS5sb29rdXBOYW1lc3BhY2VVUklcbiAgbG9jYXRlTmFtZXNwYWNlOiB7IHZhbHVlOiBmdW5jdGlvbiBsb2NhdGVOYW1lc3BhY2UocHJlZml4KSB7XG4gICAgaWYgKHRoaXMucHJlZml4ID09PSBwcmVmaXggJiYgdGhpcy5uYW1lc3BhY2VVUkkgIT09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VVUkk7XG5cbiAgICBmb3IodmFyIGkgPSAwLCBuID0gdGhpcy5fbnVtYXR0cnM7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBhID0gdGhpcy5fYXR0cihpKTtcbiAgICAgIGlmICgoYS5wcmVmaXggPT09ICd4bWxucycgJiYgYS5sb2NhbE5hbWUgPT09IHByZWZpeCkgfHxcbiAgICAgICAgKGEucHJlZml4ID09PSBudWxsICYmIGEubG9jYWxOYW1lID09PSAneG1sbnMnKSkge1xuICAgICAgICByZXR1cm4gYS52YWx1ZSB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5sb2NhdGVOYW1lc3BhY2UocHJlZml4KSA6IG51bGw7XG4gIH19LFxuXG4gIC8vXG4gIC8vIEF0dHJpYnV0ZSBoYW5kbGluZyBtZXRob2RzIGFuZCB1dGlsaXRpZXNcbiAgLy9cblxuICAvKlxuICAgKiBBdHRyaWJ1dGVzIGluIHRoZSBET00gYXJlIHRyaWNreTpcbiAgICpcbiAgICogLSB0aGVyZSBhcmUgdGhlIDggYmFzaWMgZ2V0L3NldC9oYXMvcmVtb3ZlQXR0cmlidXRle05TfSBtZXRob2RzXG4gICAqXG4gICAqIC0gYnV0IG1hbnkgSFRNTCBhdHRyaWJ1dGVzIGFyZSBhbHNvICdyZWZsZWN0ZWQnIHRocm91Z2ggSURMXG4gICAqICAgYXR0cmlidXRlcyB3aGljaCBtZWFucyB0aGF0IHRoZXkgY2FuIGJlIHF1ZXJpZWQgYW5kIHNldCB0aHJvdWdoXG4gICAqICAgcmVndWxhciBwcm9wZXJ0aWVzIG9mIHRoZSBlbGVtZW50LiAgVGhlcmUgaXMganVzdCBvbmUgYXR0cmlidXRlXG4gICAqICAgdmFsdWUsIGJ1dCB0d28gd2F5cyB0byBnZXQgYW5kIHNldCBpdC5cbiAgICpcbiAgICogLSBEaWZmZXJlbnQgSFRNTCBlbGVtZW50IHR5cGVzIGhhdmUgZGlmZmVyZW50IHNldHMgb2YgcmVmbGVjdGVkXG4gICAgIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIC0gYXR0cmlidXRlcyBjYW4gYWxzbyBiZSBxdWVyaWVkIGFuZCBzZXQgdGhyb3VnaCB0aGUgLmF0dHJpYnV0ZXNcbiAgICogICBwcm9wZXJ0eSBvZiBhbiBlbGVtZW50LiAgVGhpcyBwcm9wZXJ0eSBiZWhhdmVzIGxpa2UgYW4gYXJyYXkgb2ZcbiAgICogICBBdHRyIG9iamVjdHMuICBUaGUgdmFsdWUgcHJvcGVydHkgb2YgZWFjaCBBdHRyIGlzIHdyaXRlYWJsZSwgc29cbiAgICogICB0aGlzIGlzIGEgdGhpcmQgd2F5IHRvIHJlYWQgYW5kIHdyaXRlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIC0gZm9yIGVmZmljaWVuY3ksIHdlIHJlYWxseSB3YW50IHRvIHN0b3JlIGF0dHJpYnV0ZXMgaW4gc29tZSBraW5kXG4gICAqICAgb2YgbmFtZS0+YXR0ciBtYXAuICBCdXQgdGhlIGF0dHJpYnV0ZXNbXSBhcnJheSBpcyBhbiBhcnJheSwgbm90IGFcbiAgICogICBtYXAsIHdoaWNoIGlzIGtpbmQgb2YgdW5uYXR1cmFsLlxuICAgKlxuICAgKiAtIFdoZW4gdXNpbmcgbmFtZXNwYWNlcyBhbmQgcHJlZml4ZXMsIGFuZCBtaXhpbmcgdGhlIE5TIG1ldGhvZHNcbiAgICogICB3aXRoIHRoZSBub24tTlMgbWV0aG9kcywgaXQgaXMgYXBwYXJlbnRseSBhY3R1YWxseSBwb3NzaWJsZSBmb3JcbiAgICogICBhbiBhdHRyaWJ1dGVzW10gYXJyYXkgdG8gaGF2ZSBtb3JlIHRoYW4gb25lIGF0dHJpYnV0ZSB3aXRoIHRoZVxuICAgKiAgIHNhbWUgcXVhbGlmaWVkIG5hbWUuICBBbmQgY2VydGFpbiBtZXRob2RzIG11c3Qgb3BlcmF0ZSBvbiBvbmx5XG4gICAqICAgdGhlIGZpcnN0IGF0dHJpYnV0ZSB3aXRoIHN1Y2ggYSBuYW1lLiAgU28gZm9yIHRoZXNlIG1ldGhvZHMsIGFuXG4gICAqICAgaW5lZmZpY2llbnQgYXJyYXktbGlrZSBkYXRhIHN0cnVjdHVyZSB3b3VsZCBiZSBlYXNpZXIgdG9cbiAgICogICBpbXBsZW1lbnQuXG4gICAqXG4gICAqIC0gVGhlIGF0dHJpYnV0ZXNbXSBhcnJheSBpcyBsaXZlLCBub3QgYSBzbmFwc2hvdCwgc28gY2hhbmdlcyB0byB0aGVcbiAgICogICBhdHRyaWJ1dGVzIG11c3QgYmUgaW1tZWRpYXRlbHkgdmlzaWJsZSB0aHJvdWdoIGV4aXN0aW5nIGFycmF5cy5cbiAgICpcbiAgICogLSBXaGVuIGF0dHJpYnV0ZXMgYXJlIHF1ZXJpZWQgYW5kIHNldCB0aHJvdWdoIElETCBwcm9wZXJ0aWVzXG4gICAqICAgKGluc3RlYWQgb2YgdGhlIGdldC9zZXRBdHRyaWJ1dGVzKCkgbWV0aG9kIG9yIHRoZSBhdHRyaWJ1dGVzW11cbiAgICogICBhcnJheSkgdGhleSBtYXkgYmUgc3ViamVjdCB0byB0eXBlIGNvbnZlcnNpb25zLCBVUkxcbiAgICogICBub3JtYWxpemF0aW9uLCBldGMuLCBzbyBzb21lIGV4dHJhIHByb2Nlc3NpbmcgaXMgcmVxdWlyZWQgaW4gdGhhdFxuICAgKiAgIGNhc2UuXG4gICAqXG4gICAqIC0gQnV0IGFjY2VzcyB0aHJvdWdoIElETCBwcm9wZXJ0aWVzIGlzIHByb2JhYmx5IHRoZSBtb3N0IGNvbW1vblxuICAgKiAgIGNhc2UsIHNvIHdlJ2QgbGlrZSB0aGF0IHRvIGJlIGFzIGZhc3QgYXMgcG9zc2libGUuXG4gICAqXG4gICAqIC0gV2UgY2FuJ3QganVzdCBzdG9yZSBhdHRyaWJ1dGUgdmFsdWVzIGluIHRoZWlyIHBhcnNlZCBpZGwgZm9ybSxcbiAgICogICBiZWNhdXNlIHNldEF0dHJpYnV0ZSgpIGhhcyB0byByZXR1cm4gd2hhdGV2ZXIgc3RyaW5nIGlzIHBhc3NlZCB0b1xuICAgKiAgIGdldEF0dHJpYnV0ZSBldmVuIGlmIGl0IGlzIG5vdCBhIGxlZ2FsLCBwYXJzZWFibGUgdmFsdWUuIFNvXG4gICAqICAgYXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIHN0b3JlZCBpbiB1bnBhcnNlZCBzdHJpbmcgZm9ybS5cbiAgICpcbiAgICogLSBXZSBuZWVkIHRvIGJlIGFibGUgdG8gc2VuZCBjaGFuZ2Ugbm90aWZpY2F0aW9ucyBvciBtdXRhdGlvblxuICAgKiAgIGV2ZW50cyBvZiBzb21lIHNvcnQgdG8gdGhlIHJlbmRlcmVyIHdoZW5ldmVyIGFuIGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiAgIGNoYW5nZXMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHdheSBpbiB3aGljaCBpdCBjaGFuZ2VzLlxuICAgKlxuICAgKiAtIFNvbWUgYXR0cmlidXRlcywgc3VjaCBhcyBpZCBhbmQgY2xhc3MgYWZmZWN0IG90aGVyIHBhcnRzIG9mIHRoZVxuICAgKiAgIERPTSBBUEksIGxpa2UgZ2V0RWxlbWVudEJ5SWQgYW5kIGdldEVsZW1lbnRzQnlDbGFzc05hbWUgYW5kIHNvXG4gICAqICAgZm9yIGVmZmljaWVuY3ksIHdlIG5lZWQgdG8gc3BlY2lhbGx5IHRyYWNrIGNoYW5nZXMgdG8gdGhlc2VcbiAgICogICBzcGVjaWFsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIC0gU29tZSBhdHRyaWJ1dGVzIGxpa2UgY2xhc3MgaGF2ZSBkaWZmZXJlbnQgbmFtZXMgKGNsYXNzTmFtZSkgd2hlblxuICAgKiAgIHJlZmxlY3RlZC5cbiAgICpcbiAgICogLSBBdHRyaWJ1dGVzIHdob3NlIG5hbWVzIGJlZ2luIHdpdGggdGhlIHN0cmluZyAnZGF0YS0nIGFyZSB0cmVhdGVkXG4gICAgIHNwZWNpYWxseS5cbiAgICpcbiAgICogLSBSZWZsZWN0ZWQgYXR0cmlidXRlcyB0aGF0IGhhdmUgYSBib29sZWFuIHR5cGUgaW4gSURMIGhhdmUgc3BlY2lhbFxuICAgKiAgIGJlaGF2aW9yOiBzZXR0aW5nIHRoZW0gdG8gZmFsc2UgKGluIElETCkgaXMgdGhlIHNhbWUgYXMgcmVtb3ZpbmdcbiAgICogICB0aGVtIHdpdGggcmVtb3ZlQXR0cmlidXRlKClcbiAgICpcbiAgICogLSBudW1lcmljIGF0dHJpYnV0ZXMgKGxpa2UgSFRNTEVsZW1lbnQudGFiSW5kZXgpIGNhbiBoYXZlIGRlZmF1bHRcbiAgICogICB2YWx1ZXMgdGhhdCBtdXN0IGJlIHJldHVybmVkIGJ5IHRoZSBpZGwgZ2V0dGVyIGV2ZW4gaWYgdGhlXG4gICAqICAgY29udGVudCBhdHRyaWJ1dGUgZG9lcyBub3QgZXhpc3QuIChUaGUgZGVmYXVsdCB0YWJJbmRleCB2YWx1ZVxuICAgKiAgIGFjdHVhbGx5IHZhcmllcyBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudCwgc28gdGhhdCBpcyBhXG4gICAqICAgdHJpY2t5IG9uZSkuXG4gICAqXG4gICAqIFNlZVxuICAgKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS91cmxzLmh0bWwjcmVmbGVjdFxuICAgKiBmb3IgcnVsZXMgb24gaG93IGF0dHJpYnV0ZXMgYXJlIHJlZmxlY3RlZC5cbiAgICpcbiAgICovXG5cbiAgZ2V0QXR0cmlidXRlOiB7IHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUocW5hbWUpIHtcbiAgICBpZiAodGhpcy5pc0hUTUwpIHFuYW1lID0gdXRpbHMudG9BU0NJSUxvd2VyQ2FzZShxbmFtZSk7XG4gICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdO1xuICAgIGlmICghYXR0cikgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyKSkgIC8vIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmVcbiAgICAgIGF0dHIgPSBhdHRyWzBdOyAgICAgICAgIC8vIHVzZSB0aGUgZmlyc3RcblxuICAgIHJldHVybiBhdHRyLnZhbHVlO1xuICB9fSxcblxuICBnZXRBdHRyaWJ1dGVOUzogeyB2YWx1ZTogZnVuY3Rpb24gZ2V0QXR0cmlidXRlTlMobnMsIGxuYW1lKSB7XG4gICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyc0J5TE5hbWVbKG5zID09PSBudWxsID8gJycgOiBucykgKyAnfCcgKyBsbmFtZV07XG4gICAgcmV0dXJuIGF0dHIgPyBhdHRyLnZhbHVlIDogbnVsbDtcbiAgfX0sXG5cbiAgaGFzQXR0cmlidXRlOiB7IHZhbHVlOiBmdW5jdGlvbiBoYXNBdHRyaWJ1dGUocW5hbWUpIHtcbiAgICBpZiAodGhpcy5pc0hUTUwpIHFuYW1lID0gdXRpbHMudG9BU0NJSUxvd2VyQ2FzZShxbmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV0gIT09IHVuZGVmaW5lZDtcbiAgfX0sXG5cbiAgaGFzQXR0cmlidXRlTlM6IHsgdmFsdWU6IGZ1bmN0aW9uIGhhc0F0dHJpYnV0ZU5TKG5zLCBsbmFtZSkge1xuICAgIHZhciBrZXkgPSAobnMgPT09IG51bGwgPyAnJyA6IG5zKSArICd8JyArIGxuYW1lO1xuICAgIHJldHVybiB0aGlzLl9hdHRyc0J5TE5hbWVba2V5XSAhPT0gdW5kZWZpbmVkO1xuICB9fSxcblxuICAvLyBTZXQgdGhlIGF0dHJpYnV0ZSB3aXRob3V0IGVycm9yIGNoZWNraW5nLiBUaGUgcGFyc2VyIHVzZXMgdGhpcy5cbiAgX3NldEF0dHJpYnV0ZTogeyB2YWx1ZTogZnVuY3Rpb24gX3NldEF0dHJpYnV0ZShxbmFtZSwgdmFsdWUpIHtcbiAgICAvLyBYWFg6IHRoZSBzcGVjIHNheXMgdGhhdCB0aGlzIG5leHQgc2VhcmNoIHNob3VsZCBiZSBkb25lXG4gICAgLy8gb24gdGhlIGxvY2FsIG5hbWUsIGJ1dCBJIHRoaW5rIHRoYXQgaXMgYW4gZXJyb3IuXG4gICAgLy8gZW1haWwgcGVuZGluZyBvbiB3d3ctZG9tIGFib3V0IGl0LlxuICAgIHZhciBhdHRyID0gdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXTtcbiAgICB2YXIgaXNuZXc7XG4gICAgaWYgKCFhdHRyKSB7XG4gICAgICBhdHRyID0gdGhpcy5fbmV3YXR0cihxbmFtZSk7XG4gICAgICBpc25ldyA9IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cikpIGF0dHIgPSBhdHRyWzBdO1xuICAgIH1cblxuICAgIC8vIE5vdyBzZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBvbiB0aGUgbmV3IG9yIGV4aXN0aW5nIEF0dHIgb2JqZWN0LlxuICAgIC8vIFRoZSBBdHRyLnZhbHVlIHNldHRlciBtZXRob2QgaGFuZGxlcyBtdXRhdGlvbiBldmVudHMsIGV0Yy5cbiAgICBhdHRyLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXMpIHRoaXMuX2F0dHJpYnV0ZXNbcW5hbWVdID0gYXR0cjtcbiAgICBpZiAoaXNuZXcgJiYgdGhpcy5fbmV3YXR0cmhvb2spIHRoaXMuX25ld2F0dHJob29rKHFuYW1lLCB2YWx1ZSk7XG4gIH19LFxuXG4gIC8vIENoZWNrIGZvciBlcnJvcnMsIGFuZCB0aGVuIHNldCB0aGUgYXR0cmlidXRlXG4gIHNldEF0dHJpYnV0ZTogeyB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlKHFuYW1lLCB2YWx1ZSkge1xuICAgIGlmICgheG1sLmlzVmFsaWROYW1lKHFuYW1lKSkgdXRpbHMuSW52YWxpZENoYXJhY3RlckVycm9yKCk7XG4gICAgaWYgKHRoaXMuaXNIVE1MKSBxbmFtZSA9IHV0aWxzLnRvQVNDSUlMb3dlckNhc2UocW5hbWUpO1xuICAgIGlmIChxbmFtZS5zdWJzdHJpbmcoMCwgNSkgPT09ICd4bWxucycpIHV0aWxzLk5hbWVzcGFjZUVycm9yKCk7XG4gICAgdGhpcy5fc2V0QXR0cmlidXRlKHFuYW1lLCBTdHJpbmcodmFsdWUpKTtcbiAgfX0sXG5cblxuICAvLyBUaGUgdmVyc2lvbiB3aXRoIG5vIGVycm9yIGNoZWNraW5nIHVzZWQgYnkgdGhlIHBhcnNlclxuICBfc2V0QXR0cmlidXRlTlM6IHsgdmFsdWU6IGZ1bmN0aW9uIF9zZXRBdHRyaWJ1dGVOUyhucywgcW5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHBvcyA9IHFuYW1lLmluZGV4T2YoJzonKSwgcHJlZml4LCBsbmFtZTtcbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgcHJlZml4ID0gbnVsbDtcbiAgICAgIGxuYW1lID0gcW5hbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcHJlZml4ID0gcW5hbWUuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgICBsbmFtZSA9IHFuYW1lLnN1YnN0cmluZyhwb3MrMSk7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IChucyA9PT0gbnVsbCA/ICcnIDogbnMpICsgJ3wnICsgbG5hbWU7XG4gICAgaWYgKG5zID09PSAnJykgbnMgPSBudWxsO1xuXG4gICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyc0J5TE5hbWVba2V5XTtcbiAgICB2YXIgaXNuZXc7XG4gICAgaWYgKCFhdHRyKSB7XG4gICAgICBhdHRyID0gbmV3IEF0dHIodGhpcywgbG5hbWUsIHByZWZpeCwgbnMpO1xuICAgICAgaXNuZXcgPSB0cnVlO1xuICAgICAgdGhpcy5fYXR0cnNCeUxOYW1lW2tleV0gPSBhdHRyO1xuICAgICAgdGhpcy5fYXR0cktleXMucHVzaChrZXkpO1xuXG4gICAgICAvLyBXZSBhbHNvIGhhdmUgdG8gbWFrZSB0aGUgYXR0ciBzZWFyY2hhYmxlIGJ5IHFuYW1lLlxuICAgICAgLy8gQnV0IHdlIGhhdmUgdG8gYmUgY2FyZWZ1bCBiZWNhdXNlIHRoZXJlIG1heSBhbHJlYWR5XG4gICAgICAvLyBiZSBhbiBhdHRyIHdpdGggdGhpcyBxbmFtZS5cbiAgICAgIHRoaXMuX2FkZFFOYW1lKGF0dHIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIENhbGxpbmcgc2V0QXR0cmlidXRlTlMoKSBjYW4gY2hhbmdlIHRoZSBwcmVmaXggb2YgYW5cbiAgICAgIC8vIGV4aXN0aW5nIGF0dHJpYnV0ZSFcbiAgICAgIGlmIChhdHRyLnByZWZpeCAhPT0gcHJlZml4KSB7XG4gICAgICAgIC8vIFVuYmluZCB0aGUgb2xkIHFuYW1lXG4gICAgICAgIHRoaXMuX3JlbW92ZVFOYW1lKGF0dHIpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHByZWZpeFxuICAgICAgICBhdHRyLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgLy8gQmluZCB0aGUgbmV3IHFuYW1lXG4gICAgICAgIHRoaXMuX2FkZFFOYW1lKGF0dHIpO1xuXG4gICAgICB9XG5cbiAgICB9XG4gICAgYXR0ci52YWx1ZSA9IHZhbHVlOyAvLyBBdXRvbWF0aWNhbGx5IHNlbmRzIG11dGF0aW9uIGV2ZW50XG4gICAgaWYgKGlzbmV3ICYmIHRoaXMuX25ld2F0dHJob29rKSB0aGlzLl9uZXdhdHRyaG9vayhxbmFtZSwgdmFsdWUpO1xuICB9fSxcblxuICAvLyBEbyBlcnJvciBjaGVja2luZyB0aGVuIGNhbGwgX3NldEF0dHJpYnV0ZU5TXG4gIHNldEF0dHJpYnV0ZU5TOiB7IHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVOUyhucywgcW5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCF4bWwuaXNWYWxpZE5hbWUocW5hbWUpKSB1dGlscy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IoKTtcbiAgICBpZiAoIXhtbC5pc1ZhbGlkUU5hbWUocW5hbWUpKSB1dGlscy5OYW1lc3BhY2VFcnJvcigpO1xuXG4gICAgdmFyIHBvcyA9IHFuYW1lLmluZGV4T2YoJzonKTtcbiAgICB2YXIgcHJlZml4ID0gKHBvcyA9PT0gLTEpID8gbnVsbCA6IHFuYW1lLnN1YnN0cmluZygwLCBwb3MpO1xuICAgIGlmIChucyA9PT0gJycpIG5zID0gbnVsbDtcblxuICAgIGlmICgocHJlZml4ICE9PSBudWxsICYmIG5zID09PSBudWxsKSB8fFxuICAgICAgKHByZWZpeCA9PT0gJ3htbCcgJiYgbnMgIT09IE5BTUVTUEFDRS5YTUwpIHx8XG4gICAgICAoKHFuYW1lID09PSAneG1sbnMnIHx8IHByZWZpeCA9PT0gJ3htbG5zJykgJiZcbiAgICAgICAobnMgIT09IE5BTUVTUEFDRS5YTUxOUykpIHx8XG4gICAgICAobnMgPT09IE5BTUVTUEFDRS5YTUxOUyAmJlxuICAgICAgICEocW5hbWUgPT09ICd4bWxucycgfHwgcHJlZml4ID09PSAneG1sbnMnKSkpXG4gICAgICB1dGlscy5OYW1lc3BhY2VFcnJvcigpO1xuXG4gICAgdGhpcy5fc2V0QXR0cmlidXRlTlMobnMsIHFuYW1lLCBTdHJpbmcodmFsdWUpKTtcbiAgfX0sXG5cbiAgcmVtb3ZlQXR0cmlidXRlOiB7IHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUocW5hbWUpIHtcbiAgICBpZiAodGhpcy5pc0hUTUwpIHFuYW1lID0gdXRpbHMudG9BU0NJSUxvd2VyQ2FzZShxbmFtZSk7XG5cbiAgICB2YXIgYXR0ciA9IHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV07XG4gICAgaWYgKCFhdHRyKSByZXR1cm47XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIG1hdGNoIGZvciB0aGlzIHFuYW1lXG4gICAgLy8gc28gZG9uJ3QgZGVsZXRlIHRoZSBxbmFtZSBtYXBwaW5nLCBqdXN0IHJlbW92ZSB0aGUgZmlyc3RcbiAgICAvLyBlbGVtZW50IGZyb20gaXQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cikpIHtcbiAgICAgIGlmIChhdHRyLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgYXR0ciA9IGF0dHIuc2hpZnQoKTsgIC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBhcnJheVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV0gPSBhdHRyWzFdO1xuICAgICAgICBhdHRyID0gYXR0clswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBvbmx5IGEgc2luZ2xlIG1hdGNoLCBzbyByZW1vdmUgdGhlIHFuYW1lIG1hcHBpbmdcbiAgICAgIHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIG5zID0gYXR0ci5uYW1lc3BhY2VVUkk7XG4gICAgLy8gTm93IGF0dHIgaXMgdGhlIHJlbW92ZWQgYXR0cmlidXRlLiAgRmlndXJlIG91dCBpdHNcbiAgICAvLyBucytsbmFtZSBrZXkgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBvdGhlciBtYXBwaW5nIGFzIHdlbGwuXG4gICAgdmFyIGtleSA9IChucyA9PT0gbnVsbCA/ICcnIDogbnMpICsgJ3wnICsgYXR0ci5sb2NhbE5hbWU7XG4gICAgdGhpcy5fYXR0cnNCeUxOYW1lW2tleV0gPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgaSA9IHRoaXMuX2F0dHJLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICB0aGlzLl9hdHRyS2V5cy5zcGxpY2UoaSwgMSk7XG5cbiAgICBpZiAodGhpcy5fYXR0cmlidXRlcylcbiAgICAgIHRoaXMuX2F0dHJpYnV0ZXNbcW5hbWVdID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25jaGFuZ2UgaGFuZGxlciBmb3IgdGhlIGF0dHJpYnV0ZVxuICAgIGlmIChhdHRyLm9uY2hhbmdlKVxuICAgICAgYXR0ci5vbmNoYW5nZSh0aGlzLCBhdHRyLmxvY2FsTmFtZSwgYXR0ci52YWx1ZSwgbnVsbCk7XG5cbiAgICAvLyBNdXRhdGlvbiBldmVudFxuICAgIGlmICh0aGlzLnJvb3RlZCkgdGhpcy5vd25lckRvY3VtZW50Lm11dGF0ZVJlbW92ZUF0dHIoYXR0cik7XG4gIH19LFxuXG4gIHJlbW92ZUF0dHJpYnV0ZU5TOiB7IHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGVOUyhucywgbG5hbWUpIHtcbiAgICB2YXIga2V5ID0gKG5zID09PSBudWxsID8gJycgOiBucykgKyAnfCcgKyBsbmFtZTtcbiAgICB2YXIgYXR0ciA9IHRoaXMuX2F0dHJzQnlMTmFtZVtrZXldO1xuICAgIGlmICghYXR0cikgcmV0dXJuO1xuXG4gICAgdGhpcy5fYXR0cnNCeUxOYW1lW2tleV0gPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgaSA9IHRoaXMuX2F0dHJLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICB0aGlzLl9hdHRyS2V5cy5zcGxpY2UoaSwgMSk7XG5cbiAgICAvLyBOb3cgZmluZCB0aGUgc2FtZSBBdHRyIG9iamVjdCBpbiB0aGUgcW5hbWUgbWFwcGluZyBhbmQgcmVtb3ZlIGl0XG4gICAgLy8gQnV0IGJlIGNhcmVmdWwgYmVjYXVzZSB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBtYXRjaC5cbiAgICB0aGlzLl9yZW1vdmVRTmFtZShhdHRyKTtcblxuICAgIC8vIE9uY2hhbmdlIGhhbmRsZXIgZm9yIHRoZSBhdHRyaWJ1dGVcbiAgICBpZiAoYXR0ci5vbmNoYW5nZSlcbiAgICAgIGF0dHIub25jaGFuZ2UodGhpcywgYXR0ci5sb2NhbE5hbWUsIGF0dHIudmFsdWUsIG51bGwpO1xuICAgIC8vIE11dGF0aW9uIGV2ZW50XG4gICAgaWYgKHRoaXMucm9vdGVkKSB0aGlzLm93bmVyRG9jdW1lbnQubXV0YXRlUmVtb3ZlQXR0cihhdHRyKTtcbiAgfX0sXG5cbiAgLy8gVGhpcyAncmF3JyB2ZXJzaW9uIG9mIGdldEF0dHJpYnV0ZSBpcyB1c2VkIGJ5IHRoZSBnZXR0ZXIgZnVuY3Rpb25zXG4gIC8vIG9mIHJlZmxlY3RlZCBhdHRyaWJ1dGVzLiBJdCBza2lwcyBzb21lIGVycm9yIGNoZWNraW5nIGFuZFxuICAvLyBuYW1lc3BhY2Ugc3RlcHNcbiAgX2dldGF0dHI6IHsgdmFsdWU6IGZ1bmN0aW9uIF9nZXRhdHRyKHFuYW1lKSB7XG4gICAgLy8gQXNzdW1lIHRoYXQgcW5hbWUgaXMgYWxyZWFkeSBsb3dlcmNhc2VkLCBzbyBkb24ndCBkbyBpdCBoZXJlLlxuICAgIC8vIEFsc28gZG9uJ3QgY2hlY2sgd2hldGhlciBhdHRyIGlzIGFuIGFycmF5OiBhIHFuYW1lIHdpdGggbm9cbiAgICAvLyBwcmVmaXggd2lsbCBuZXZlciBoYXZlIHR3byBtYXRjaGluZyBBdHRyIG9iamVjdHMgKGJlY2F1c2VcbiAgICAvLyBzZXRBdHRyaWJ1dGVOUyBkb2Vzbid0IGFsbG93IGEgbm9uLW51bGwgbmFtZXNwYWNlIHdpdGggYVxuICAgIC8vIG51bGwgcHJlZml4LlxuICAgIHZhciBhdHRyID0gdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXTtcbiAgICByZXR1cm4gYXR0ciA/IGF0dHIudmFsdWUgOiBudWxsO1xuICB9fSxcblxuICAvLyBUaGUgcmF3IHZlcnNpb24gb2Ygc2V0QXR0cmlidXRlIGZvciByZWZsZWN0ZWQgaWRsIGF0dHJpYnV0ZXMuXG4gIF9zZXRhdHRyOiB7IHZhbHVlOiBmdW5jdGlvbiBfc2V0YXR0cihxbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYXR0ciA9IHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV07XG4gICAgdmFyIGlzbmV3O1xuICAgIGlmICghYXR0cikge1xuICAgICAgYXR0ciA9IHRoaXMuX25ld2F0dHIocW5hbWUpO1xuICAgICAgaXNuZXcgPSB0cnVlO1xuICAgIH1cbiAgICBhdHRyLnZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAodGhpcy5fYXR0cmlidXRlcykgdGhpcy5fYXR0cmlidXRlc1txbmFtZV0gPSBhdHRyO1xuICAgIGlmIChpc25ldyAmJiB0aGlzLl9uZXdhdHRyaG9vaykgdGhpcy5fbmV3YXR0cmhvb2socW5hbWUsIHZhbHVlKTtcbiAgfX0sXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IEF0dHIgb2JqZWN0LCBpbnNlcnQgaXQsIGFuZCByZXR1cm4gaXQuXG4gIC8vIFVzZWQgYnkgc2V0QXR0cmlidXRlKCkgYW5kIGJ5IHNldCgpXG4gIF9uZXdhdHRyOiB7IHZhbHVlOiBmdW5jdGlvbiBfbmV3YXR0cihxbmFtZSkge1xuICAgIHZhciBhdHRyID0gbmV3IEF0dHIodGhpcywgcW5hbWUsIG51bGwsIG51bGwpO1xuICAgIHZhciBrZXkgPSAnfCcgKyBxbmFtZTtcbiAgICB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdID0gYXR0cjtcbiAgICB0aGlzLl9hdHRyc0J5TE5hbWVba2V5XSA9IGF0dHI7XG4gICAgdGhpcy5fYXR0cktleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBhdHRyO1xuICB9fSxcblxuICAvLyBBZGQgYSBxbmFtZS0+QXR0ciBtYXBwaW5nIHRvIHRoZSBfYXR0cnNCeVFOYW1lIG9iamVjdCwgdGFraW5nIGludG9cbiAgLy8gYWNjb3VudCB0aGF0IHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIGF0dHIgb2JqZWN0IHdpdGggdGhlXG4gIC8vIHNhbWUgcW5hbWVcbiAgX2FkZFFOYW1lOiB7IHZhbHVlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgdmFyIHFuYW1lID0gYXR0ci5uYW1lO1xuICAgIHZhciBleGlzdGluZyA9IHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV07XG4gICAgaWYgKCFleGlzdGluZykge1xuICAgICAgdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXSA9IGF0dHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICBleGlzdGluZy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX2F0dHJzQnlRTmFtZVtxbmFtZV0gPSBbZXhpc3RpbmcsIGF0dHJdO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYXR0cmlidXRlcykgdGhpcy5fYXR0cmlidXRlc1txbmFtZV0gPSBhdHRyO1xuICB9fSxcblxuICAvLyBSZW1vdmUgYSBxbmFtZS0+QXR0ciBtYXBwaW5nIHRvIHRoZSBfYXR0cnNCeVFOYW1lIG9iamVjdCwgdGFraW5nIGludG9cbiAgLy8gYWNjb3VudCB0aGF0IHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIGF0dHIgb2JqZWN0IHdpdGggdGhlXG4gIC8vIHNhbWUgcW5hbWVcbiAgX3JlbW92ZVFOYW1lOiB7IHZhbHVlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgdmFyIHFuYW1lID0gYXR0ci5uYW1lO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgdmFyIGlkeCA9IHRhcmdldC5pbmRleE9mKGF0dHIpO1xuICAgICAgdXRpbHMuYXNzZXJ0KGlkeCAhPT0gLTEpOyAvLyBJdCBtdXN0IGJlIGhlcmUgc29tZXdoZXJlXG4gICAgICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9hdHRyc0J5UU5hbWVbcW5hbWVdID0gdGFyZ2V0WzEtaWR4XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdXRpbHMuYXNzZXJ0KHRhcmdldCA9PT0gYXR0cik7ICAvLyBJZiBvbmx5IG9uZSwgaXQgbXVzdCBtYXRjaFxuICAgICAgdGhpcy5fYXR0cnNCeVFOYW1lW3FuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH19LFxuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGF0dHJpYnV0ZXNcbiAgX251bWF0dHJzOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9hdHRyS2V5cy5sZW5ndGg7IH19LFxuICAvLyBSZXR1cm4gdGhlIG50aCBBdHRyIG9iamVjdFxuICBfYXR0cjogeyB2YWx1ZTogZnVuY3Rpb24obikge1xuICAgIHJldHVybiB0aGlzLl9hdHRyc0J5TE5hbWVbdGhpcy5fYXR0cktleXNbbl1dO1xuICB9fSxcblxuICAvLyBEZWZpbmUgZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgYW4gJ2lkJyBwcm9wZXJ0eSB0aGF0IHJlZmxlY3RzXG4gIC8vIHRoZSBjb250ZW50IGF0dHJpYnV0ZSAnaWQnLlxuICBpZDogYXR0cmlidXRlcy5wcm9wZXJ0eSh7bmFtZTogJ2lkJ30pLFxuXG4gIC8vIERlZmluZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciBhICdjbGFzc05hbWUnIHByb3BlcnR5IHRoYXQgcmVmbGVjdHNcbiAgLy8gdGhlIGNvbnRlbnQgYXR0cmlidXRlICdjbGFzcycuXG4gIGNsYXNzTmFtZTogYXR0cmlidXRlcy5wcm9wZXJ0eSh7bmFtZTogJ2NsYXNzJ30pLFxuXG4gIGNsYXNzTGlzdDogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5fY2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xhc3NMaXN0O1xuICAgIH1cbiAgICB2YXIgZHRsaXN0ID0gbmV3IERPTVRva2VuTGlzdChcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5jbGFzc05hbWUgfHwgXCJcIjtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbih2KSB7XG4gICAgICAgIHNlbGYuY2xhc3NOYW1lID0gdjtcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuX2NsYXNzTGlzdCA9IGR0bGlzdDtcbiAgICByZXR1cm4gZHRsaXN0O1xuICB9fSxcblxuICBtYXRjaGVzOiB7IHZhbHVlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3QubWF0Y2hlcyh0aGlzLCBzZWxlY3Rvcik7XG4gIH19LFxuXG4gIGNsb3Nlc3Q6IHsgdmFsdWU6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsID0gdGhpcztcbiAgICB3aGlsZSAoZWwubWF0Y2hlcyAmJiAhZWwubWF0Y2hlcyhzZWxlY3RvcikpIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gZWwubWF0Y2hlcyA/IGVsIDogbnVsbDtcbiAgfX0sXG5cbiAgcXVlcnlTZWxlY3RvcjogeyB2YWx1ZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0KHNlbGVjdG9yLCB0aGlzKVswXTtcbiAgfX0sXG5cbiAgcXVlcnlTZWxlY3RvckFsbDogeyB2YWx1ZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgbm9kZXMgPSBzZWxlY3Qoc2VsZWN0b3IsIHRoaXMpO1xuICAgIHJldHVybiBub2Rlcy5pdGVtID8gbm9kZXMgOiBuZXcgTm9kZUxpc3Qobm9kZXMpO1xuICB9fVxuXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRWxlbWVudC5wcm90b3R5cGUsIENoaWxkTm9kZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFbGVtZW50LnByb3RvdHlwZSwgTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlKTtcblxuLy8gUmVnaXN0ZXIgc3BlY2lhbCBoYW5kbGluZyBmb3IgdGhlIGlkIGF0dHJpYnV0ZVxuYXR0cmlidXRlcy5yZWdpc3RlckNoYW5nZUhhbmRsZXIoRWxlbWVudCwgJ2lkJyxcbiBmdW5jdGlvbihlbGVtZW50LCBsbmFtZSwgb2xkdmFsLCBuZXd2YWwpIHtcbiAgIGlmIChlbGVtZW50LnJvb3RlZCkge1xuICAgICBpZiAob2xkdmFsKSB7XG4gICAgICAgZWxlbWVudC5vd25lckRvY3VtZW50LmRlbElkKG9sZHZhbCwgZWxlbWVudCk7XG4gICAgIH1cbiAgICAgaWYgKG5ld3ZhbCkge1xuICAgICAgIGVsZW1lbnQub3duZXJEb2N1bWVudC5hZGRJZChuZXd2YWwsIGVsZW1lbnQpO1xuICAgICB9XG4gICB9XG4gfVxuKTtcblxuXG4vLyBUaGUgQXR0ciBjbGFzcyByZXByZXNlbnRzIGEgc2luZ2xlIGF0dHJpYnV0ZS4gIFRoZSB2YWx1ZXMgaW5cbi8vIF9hdHRyc0J5UU5hbWUgYW5kIF9hdHRyc0J5TE5hbWUgYXJlIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLlxuZnVuY3Rpb24gQXR0cihlbHQsIGxuYW1lLCBwcmVmaXgsIG5hbWVzcGFjZSkge1xuICAvLyBBbHdheXMgcmVtZW1iZXIgd2hhdCBlbGVtZW50IHdlJ3JlIGFzc29jaWF0ZWQgd2l0aC5cbiAgLy8gV2UgbmVlZCB0aGlzIHRvIHByb3BlcnR5IGhhbmRsZSBtdXRhdGlvbnNcbiAgdGhpcy5vd25lckVsZW1lbnQgPSBlbHQ7XG5cbiAgaWYgKCFuYW1lc3BhY2UgJiYgIXByZWZpeCAmJiBlbHQuX2F0dHJpYnV0ZUNoYW5nZUhhbmRsZXJzW2xuYW1lXSlcbiAgICB0aGlzLm9uY2hhbmdlID0gZWx0Ll9hdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyc1tsbmFtZV07XG5cbiAgLy8gbG9jYWxOYW1lIGFuZCBuYW1lc3BhY2UgYXJlIGNvbnN0YW50IGZvciBhbnkgYXR0ciBvYmplY3QuXG4gIC8vIEJ1dCB2YWx1ZSBtYXkgY2hhbmdlLiAgQW5kIHNvIGNhbiBwcmVmaXgsIGFuZCBzbywgdGhlcmVmb3JlIGNhbiBuYW1lLlxuICB0aGlzLmxvY2FsTmFtZSA9IGxuYW1lO1xuICB0aGlzLnByZWZpeCA9IChwcmVmaXg9PT1udWxsIHx8IHByZWZpeD09PScnKSA/IG51bGwgOiAoJycgKyBwcmVmaXgpO1xuICB0aGlzLm5hbWVzcGFjZVVSSSA9IChuYW1lc3BhY2U9PT1udWxsIHx8IG5hbWVzcGFjZT09PScnKSA/IG51bGwgOiAoJycgKyBuYW1lc3BhY2UpO1xufVxuXG5BdHRyLnByb3RvdHlwZSA9IHtcbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZml4ID8gdGhpcy5wcmVmaXggKyAnOicgKyB0aGlzLmxvY2FsTmFtZSA6IHRoaXMubG9jYWxOYW1lO1xuICB9LFxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9LFxuXG4gIGdldCBzcGVjaWZpZWQoKSB7XG4gICAgLy8gRGVwcmVjYXRlZFxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIHZhciBvbGR2YWwgPSB0aGlzLmRhdGE7XG4gICAgdmFsdWUgPSAodmFsdWUgPT09IHVuZGVmaW5lZCkgPyAnJyA6IHZhbHVlICsgJyc7XG4gICAgaWYgKHZhbHVlID09PSBvbGR2YWwpIHJldHVybjtcblxuICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuXG4gICAgLy8gUnVuIHRoZSBvbmNoYW5nZSBob29rIGZvciB0aGUgYXR0cmlidXRlXG4gICAgLy8gaWYgdGhlcmUgaXMgb25lLlxuICAgIGlmICh0aGlzLm9uY2hhbmdlKVxuICAgICAgdGhpcy5vbmNoYW5nZSh0aGlzLm93bmVyRWxlbWVudCx0aGlzLmxvY2FsTmFtZSwgb2xkdmFsLCB2YWx1ZSk7XG5cbiAgICAvLyBHZW5lcmF0ZSBhIG11dGF0aW9uIGV2ZW50IGlmIHRoZSBlbGVtZW50IGlzIHJvb3RlZFxuICAgIGlmICh0aGlzLm93bmVyRWxlbWVudC5yb290ZWQpXG4gICAgICB0aGlzLm93bmVyRWxlbWVudC5vd25lckRvY3VtZW50Lm11dGF0ZUF0dHIodGhpcywgb2xkdmFsKTtcbiAgfSxcblxuICAvLyBMZWdhY3kgYWxpYXNlcyAoc2VlIGdoIzcwIGFuZCBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1hdHRyKVxuICBnZXQgbm9kZU5hbWUoKSB7IHJldHVybiB0aGlzLm5hbWU7IH0sXG4gIGdldCBub2RlVmFsdWUoKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9LFxuICBnZXQgdGV4dENvbnRlbnQoKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9LFxuICBzZXQgbm9kZVZhbHVlKHYpIHsgdGhpcy52YWx1ZSA9IHY7IH0sXG4gIHNldCB0ZXh0Q29udGVudCh2KSB7IHRoaXMudmFsdWUgPSB2OyB9LFxufTtcblxuXG4vLyBUaGUgYXR0cmlidXRlcyBwcm9wZXJ0eSBvZiBhbiBFbGVtZW50IHdpbGwgYmUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbi8vIFRoaXMgY2xhc3MgaXMgcmVhbGx5IGp1c3QgYSBkdW1teSwgdGhvdWdoLiBJdCBvbmx5IGRlZmluZXMgYSBsZW5ndGhcbi8vIHByb3BlcnR5IGFuZCBhbiBpdGVtKCkgbWV0aG9kLiBUaGUgQXR0ckFycmF5UHJveHkgdGhhdFxuLy8gZGVmaW5lcyB0aGUgcHVibGljIEFQSSBqdXN0IHVzZXMgdGhlIEVsZW1lbnQgb2JqZWN0IGl0c2VsZi5cbmZ1bmN0aW9uIEF0dHJpYnV0ZXNBcnJheShlbHQpIHtcbiAgdGhpcy5lbGVtZW50ID0gZWx0O1xuICBmb3IgKHZhciBuYW1lIGluIGVsdC5fYXR0cnNCeVFOYW1lKSB7XG4gICAgdGhpc1tuYW1lXSA9IGVsdC5fYXR0cnNCeVFOYW1lW25hbWVdO1xuICB9XG59XG5BdHRyaWJ1dGVzQXJyYXkucHJvdG90eXBlID0ge1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuX2F0dHJLZXlzLmxlbmd0aDtcbiAgfSxcbiAgaXRlbTogZnVuY3Rpb24obikge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuX2F0dHJzQnlMTmFtZVt0aGlzLmVsZW1lbnQuX2F0dHJLZXlzW25dXTtcbiAgfVxufTtcblxuXG4vLyBUaGUgY2hpbGRyZW4gcHJvcGVydHkgb2YgYW4gRWxlbWVudCB3aWxsIGJlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4vLyBJdCBkZWZpbmVzIGxlbmd0aCwgaXRlbSgpIGFuZCBuYW1lZEl0ZW0oKSBhbmQgd2lsbCBiZSB3cmFwcGVkIGJ5IGFuXG4vLyBIVE1MQ29sbGVjdGlvbiB3aGVuIGV4cG9zZWQgdGhyb3VnaCB0aGUgRE9NLlxuZnVuY3Rpb24gQ2hpbGRyZW5Db2xsZWN0aW9uKGUpIHtcbiAgdGhpcy5lbGVtZW50ID0gZTtcbiAgdGhpcy51cGRhdGVDYWNoZSgpO1xufVxuXG5DaGlsZHJlbkNvbGxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIHRoaXMudXBkYXRlQ2FjaGUoKTtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbkJ5TnVtYmVyLmxlbmd0aDtcbiAgfSxcbiAgaXRlbTogZnVuY3Rpb24gaXRlbShuKSB7XG4gICAgdGhpcy51cGRhdGVDYWNoZSgpO1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuQnlOdW1iZXJbbl0gfHwgbnVsbDtcbiAgfSxcblxuICBuYW1lZEl0ZW06IGZ1bmN0aW9uIG5hbWVkSXRlbShuYW1lKSB7XG4gICAgdGhpcy51cGRhdGVDYWNoZSgpO1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuQnlOYW1lW25hbWVdIHx8IG51bGw7XG4gIH0sXG5cbiAgLy8gVGhpcyBhdHRyaWJ1dGUgcmV0dXJucyB0aGUgZW50aXJlIG5hbWUtPmVsZW1lbnQgbWFwLlxuICAvLyBJdCBpcyBub3QgcGFydCBvZiB0aGUgSFRNTENvbGxlY3Rpb24gQVBJLCBidXQgd2UgbmVlZCBpdCBpblxuICAvLyBzcmMvSFRNTENvbGxlY3Rpb25Qcm94eVxuICBnZXQgbmFtZWRJdGVtcygpIHtcbiAgICB0aGlzLnVwZGF0ZUNhY2hlKCk7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5CeU5hbWU7XG4gIH0sXG5cbiAgdXBkYXRlQ2FjaGU6IGZ1bmN0aW9uIHVwZGF0ZUNhY2hlKCkge1xuICAgIHZhciBuYW1lZEVsdHMgPSAvXihhfGFwcGxldHxhcmVhfGVtYmVkfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aWZyYW1lfGltZ3xvYmplY3QpJC87XG4gICAgaWYgKHRoaXMubGFzdE1vZFRpbWUgIT09IHRoaXMuZWxlbWVudC5sYXN0TW9kVGltZSkge1xuICAgICAgdGhpcy5sYXN0TW9kVGltZSA9IHRoaXMuZWxlbWVudC5sYXN0TW9kVGltZTtcblxuICAgICAgdmFyIG4gPSB0aGlzLmNoaWxkcmVuQnlOdW1iZXIgJiYgdGhpcy5jaGlsZHJlbkJ5TnVtYmVyLmxlbmd0aCB8fCAwO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoaWxkcmVuQnlOdW1iZXIgPSBbXTtcbiAgICAgIHRoaXMuY2hpbGRyZW5CeU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICBmb3IoaSA9IDAsIG4gPSB0aGlzLmVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGMubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG5cbiAgICAgICAgICB0aGlzW3RoaXMuY2hpbGRyZW5CeU51bWJlci5sZW5ndGhdID0gYztcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuQnlOdW1iZXIucHVzaChjKTtcblxuICAgICAgICAgIC8vIFhYWCBBcmUgdGhlcmUgYW55IHJlcXVpcmVtZW50cyBhYm91dCB0aGUgbmFtZXNwYWNlXG4gICAgICAgICAgLy8gb2YgdGhlIGlkIHByb3BlcnR5P1xuICAgICAgICAgIHZhciBpZCA9IGMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaWQgdGhhdCBpcyBub3QgYWxyZWFkeSBpbiB1c2UuLi5cbiAgICAgICAgICBpZiAoaWQgJiYgIXRoaXMuY2hpbGRyZW5CeU5hbWVbaWRdKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbkJ5TmFtZVtpZF0gPSBjO1xuXG4gICAgICAgICAgLy8gRm9yIGNlcnRhaW4gSFRNTCBlbGVtZW50cyB3ZSBjaGVjayB0aGUgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICB2YXIgbmFtZSA9IGMuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgICAgaWYgKG5hbWUgJiZcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5IVE1MICYmXG4gICAgICAgICAgICBuYW1lZEVsdHMudGVzdCh0aGlzLmVsZW1lbnQubG9jYWxOYW1lKSAmJlxuICAgICAgICAgICAgIXRoaXMuY2hpbGRyZW5CeU5hbWVbbmFtZV0pXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuQnlOYW1lW2lkXSA9IGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIFRoZXNlIGZ1bmN0aW9ucyByZXR1cm4gcHJlZGljYXRlcyBmb3IgZmlsdGVyaW5nIGVsZW1lbnRzLlxuLy8gVGhleSdyZSB1c2VkIGJ5IHRoZSBEb2N1bWVudCBhbmQgRWxlbWVudCBjbGFzc2VzIGZvciBtZXRob2RzIGxpa2Vcbi8vIGdldEVsZW1lbnRzQnlUYWdOYW1lIGFuZCBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lXG5cbmZ1bmN0aW9uIGxvY2FsTmFtZUVsZW1lbnRGaWx0ZXIobG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUubG9jYWxOYW1lID09PSBsbmFtZTsgfTtcbn1cblxuZnVuY3Rpb24gaHRtbExvY2FsTmFtZUVsZW1lbnRGaWx0ZXIobG5hbWUpIHtcbiAgdmFyIGxjbG5hbWUgPSB1dGlscy50b0FTQ0lJTG93ZXJDYXNlKGxuYW1lKTtcbiAgaWYgKGxjbG5hbWUgPT09IGxuYW1lKVxuICAgIHJldHVybiBsb2NhbE5hbWVFbGVtZW50RmlsdGVyKGxuYW1lKTtcblxuICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlLmlzSFRNTCA/IGUubG9jYWxOYW1lID09PSBsY2xuYW1lIDogZS5sb2NhbE5hbWUgPT09IGxuYW1lO1xuICB9O1xufVxuXG5mdW5jdGlvbiBuYW1lc3BhY2VFbGVtZW50RmlsdGVyKG5zKSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7IHJldHVybiBlLm5hbWVzcGFjZVVSSSA9PT0gbnM7IH07XG59XG5cbmZ1bmN0aW9uIG5hbWVzcGFjZUxvY2FsTmFtZUVsZW1lbnRGaWx0ZXIobnMsIGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGUubmFtZXNwYWNlVVJJID09PSBucyAmJiBlLmxvY2FsTmFtZSA9PT0gbG5hbWU7XG4gIH07XG59XG5cbi8vIFhYWFxuLy8gT3B0aW1pemUgdGhpcyB3aGVuIEkgaW1wbGVtZW50IGNsYXNzTGlzdC5cbmZ1bmN0aW9uIGNsYXNzTmFtZXNFbGVtZW50RmlsdGVyKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNsYXNzQXR0ciA9IGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpO1xuICAgIGlmICghY2xhc3NBdHRyKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGNsYXNzZXMgPSBjbGFzc0F0dHIudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgcmV0dXJuIG5hbWVzLmV2ZXJ5KGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBjbGFzc2VzLmluZGV4T2YobikgIT09IC0xO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TmFtZUZpbHRlcihuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGUuZ2V0QXR0cmlidXRlKCduYW1lJykgPT09IG5hbWU7XG4gIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0VsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxKSkoMCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2YWJsZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxKSkoNyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9idW5kbGVzL2NvbW1vbi51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NS4yLjNcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgncnhqcy9vYnNlcnZhYmxlL29mJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvY29uY2F0TWFwJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvZmlsdGVyJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvbWFwJyksIHJlcXVpcmUoJ3RzbGliJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbW1vbicpLCByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJywgWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAncnhqcy9vYnNlcnZhYmxlL29mJywgJ3J4anMvb3BlcmF0b3IvY29uY2F0TWFwJywgJ3J4anMvb3BlcmF0b3IvZmlsdGVyJywgJ3J4anMvb3BlcmF0b3IvbWFwJywgJ3RzbGliJywgJ0Bhbmd1bGFyL2NvbW1vbicsICdyeGpzL09ic2VydmFibGUnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcuY29tbW9uID0gZ2xvYmFsLm5nLmNvbW1vbiB8fCB7fSwgZ2xvYmFsLm5nLmNvbW1vbi5odHRwID0ge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwudHNsaWIsZ2xvYmFsLm5nLmNvbW1vbixnbG9iYWwuUngpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUscnhqc19vYnNlcnZhYmxlX29mLHJ4anNfb3BlcmF0b3JfY29uY2F0TWFwLHJ4anNfb3BlcmF0b3JfZmlsdGVyLHJ4anNfb3BlcmF0b3JfbWFwLHRzbGliLF9hbmd1bGFyX2NvbW1vbixyeGpzX09ic2VydmFibGUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjUuMi4zXG4gKiAoYykgMjAxMC0yMDE4IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGBIdHRwUmVxdWVzdGAgaW50byBhIHN0cmVhbSBvZiBgSHR0cEV2ZW50YHMsIG9uZSBvZiB3aGljaCB3aWxsIGxpa2VseSBiZSBhXG4gKiBgSHR0cFJlc3BvbnNlYC5cbiAqXG4gKiBgSHR0cEhhbmRsZXJgIGlzIGluamVjdGFibGUuIFdoZW4gaW5qZWN0ZWQsIHRoZSBoYW5kbGVyIGluc3RhbmNlIGRpc3BhdGNoZXMgcmVxdWVzdHMgdG8gdGhlXG4gKiBmaXJzdCBpbnRlcmNlcHRvciBpbiB0aGUgY2hhaW4sIHdoaWNoIGRpc3BhdGNoZXMgdG8gdGhlIHNlY29uZCwgZXRjLCBldmVudHVhbGx5IHJlYWNoaW5nIHRoZVxuICogYEh0dHBCYWNrZW5kYC5cbiAqXG4gKiBJbiBhbiBgSHR0cEludGVyY2VwdG9yYCwgdGhlIGBIdHRwSGFuZGxlcmAgcGFyYW1ldGVyIGlzIHRoZSBuZXh0IGludGVyY2VwdG9yIGluIHRoZSBjaGFpbi5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgSHR0cEhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cEhhbmRsZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBIdHRwSGFuZGxlcjtcbn0oKSk7XG4vKipcbiAqIEEgZmluYWwgYEh0dHBIYW5kbGVyYCB3aGljaCB3aWxsIGRpc3BhdGNoIHRoZSByZXF1ZXN0IHZpYSBicm93c2VyIEhUVFAgQVBJcyB0byBhIGJhY2tlbmQuXG4gKlxuICogSW50ZXJjZXB0b3JzIHNpdCBiZXR3ZWVuIHRoZSBgSHR0cENsaWVudGAgaW50ZXJmYWNlIGFuZCB0aGUgYEh0dHBCYWNrZW5kYC5cbiAqXG4gKiBXaGVuIGluamVjdGVkLCBgSHR0cEJhY2tlbmRgIGRpc3BhdGNoZXMgcmVxdWVzdHMgZGlyZWN0bHkgdG8gdGhlIGJhY2tlbmQsIHdpdGhvdXQgZ29pbmdcbiAqIHRocm91Z2ggdGhlIGludGVyY2VwdG9yIGNoYWluLlxuICpcbiAqIFxcQHN0YWJsZVxuICogQGFic3RyYWN0XG4gKi9cbnZhciBIdHRwQmFja2VuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwQmFja2VuZCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEh0dHBCYWNrZW5kO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcmVjb3JkXG4gKi9cbi8qKlxuICogSW1tdXRhYmxlIHNldCBvZiBIdHRwIGhlYWRlcnMsIHdpdGggbGF6eSBwYXJzaW5nLlxuICogXFxAc3RhYmxlXG4gKi9cbnZhciBIdHRwSGVhZGVycyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBtYXAgb2YgbG93ZXJjYXNlZCBoZWFkZXIgbmFtZXMgdG8gdGhlIG5vcm1hbGl6ZWRcbiAgICAgICAgICogZm9ybSBvZiB0aGUgbmFtZSAodGhlIGZvcm0gc2VlbiBmaXJzdCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZWROYW1lcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFF1ZXVlZCB1cGRhdGVzIHRvIGJlIG1hdGVyaWFsaXplZCB0aGUgbmV4dCBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGF6eVVwZGF0ZSA9IG51bGw7XG4gICAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBoZWFkZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5sYXp5SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oZWFkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZV8xID0gbGluZS5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSBuYW1lXzEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gbGluZS5zbGljZShpbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1heWJlU2V0Tm9ybWFsaXplZE5hbWUobmFtZV8xLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmhlYWRlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovICgoX3RoaXMuaGVhZGVycy5nZXQoa2V5KSkpLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGVhZGVycy5zZXQoa2V5LCBbdmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGF6eUluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlcyA9IGhlYWRlcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhlYWRlcnMuc2V0KGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1heWJlU2V0Tm9ybWFsaXplZE5hbWUobmFtZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGV4aXN0ZW5jZSBvZiBoZWFkZXIgYnkgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGV4aXN0ZW5jZSBvZiBoZWFkZXIgYnkgZ2l2ZW4gbmFtZS5cbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSAvKipcbiAgICAgKiBDaGVja3MgZm9yIGV4aXN0ZW5jZSBvZiBoZWFkZXIgYnkgZ2l2ZW4gbmFtZS5cbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaXJzdCBoZWFkZXIgdGhhdCBtYXRjaGVzIGdpdmVuIG5hbWUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaXJzdCBoZWFkZXIgdGhhdCBtYXRjaGVzIGdpdmVuIG5hbWUuXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gLyoqXG4gICAgICogUmV0dXJucyBmaXJzdCBoZWFkZXIgdGhhdCBtYXRjaGVzIGdpdmVuIG5hbWUuXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVzID0gdGhpcy5oZWFkZXJzLmdldChuYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggPiAwID8gdmFsdWVzWzBdIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIHRoZSBoZWFkZXJzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZXMgb2YgdGhlIGhlYWRlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZXMgb2YgdGhlIGhlYWRlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubm9ybWFsaXplZE5hbWVzLnZhbHVlcygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGlzdCBvZiBoZWFkZXIgdmFsdWVzIGZvciBhIGdpdmVuIG5hbWUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsaXN0IG9mIGhlYWRlciB2YWx1ZXMgZm9yIGEgZ2l2ZW4gbmFtZS5cbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5nZXRBbGwgPSAvKipcbiAgICAgKiBSZXR1cm5zIGxpc3Qgb2YgaGVhZGVyIHZhbHVlcyBmb3IgYSBnaXZlbiBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnMuZ2V0KG5hbWUudG9Mb3dlckNhc2UoKSkgfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIG9wOiAnYScgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBvcDogJ3MnIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5kZWxldGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBvcDogJ2QnIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBsY05hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5tYXliZVNldE5vcm1hbGl6ZWROYW1lID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBsY05hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lLCBsY05hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vcm1hbGl6ZWROYW1lcy5oYXMobGNOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkTmFtZXMuc2V0KGxjTmFtZSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEhlYWRlcnMucHJvdG90eXBlLmluaXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCEhdGhpcy5sYXp5SW5pdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGF6eUluaXQgaW5zdGFuY2VvZiBIdHRwSGVhZGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29weUZyb20odGhpcy5sYXp5SW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhenlJbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhenlJbml0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghIXRoaXMubGF6eVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF6eVVwZGF0ZS5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHsgcmV0dXJuIF90aGlzLmFwcGx5VXBkYXRlKHVwZGF0ZSk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMubGF6eVVwZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3RoZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBIZWFkZXJzLnByb3RvdHlwZS5jb3B5RnJvbSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3RoZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvdGhlci5pbml0KCk7XG4gICAgICAgIEFycmF5LmZyb20ob3RoZXIuaGVhZGVycy5rZXlzKCkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgX3RoaXMuaGVhZGVycy5zZXQoa2V5LCAvKiogQHR5cGUgez99ICovICgob3RoZXIuaGVhZGVycy5nZXQoa2V5KSkpKTtcbiAgICAgICAgICAgIF90aGlzLm5vcm1hbGl6ZWROYW1lcy5zZXQoa2V5LCAvKiogQHR5cGUgez99ICovICgob3RoZXIubm9ybWFsaXplZE5hbWVzLmdldChrZXkpKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuY2xvbmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHVwZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9uZSA9IG5ldyBIdHRwSGVhZGVycygpO1xuICAgICAgICBjbG9uZS5sYXp5SW5pdCA9XG4gICAgICAgICAgICAoISF0aGlzLmxhenlJbml0ICYmIHRoaXMubGF6eUluaXQgaW5zdGFuY2VvZiBIdHRwSGVhZGVycykgPyB0aGlzLmxhenlJbml0IDogdGhpcztcbiAgICAgICAgY2xvbmUubGF6eVVwZGF0ZSA9ICh0aGlzLmxhenlVcGRhdGUgfHwgW10pLmNvbmNhdChbdXBkYXRlXSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuYXBwbHlVcGRhdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHVwZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSB1cGRhdGUubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKHVwZGF0ZS5vcCkge1xuICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IC8qKiBAdHlwZSB7P30gKi8gKCh1cGRhdGUudmFsdWUpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlU2V0Tm9ybWFsaXplZE5hbWUodXBkYXRlLm5hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZSA9ICh1cGRhdGUub3AgPT09ICdhJyA/IHRoaXMuaGVhZGVycy5nZXQoa2V5KSA6IHVuZGVmaW5lZCkgfHwgW107XG4gICAgICAgICAgICAgICAgYmFzZS5wdXNoLmFwcGx5KGJhc2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KGtleSwgYmFzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b0RlbGV0ZV8xID0gLyoqIEB0eXBlIHs/fSAqLyAodXBkYXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRvRGVsZXRlXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWROYW1lcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4aXN0aW5nID0gdGhpcy5oZWFkZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcgPSBleGlzdGluZy5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0b0RlbGV0ZV8xLmluZGV4T2YodmFsdWUpID09PSAtMTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZE5hbWVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldChrZXksIGV4aXN0aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMubm9ybWFsaXplZE5hbWVzLmtleXMoKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKC8qKiBAdHlwZSB7P30gKi8gKChfdGhpcy5ub3JtYWxpemVkTmFtZXMuZ2V0KGtleSkpKSwgLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLmhlYWRlcnMuZ2V0KGtleSkpKSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBIZWFkZXJzO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIGNvZGVjIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgcGFyYW1ldGVycyBpbiBVUkxzLlxuICpcbiAqIFVzZWQgYnkgYEh0dHBQYXJhbXNgLlxuICpcbiAqIFxcQHN0YWJsZVxuICpcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIEEgYEh0dHBQYXJhbWV0ZXJDb2RlY2AgdGhhdCB1c2VzIGBlbmNvZGVVUklDb21wb25lbnRgIGFuZCBgZGVjb2RlVVJJQ29tcG9uZW50YCB0b1xuICogc2VyaWFsaXplIGFuZCBwYXJzZSBVUkwgcGFyYW1ldGVyIGtleXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEh0dHBVcmxFbmNvZGluZ0NvZGVjID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHBVcmxFbmNvZGluZ0NvZGVjKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGtcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBVcmxFbmNvZGluZ0NvZGVjLnByb3RvdHlwZS5lbmNvZGVLZXkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGtcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChrKSB7IHJldHVybiBzdGFuZGFyZEVuY29kaW5nKGspOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFVybEVuY29kaW5nQ29kZWMucHJvdG90eXBlLmVuY29kZVZhbHVlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB2XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RhbmRhcmRFbmNvZGluZyh2KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGtcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBVcmxFbmNvZGluZ0NvZGVjLnByb3RvdHlwZS5kZWNvZGVLZXkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGtcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChrKSB7IHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoayk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwVXJsRW5jb2RpbmdDb2RlYy5wcm90b3R5cGUuZGVjb2RlVmFsdWUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh2KSB7IHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodik7IH07XG4gICAgcmV0dXJuIEh0dHBVcmxFbmNvZGluZ0NvZGVjO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSByYXdQYXJhbXNcbiAqIEBwYXJhbSB7P30gY29kZWNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcmFtUGFyc2VyKHJhd1BhcmFtcywgY29kZWMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXAkJDEgPSBuZXcgTWFwKCk7XG4gICAgaWYgKHJhd1BhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtcyA9IHJhd1BhcmFtcy5zcGxpdCgnJicpO1xuICAgICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVxSWR4ID0gcGFyYW0uaW5kZXhPZignPScpO1xuICAgICAgICAgICAgdmFyIF9hID0gZXFJZHggPT0gLTEgP1xuICAgICAgICAgICAgICAgIFtjb2RlYy5kZWNvZGVLZXkocGFyYW0pLCAnJ10gOlxuICAgICAgICAgICAgICAgIFtjb2RlYy5kZWNvZGVLZXkocGFyYW0uc2xpY2UoMCwgZXFJZHgpKSwgY29kZWMuZGVjb2RlVmFsdWUocGFyYW0uc2xpY2UoZXFJZHggKyAxKSldLCBrZXkgPSBfYVswXSwgdmFsID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ID0gbWFwJCQxLmdldChrZXkpIHx8IFtdO1xuICAgICAgICAgICAgbGlzdC5wdXNoKHZhbCk7XG4gICAgICAgICAgICBtYXAkJDEuc2V0KGtleSwgbGlzdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwJCQxO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkRW5jb2Rpbmcodikge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodilcbiAgICAgICAgLnJlcGxhY2UoLyU0MC9naSwgJ0AnKVxuICAgICAgICAucmVwbGFjZSgvJTNBL2dpLCAnOicpXG4gICAgICAgIC5yZXBsYWNlKC8lMjQvZ2ksICckJylcbiAgICAgICAgLnJlcGxhY2UoLyUyQy9naSwgJywnKVxuICAgICAgICAucmVwbGFjZSgvJTNCL2dpLCAnOycpXG4gICAgICAgIC5yZXBsYWNlKC8lMkIvZ2ksICcrJylcbiAgICAgICAgLnJlcGxhY2UoLyUzRC9naSwgJz0nKVxuICAgICAgICAucmVwbGFjZSgvJTNGL2dpLCAnPycpXG4gICAgICAgIC5yZXBsYWNlKC8lMkYvZ2ksICcvJyk7XG59XG4vKipcbiAqIE9wdGlvbnMgdXNlZCB0byBjb25zdHJ1Y3QgYW4gYEh0dHBQYXJhbXNgIGluc3RhbmNlLlxuICogQHJlY29yZFxuICovXG5cbi8qKlxuICogQW4gSFRUUCByZXF1ZXN0L3Jlc3BvbnNlIGJvZHkgdGhhdCByZXByZXNlbnRzIHNlcmlhbGl6ZWQgcGFyYW1ldGVycyxcbiAqIHBlciB0aGUgTUlNRSB0eXBlIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgaW1tdXRhYmxlIC0gYWxsIG11dGF0aW9uIG9wZXJhdGlvbnMgcmV0dXJuIGEgbmV3IGluc3RhbmNlLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgSHR0cFBhcmFtcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gLyoqIEB0eXBlIHs/fSAqLyAoe30pOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudXBkYXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xvbmVGcm9tID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gb3B0aW9ucy5lbmNvZGVyIHx8IG5ldyBIdHRwVXJsRW5jb2RpbmdDb2RlYygpO1xuICAgICAgICBpZiAoISFvcHRpb25zLmZyb21TdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICghIW9wdGlvbnMuZnJvbU9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzcGVjaWZ5IGJvdGggZnJvbVN0cmluZyBhbmQgZnJvbU9iamVjdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hcCA9IHBhcmFtUGFyc2VyKG9wdGlvbnMuZnJvbVN0cmluZywgdGhpcy5lbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghIW9wdGlvbnMuZnJvbU9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLmZyb21PYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gKC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMuZnJvbU9iamVjdCkpW2tleV07IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAoKF90aGlzLm1hcCkpLnNldChrZXksIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJvZHkgaGFzIG9uZSBvciBtb3JlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJvZHkgaGFzIG9uZSBvciBtb3JlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBQYXJhbXMucHJvdG90eXBlLmhhcyA9IC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJvZHkgaGFzIG9uZSBvciBtb3JlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLm1hcCkpLmhhcyhwYXJhbSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpcnN0IHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUsIG9yIGBudWxsYCBpZiBpdCdzIG5vdCBwcmVzZW50LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlyc3QgdmFsdWUgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXIgbmFtZSwgb3IgYG51bGxgIGlmIGl0J3Mgbm90IHByZXNlbnQuXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFBhcmFtcy5wcm90b3R5cGUuZ2V0ID0gLyoqXG4gICAgICogR2V0IHRoZSBmaXJzdCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLCBvciBgbnVsbGAgaWYgaXQncyBub3QgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0gez99IHBhcmFtXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLm1hcCkpLmdldChwYXJhbSk7XG4gICAgICAgIHJldHVybiAhIXJlcyA/IHJlc1swXSA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLCBvciBgbnVsbGAgaWYgaXQncyBub3QgcHJlc2VudC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLCBvciBgbnVsbGAgaWYgaXQncyBub3QgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0gez99IHBhcmFtXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS5nZXRBbGwgPSAvKipcbiAgICAgKiBHZXQgYWxsIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLCBvciBgbnVsbGAgaWYgaXQncyBub3QgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0gez99IHBhcmFtXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUgez99ICovICgodGhpcy5tYXApKS5nZXQocGFyYW0pIHx8IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgZm9yIHRoaXMgYm9keS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgZm9yIHRoaXMgYm9keS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBQYXJhbXMucHJvdG90eXBlLmtleXMgPSAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgZm9yIHRoaXMgYm9keS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKC8qKiBAdHlwZSB7P30gKi8gKCh0aGlzLm1hcCkpLmtleXMoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9keSB3aXRoIGFuIGFwcGVuZGVkIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGJvZHkgd2l0aCBhbiBhcHBlbmRlZCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS5hcHBlbmQgPSAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9keSB3aXRoIGFuIGFwcGVuZGVkIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUuXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJhbSwgdmFsdWUpIHsgcmV0dXJuIHRoaXMuY2xvbmUoeyBwYXJhbTogcGFyYW0sIHZhbHVlOiB2YWx1ZSwgb3A6ICdhJyB9KTsgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9keSB3aXRoIGEgbmV3IHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGJvZHkgd2l0aCBhIG5ldyB2YWx1ZSBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lLlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS5zZXQgPSAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9keSB3aXRoIGEgbmV3IHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWUuXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJhbSwgdmFsdWUpIHsgcmV0dXJuIHRoaXMuY2xvbmUoeyBwYXJhbTogcGFyYW0sIHZhbHVlOiB2YWx1ZSwgb3A6ICdzJyB9KTsgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9keSB3aXRoIGVpdGhlciB0aGUgZ2l2ZW4gdmFsdWUgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXJcbiAgICAgKiByZW1vdmVkLCBpZiBhIHZhbHVlIGlzIGdpdmVuLCBvciBhbGwgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIHJlbW92ZWRcbiAgICAgKiBpZiBub3QuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGJvZHkgd2l0aCBlaXRoZXIgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyXG4gICAgICogcmVtb3ZlZCwgaWYgYSB2YWx1ZSBpcyBnaXZlbiwgb3IgYWxsIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciByZW1vdmVkXG4gICAgICogaWYgbm90LlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFBhcmFtcy5wcm90b3R5cGUuZGVsZXRlID0gLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGJvZHkgd2l0aCBlaXRoZXIgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyXG4gICAgICogcmVtb3ZlZCwgaWYgYSB2YWx1ZSBpcyBnaXZlbiwgb3IgYWxsIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciByZW1vdmVkXG4gICAgICogaWYgbm90LlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBhcmFtLCB2YWx1ZSkgeyByZXR1cm4gdGhpcy5jbG9uZSh7IHBhcmFtOiBwYXJhbSwgdmFsdWU6IHZhbHVlLCBvcDogJ2QnIH0pOyB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgYm9keSB0byBhbiBlbmNvZGVkIHN0cmluZywgd2hlcmUga2V5LXZhbHVlIHBhaXJzIChzZXBhcmF0ZWQgYnkgYD1gKSBhcmVcbiAgICAgKiBzZXBhcmF0ZWQgYnkgYCZgcy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGJvZHkgdG8gYW4gZW5jb2RlZCBzdHJpbmcsIHdoZXJlIGtleS12YWx1ZSBwYWlycyAoc2VwYXJhdGVkIGJ5IGA9YCkgYXJlXG4gICAgICogc2VwYXJhdGVkIGJ5IGAmYHMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUGFyYW1zLnByb3RvdHlwZS50b1N0cmluZyA9IC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgYm9keSB0byBhbiBlbmNvZGVkIHN0cmluZywgd2hlcmUga2V5LXZhbHVlIHBhaXJzIChzZXBhcmF0ZWQgYnkgYD1gKSBhcmVcbiAgICAgKiBzZXBhcmF0ZWQgYnkgYCZgcy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlS2V5ID0gX3RoaXMuZW5jb2Rlci5lbmNvZGVLZXkoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiAvKiogQHR5cGUgez99ICovICgoLyoqIEB0eXBlIHs/fSAqLyAoKF90aGlzLm1hcCkpLmdldChrZXkpKSkubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZUtleSArICc9JyArIF90aGlzLmVuY29kZXIuZW5jb2RlVmFsdWUodmFsdWUpOyB9KS5qb2luKCcmJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBQYXJhbXMucHJvdG90eXBlLmNsb25lID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cGRhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvbmUgPSBuZXcgSHR0cFBhcmFtcygvKiogQHR5cGUgez99ICovICh7IGVuY29kZXI6IHRoaXMuZW5jb2RlciB9KSk7XG4gICAgICAgIGNsb25lLmNsb25lRnJvbSA9IHRoaXMuY2xvbmVGcm9tIHx8IHRoaXM7XG4gICAgICAgIGNsb25lLnVwZGF0ZXMgPSAodGhpcy51cGRhdGVzIHx8IFtdKS5jb25jYXQoW3VwZGF0ZV0pO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBQYXJhbXMucHJvdG90eXBlLmluaXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMubWFwID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbG9uZUZyb20gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvbmVGcm9tLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xvbmVGcm9tLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICgoX3RoaXMubWFwKSkuc2V0KGtleSwgLyoqIEB0eXBlIHs/fSAqLyAoKC8qKiBAdHlwZSB7P30gKi8gKCgvKiogQHR5cGUgez99ICovICgoX3RoaXMuY2xvbmVGcm9tKSkubWFwKSkuZ2V0KGtleSkpKSk7IH0pOyAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAoKHRoaXMudXBkYXRlcykpLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodXBkYXRlLm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2UgPSAodXBkYXRlLm9wID09PSAnYScgPyAvKiogQHR5cGUgez99ICovICgoX3RoaXMubWFwKSkuZ2V0KHVwZGF0ZS5wYXJhbSkgOiB1bmRlZmluZWQpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZS5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKCh1cGRhdGUudmFsdWUpKSk7IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICgoX3RoaXMubWFwKSkuc2V0KHVwZGF0ZS5wYXJhbSwgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlXzEgPSAvKiogQHR5cGUgez99ICovICgoX3RoaXMubWFwKSkuZ2V0KHVwZGF0ZS5wYXJhbSkgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWR4ID0gYmFzZV8xLmluZGV4T2YodXBkYXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlXzEuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlXzEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovICgoX3RoaXMubWFwKSkuc2V0KHVwZGF0ZS5wYXJhbSwgYmFzZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi8gKChfdGhpcy5tYXApKS5kZWxldGUodXBkYXRlLnBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovICgoX3RoaXMubWFwKSkuZGVsZXRlKHVwZGF0ZS5wYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNsb25lRnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBIdHRwUGFyYW1zO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgZ2l2ZW4gSFRUUCBtZXRob2QgbWF5IGluY2x1ZGUgYSBib2R5LlxuICogQHBhcmFtIHs/fSBtZXRob2RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG1pZ2h0SGF2ZUJvZHkobWV0aG9kKSB7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgY2FzZSAnREVMRVRFJzpcbiAgICAgICAgY2FzZSAnR0VUJzpcbiAgICAgICAgY2FzZSAnSEVBRCc6XG4gICAgICAgIGNhc2UgJ09QVElPTlMnOlxuICAgICAgICBjYXNlICdKU09OUCc6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcbiAqIFNhZmVseSBhc3NlcnQgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIuXG4gKlxuICogSW4gc29tZSBleGVjdXRpb24gZW52aXJvbm1lbnRzIEFycmF5QnVmZmVyIGlzIG5vdCBkZWZpbmVkLlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG4vKipcbiAqIFNhZmVseSBhc3NlcnQgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBCbG9iLlxuICpcbiAqIEluIHNvbWUgZXhlY3V0aW9uIGVudmlyb25tZW50cyBCbG9iIGlzIG5vdCBkZWZpbmVkLlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2I7XG59XG4vKipcbiAqIFNhZmVseSBhc3NlcnQgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBGb3JtRGF0YSBpbnN0YW5jZS5cbiAqXG4gKiBJbiBzb21lIGV4ZWN1dGlvbiBlbnZpcm9ubWVudHMgRm9ybURhdGEgaXMgbm90IGRlZmluZWQuXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBGb3JtRGF0YTtcbn1cbi8qKlxuICogQW4gb3V0Z29pbmcgSFRUUCByZXF1ZXN0IHdpdGggYW4gb3B0aW9uYWwgdHlwZWQgYm9keS5cbiAqXG4gKiBgSHR0cFJlcXVlc3RgIHJlcHJlc2VudHMgYW4gb3V0Z29pbmcgcmVxdWVzdCwgaW5jbHVkaW5nIFVSTCwgbWV0aG9kLFxuICogaGVhZGVycywgYm9keSwgYW5kIG90aGVyIHJlcXVlc3QgY29uZmlndXJhdGlvbiBvcHRpb25zLiBJbnN0YW5jZXMgc2hvdWxkIGJlXG4gKiBhc3N1bWVkIHRvIGJlIGltbXV0YWJsZS4gVG8gbW9kaWZ5IGEgYEh0dHBSZXF1ZXN0YCwgdGhlIGBjbG9uZWBcbiAqIG1ldGhvZCBzaG91bGQgYmUgdXNlZC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEh0dHBSZXF1ZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHBSZXF1ZXN0KG1ldGhvZCwgdXJsLCB0aGlyZCwgZm91cnRoKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlcXVlc3QgYm9keSwgb3IgYG51bGxgIGlmIG9uZSBpc24ndCBzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJvZGllcyBhcmUgbm90IGVuZm9yY2VkIHRvIGJlIGltbXV0YWJsZSwgYXMgdGhleSBjYW4gaW5jbHVkZSBhIHJlZmVyZW5jZSB0byBhbnlcbiAgICAgICAgICogdXNlci1kZWZpbmVkIGRhdGEgdHlwZS4gSG93ZXZlciwgaW50ZXJjZXB0b3JzIHNob3VsZCB0YWtlIGNhcmUgdG8gcHJlc2VydmVcbiAgICAgICAgICogaWRlbXBvdGVuY2UgYnkgdHJlYXRpbmcgdGhlbSBhcyBzdWNoLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyByZXF1ZXN0IHNob3VsZCBiZSBtYWRlIGluIGEgd2F5IHRoYXQgZXhwb3NlcyBwcm9ncmVzcyBldmVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFByb2dyZXNzIGV2ZW50cyBhcmUgZXhwZW5zaXZlIChjaGFuZ2UgZGV0ZWN0aW9uIHJ1bnMgb24gZWFjaCBldmVudCkgYW5kIHNvXG4gICAgICAgICAqIHRoZXkgc2hvdWxkIG9ubHkgYmUgcmVxdWVzdGVkIGlmIHRoZSBjb25zdW1lciBpbnRlbmRzIHRvIG1vbml0b3IgdGhlbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVwb3J0UHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyByZXF1ZXN0IHNob3VsZCBiZSBzZW50IHdpdGggb3V0Z29pbmcgY3JlZGVudGlhbHMgKGNvb2tpZXMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBleHBlY3RlZCByZXNwb25zZSB0eXBlIG9mIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZCB0byBwYXJzZSB0aGUgcmVzcG9uc2UgYXBwcm9wcmlhdGVseSBiZWZvcmUgcmV0dXJuaW5nIGl0IHRvXG4gICAgICAgICAqIHRoZSByZXF1ZXN0ZWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgLy8gTmV4dCwgbmVlZCB0byBmaWd1cmUgb3V0IHdoaWNoIGFyZ3VtZW50IGhvbGRzIHRoZSBIdHRwUmVxdWVzdEluaXRcbiAgICAgICAgLy8gb3B0aW9ucywgaWYgYW55LlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGEgYm9keSBhcmd1bWVudCBpcyBleHBlY3RlZC4gVGhlIG9ubHkgdmFsaWQgd2F5IHRvIG9taXRcbiAgICAgICAgLy8gdGhlIGJvZHkgYXJndW1lbnQgaXMgdG8gdXNlIGEga25vd24gbm8tYm9keSBtZXRob2QgbGlrZSBHRVQuXG4gICAgICAgIGlmIChtaWdodEhhdmVCb2R5KHRoaXMubWV0aG9kKSB8fCAhIWZvdXJ0aCkge1xuICAgICAgICAgICAgLy8gQm9keSBpcyB0aGUgdGhpcmQgYXJndW1lbnQsIG9wdGlvbnMgYXJlIHRoZSBmb3VydGguXG4gICAgICAgICAgICB0aGlzLmJvZHkgPSAodGhpcmQgIT09IHVuZGVmaW5lZCkgPyAvKiogQHR5cGUgez99ICovICh0aGlyZCkgOiBudWxsO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGZvdXJ0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGJvZHkgcmVxdWlyZWQsIG9wdGlvbnMgYXJlIHRoZSB0aGlyZCBhcmd1bWVudC4gVGhlIGJvZHkgc3RheXMgbnVsbC5cbiAgICAgICAgICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgez99ICovICh0aGlyZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkLCBpbnRlcnByZXQgdGhlbS5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSByZXBvcnRQcm9ncmVzcyBhbmQgd2l0aENyZWRlbnRpYWxzLlxuICAgICAgICAgICAgdGhpcy5yZXBvcnRQcm9ncmVzcyA9ICEhb3B0aW9ucy5yZXBvcnRQcm9ncmVzcztcbiAgICAgICAgICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gISFvcHRpb25zLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQgcmVzcG9uc2UgdHlwZSBvZiAnanNvbicgaWYgb25lIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgaWYgKCEhb3B0aW9ucy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgaGVhZGVycyBpZiB0aGV5J3JlIHByb3ZpZGVkLlxuICAgICAgICAgICAgaWYgKCEhb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEhb3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIGhlYWRlcnMgaGF2ZSBiZWVuIHBhc3NlZCBpbiwgY29uc3RydWN0IGEgbmV3IEh0dHBIZWFkZXJzIGluc3RhbmNlLlxuICAgICAgICBpZiAoIXRoaXMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEh0dHBIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gcGFyYW1ldGVycyBoYXZlIGJlZW4gcGFzc2VkIGluLCBjb25zdHJ1Y3QgYSBuZXcgSHR0cFVybEVuY29kZWRQYXJhbXMgaW5zdGFuY2UuXG4gICAgICAgIGlmICghdGhpcy5wYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gbmV3IEh0dHBQYXJhbXMoKTtcbiAgICAgICAgICAgIHRoaXMudXJsV2l0aFBhcmFtcyA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgcGFyYW1ldGVycyB0byBhIHN0cmluZyBpbiBwcmVwYXJhdGlvbiBmb3IgaW5jbHVzaW9uIGluIHRoZSBVUkwuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXMgPSB0aGlzLnBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBObyBwYXJhbWV0ZXJzLCB0aGUgdmlzaWJsZSBVUkwgaXMganVzdCB0aGUgVVJMIGdpdmVuIGF0IGNyZWF0aW9uIHRpbWUuXG4gICAgICAgICAgICAgICAgdGhpcy51cmxXaXRoUGFyYW1zID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lcyB0aGUgVVJMIGFscmVhZHkgaGF2ZSBxdWVyeSBwYXJhbWV0ZXJzPyBMb29rIGZvciAnPycuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcUlkeCA9IHVybC5pbmRleE9mKCc/Jyk7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIDMgY2FzZXMgdG8gaGFuZGxlOlxuICAgICAgICAgICAgICAgIC8vIDEpIE5vIGV4aXN0aW5nIHBhcmFtZXRlcnMgLT4gYXBwZW5kICc/JyBmb2xsb3dlZCBieSBwYXJhbXMuXG4gICAgICAgICAgICAgICAgLy8gMikgJz8nIGV4aXN0cyBhbmQgaXMgZm9sbG93ZWQgYnkgZXhpc3RpbmcgcXVlcnkgc3RyaW5nIC0+XG4gICAgICAgICAgICAgICAgLy8gICAgYXBwZW5kICcmJyBmb2xsb3dlZCBieSBwYXJhbXMuXG4gICAgICAgICAgICAgICAgLy8gMykgJz8nIGV4aXN0cyBhdCB0aGUgZW5kIG9mIHRoZSB1cmwgLT4gYXBwZW5kIHBhcmFtcyBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGJhc2ljYWxseSBhbW91bnRzIHRvIGRldGVybWluaW5nIHRoZSBjaGFyYWN0ZXIsIGlmIGFueSwgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHRvIGpvaW4gdGhlIFVSTCBhbmQgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXAgPSBxSWR4ID09PSAtMSA/ICc/JyA6IChxSWR4IDwgdXJsLmxlbmd0aCAtIDEgPyAnJicgOiAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy51cmxXaXRoUGFyYW1zID0gdXJsICsgc2VwICsgcGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgZnJlZS1mb3JtIGJvZHkgaW50byBhIHNlcmlhbGl6ZWQgZm9ybWF0IHN1aXRhYmxlIGZvclxuICAgICAqIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgZnJlZS1mb3JtIGJvZHkgaW50byBhIHNlcmlhbGl6ZWQgZm9ybWF0IHN1aXRhYmxlIGZvclxuICAgICAqIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlcmlhbGl6ZUJvZHkgPSAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIGZyZWUtZm9ybSBib2R5IGludG8gYSBzZXJpYWxpemVkIGZvcm1hdCBzdWl0YWJsZSBmb3JcbiAgICAgKiB0cmFuc21pc3Npb24gdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgbm8gYm9keSBpcyBwcmVzZW50LCBubyBuZWVkIHRvIHNlcmlhbGl6ZSBpdC5cbiAgICAgICAgaWYgKHRoaXMuYm9keSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgYm9keSBpcyBhbHJlYWR5IGluIGEgc2VyaWFsaXplZCBmb3JtLiBJZiBzbyxcbiAgICAgICAgLy8gaXQgY2FuIGp1c3QgYmUgcmV0dXJuZWQgZGlyZWN0bHkuXG4gICAgICAgIGlmIChpc0FycmF5QnVmZmVyKHRoaXMuYm9keSkgfHwgaXNCbG9iKHRoaXMuYm9keSkgfHwgaXNGb3JtRGF0YSh0aGlzLmJvZHkpIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5ib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBib2R5IGlzIGFuIGluc3RhbmNlIG9mIEh0dHBVcmxFbmNvZGVkUGFyYW1zLlxuICAgICAgICBpZiAodGhpcy5ib2R5IGluc3RhbmNlb2YgSHR0cFBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGJvZHkgaXMgYW4gb2JqZWN0IG9yIGFycmF5LCBhbmQgc2VyaWFsaXplIHdpdGggSlNPTiBpZiBzby5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJvZHkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB0aGlzLmJvZHkgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmJvZHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsIGJhY2sgb24gdG9TdHJpbmcoKSBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuYm9keSkpLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGFtaW5lIHRoZSBib2R5IGFuZCBhdHRlbXB0IHRvIGluZmVyIGFuIGFwcHJvcHJpYXRlIE1JTUUgdHlwZVxuICAgICAqIGZvciBpdC5cbiAgICAgKlxuICAgICAqIElmIG5vIHN1Y2ggdHlwZSBjYW4gYmUgaW5mZXJyZWQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGBudWxsYC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBFeGFtaW5lIHRoZSBib2R5IGFuZCBhdHRlbXB0IHRvIGluZmVyIGFuIGFwcHJvcHJpYXRlIE1JTUUgdHlwZVxuICAgICAqIGZvciBpdC5cbiAgICAgKlxuICAgICAqIElmIG5vIHN1Y2ggdHlwZSBjYW4gYmUgaW5mZXJyZWQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGBudWxsYC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5kZXRlY3RDb250ZW50VHlwZUhlYWRlciA9IC8qKlxuICAgICAqIEV4YW1pbmUgdGhlIGJvZHkgYW5kIGF0dGVtcHQgdG8gaW5mZXIgYW4gYXBwcm9wcmlhdGUgTUlNRSB0eXBlXG4gICAgICogZm9yIGl0LlxuICAgICAqXG4gICAgICogSWYgbm8gc3VjaCB0eXBlIGNhbiBiZSBpbmZlcnJlZCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYG51bGxgLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBbiBlbXB0eSBib2R5IGhhcyBubyBjb250ZW50IHR5cGUuXG4gICAgICAgIGlmICh0aGlzLmJvZHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcm1EYXRhIGJvZGllcyByZWx5IG9uIHRoZSBicm93c2VyJ3MgY29udGVudCB0eXBlIGFzc2lnbm1lbnQuXG4gICAgICAgIGlmIChpc0Zvcm1EYXRhKHRoaXMuYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJsb2JzIHVzdWFsbHkgaGF2ZSB0aGVpciBvd24gY29udGVudCB0eXBlLiBJZiBpdCBkb2Vzbid0LCB0aGVuXG4gICAgICAgIC8vIG5vIHR5cGUgY2FuIGJlIGluZmVycmVkLlxuICAgICAgICBpZiAoaXNCbG9iKHRoaXMuYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkudHlwZSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IGJ1ZmZlcnMgaGF2ZSB1bmtub3duIGNvbnRlbnRzIGFuZCB0aHVzIG5vIHR5cGUgY2FuIGJlIGluZmVycmVkLlxuICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcih0aGlzLmJvZHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZWNobmljYWxseSwgc3RyaW5ncyBjb3VsZCBiZSBhIGZvcm0gb2YgSlNPTiBkYXRhLCBidXQgaXQncyBzYWZlIGVub3VnaFxuICAgICAgICAvLyB0byBhc3N1bWUgdGhleSdyZSBwbGFpbiBzdHJpbmdzLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAndGV4dC9wbGFpbic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYEh0dHBVcmxFbmNvZGVkUGFyYW1zYCBoYXMgaXRzIG93biBjb250ZW50LXR5cGUuXG4gICAgICAgIGlmICh0aGlzLmJvZHkgaW5zdGFuY2VvZiBIdHRwUGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JztcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheXMsIG9iamVjdHMsIGFuZCBudW1iZXJzIHdpbGwgYmUgZW5jb2RlZCBhcyBKU09OLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYm9keSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHRoaXMuYm9keSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5ib2R5KSkge1xuICAgICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgfVxuICAgICAgICAvLyBObyB0eXBlIGNvdWxkIGJlIGluZmVycmVkLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHVwZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gLyoqXG4gICAgICogQHBhcmFtIHs/PX0gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUgPT09IHZvaWQgMCkgeyB1cGRhdGUgPSB7fTsgfVxuICAgICAgICAvLyBGb3IgbWV0aG9kLCB1cmwsIGFuZCByZXNwb25zZVR5cGUsIHRha2UgdGhlIGN1cnJlbnQgdmFsdWUgdW5sZXNzXG4gICAgICAgIC8vIGl0IGlzIG92ZXJyaWRkZW4gaW4gdGhlIHVwZGF0ZSBoYXNoLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRob2QgPSB1cGRhdGUubWV0aG9kIHx8IHRoaXMubWV0aG9kO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmwgPSB1cGRhdGUudXJsIHx8IHRoaXMudXJsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNwb25zZVR5cGUgPSB1cGRhdGUucmVzcG9uc2VUeXBlIHx8IHRoaXMucmVzcG9uc2VUeXBlO1xuICAgICAgICAvLyBUaGUgYm9keSBpcyBzb21ld2hhdCBzcGVjaWFsIC0gYSBgbnVsbGAgdmFsdWUgaW4gdXBkYXRlLmJvZHkgbWVhbnNcbiAgICAgICAgLy8gd2hhdGV2ZXIgY3VycmVudCBib2R5IGlzIHByZXNlbnQgaXMgYmVpbmcgb3ZlcnJpZGRlbiB3aXRoIGFuIGVtcHR5XG4gICAgICAgIC8vIGJvZHksIHdoZXJlYXMgYW4gYHVuZGVmaW5lZGAgdmFsdWUgaW4gdXBkYXRlLmJvZHkgaW1wbGllcyBub1xuICAgICAgICAvLyBvdmVycmlkZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9ICh1cGRhdGUuYm9keSAhPT0gdW5kZWZpbmVkKSA/IHVwZGF0ZS5ib2R5IDogdGhpcy5ib2R5O1xuICAgICAgICAvLyBDYXJlZnVsbHkgaGFuZGxlIHRoZSBib29sZWFuIG9wdGlvbnMgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuXG4gICAgICAgIC8vIGBmYWxzZWAgYW5kIGB1bmRlZmluZWRgIGluIHRoZSB1cGRhdGUgYXJncy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2l0aENyZWRlbnRpYWxzID0gKHVwZGF0ZS53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCkgPyB1cGRhdGUud2l0aENyZWRlbnRpYWxzIDogdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcG9ydFByb2dyZXNzID0gKHVwZGF0ZS5yZXBvcnRQcm9ncmVzcyAhPT0gdW5kZWZpbmVkKSA/IHVwZGF0ZS5yZXBvcnRQcm9ncmVzcyA6IHRoaXMucmVwb3J0UHJvZ3Jlc3M7XG4gICAgICAgIC8vIEhlYWRlcnMgYW5kIHBhcmFtcyBtYXkgYmUgYXBwZW5kZWQgdG8gaWYgYHNldEhlYWRlcnNgIG9yXG4gICAgICAgIC8vIGBzZXRQYXJhbXNgIGFyZSB1c2VkLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZWFkZXJzID0gdXBkYXRlLmhlYWRlcnMgfHwgdGhpcy5oZWFkZXJzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXMgPSB1cGRhdGUucGFyYW1zIHx8IHRoaXMucGFyYW1zO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBjYWxsZXIgaGFzIGFza2VkIHRvIGFkZCBoZWFkZXJzLlxuICAgICAgICBpZiAodXBkYXRlLnNldEhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2V0IGV2ZXJ5IHJlcXVlc3RlZCBoZWFkZXIuXG4gICAgICAgICAgICBoZWFkZXJzID1cbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh1cGRhdGUuc2V0SGVhZGVycylcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoaGVhZGVycywgbmFtZSkgeyByZXR1cm4gaGVhZGVycy5zZXQobmFtZSwgLyoqIEB0eXBlIHs/fSAqLyAoKHVwZGF0ZS5zZXRIZWFkZXJzKSlbbmFtZV0pOyB9LCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBjYWxsZXIgaGFzIGFza2VkIHRvIHNldCBwYXJhbXMuXG4gICAgICAgIGlmICh1cGRhdGUuc2V0UGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBTZXQgZXZlcnkgcmVxdWVzdGVkIHBhcmFtLlxuICAgICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmtleXModXBkYXRlLnNldFBhcmFtcylcbiAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIHBhcmFtKSB7IHJldHVybiBwYXJhbXMuc2V0KHBhcmFtLCAvKiogQHR5cGUgez99ICovICgodXBkYXRlLnNldFBhcmFtcykpW3BhcmFtXSk7IH0sIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxseSwgY29uc3RydWN0IHRoZSBuZXcgSHR0cFJlcXVlc3QgdXNpbmcgdGhlIHBpZWNlcyBmcm9tIGFib3ZlLlxuICAgICAgICByZXR1cm4gbmV3IEh0dHBSZXF1ZXN0KG1ldGhvZCwgdXJsLCBib2R5LCB7XG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcywgaGVhZGVyczogaGVhZGVycywgcmVwb3J0UHJvZ3Jlc3M6IHJlcG9ydFByb2dyZXNzLCByZXNwb25zZVR5cGU6IHJlc3BvbnNlVHlwZSwgd2l0aENyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBSZXF1ZXN0O1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG52YXIgSHR0cEV2ZW50VHlwZSA9IHtcbiAgICAvKipcbiAgICAgICAqIFRoZSByZXF1ZXN0IHdhcyBzZW50IG91dCBvdmVyIHRoZSB3aXJlLlxuICAgICAgICovXG4gICAgU2VudDogMCxcbiAgICAvKipcbiAgICAgICAqIEFuIHVwbG9hZCBwcm9ncmVzcyBldmVudCB3YXMgcmVjZWl2ZWQuXG4gICAgICAgKi9cbiAgICBVcGxvYWRQcm9ncmVzczogMSxcbiAgICAvKipcbiAgICAgICAqIFRoZSByZXNwb25zZSBzdGF0dXMgY29kZSBhbmQgaGVhZGVycyB3ZXJlIHJlY2VpdmVkLlxuICAgICAgICovXG4gICAgUmVzcG9uc2VIZWFkZXI6IDIsXG4gICAgLyoqXG4gICAgICAgKiBBIGRvd25sb2FkIHByb2dyZXNzIGV2ZW50IHdhcyByZWNlaXZlZC5cbiAgICAgICAqL1xuICAgIERvd25sb2FkUHJvZ3Jlc3M6IDMsXG4gICAgLyoqXG4gICAgICAgKiBUaGUgZnVsbCByZXNwb25zZSBpbmNsdWRpbmcgdGhlIGJvZHkgd2FzIHJlY2VpdmVkLlxuICAgICAgICovXG4gICAgUmVzcG9uc2U6IDQsXG4gICAgLyoqXG4gICAgICAgKiBBIGN1c3RvbSBldmVudCBmcm9tIGFuIGludGVyY2VwdG9yIG9yIGEgYmFja2VuZC5cbiAgICAgICAqL1xuICAgIFVzZXI6IDUsXG59O1xuSHR0cEV2ZW50VHlwZVtIdHRwRXZlbnRUeXBlLlNlbnRdID0gXCJTZW50XCI7XG5IdHRwRXZlbnRUeXBlW0h0dHBFdmVudFR5cGUuVXBsb2FkUHJvZ3Jlc3NdID0gXCJVcGxvYWRQcm9ncmVzc1wiO1xuSHR0cEV2ZW50VHlwZVtIdHRwRXZlbnRUeXBlLlJlc3BvbnNlSGVhZGVyXSA9IFwiUmVzcG9uc2VIZWFkZXJcIjtcbkh0dHBFdmVudFR5cGVbSHR0cEV2ZW50VHlwZS5Eb3dubG9hZFByb2dyZXNzXSA9IFwiRG93bmxvYWRQcm9ncmVzc1wiO1xuSHR0cEV2ZW50VHlwZVtIdHRwRXZlbnRUeXBlLlJlc3BvbnNlXSA9IFwiUmVzcG9uc2VcIjtcbkh0dHBFdmVudFR5cGVbSHR0cEV2ZW50VHlwZS5Vc2VyXSA9IFwiVXNlclwiO1xuLyoqXG4gKiBCYXNlIGludGVyZmFjZSBmb3IgcHJvZ3Jlc3MgZXZlbnRzLlxuICpcbiAqIFxcQHN0YWJsZVxuICogQHJlY29yZFxuICovXG5cbi8qKlxuICogQSBkb3dubG9hZCBwcm9ncmVzcyBldmVudC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIEFuIHVwbG9hZCBwcm9ncmVzcyBldmVudC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIEFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgcmVxdWVzdCB3YXMgc2VudCB0byB0aGUgc2VydmVyLiBVc2VmdWxcbiAqIHdoZW4gYSByZXF1ZXN0IG1heSBiZSByZXRyaWVkIG11bHRpcGxlIHRpbWVzLCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gKiByZXRyaWVzIG9uIHRoZSBmaW5hbCBldmVudCBzdHJlYW0uXG4gKlxuICogXFxAc3RhYmxlXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBBIHVzZXItZGVmaW5lZCBldmVudC5cbiAqXG4gKiBHcm91cGluZyBhbGwgY3VzdG9tIGV2ZW50cyB1bmRlciB0aGlzIHR5cGUgZW5zdXJlcyB0aGV5IHdpbGwgYmUgaGFuZGxlZFxuICogYW5kIGZvcndhcmRlZCBieSBhbGwgaW1wbGVtZW50YXRpb25zIG9mIGludGVyY2VwdG9ycy5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIEFuIGVycm9yIHRoYXQgcmVwcmVzZW50cyBhIGZhaWxlZCBhdHRlbXB0IHRvIEpTT04ucGFyc2UgdGV4dCBjb21pbmcgYmFja1xuICogZnJvbSB0aGUgc2VydmVyLlxuICpcbiAqIEl0IGJ1bmRsZXMgdGhlIEVycm9yIG9iamVjdCB3aXRoIHRoZSBhY3R1YWwgcmVzcG9uc2UgYm9keSB0aGF0IGZhaWxlZCB0byBwYXJzZS5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGJvdGggYEh0dHBSZXNwb25zZWAgYW5kIGBIdHRwSGVhZGVyUmVzcG9uc2VgLlxuICpcbiAqIFxcQHN0YWJsZVxuICogQGFic3RyYWN0XG4gKi9cbnZhciBIdHRwUmVzcG9uc2VCYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFN1cGVyLWNvbnN0cnVjdG9yIGZvciBhbGwgcmVzcG9uc2VzLlxuICAgICAqXG4gICAgICogVGhlIHNpbmdsZSBwYXJhbWV0ZXIgYWNjZXB0ZWQgaXMgYW4gaW5pdGlhbGl6YXRpb24gaGFzaC4gQW55IHByb3BlcnRpZXNcbiAgICAgKiBvZiB0aGUgcmVzcG9uc2UgcGFzc2VkIHRoZXJlIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEh0dHBSZXNwb25zZUJhc2UoaW5pdCwgZGVmYXVsdFN0YXR1cywgZGVmYXVsdFN0YXR1c1RleHQpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRTdGF0dXMgPT09IHZvaWQgMCkgeyBkZWZhdWx0U3RhdHVzID0gMjAwOyB9XG4gICAgICAgIGlmIChkZWZhdWx0U3RhdHVzVGV4dCA9PT0gdm9pZCAwKSB7IGRlZmF1bHRTdGF0dXNUZXh0ID0gJ09LJzsgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgdmFsdWVzIHBhc3NlZCwgdXNlIHRoZW0gdG8gaW5pdGlhbGl6ZSB0aGUgcmVzcG9uc2UuXG4gICAgICAgIC8vIE90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBpbml0LmhlYWRlcnMgfHwgbmV3IEh0dHBIZWFkZXJzKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gaW5pdC5zdGF0dXMgIT09IHVuZGVmaW5lZCA/IGluaXQuc3RhdHVzIDogZGVmYXVsdFN0YXR1cztcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gaW5pdC5zdGF0dXNUZXh0IHx8IGRlZmF1bHRTdGF0dXNUZXh0O1xuICAgICAgICB0aGlzLnVybCA9IGluaXQudXJsIHx8IG51bGw7XG4gICAgICAgIC8vIENhY2hlIHRoZSBvayB2YWx1ZSB0byBhdm9pZCBkZWZpbmluZyBhIGdldHRlci5cbiAgICAgICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICB9XG4gICAgcmV0dXJuIEh0dHBSZXNwb25zZUJhc2U7XG59KCkpO1xuLyoqXG4gKiBBIHBhcnRpYWwgSFRUUCByZXNwb25zZSB3aGljaCBvbmx5IGluY2x1ZGVzIHRoZSBzdGF0dXMgYW5kIGhlYWRlciBkYXRhLFxuICogYnV0IG5vIHJlc3BvbnNlIGJvZHkuXG4gKlxuICogYEh0dHBIZWFkZXJSZXNwb25zZWAgaXMgYSBgSHR0cEV2ZW50YCBhdmFpbGFibGUgb24gdGhlIHJlc3BvbnNlXG4gKiBldmVudCBzdHJlYW0sIG9ubHkgd2hlbiBwcm9ncmVzcyBldmVudHMgYXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEh0dHBIZWFkZXJSZXNwb25zZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoSHR0cEhlYWRlclJlc3BvbnNlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBgSHR0cEhlYWRlclJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEh0dHBIZWFkZXJSZXNwb25zZShpbml0KSB7XG4gICAgICAgIGlmIChpbml0ID09PSB2b2lkIDApIHsgaW5pdCA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBIdHRwRXZlbnRUeXBlLlJlc3BvbnNlSGVhZGVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHkgdGhpcyBgSHR0cEhlYWRlclJlc3BvbnNlYCwgb3ZlcnJpZGluZyBpdHMgY29udGVudHMgd2l0aCB0aGVcbiAgICAgKiBnaXZlbiBwYXJhbWV0ZXIgaGFzaC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb3B5IHRoaXMgYEh0dHBIZWFkZXJSZXNwb25zZWAsIG92ZXJyaWRpbmcgaXRzIGNvbnRlbnRzIHdpdGggdGhlXG4gICAgICogZ2l2ZW4gcGFyYW1ldGVyIGhhc2guXG4gICAgICogQHBhcmFtIHs/PX0gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSGVhZGVyUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gLyoqXG4gICAgICogQ29weSB0aGlzIGBIdHRwSGVhZGVyUmVzcG9uc2VgLCBvdmVycmlkaW5nIGl0cyBjb250ZW50cyB3aXRoIHRoZVxuICAgICAqIGdpdmVuIHBhcmFtZXRlciBoYXNoLlxuICAgICAqIEBwYXJhbSB7Pz19IHVwZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlID09PSB2b2lkIDApIHsgdXBkYXRlID0ge307IH1cbiAgICAgICAgLy8gUGVyZm9ybSBhIHN0cmFpZ2h0Zm9yd2FyZCBpbml0aWFsaXphdGlvbiBvZiB0aGUgbmV3IEh0dHBIZWFkZXJSZXNwb25zZSxcbiAgICAgICAgLy8gb3ZlcnJpZGluZyB0aGUgY3VycmVudCBwYXJhbWV0ZXJzIHdpdGggbmV3IG9uZXMgaWYgZ2l2ZW4uXG4gICAgICAgIHJldHVybiBuZXcgSHR0cEhlYWRlclJlc3BvbnNlKHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHVwZGF0ZS5oZWFkZXJzIHx8IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1czogdXBkYXRlLnN0YXR1cyAhPT0gdW5kZWZpbmVkID8gdXBkYXRlLnN0YXR1cyA6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogdXBkYXRlLnN0YXR1c1RleHQgfHwgdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgdXJsOiB1cGRhdGUudXJsIHx8IHRoaXMudXJsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSHR0cEhlYWRlclJlc3BvbnNlO1xufShIdHRwUmVzcG9uc2VCYXNlKSk7XG4vKipcbiAqIEEgZnVsbCBIVFRQIHJlc3BvbnNlLCBpbmNsdWRpbmcgYSB0eXBlZCByZXNwb25zZSBib2R5ICh3aGljaCBtYXkgYmUgYG51bGxgXG4gKiBpZiBvbmUgd2FzIG5vdCByZXR1cm5lZCkuXG4gKlxuICogYEh0dHBSZXNwb25zZWAgaXMgYSBgSHR0cEV2ZW50YCBhdmFpbGFibGUgb24gdGhlIHJlc3BvbnNlIGV2ZW50XG4gKiBzdHJlYW0uXG4gKlxuICogXFxAc3RhYmxlXG4gKi9cbnZhciBIdHRwUmVzcG9uc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEh0dHBSZXNwb25zZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgYEh0dHBSZXNwb25zZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSHR0cFJlc3BvbnNlKGluaXQpIHtcbiAgICAgICAgaWYgKGluaXQgPT09IHZvaWQgMCkgeyBpbml0ID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IEh0dHBFdmVudFR5cGUuUmVzcG9uc2U7XG4gICAgICAgIF90aGlzLmJvZHkgPSBpbml0LmJvZHkgIT09IHVuZGVmaW5lZCA/IGluaXQuYm9keSA6IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gLyoqXG4gICAgICogQHBhcmFtIHs/PX0gdXBkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUgPT09IHZvaWQgMCkgeyB1cGRhdGUgPSB7fTsgfVxuICAgICAgICByZXR1cm4gbmV3IEh0dHBSZXNwb25zZSh7XG4gICAgICAgICAgICBib2R5OiAodXBkYXRlLmJvZHkgIT09IHVuZGVmaW5lZCkgPyB1cGRhdGUuYm9keSA6IHRoaXMuYm9keSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHVwZGF0ZS5oZWFkZXJzIHx8IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1czogKHVwZGF0ZS5zdGF0dXMgIT09IHVuZGVmaW5lZCkgPyB1cGRhdGUuc3RhdHVzIDogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB1cGRhdGUuc3RhdHVzVGV4dCB8fCB0aGlzLnN0YXR1c1RleHQsXG4gICAgICAgICAgICB1cmw6IHVwZGF0ZS51cmwgfHwgdGhpcy51cmwgfHwgdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBIdHRwUmVzcG9uc2U7XG59KEh0dHBSZXNwb25zZUJhc2UpKTtcbi8qKlxuICogQSByZXNwb25zZSB0aGF0IHJlcHJlc2VudHMgYW4gZXJyb3Igb3IgZmFpbHVyZSwgZWl0aGVyIGZyb20gYVxuICogbm9uLXN1Y2Nlc3NmdWwgSFRUUCBzdGF0dXMsIGFuIGVycm9yIHdoaWxlIGV4ZWN1dGluZyB0aGUgcmVxdWVzdCxcbiAqIG9yIHNvbWUgb3RoZXIgZmFpbHVyZSB3aGljaCBvY2N1cnJlZCBkdXJpbmcgdGhlIHBhcnNpbmcgb2YgdGhlIHJlc3BvbnNlLlxuICpcbiAqIEFueSBlcnJvciByZXR1cm5lZCBvbiB0aGUgYE9ic2VydmFibGVgIHJlc3BvbnNlIHN0cmVhbSB3aWxsIGJlXG4gKiB3cmFwcGVkIGluIGFuIGBIdHRwRXJyb3JSZXNwb25zZWAgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIGNvbnRleHQgYWJvdXRcbiAqIHRoZSBzdGF0ZSBvZiB0aGUgSFRUUCBsYXllciB3aGVuIHRoZSBlcnJvciBvY2N1cnJlZC4gVGhlIGVycm9yIHByb3BlcnR5XG4gKiB3aWxsIGNvbnRhaW4gZWl0aGVyIGEgd3JhcHBlZCBFcnJvciBvYmplY3Qgb3IgdGhlIGVycm9yIHJlc3BvbnNlIHJldHVybmVkXG4gKiBmcm9tIHRoZSBzZXJ2ZXIuXG4gKlxuICogXFxAc3RhYmxlXG4gKi9cbnZhciBIdHRwRXJyb3JSZXNwb25zZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoSHR0cEVycm9yUmVzcG9uc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHR0cEVycm9yUmVzcG9uc2UoaW5pdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIGEgZGVmYXVsdCBzdGF0dXMgb2YgMCAvIFVua25vd24gRXJyb3IuXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGluaXQsIDAsICdVbmtub3duIEVycm9yJykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdIdHRwRXJyb3JSZXNwb25zZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFcnJvcnMgYXJlIG5ldmVyIG9rYXksIGV2ZW4gd2hlbiB0aGUgc3RhdHVzIGNvZGUgaXMgaW4gdGhlIDJ4eCBzdWNjZXNzIHJhbmdlLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMub2sgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlIHdhcyBzdWNjZXNzZnVsLCB0aGVuIHRoaXMgd2FzIGEgcGFyc2UgZXJyb3IuIE90aGVyd2lzZSwgaXQgd2FzXG4gICAgICAgIC8vIGEgcHJvdG9jb2wtbGV2ZWwgZmFpbHVyZSBvZiBzb21lIHNvcnQuIEVpdGhlciB0aGUgcmVxdWVzdCBmYWlsZWQgaW4gdHJhbnNpdFxuICAgICAgICAvLyBvciB0aGUgc2VydmVyIHJldHVybmVkIGFuIHVuc3VjY2Vzc2Z1bCBzdGF0dXMgY29kZS5cbiAgICAgICAgaWYgKF90aGlzLnN0YXR1cyA+PSAyMDAgJiYgX3RoaXMuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICBfdGhpcy5tZXNzYWdlID0gXCJIdHRwIGZhaWx1cmUgZHVyaW5nIHBhcnNpbmcgZm9yIFwiICsgKGluaXQudXJsIHx8ICcodW5rbm93biB1cmwpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5tZXNzYWdlID1cbiAgICAgICAgICAgICAgICBcIkh0dHAgZmFpbHVyZSByZXNwb25zZSBmb3IgXCIgKyAoaW5pdC51cmwgfHwgJyh1bmtub3duIHVybCknKSArIFwiOiBcIiArIGluaXQuc3RhdHVzICsgXCIgXCIgKyBpbml0LnN0YXR1c1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZXJyb3IgPSBpbml0LmVycm9yIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEh0dHBFcnJvclJlc3BvbnNlO1xufShIdHRwUmVzcG9uc2VCYXNlKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ29uc3RydWN0IGFuIGluc3RhbmNlIG9mIGBIdHRwUmVxdWVzdE9wdGlvbnM8VD5gIGZyb20gYSBzb3VyY2UgYEh0dHBNZXRob2RPcHRpb25zYCBhbmRcbiAqIHRoZSBnaXZlbiBgYm9keWAuIEJhc2ljYWxseSwgdGhpcyBjbG9uZXMgdGhlIG9iamVjdCBhbmQgYWRkcyB0aGUgYm9keS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IG9wdGlvbnNcbiAqIEBwYXJhbSB7P30gYm9keVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYWRkQm9keShvcHRpb25zLCBib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICBvYnNlcnZlOiBvcHRpb25zLm9ic2VydmUsXG4gICAgICAgIHBhcmFtczogb3B0aW9ucy5wYXJhbXMsXG4gICAgICAgIHJlcG9ydFByb2dyZXNzOiBvcHRpb25zLnJlcG9ydFByb2dyZXNzLFxuICAgICAgICByZXNwb25zZVR5cGU6IG9wdGlvbnMucmVzcG9uc2VUeXBlLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzLFxuICAgIH07XG59XG4vKipcbiAqIFBlcmZvcm0gSFRUUCByZXF1ZXN0cy5cbiAqXG4gKiBgSHR0cENsaWVudGAgaXMgYXZhaWxhYmxlIGFzIGFuIGluamVjdGFibGUgY2xhc3MsIHdpdGggbWV0aG9kcyB0byBwZXJmb3JtIEhUVFAgcmVxdWVzdHMuXG4gKiBFYWNoIHJlcXVlc3QgbWV0aG9kIGhhcyBtdWx0aXBsZSBzaWduYXR1cmVzLCBhbmQgdGhlIHJldHVybiB0eXBlIHZhcmllcyBhY2NvcmRpbmcgdG8gd2hpY2hcbiAqIHNpZ25hdHVyZSBpcyBjYWxsZWQgKG1haW5seSB0aGUgdmFsdWVzIG9mIGBvYnNlcnZlYCBhbmQgYHJlc3BvbnNlVHlwZWApLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgSHR0cENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwQ2xpZW50KGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgZm9yIGEgcGFydGljdWxhciBIVFRQIHJlcXVlc3QgdGhhdCwgd2hlbiBzdWJzY3JpYmVkLFxuICAgICAqIGZpcmVzIHRoZSByZXF1ZXN0IHRocm91Z2ggdGhlIGNoYWluIG9mIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzIGFuZCBvbiB0byB0aGVcbiAgICAgKiBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGluIG9uZSBvZiB0d28gd2F5cy4gRWl0aGVyIGFuIGBIdHRwUmVxdWVzdGBcbiAgICAgKiBpbnN0YW5jZSBjYW4gYmUgcGFzc2VkIGRpcmVjdGx5IGFzIHRoZSBvbmx5IHBhcmFtZXRlciwgb3IgYSBtZXRob2QgY2FuIGJlXG4gICAgICogcGFzc2VkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIGEgc3RyaW5nIFVSTCBhcyB0aGUgc2Vjb25kLCBhbmQgYW5cbiAgICAgKiBvcHRpb25zIGhhc2ggYXMgdGhlIHRoaXJkLlxuICAgICAqXG4gICAgICogSWYgYSBgSHR0cFJlcXVlc3RgIG9iamVjdCBpcyBwYXNzZWQgZGlyZWN0bHksIGFuIGBPYnNlcnZhYmxlYCBvZiB0aGVcbiAgICAgKiByYXcgYEh0dHBFdmVudGAgc3RyZWFtIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBJZiBhIHJlcXVlc3QgaXMgaW5zdGVhZCBidWlsdCBieSBwcm92aWRpbmcgYSBVUkwsIHRoZSBvcHRpb25zIG9iamVjdFxuICAgICAqIGRldGVybWluZXMgdGhlIHJldHVybiB0eXBlIG9mIGByZXF1ZXN0KClgLiBJbiBhZGRpdGlvbiB0byBjb25maWd1cmluZ1xuICAgICAqIHJlcXVlc3QgcGFyYW1ldGVycyBzdWNoIGFzIHRoZSBvdXRnb2luZyBoZWFkZXJzIGFuZC9vciB0aGUgYm9keSwgdGhlIG9wdGlvbnNcbiAgICAgKiBoYXNoIHNwZWNpZmllcyB0d28ga2V5IHBpZWNlcyBvZiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdDogdGhlXG4gICAgICogYHJlc3BvbnNlVHlwZWAgYW5kIHdoYXQgdG8gYG9ic2VydmVgLlxuICAgICAqXG4gICAgICogVGhlIGByZXNwb25zZVR5cGVgIHZhbHVlIGRldGVybWluZXMgaG93IGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBib2R5IHdpbGwgYmVcbiAgICAgKiBwYXJzZWQuIElmIGByZXNwb25zZVR5cGVgIGlzIHRoZSBkZWZhdWx0IGBqc29uYCwgYSB0eXBlIGludGVyZmFjZSBmb3IgdGhlXG4gICAgICogcmVzdWx0aW5nIG9iamVjdCBtYXkgYmUgcGFzc2VkIGFzIGEgdHlwZSBwYXJhbWV0ZXIgdG8gYHJlcXVlc3QoKWAuXG4gICAgICpcbiAgICAgKiBUaGUgYG9ic2VydmVgIHZhbHVlIGRldGVybWluZXMgdGhlIHJldHVybiB0eXBlIG9mIGByZXF1ZXN0KClgLCBiYXNlZCBvbiB3aGF0XG4gICAgICogdGhlIGNvbnN1bWVyIGlzIGludGVyZXN0ZWQgaW4gb2JzZXJ2aW5nLiBBIHZhbHVlIG9mIGBldmVudHNgIHdpbGwgcmV0dXJuIGFuXG4gICAgICogYE9ic2VydmFibGU8SHR0cEV2ZW50PmAgcmVwcmVzZW50aW5nIHRoZSByYXcgYEh0dHBFdmVudGAgc3RyZWFtLFxuICAgICAqIGluY2x1ZGluZyBwcm9ncmVzcyBldmVudHMgYnkgZGVmYXVsdC4gQSB2YWx1ZSBvZiBgcmVzcG9uc2VgIHdpbGwgcmV0dXJuIGFuXG4gICAgICogYE9ic2VydmFibGU8SHR0cFJlc3BvbnNlPFQ+PmAgd2hlcmUgdGhlIGBUYCBwYXJhbWV0ZXIgb2YgYEh0dHBSZXNwb25zZWBcbiAgICAgKiBkZXBlbmRzIG9uIHRoZSBgcmVzcG9uc2VUeXBlYCBhbmQgYW55IG9wdGlvbmFsbHkgcHJvdmlkZWQgdHlwZSBwYXJhbWV0ZXIuXG4gICAgICogQSB2YWx1ZSBvZiBgYm9keWAgd2lsbCByZXR1cm4gYW4gYE9ic2VydmFibGU8VD5gIHdpdGggdGhlIHNhbWUgYFRgIGJvZHkgdHlwZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCBmb3IgYSBwYXJ0aWN1bGFyIEhUVFAgcmVxdWVzdCB0aGF0LCB3aGVuIHN1YnNjcmliZWQsXG4gICAgICogZmlyZXMgdGhlIHJlcXVlc3QgdGhyb3VnaCB0aGUgY2hhaW4gb2YgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnMgYW5kIG9uIHRvIHRoZVxuICAgICAqIHNlcnZlci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgaW4gb25lIG9mIHR3byB3YXlzLiBFaXRoZXIgYW4gYEh0dHBSZXF1ZXN0YFxuICAgICAqIGluc3RhbmNlIGNhbiBiZSBwYXNzZWQgZGlyZWN0bHkgYXMgdGhlIG9ubHkgcGFyYW1ldGVyLCBvciBhIG1ldGhvZCBjYW4gYmVcbiAgICAgKiBwYXNzZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciwgYSBzdHJpbmcgVVJMIGFzIHRoZSBzZWNvbmQsIGFuZCBhblxuICAgICAqIG9wdGlvbnMgaGFzaCBhcyB0aGUgdGhpcmQuXG4gICAgICpcbiAgICAgKiBJZiBhIGBIdHRwUmVxdWVzdGAgb2JqZWN0IGlzIHBhc3NlZCBkaXJlY3RseSwgYW4gYE9ic2VydmFibGVgIG9mIHRoZVxuICAgICAqIHJhdyBgSHR0cEV2ZW50YCBzdHJlYW0gd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIElmIGEgcmVxdWVzdCBpcyBpbnN0ZWFkIGJ1aWx0IGJ5IHByb3ZpZGluZyBhIFVSTCwgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgICogZGV0ZXJtaW5lcyB0aGUgcmV0dXJuIHR5cGUgb2YgYHJlcXVlc3QoKWAuIEluIGFkZGl0aW9uIHRvIGNvbmZpZ3VyaW5nXG4gICAgICogcmVxdWVzdCBwYXJhbWV0ZXJzIHN1Y2ggYXMgdGhlIG91dGdvaW5nIGhlYWRlcnMgYW5kL29yIHRoZSBib2R5LCB0aGUgb3B0aW9uc1xuICAgICAqIGhhc2ggc3BlY2lmaWVzIHR3byBrZXkgcGllY2VzIG9mIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXF1ZXN0OiB0aGVcbiAgICAgKiBgcmVzcG9uc2VUeXBlYCBhbmQgd2hhdCB0byBgb2JzZXJ2ZWAuXG4gICAgICpcbiAgICAgKiBUaGUgYHJlc3BvbnNlVHlwZWAgdmFsdWUgZGV0ZXJtaW5lcyBob3cgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIGJvZHkgd2lsbCBiZVxuICAgICAqIHBhcnNlZC4gSWYgYHJlc3BvbnNlVHlwZWAgaXMgdGhlIGRlZmF1bHQgYGpzb25gLCBhIHR5cGUgaW50ZXJmYWNlIGZvciB0aGVcbiAgICAgKiByZXN1bHRpbmcgb2JqZWN0IG1heSBiZSBwYXNzZWQgYXMgYSB0eXBlIHBhcmFtZXRlciB0byBgcmVxdWVzdCgpYC5cbiAgICAgKlxuICAgICAqIFRoZSBgb2JzZXJ2ZWAgdmFsdWUgZGV0ZXJtaW5lcyB0aGUgcmV0dXJuIHR5cGUgb2YgYHJlcXVlc3QoKWAsIGJhc2VkIG9uIHdoYXRcbiAgICAgKiB0aGUgY29uc3VtZXIgaXMgaW50ZXJlc3RlZCBpbiBvYnNlcnZpbmcuIEEgdmFsdWUgb2YgYGV2ZW50c2Agd2lsbCByZXR1cm4gYW5cbiAgICAgKiBgT2JzZXJ2YWJsZTxIdHRwRXZlbnQ+YCByZXByZXNlbnRpbmcgdGhlIHJhdyBgSHR0cEV2ZW50YCBzdHJlYW0sXG4gICAgICogaW5jbHVkaW5nIHByb2dyZXNzIGV2ZW50cyBieSBkZWZhdWx0LiBBIHZhbHVlIG9mIGByZXNwb25zZWAgd2lsbCByZXR1cm4gYW5cbiAgICAgKiBgT2JzZXJ2YWJsZTxIdHRwUmVzcG9uc2U8VD4+YCB3aGVyZSB0aGUgYFRgIHBhcmFtZXRlciBvZiBgSHR0cFJlc3BvbnNlYFxuICAgICAqIGRlcGVuZHMgb24gdGhlIGByZXNwb25zZVR5cGVgIGFuZCBhbnkgb3B0aW9uYWxseSBwcm92aWRlZCB0eXBlIHBhcmFtZXRlci5cbiAgICAgKiBBIHZhbHVlIG9mIGBib2R5YCB3aWxsIHJldHVybiBhbiBgT2JzZXJ2YWJsZTxUPmAgd2l0aCB0aGUgc2FtZSBgVGAgYm9keSB0eXBlLlxuICAgICAqIEBwYXJhbSB7P30gZmlyc3RcbiAgICAgKiBAcGFyYW0gez89fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5yZXF1ZXN0ID0gLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgZm9yIGEgcGFydGljdWxhciBIVFRQIHJlcXVlc3QgdGhhdCwgd2hlbiBzdWJzY3JpYmVkLFxuICAgICAqIGZpcmVzIHRoZSByZXF1ZXN0IHRocm91Z2ggdGhlIGNoYWluIG9mIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzIGFuZCBvbiB0byB0aGVcbiAgICAgKiBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGluIG9uZSBvZiB0d28gd2F5cy4gRWl0aGVyIGFuIGBIdHRwUmVxdWVzdGBcbiAgICAgKiBpbnN0YW5jZSBjYW4gYmUgcGFzc2VkIGRpcmVjdGx5IGFzIHRoZSBvbmx5IHBhcmFtZXRlciwgb3IgYSBtZXRob2QgY2FuIGJlXG4gICAgICogcGFzc2VkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIGEgc3RyaW5nIFVSTCBhcyB0aGUgc2Vjb25kLCBhbmQgYW5cbiAgICAgKiBvcHRpb25zIGhhc2ggYXMgdGhlIHRoaXJkLlxuICAgICAqXG4gICAgICogSWYgYSBgSHR0cFJlcXVlc3RgIG9iamVjdCBpcyBwYXNzZWQgZGlyZWN0bHksIGFuIGBPYnNlcnZhYmxlYCBvZiB0aGVcbiAgICAgKiByYXcgYEh0dHBFdmVudGAgc3RyZWFtIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBJZiBhIHJlcXVlc3QgaXMgaW5zdGVhZCBidWlsdCBieSBwcm92aWRpbmcgYSBVUkwsIHRoZSBvcHRpb25zIG9iamVjdFxuICAgICAqIGRldGVybWluZXMgdGhlIHJldHVybiB0eXBlIG9mIGByZXF1ZXN0KClgLiBJbiBhZGRpdGlvbiB0byBjb25maWd1cmluZ1xuICAgICAqIHJlcXVlc3QgcGFyYW1ldGVycyBzdWNoIGFzIHRoZSBvdXRnb2luZyBoZWFkZXJzIGFuZC9vciB0aGUgYm9keSwgdGhlIG9wdGlvbnNcbiAgICAgKiBoYXNoIHNwZWNpZmllcyB0d28ga2V5IHBpZWNlcyBvZiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdDogdGhlXG4gICAgICogYHJlc3BvbnNlVHlwZWAgYW5kIHdoYXQgdG8gYG9ic2VydmVgLlxuICAgICAqXG4gICAgICogVGhlIGByZXNwb25zZVR5cGVgIHZhbHVlIGRldGVybWluZXMgaG93IGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBib2R5IHdpbGwgYmVcbiAgICAgKiBwYXJzZWQuIElmIGByZXNwb25zZVR5cGVgIGlzIHRoZSBkZWZhdWx0IGBqc29uYCwgYSB0eXBlIGludGVyZmFjZSBmb3IgdGhlXG4gICAgICogcmVzdWx0aW5nIG9iamVjdCBtYXkgYmUgcGFzc2VkIGFzIGEgdHlwZSBwYXJhbWV0ZXIgdG8gYHJlcXVlc3QoKWAuXG4gICAgICpcbiAgICAgKiBUaGUgYG9ic2VydmVgIHZhbHVlIGRldGVybWluZXMgdGhlIHJldHVybiB0eXBlIG9mIGByZXF1ZXN0KClgLCBiYXNlZCBvbiB3aGF0XG4gICAgICogdGhlIGNvbnN1bWVyIGlzIGludGVyZXN0ZWQgaW4gb2JzZXJ2aW5nLiBBIHZhbHVlIG9mIGBldmVudHNgIHdpbGwgcmV0dXJuIGFuXG4gICAgICogYE9ic2VydmFibGU8SHR0cEV2ZW50PmAgcmVwcmVzZW50aW5nIHRoZSByYXcgYEh0dHBFdmVudGAgc3RyZWFtLFxuICAgICAqIGluY2x1ZGluZyBwcm9ncmVzcyBldmVudHMgYnkgZGVmYXVsdC4gQSB2YWx1ZSBvZiBgcmVzcG9uc2VgIHdpbGwgcmV0dXJuIGFuXG4gICAgICogYE9ic2VydmFibGU8SHR0cFJlc3BvbnNlPFQ+PmAgd2hlcmUgdGhlIGBUYCBwYXJhbWV0ZXIgb2YgYEh0dHBSZXNwb25zZWBcbiAgICAgKiBkZXBlbmRzIG9uIHRoZSBgcmVzcG9uc2VUeXBlYCBhbmQgYW55IG9wdGlvbmFsbHkgcHJvdmlkZWQgdHlwZSBwYXJhbWV0ZXIuXG4gICAgICogQSB2YWx1ZSBvZiBgYm9keWAgd2lsbCByZXR1cm4gYW4gYE9ic2VydmFibGU8VD5gIHdpdGggdGhlIHNhbWUgYFRgIGJvZHkgdHlwZS5cbiAgICAgKiBAcGFyYW0gez99IGZpcnN0XG4gICAgICogQHBhcmFtIHs/PX0gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZpcnN0LCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVxO1xuICAgICAgICAvLyBGaXJzdGx5LCBjaGVjayB3aGV0aGVyIHRoZSBwcmltYXJ5IGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIGBIdHRwUmVxdWVzdGAuXG4gICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAvLyBJdCBpcy4gVGhlIG90aGVyIGFyZ3VtZW50cyBtdXN0IGJlIHVuZGVmaW5lZCAocGVyIHRoZSBzaWduYXR1cmVzKSBhbmQgY2FuIGJlXG4gICAgICAgICAgICAvLyBpZ25vcmVkLlxuICAgICAgICAgICAgcmVxID0gLyoqIEB0eXBlIHs/fSAqLyAoZmlyc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSXQncyBhIHN0cmluZywgc28gaXQgcmVwcmVzZW50cyBhIFVSTC4gQ29uc3RydWN0IGEgcmVxdWVzdCBiYXNlZCBvbiBpdCxcbiAgICAgICAgICAgIC8vIGFuZCBpbmNvcnBvcmF0ZSB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyAoYXNzdW1pbmcgR0VUIHVubGVzcyBhIG1ldGhvZCBpc1xuICAgICAgICAgICAgLy8gcHJvdmlkZWQuXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBoZWFkZXJzLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGVhZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiBIdHRwSGVhZGVycykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gbmV3IEh0dHBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb3J0IG91dCBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCEhb3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJhbXMgaW5zdGFuY2VvZiBIdHRwUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbmV3IEh0dHBQYXJhbXMoLyoqIEB0eXBlIHs/fSAqLyAoeyBmcm9tT2JqZWN0OiBvcHRpb25zLnBhcmFtcyB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSByZXF1ZXN0LlxuICAgICAgICAgICAgcmVxID0gbmV3IEh0dHBSZXF1ZXN0KGZpcnN0LCAvKiogQHR5cGUgez99ICovICgodXJsKSksIChvcHRpb25zLmJvZHkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYm9keSA6IG51bGwpLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICByZXBvcnRQcm9ncmVzczogb3B0aW9ucy5yZXBvcnRQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBKU09OIGlzIGFzc3VtZWQgdG8gYmUgcmV0dXJuZWQgZm9yIGFsbCBjYWxscy5cbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IG9wdGlvbnMucmVzcG9uc2VUeXBlIHx8ICdqc29uJyxcbiAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhbiBPYnNlcnZhYmxlLm9mKCkgdGhlIGluaXRpYWwgcmVxdWVzdCwgYW5kIHJ1biB0aGUgaGFuZGxlciAod2hpY2hcbiAgICAgICAgLy8gaW5jbHVkZXMgYWxsIGludGVyY2VwdG9ycykgaW5zaWRlIGEgY29uY2F0TWFwKCkuIFRoaXMgd2F5LCB0aGUgaGFuZGxlciBydW5zXG4gICAgICAgIC8vIGluc2lkZSBhbiBPYnNlcnZhYmxlIGNoYWluLCB3aGljaCBjYXVzZXMgaW50ZXJjZXB0b3JzIHRvIGJlIHJlLXJ1biBvbiBldmVyeVxuICAgICAgICAvLyBzdWJzY3JpcHRpb24gKHRoaXMgYWxzbyBtYWtlcyByZXRyaWVzIHJlLXJ1biB0aGUgaGFuZGxlciwgaW5jbHVkaW5nIGludGVyY2VwdG9ycykuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV2ZW50cyQgPSByeGpzX29wZXJhdG9yX2NvbmNhdE1hcC5jb25jYXRNYXAuY2FsbChyeGpzX29ic2VydmFibGVfb2Yub2YocmVxKSwgZnVuY3Rpb24gKHJlcSkgeyByZXR1cm4gX3RoaXMuaGFuZGxlci5oYW5kbGUocmVxKTsgfSk7XG4gICAgICAgIC8vIElmIGNvbWluZyB2aWEgdGhlIEFQSSBzaWduYXR1cmUgd2hpY2ggYWNjZXB0cyBhIHByZXZpb3VzbHkgY29uc3RydWN0ZWQgSHR0cFJlcXVlc3QsXG4gICAgICAgIC8vIHRoZSBvbmx5IG9wdGlvbiBpcyB0byBnZXQgdGhlIGV2ZW50IHN0cmVhbS4gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIGV2ZW50IHN0cmVhbSBpZlxuICAgICAgICAvLyB0aGF0IGlzIHdoYXQgd2FzIHJlcXVlc3RlZC5cbiAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgSHR0cFJlcXVlc3QgfHwgb3B0aW9ucy5vYnNlcnZlID09PSAnZXZlbnRzJykge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50cyQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHJlcXVlc3RlZCBzdHJlYW0gY29udGFpbnMgZWl0aGVyIHRoZSBmdWxsIHJlc3BvbnNlIG9yIHRoZSBib2R5LiBJbiBlaXRoZXJcbiAgICAgICAgLy8gY2FzZSwgdGhlIGZpcnN0IHN0ZXAgaXMgdG8gZmlsdGVyIHRoZSBldmVudCBzdHJlYW0gdG8gZXh0cmFjdCBhIHN0cmVhbSBvZlxuICAgICAgICAvLyByZXNwb25zZXMocykuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyQgPSByeGpzX29wZXJhdG9yX2ZpbHRlci5maWx0ZXIuY2FsbChldmVudHMkLCBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlOyB9KTtcbiAgICAgICAgLy8gRGVjaWRlIHdoaWNoIHN0cmVhbSB0byByZXR1cm4uXG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5vYnNlcnZlIHx8ICdib2R5Jykge1xuICAgICAgICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3RlZCBzdHJlYW0gaXMgdGhlIGJvZHkuIE1hcCB0aGUgcmVzcG9uc2Ugc3RyZWFtIHRvIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIGJvZHkuIFRoaXMgY291bGQgYmUgZG9uZSBtb3JlIHNpbXBseSwgYnV0IGEgbWlzYmVoYXZpbmcgaW50ZXJjZXB0b3IgbWlnaHRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm0gdGhlIHJlc3BvbnNlIGJvZHkgaW50byBhIGRpZmZlcmVudCBmb3JtYXQgYW5kIGlnbm9yZSB0aGUgcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2VUeXBlLiBHdWFyZCBhZ2FpbnN0IHRoaXMgYnkgdmFsaWRhdGluZyB0aGF0IHRoZSByZXNwb25zZSBpcyBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0ZWQgdHlwZS5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlcS5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anNfb3BlcmF0b3JfbWFwLm1hcC5jYWxsKHJlcyQsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBib2R5IGlzIGFuIEFycmF5QnVmZmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMuYm9keSAhPT0gbnVsbCAmJiAhKHJlcy5ib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaXMgbm90IGFuIEFycmF5QnVmZmVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqc19vcGVyYXRvcl9tYXAubWFwLmNhbGwocmVzJCwgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIGJvZHkgaXMgYSBCbG9iLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMuYm9keSAhPT0gbnVsbCAmJiAhKHJlcy5ib2R5IGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBpcyBub3QgYSBCbG9iLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqc19vcGVyYXRvcl9tYXAubWFwLmNhbGwocmVzJCwgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIGJvZHkgaXMgYSBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5ib2R5ICE9PSBudWxsICYmIHR5cGVvZiByZXMuYm9keSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBpcyBub3QgYSBzdHJpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHZhbGlkYXRpb24gbmVlZGVkIGZvciBKU09OIHJlc3BvbnNlcywgYXMgdGhleSBjYW4gYmUgb2YgYW55IHR5cGUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqc19vcGVyYXRvcl9tYXAubWFwLmNhbGwocmVzJCwgZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLmJvZHk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3Jlc3BvbnNlJzpcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVzcG9uc2Ugc3RyZWFtIHdhcyByZXF1ZXN0ZWQgZGlyZWN0bHksIHNvIHJldHVybiBpdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzJDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCBuZXcgZnV0dXJlIG9ic2VydmUgdHlwZXMgYmVpbmcgYWRkZWQuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWFjaGFibGU6IHVuaGFuZGxlZCBvYnNlcnZlIHR5cGUgXCIgKyBvcHRpb25zLm9ic2VydmUgKyBcIn1cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBERUxFVEUgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYGRlbGV0ZSgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBERUxFVEUgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYGRlbGV0ZSgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUuZGVsZXRlID0gLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIERFTEVURSByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgZGVsZXRlKClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ0RFTEVURScsIHVybCwgLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIEdFVCByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgZ2V0KClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIEdFVCByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgZ2V0KClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5nZXQgPSAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogR0VUIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBnZXQoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnR0VUJywgdXJsLCAvKiogQHR5cGUgez99ICovIChvcHRpb25zKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogSEVBRCByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgaGVhZCgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBIRUFEIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBoZWFkKClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5oZWFkID0gLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIEhFQUQgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYGhlYWQoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnSEVBRCcsIHVybCwgLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSBhIHJlcXVlc3RcbiAgICAgKiB3aXRoIHRoZSBzcGVjaWFsIG1ldGhvZCBgSlNPTlBgIHRvIGJlIGRpc3BhdGNoZWQgdmlhIHRoZSBpbnRlcmNlcHRvciBwaXBlbGluZS5cbiAgICAgKlxuICAgICAqIEEgc3VpdGFibGUgaW50ZXJjZXB0b3IgbXVzdCBiZSBpbnN0YWxsZWQgKGUuZy4gdmlhIHRoZSBgSHR0cENsaWVudEpzb25wTW9kdWxlYCkuXG4gICAgICogSWYgbm8gc3VjaCBpbnRlcmNlcHRvciBpcyByZWFjaGVkLCB0aGVuIHRoZSBgSlNPTlBgIHJlcXVlc3Qgd2lsbCBsaWtlbHkgYmVcbiAgICAgKiByZWplY3RlZCBieSB0aGUgY29uZmlndXJlZCBiYWNrZW5kLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgYSByZXF1ZXN0XG4gICAgICogd2l0aCB0aGUgc3BlY2lhbCBtZXRob2QgYEpTT05QYCB0byBiZSBkaXNwYXRjaGVkIHZpYSB0aGUgaW50ZXJjZXB0b3IgcGlwZWxpbmUuXG4gICAgICpcbiAgICAgKiBBIHN1aXRhYmxlIGludGVyY2VwdG9yIG11c3QgYmUgaW5zdGFsbGVkIChlLmcuIHZpYSB0aGUgYEh0dHBDbGllbnRKc29ucE1vZHVsZWApLlxuICAgICAqIElmIG5vIHN1Y2ggaW50ZXJjZXB0b3IgaXMgcmVhY2hlZCwgdGhlbiB0aGUgYEpTT05QYCByZXF1ZXN0IHdpbGwgbGlrZWx5IGJlXG4gICAgICogcmVqZWN0ZWQgYnkgdGhlIGNvbmZpZ3VyZWQgYmFja2VuZC5cbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1BhcmFtXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5qc29ucCA9IC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgYSByZXF1ZXN0XG4gICAgICogd2l0aCB0aGUgc3BlY2lhbCBtZXRob2QgYEpTT05QYCB0byBiZSBkaXNwYXRjaGVkIHZpYSB0aGUgaW50ZXJjZXB0b3IgcGlwZWxpbmUuXG4gICAgICpcbiAgICAgKiBBIHN1aXRhYmxlIGludGVyY2VwdG9yIG11c3QgYmUgaW5zdGFsbGVkIChlLmcuIHZpYSB0aGUgYEh0dHBDbGllbnRKc29ucE1vZHVsZWApLlxuICAgICAqIElmIG5vIHN1Y2ggaW50ZXJjZXB0b3IgaXMgcmVhY2hlZCwgdGhlbiB0aGUgYEpTT05QYCByZXF1ZXN0IHdpbGwgbGlrZWx5IGJlXG4gICAgICogcmVqZWN0ZWQgYnkgdGhlIGNvbmZpZ3VyZWQgYmFja2VuZC5cbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1BhcmFtXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXJsLCBjYWxsYmFja1BhcmFtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ0pTT05QJywgdXJsLCB7XG4gICAgICAgICAgICBwYXJhbXM6IG5ldyBIdHRwUGFyYW1zKCkuYXBwZW5kKGNhbGxiYWNrUGFyYW0sICdKU09OUF9DQUxMQkFDSycpLFxuICAgICAgICAgICAgb2JzZXJ2ZTogJ2JvZHknLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIE9QVElPTlMgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYG9wdGlvbnMoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogT1BUSU9OUyByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgb3B0aW9ucygpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUub3B0aW9ucyA9IC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBPUFRJT05TIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBvcHRpb25zKClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ09QVElPTlMnLCB1cmwsIC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBQQVRDSCByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgcGF0Y2goKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogUEFUQ0ggcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYHBhdGNoKClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez99IGJvZHlcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5wYXRjaCA9IC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBQQVRDSCByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgcGF0Y2goKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7P30gYm9keVxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1cmwsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnUEFUQ0gnLCB1cmwsIGFkZEJvZHkob3B0aW9ucywgYm9keSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIFBPU1QgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYHBvc3QoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogUE9TVCByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgcG9zdCgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/fSBib2R5XG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUucG9zdCA9IC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gYE9ic2VydmFibGVgIHdoaWNoLCB3aGVuIHN1YnNjcmliZWQsIHdpbGwgY2F1c2UgdGhlIGNvbmZpZ3VyZWRcbiAgICAgKiBQT1NUIHJlcXVlc3QgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlci4gU2VlIHRoZSBpbmRpdmlkdWFsIG92ZXJsb2FkcyBmb3JcbiAgICAgKiBkZXRhaWxzIG9mIGBwb3N0KClgJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez99IGJvZHlcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ1BPU1QnLCB1cmwsIGFkZEJvZHkob3B0aW9ucywgYm9keSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIFBPU1QgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYHBvc3QoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGBPYnNlcnZhYmxlYCB3aGljaCwgd2hlbiBzdWJzY3JpYmVkLCB3aWxsIGNhdXNlIHRoZSBjb25maWd1cmVkXG4gICAgICogUE9TVCByZXF1ZXN0IHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBzZXJ2ZXIuIFNlZSB0aGUgaW5kaXZpZHVhbCBvdmVybG9hZHMgZm9yXG4gICAgICogZGV0YWlscyBvZiBgcG9zdCgpYCdzIHJldHVybiB0eXBlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/fSBib2R5XG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUucHV0ID0gLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBgT2JzZXJ2YWJsZWAgd2hpY2gsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBjYXVzZSB0aGUgY29uZmlndXJlZFxuICAgICAqIFBPU1QgcmVxdWVzdCB0byBiZSBleGVjdXRlZCBvbiB0aGUgc2VydmVyLiBTZWUgdGhlIGluZGl2aWR1YWwgb3ZlcmxvYWRzIGZvclxuICAgICAqIGRldGFpbHMgb2YgYHBvc3QoKWAncyByZXR1cm4gdHlwZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7P30gYm9keVxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1cmwsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnUFVUJywgdXJsLCBhZGRCb2R5KG9wdGlvbnMsIGJvZHkpKTtcbiAgICB9O1xuICAgIEh0dHBDbGllbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEh0dHBDbGllbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogSHR0cEhhbmRsZXIsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gSHR0cENsaWVudDtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogSW50ZXJjZXB0cyBgSHR0cFJlcXVlc3RgIGFuZCBoYW5kbGVzIHRoZW0uXG4gKlxuICogTW9zdCBpbnRlcmNlcHRvcnMgd2lsbCB0cmFuc2Zvcm0gdGhlIG91dGdvaW5nIHJlcXVlc3QgYmVmb3JlIHBhc3NpbmcgaXQgdG8gdGhlXG4gKiBuZXh0IGludGVyY2VwdG9yIGluIHRoZSBjaGFpbiwgYnkgY2FsbGluZyBgbmV4dC5oYW5kbGUodHJhbnNmb3JtZWRSZXEpYC5cbiAqXG4gKiBJbiByYXJlIGNhc2VzLCBpbnRlcmNlcHRvcnMgbWF5IHdpc2ggdG8gY29tcGxldGVseSBoYW5kbGUgYSByZXF1ZXN0IHRoZW1zZWx2ZXMsXG4gKiBhbmQgbm90IGRlbGVnYXRlIHRvIHRoZSByZW1haW5kZXIgb2YgdGhlIGNoYWluLiBUaGlzIGJlaGF2aW9yIGlzIGFsbG93ZWQuXG4gKlxuICogXFxAc3RhYmxlXG4gKiBAcmVjb3JkXG4gKi9cblxuLyoqXG4gKiBgSHR0cEhhbmRsZXJgIHdoaWNoIGFwcGxpZXMgYW4gYEh0dHBJbnRlcmNlcHRvcmAgdG8gYW4gYEh0dHBSZXF1ZXN0YC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEh0dHBJbnRlcmNlcHRvckhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cEludGVyY2VwdG9ySGFuZGxlcihuZXh0LCBpbnRlcmNlcHRvcikge1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gaW50ZXJjZXB0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwSW50ZXJjZXB0b3JIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcmNlcHRvci5pbnRlcmNlcHQocmVxLCB0aGlzLm5leHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0dHBJbnRlcmNlcHRvckhhbmRsZXI7XG59KCkpO1xuLyoqXG4gKiBBIG11bHRpLXByb3ZpZGVyIHRva2VuIHdoaWNoIHJlcHJlc2VudHMgdGhlIGFycmF5IG9mIGBIdHRwSW50ZXJjZXB0b3JgcyB0aGF0XG4gKiBhcmUgcmVnaXN0ZXJlZC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIEhUVFBfSU5URVJDRVBUT1JTID0gbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0aW9uVG9rZW4oJ0hUVFBfSU5URVJDRVBUT1JTJyk7XG52YXIgTm9vcEludGVyY2VwdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vb3BJbnRlcmNlcHRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgKiBAcGFyYW0gez99IG5leHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BJbnRlcmNlcHRvci5wcm90b3R5cGUuaW50ZXJjZXB0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgKiBAcGFyYW0gez99IG5leHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXEsIG5leHQpIHtcbiAgICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcSk7XG4gICAgfTtcbiAgICBOb29wSW50ZXJjZXB0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE5vb3BJbnRlcmNlcHRvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBOb29wSW50ZXJjZXB0b3I7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBFdmVyeSByZXF1ZXN0IG1hZGUgdGhyb3VnaCBKU09OUCBuZWVkcyBhIGNhbGxiYWNrIG5hbWUgdGhhdCdzIHVuaXF1ZSBhY3Jvc3MgdGhlXG4vLyB3aG9sZSBwYWdlLiBFYWNoIHJlcXVlc3QgaXMgYXNzaWduZWQgYW4gaWQgYW5kIHRoZSBjYWxsYmFjayBuYW1lIGlzIGNvbnN0cnVjdGVkXG4vLyBmcm9tIHRoYXQuIFRoZSBuZXh0IGlkIHRvIGJlIGFzc2lnbmVkIGlzIHRyYWNrZWQgaW4gYSBnbG9iYWwgdmFyaWFibGUgaGVyZSB0aGF0XG4vLyBpcyBzaGFyZWQgYW1vbmcgYWxsIGFwcGxpY2F0aW9ucyBvbiB0aGUgcGFnZS5cbnZhciBuZXh0UmVxdWVzdElkID0gMDtcbi8vIEVycm9yIHRleHQgZ2l2ZW4gd2hlbiBhIEpTT05QIHNjcmlwdCBpcyBpbmplY3RlZCwgYnV0IGRvZXNuJ3QgaW52b2tlIHRoZSBjYWxsYmFja1xuLy8gcGFzc2VkIGluIGl0cyBVUkwuXG52YXIgSlNPTlBfRVJSX05PX0NBTExCQUNLID0gJ0pTT05QIGluamVjdGVkIHNjcmlwdCBkaWQgbm90IGludm9rZSBjYWxsYmFjay4nO1xuLy8gRXJyb3IgdGV4dCBnaXZlbiB3aGVuIGEgcmVxdWVzdCBpcyBwYXNzZWQgdG8gdGhlIEpzb25wQ2xpZW50QmFja2VuZCB0aGF0IGRvZXNuJ3Rcbi8vIGhhdmUgYSByZXF1ZXN0IG1ldGhvZCBKU09OUC5cbnZhciBKU09OUF9FUlJfV1JPTkdfTUVUSE9EID0gJ0pTT05QIHJlcXVlc3RzIG11c3QgdXNlIEpTT05QIHJlcXVlc3QgbWV0aG9kLic7XG52YXIgSlNPTlBfRVJSX1dST05HX1JFU1BPTlNFX1RZUEUgPSAnSlNPTlAgcmVxdWVzdHMgbXVzdCB1c2UgSnNvbiByZXNwb25zZSB0eXBlLic7XG4vKipcbiAqIERJIHRva2VuL2Fic3RyYWN0IHR5cGUgcmVwcmVzZW50aW5nIGEgbWFwIG9mIEpTT05QIGNhbGxiYWNrcy5cbiAqXG4gKiBJbiB0aGUgYnJvd3NlciwgdGhpcyBzaG91bGQgYWx3YXlzIGJlIHRoZSBgd2luZG93YCBvYmplY3QuXG4gKlxuICogXFxAc3RhYmxlXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEpzb25wQ2FsbGJhY2tDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpzb25wQ2FsbGJhY2tDb250ZXh0KCkge1xuICAgIH1cbiAgICByZXR1cm4gSnNvbnBDYWxsYmFja0NvbnRleHQ7XG59KCkpO1xuLyoqXG4gKiBgSHR0cEJhY2tlbmRgIHRoYXQgb25seSBwcm9jZXNzZXMgYEh0dHBSZXF1ZXN0YCB3aXRoIHRoZSBKU09OUCBtZXRob2QsXG4gKiBieSBwZXJmb3JtaW5nIEpTT05QIHN0eWxlIHJlcXVlc3RzLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgSnNvbnBDbGllbnRCYWNrZW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpzb25wQ2xpZW50QmFja2VuZChjYWxsYmFja01hcCwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja01hcCA9IGNhbGxiYWNrTWFwO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgbmV4dCBjYWxsYmFjayBtZXRob2QsIGJ5IGluY3JlbWVudGluZyB0aGUgZ2xvYmFsIGBuZXh0UmVxdWVzdElkYC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEpzb25wQ2xpZW50QmFja2VuZC5wcm90b3R5cGUubmV4dENhbGxiYWNrID0gLyoqXG4gICAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSBuZXh0IGNhbGxiYWNrIG1ldGhvZCwgYnkgaW5jcmVtZW50aW5nIHRoZSBnbG9iYWwgYG5leHRSZXF1ZXN0SWRgLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJuZ19qc29ucF9jYWxsYmFja19cIiArIG5leHRSZXF1ZXN0SWQrKzsgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgSlNPTlAgcmVxdWVzdCBhbmQgcmV0dXJuIGFuIGV2ZW50IHN0cmVhbSBvZiB0aGUgcmVzdWx0cy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgSlNPTlAgcmVxdWVzdCBhbmQgcmV0dXJuIGFuIGV2ZW50IHN0cmVhbSBvZiB0aGUgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSnNvbnBDbGllbnRCYWNrZW5kLnByb3RvdHlwZS5oYW5kbGUgPSAvKipcbiAgICAgKiBQcm9jZXNzIGEgSlNPTlAgcmVxdWVzdCBhbmQgcmV0dXJuIGFuIGV2ZW50IHN0cmVhbSBvZiB0aGUgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBGaXJzdGx5LCBjaGVjayBib3RoIHRoZSBtZXRob2QgYW5kIHJlc3BvbnNlIHR5cGUuIElmIGVpdGhlciBkb2Vzbid0IG1hdGNoXG4gICAgICAgIC8vIHRoZW4gdGhlIHJlcXVlc3Qgd2FzIGltcHJvcGVybHkgcm91dGVkIGhlcmUgYW5kIGNhbm5vdCBiZSBoYW5kbGVkLlxuICAgICAgICBpZiAocmVxLm1ldGhvZCAhPT0gJ0pTT05QJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT05QX0VSUl9XUk9OR19NRVRIT0QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcS5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT05QX0VSUl9XUk9OR19SRVNQT05TRV9UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaGFwcGVucyBpbnNpZGUgdGhlIE9ic2VydmFibGUgYm91bmRhcnkuXG4gICAgICAgIHJldHVybiBuZXcgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAvLyBUaGUgZmlyc3Qgc3RlcCB0byBtYWtlIGEgcmVxdWVzdCBpcyB0byBnZW5lcmF0ZSB0aGUgY2FsbGJhY2sgbmFtZSwgYW5kIHJlcGxhY2UgdGhlXG4gICAgICAgICAgICAvLyBjYWxsYmFjayBwbGFjZWhvbGRlciBpbiB0aGUgVVJMIHdpdGggdGhlIG5hbWUuIENhcmUgaGFzIHRvIGJlIHRha2VuIGhlcmUgdG8gZW5zdXJlXG4gICAgICAgICAgICAvLyBhIHRyYWlsaW5nICYsIGlmIG1hdGNoZWQsIGdldHMgaW5zZXJ0ZWQgYmFjayBpbnRvIHRoZSBVUkwgaW4gdGhlIGNvcnJlY3QgcGxhY2UuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYWxsYmFjayA9IF90aGlzLm5leHRDYWxsYmFjaygpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsID0gcmVxLnVybFdpdGhQYXJhbXMucmVwbGFjZSgvPUpTT05QX0NBTExCQUNLKCZ8JCkvLCBcIj1cIiArIGNhbGxiYWNrICsgXCIkMVwiKTtcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgPHNjcmlwdD4gdGFnIGFuZCBwb2ludCBpdCBhdCB0aGUgVVJMLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZSA9IF90aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgbm9kZS5zcmMgPSB1cmw7XG4gICAgICAgICAgICAvLyBBIEpTT05QIHJlcXVlc3QgcmVxdWlyZXMgd2FpdGluZyBmb3IgbXVsdGlwbGUgY2FsbGJhY2tzLiBUaGVzZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIC8vIGFyZSBjbG9zZWQgb3ZlciBhbmQgdHJhY2sgc3RhdGUgYWNyb3NzIHRob3NlIGNhbGxiYWNrcy5cbiAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZSBvYmplY3QsIGlmIG9uZSBoYXMgYmVlbiByZWNlaXZlZCwgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib2R5ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgdGhlIHJlc3BvbnNlIGNhbGxiYWNrIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBXaGV0aGVyIHRoZSByZXF1ZXN0IGhhcyBiZWVuIGNhbmNlbGxlZCAoYW5kIHRodXMgYW55IG90aGVyIGNhbGxiYWNrcylcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHJlc3BvbnNlIGNhbGxiYWNrIGluIHRoaXMuY2FsbGJhY2tNYXAgKHdoaWNoIHdpbGwgYmUgdGhlIHdpbmRvd1xuICAgICAgICAgICAgLy8gb2JqZWN0IGluIHRoZSBicm93c2VyLiBUaGUgc2NyaXB0IGJlaW5nIGxvYWRlZCB2aWEgdGhlIDxzY3JpcHQ+IHRhZyB3aWxsXG4gICAgICAgICAgICAvLyBldmVudHVhbGx5IGNhbGwgdGhpcyBjYWxsYmFjay5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgcmVzcG9uc2UgY2FsbGJhY2sgaW4gdGhpcy5jYWxsYmFja01hcCAod2hpY2ggd2lsbCBiZSB0aGUgd2luZG93XG4gICAgICAgICAgICAvLyBvYmplY3QgaW4gdGhlIGJyb3dzZXIuIFRoZSBzY3JpcHQgYmVpbmcgbG9hZGVkIHZpYSB0aGUgPHNjcmlwdD4gdGFnIHdpbGxcbiAgICAgICAgICAgIC8vIGV2ZW50dWFsbHkgY2FsbCB0aGlzIGNhbGxiYWNrLlxuICAgICAgICAgICAgX3RoaXMuY2FsbGJhY2tNYXBbY2FsbGJhY2tdID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRhIGhhcyBiZWVuIHJlY2VpdmVkIGZyb20gdGhlIEpTT05QIHNjcmlwdC4gRmlyc3RseSwgZGVsZXRlIHRoaXMgY2FsbGJhY2suXG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLmNhbGxiYWNrTWFwW2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICAvLyBOZXh0LCBtYWtlIHN1cmUgdGhlIHJlcXVlc3Qgd2Fzbid0IGNhbmNlbGxlZCBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNldCBzdGF0ZSB0byBpbmRpY2F0ZSBkYXRhIHdhcyByZWNlaXZlZC5cbiAgICAgICAgICAgICAgICBib2R5ID0gZGF0YTtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY2xlYW51cCgpIGlzIGEgdXRpbGl0eSBjbG9zdXJlIHRoYXQgcmVtb3ZlcyB0aGUgPHNjcmlwdD4gZnJvbSB0aGUgcGFnZSBhbmRcbiAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBjYWxsYmFjayBmcm9tIHRoZSB3aW5kb3cuIFRoaXMgbG9naWMgaXMgdXNlZCBpbiBib3RoIHRoZVxuICAgICAgICAgICAgLy8gc3VjY2VzcywgZXJyb3IsIGFuZCBjYW5jZWxsYXRpb24gcGF0aHMsIHNvIGl0J3MgZXh0cmFjdGVkIG91dCBmb3IgY29udmVuaWVuY2UuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgPHNjcmlwdD4gdGFnIGlmIGl0J3Mgc3RpbGwgb24gdGhlIHBhZ2UuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcmVzcG9uc2UgY2FsbGJhY2sgZnJvbSB0aGUgY2FsbGJhY2tNYXAgKHdpbmRvdyBvYmplY3QgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYnJvd3NlcikuXG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLmNhbGxiYWNrTWFwW2NhbGxiYWNrXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBvbkxvYWQoKSBpcyB0aGUgc3VjY2VzcyBjYWxsYmFjayB3aGljaCBydW5zIGFmdGVyIHRoZSByZXNwb25zZSBjYWxsYmFja1xuICAgICAgICAgICAgLy8gaWYgdGhlIEpTT05QIHNjcmlwdCBsb2FkcyBzdWNjZXNzZnVsbHkuIFRoZSBldmVudCBpdHNlbGYgaXMgdW5pbXBvcnRhbnQuXG4gICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgd2VudCB3cm9uZywgb25Mb2FkKCkgbWF5IHJ1biB3aXRob3V0IHRoZSByZXNwb25zZSBjYWxsYmFja1xuICAgICAgICAgICAgLy8gaGF2aW5nIGJlZW4gaW52b2tlZC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9uTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIHJlcXVlc3QgaGFzIGJlZW4gY2FuY2VsbGVkLlxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDbGVhbnVwIHRoZSBwYWdlLlxuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByZXNwb25zZSBjYWxsYmFjayBoYXMgcnVuLlxuICAgICAgICAgICAgICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgaGFzbid0LCBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIHRoZSByZXF1ZXN0LiBSZXR1cm4gYW4gZXJyb3IgdmlhXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBPYnNlcnZhYmxlIGVycm9yIHBhdGguIEFsbCBKU09OUCBlcnJvcnMgaGF2ZSBzdGF0dXMgMC5cbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmV3IEh0dHBFcnJvclJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogJ0pTT05QIEVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoSlNPTlBfRVJSX05PX0NBTExCQUNLKSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MuIGJvZHkgZWl0aGVyIGNvbnRhaW5zIHRoZSByZXNwb25zZSBib2R5IG9yIG51bGwgaWYgbm9uZSB3YXNcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5lZC5cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KG5ldyBIdHRwUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogJ09LJywgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlIHRoZSBzdHJlYW0sIHRoZSByZXNwb3NuZSBpcyBvdmVyLlxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gb25FcnJvcigpIGlzIHRoZSBlcnJvciBjYWxsYmFjaywgd2hpY2ggcnVucyBpZiB0aGUgc2NyaXB0IHJldHVybmVkIGdlbmVyYXRlc1xuICAgICAgICAgICAgLy8gYSBKYXZhc2NyaXB0IGVycm9yLiBJdCBlbWl0cyB0aGUgZXJyb3IgdmlhIHRoZSBPYnNlcnZhYmxlIGVycm9yIGNoYW5uZWwgYXNcbiAgICAgICAgICAgIC8vIGEgSHR0cEVycm9yUmVzcG9uc2UuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3Qgd2FzIGFscmVhZHkgY2FuY2VsbGVkLCBubyBuZWVkIHRvIGVtaXQgYW55dGhpbmcuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAvLyBXcmFwIHRoZSBlcnJvciBpbiBhIEh0dHBFcnJvclJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKG5ldyBIdHRwRXJyb3JSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiAnSlNPTlAgRXJyb3InLCB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGJvdGggdGhlIHN1Y2Nlc3MgKGxvYWQpIGFuZCBlcnJvciBldmVudHMgb24gdGhlIDxzY3JpcHQ+IHRhZyxcbiAgICAgICAgICAgIC8vIGFuZCBhZGQgaXQgdG8gdGhlIHBhZ2UuXG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgX3RoaXMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IGhhcyBub3cgYmVlbiBzdWNjZXNzZnVsbHkgc2VudC5cbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeyB0eXBlOiBIdHRwRXZlbnRUeXBlLlNlbnQgfSk7XG4gICAgICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFuZGxlci5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgdGhlIGNhbmNlbGxhdGlvbiBzbyBldmVudCBsaXN0ZW5lcnMgd29uJ3QgZG8gYW55dGhpbmcgZXZlbiBpZiBhbHJlYWR5IHNjaGVkdWxlZC5cbiAgICAgICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzIHNvIHRoZXkgd29uJ3QgcnVuIGlmIHRoZSBldmVudHMgbGF0ZXIgZmlyZS5cbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBBbmQgZmluYWxseSwgY2xlYW4gdXAgdGhlIHBhZ2UuXG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKc29ucENsaWVudEJhY2tlbmQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEpzb25wQ2xpZW50QmFja2VuZC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBKc29ucENhbGxiYWNrQ29udGV4dCwgfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29tbW9uLkRPQ1VNRU5ULF0gfSxdIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gSnNvbnBDbGllbnRCYWNrZW5kO1xufSgpKTtcbi8qKlxuICogQW4gYEh0dHBJbnRlcmNlcHRvcmAgd2hpY2ggaWRlbnRpZmllcyByZXF1ZXN0cyB3aXRoIHRoZSBtZXRob2QgSlNPTlAgYW5kXG4gKiBzaGlmdHMgdGhlbSB0byB0aGUgYEpzb25wQ2xpZW50QmFja2VuZGAuXG4gKlxuICogXFxAc3RhYmxlXG4gKi9cbnZhciBKc29ucEludGVyY2VwdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpzb25wSW50ZXJjZXB0b3IoanNvbnApIHtcbiAgICAgICAgdGhpcy5qc29ucCA9IGpzb25wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSnNvbnBJbnRlcmNlcHRvci5wcm90b3R5cGUuaW50ZXJjZXB0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgKiBAcGFyYW0gez99IG5leHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXEsIG5leHQpIHtcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09ICdKU09OUCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmpzb25wLmhhbmRsZSgvKiogQHR5cGUgez99ICovIChyZXEpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsIHRocm91Z2ggZm9yIG5vcm1hbCBIVFRQIHJlcXVlc3RzLlxuICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICB9O1xuICAgIEpzb25wSW50ZXJjZXB0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEpzb25wSW50ZXJjZXB0b3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogSnNvbnBDbGllbnRCYWNrZW5kLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIEpzb25wSW50ZXJjZXB0b3I7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgWFNTSV9QUkVGSVggPSAvXlxcKVxcXVxcfScsP1xcbi87XG4vKipcbiAqIERldGVybWluZSBhbiBhcHByb3ByaWF0ZSBVUkwgZm9yIHRoZSByZXNwb25zZSwgYnkgY2hlY2tpbmcgZWl0aGVyXG4gKiBYTUxIdHRwUmVxdWVzdC5yZXNwb25zZVVSTCBvciB0aGUgWC1SZXF1ZXN0LVVSTCBoZWFkZXIuXG4gKiBAcGFyYW0gez99IHhoclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0UmVzcG9uc2VVcmwoeGhyKSB7XG4gICAgaWYgKCdyZXNwb25zZVVSTCcgaW4geGhyICYmIHhoci5yZXNwb25zZVVSTCkge1xuICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVVJMO1xuICAgIH1cbiAgICBpZiAoL15YLVJlcXVlc3QtVVJMOi9tLnRlc3QoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgICByZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLVJlcXVlc3QtVVJMJyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBgWE1MSHR0cFJlcXVlc3RgIGNvbnN0cnVjdG9yLlxuICpcbiAqIFxcQHN0YWJsZVxuICogQGFic3RyYWN0XG4gKi9cbnZhciBYaHJGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhockZhY3RvcnkoKSB7XG4gICAgfVxuICAgIHJldHVybiBYaHJGYWN0b3J5O1xufSgpKTtcbi8qKlxuICogQSBmYWN0b3J5IGZvciBcXEB7bGluayBIdHRwWGhyQmFja2VuZH0gdGhhdCB1c2VzIHRoZSBgWE1MSHR0cFJlcXVlc3RgIGJyb3dzZXIgQVBJLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgQnJvd3NlclhociA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VyWGhyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJyb3dzZXJYaHIucHJvdG90eXBlLmJ1aWxkID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAvKiogQHR5cGUgez99ICovICgobmV3IFhNTEh0dHBSZXF1ZXN0KCkpKTsgfTtcbiAgICBCcm93c2VyWGhyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBCcm93c2VyWGhyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIEJyb3dzZXJYaHI7XG59KCkpO1xuLyoqXG4gKiBBbiBgSHR0cEJhY2tlbmRgIHdoaWNoIHVzZXMgdGhlIFhNTEh0dHBSZXF1ZXN0IEFQSSB0byBzZW5kXG4gKiByZXF1ZXN0cyB0byBhIGJhY2tlbmQgc2VydmVyLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgSHR0cFhockJhY2tlbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cFhockJhY2tlbmQoeGhyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnhockZhY3RvcnkgPSB4aHJGYWN0b3J5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgcmVxdWVzdCBhbmQgcmV0dXJuIGEgc3RyZWFtIG9mIHJlc3BvbnNlIGV2ZW50cy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgcmVxdWVzdCBhbmQgcmV0dXJuIGEgc3RyZWFtIG9mIHJlc3BvbnNlIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cFhockJhY2tlbmQucHJvdG90eXBlLmhhbmRsZSA9IC8qKlxuICAgICAqIFByb2Nlc3MgYSByZXF1ZXN0IGFuZCByZXR1cm4gYSBzdHJlYW0gb2YgcmVzcG9uc2UgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFF1aWNrIGNoZWNrIHRvIGdpdmUgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZSB3aGVuIGEgdXNlciBhdHRlbXB0cyB0byB1c2VcbiAgICAgICAgLy8gSHR0cENsaWVudC5qc29ucCgpIHdpdGhvdXQgaW5zdGFsbGluZyB0aGUgSnNvbnBDbGllbnRNb2R1bGVcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09ICdKU09OUCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBjb25zdHJ1Y3QgSnNvbnAgcmVxdWVzdCB3aXRob3V0IEpzb25wQ2xpZW50TW9kdWxlIGluc3RhbGxlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZlcnl0aGluZyBoYXBwZW5zIG9uIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICByZXR1cm4gbmV3IHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgLy8gU3RhcnQgYnkgc2V0dGluZyB1cCB0aGUgWEhSIG9iamVjdCB3aXRoIHJlcXVlc3QgbWV0aG9kLCBVUkwsIGFuZCB3aXRoQ3JlZGVudGlhbHMgZmxhZy5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhociA9IF90aGlzLnhockZhY3RvcnkuYnVpbGQoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKHJlcS5tZXRob2QsIHJlcS51cmxXaXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGlmICghIXJlcS53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBhbGwgdGhlIHJlcXVlc3RlZCBoZWFkZXJzLlxuICAgICAgICAgICAgcmVxLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgdmFsdWVzKSB7IHJldHVybiB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZXMuam9pbignLCcpKTsgfSk7XG4gICAgICAgICAgICAvLyBBZGQgYW4gQWNjZXB0IGhlYWRlciBpZiBvbmUgaXNuJ3QgcHJlc2VudCBhbHJlYWR5LlxuICAgICAgICAgICAgaWYgKCFyZXEuaGVhZGVycy5oYXMoJ0FjY2VwdCcpKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF1dG8tZGV0ZWN0IHRoZSBDb250ZW50LVR5cGUgaGVhZGVyIGlmIG9uZSBpc24ndCBwcmVzZW50IGFscmVhZHkuXG4gICAgICAgICAgICBpZiAoIXJlcS5oZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRlY3RlZFR5cGUgPSByZXEuZGV0ZWN0Q29udGVudFR5cGVIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgQ29udGVudC1UeXBlIGRldGVjdGlvbiBmYWlscy5cbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWRUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBkZXRlY3RlZFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB0aGUgcmVzcG9uc2VUeXBlIGlmIG9uZSB3YXMgcmVxdWVzdGVkLlxuICAgICAgICAgICAgaWYgKHJlcS5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNwb25zZVR5cGUgPSByZXEucmVzcG9uc2VUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgLy8gSlNPTiByZXNwb25zZXMgbmVlZCB0byBiZSBwcm9jZXNzZWQgYXMgdGV4dC4gVGhpcyBpcyBiZWNhdXNlIGlmIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGFuIFhTU0ktcHJlZml4ZWQgSlNPTiByZXNwb25zZSwgdGhlIGJyb3dzZXIgd2lsbCBmYWlsIHRvIHBhcnNlIGl0LFxuICAgICAgICAgICAgICAgIC8vIHhoci5yZXNwb25zZSB3aWxsIGJlIG51bGwsIGFuZCB4aHIucmVzcG9uc2VUZXh0IGNhbm5vdCBiZSBhY2Nlc3NlZCB0b1xuICAgICAgICAgICAgICAgIC8vIHJldHJpZXZlIHRoZSBwcmVmaXhlZCBKU09OIGRhdGEgaW4gb3JkZXIgdG8gc3RyaXAgdGhlIHByZWZpeC4gVGh1cywgYWxsIEpTT05cbiAgICAgICAgICAgICAgICAvLyBpcyBwYXJzZWQgYnkgZmlyc3QgcmVxdWVzdGluZyB0ZXh0IGFuZCB0aGVuIGFwcGx5aW5nIEpTT04ucGFyc2UuXG4gICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IC8qKiBAdHlwZSB7P30gKi8gKCgocmVzcG9uc2VUeXBlICE9PSAnanNvbicpID8gcmVzcG9uc2VUeXBlIDogJ3RleHQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgdGhlIHJlcXVlc3QgYm9keSBpZiBvbmUgaXMgcHJlc2VudC4gSWYgbm90LCB0aGlzIHdpbGwgYmUgc2V0IHRvIG51bGwuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXFCb2R5ID0gcmVxLnNlcmlhbGl6ZUJvZHkoKTtcbiAgICAgICAgICAgIC8vIElmIHByb2dyZXNzIGV2ZW50cyBhcmUgZW5hYmxlZCwgcmVzcG9uc2UgaGVhZGVycyB3aWxsIGJlIGRlbGl2ZXJlZFxuICAgICAgICAgICAgLy8gaW4gdHdvIGV2ZW50cyAtIHRoZSBIdHRwSGVhZGVyUmVzcG9uc2UgZXZlbnQgYW5kIHRoZSBmdWxsIEh0dHBSZXNwb25zZVxuICAgICAgICAgICAgLy8gZXZlbnQuIEhvd2V2ZXIsIHNpbmNlIHJlc3BvbnNlIGhlYWRlcnMgZG9uJ3QgY2hhbmdlIGluIGJldHdlZW4gdGhlc2VcbiAgICAgICAgICAgIC8vIHR3byBldmVudHMsIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBwYXJzZSB0aGVtIHR3aWNlLiBTbyBoZWFkZXJSZXNwb25zZVxuICAgICAgICAgICAgLy8gY2FjaGVzIHRoZSBkYXRhIGV4dHJhY3RlZCBmcm9tIHRoZSByZXNwb25zZSB3aGVuZXZlciBpdCdzIGZpcnN0IHBhcnNlZCxcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBwYXJzaW5nIGlzbid0IGR1cGxpY2F0ZWQuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZWFkZXJSZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBwYXJ0aWFsRnJvbVhociBleHRyYWN0cyB0aGUgSHR0cEhlYWRlclJlc3BvbnNlIGZyb20gdGhlIGN1cnJlbnQgWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgICAgIC8vIHN0YXRlLCBhbmQgbWVtb2l6ZXMgaXQgaW50byBoZWFkZXJSZXNwb25zZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRpYWxGcm9tWGhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJSZXNwb25zZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlYWQgc3RhdHVzIGFuZCBub3JtYWxpemUgYW4gSUU5IGJ1ZyAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MCkuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdHVzID0geGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdHVzVGV4dCA9IHhoci5zdGF0dXNUZXh0IHx8ICdPSyc7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgaGVhZGVycyBmcm9tIFhNTEh0dHBSZXF1ZXN0IC0gdGhpcyBzdGVwIGlzIGxhenkuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGVhZGVycyA9IG5ldyBIdHRwSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIHJlc3BvbnNlIFVSTCBmcm9tIHRoZSBYTUxIdHRwUmVzcG9uc2UgaW5zdGFuY2UgYW5kIGZhbGwgYmFjayBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IFVSTC5cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmwgPSBnZXRSZXNwb25zZVVybCh4aHIpIHx8IHJlcS51cmw7XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBIdHRwSGVhZGVyUmVzcG9uc2UgYW5kIG1lbW9pemUgaXQuXG4gICAgICAgICAgICAgICAgaGVhZGVyUmVzcG9uc2UgPSBuZXcgSHR0cEhlYWRlclJlc3BvbnNlKHsgaGVhZGVyczogaGVhZGVycywgc3RhdHVzOiBzdGF0dXMsIHN0YXR1c1RleHQ6IHN0YXR1c1RleHQsIHVybDogdXJsIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJSZXNwb25zZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBOZXh0LCBhIGZldyBjbG9zdXJlcyBhcmUgZGVmaW5lZCBmb3IgdGhlIHZhcmlvdXMgZXZlbnRzIHdoaWNoIFhNTEh0dHBSZXF1ZXN0IGNhblxuICAgICAgICAgICAgLy8gZW1pdC4gVGhpcyBhbGxvd3MgdGhlbSB0byBiZSB1bnJlZ2lzdGVyZWQgYXMgZXZlbnQgbGlzdGVuZXJzIGxhdGVyLlxuICAgICAgICAgICAgLy8gRmlyc3QgdXAgaXMgdGhlIGxvYWQgZXZlbnQsIHdoaWNoIHJlcHJlc2VudHMgYSByZXNwb25zZSBiZWluZyBmdWxseSBhdmFpbGFibGUuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhZCByZXNwb25zZSBzdGF0ZSBmcm9tIHRoZSBtZW1vaXplZCBwYXJ0aWFsIGRhdGEuXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gcGFydGlhbEZyb21YaHIoKSwgaGVhZGVycyA9IF9hLmhlYWRlcnMsIHN0YXR1cyA9IF9hLnN0YXR1cywgc3RhdHVzVGV4dCA9IF9hLnN0YXR1c1RleHQsIHVybCA9IF9hLnVybDtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYm9keSB3aWxsIGJlIHJlYWQgb3V0IGlmIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBYTUxIdHRwUmVxdWVzdC5yZXNwb25zZSBpZiBzZXQsIHJlc3BvbnNlVGV4dCBvdGhlcndpc2UuXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSAodHlwZW9mIHhoci5yZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpID8geGhyLnJlc3BvbnNlVGV4dCA6IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsaXplIGFub3RoZXIgcG90ZW50aWFsIGJ1ZyAodGhpcyBvbmUgY29tZXMgZnJvbSBDT1JTKS5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICEhYm9keSA/IDIwMCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9rIGRldGVybWluZXMgd2hldGhlciB0aGUgcmVzcG9uc2Ugd2lsbCBiZSB0cmFuc21pdHRlZCBvbiB0aGUgZXZlbnQgb3JcbiAgICAgICAgICAgICAgICAvLyBlcnJvciBjaGFubmVsLiBVbnN1Y2Nlc3NmdWwgc3RhdHVzIGNvZGVzIChub3QgMnh4KSB3aWxsIGFsd2F5cyBiZSBlcnJvcnMsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGEgc3VjY2Vzc2Z1bCBzdGF0dXMgY29kZSBjYW4gc3RpbGwgcmVzdWx0IGluIGFuIGVycm9yIGlmIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgLy8gYXNrZWQgZm9yIEpTT04gZGF0YSBhbmQgdGhlIGJvZHkgY2Fubm90IGJlIHBhcnNlZCBhcyBzdWNoLlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9rID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgYm9keSBuZWVkcyB0byBiZSBwYXJzZWQgYXMgSlNPTiAoaW4gbWFueSBjYXNlcyB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIHdpbGwgaGF2ZSBkb25lIHRoYXQgYWxyZWFkeSkuXG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiB0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgb3JpZ2luYWwgYm9keSwgYmVmb3JlIGF0dGVtcHRpbmcgWFNTSSBwcmVmaXggc3RyaXBwaW5nLlxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5hbEJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gYm9keS5yZXBsYWNlKFhTU0lfUFJFRklYLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRoZSBwYXJzZS4gSWYgaXQgZmFpbHMsIGEgcGFyc2UgZXJyb3Igc2hvdWxkIGJlIGRlbGl2ZXJlZCB0byB0aGUgdXNlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSAnJyA/IEpTT04ucGFyc2UoYm9keSkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoICgvKiogQHR5cGUgez99ICovIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgSlNPTi5wYXJzZSBmYWlsZWQsIGl0J3MgcmVhc29uYWJsZSB0byBhc3N1bWUgdGhpcyBtaWdodCBub3QgaGF2ZSBiZWVuIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpTT04gcmVzcG9uc2UuIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGJvZHkgKGluY2x1ZGluZyBhbnkgWFNTSSBwcmVmaXgpIHRvIGRlbGl2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgYmV0dGVyIGVycm9yIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IG9yaWdpbmFsQm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGFuIGVycm9yIHJlcXVlc3QgdG8gYmVnaW4gd2l0aCwgbGVhdmUgaXQgYXMgYSBzdHJpbmcsIGl0IHByb2JhYmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGlzbid0IEpTT04uIE90aGVyd2lzZSwgZGVsaXZlciB0aGUgcGFyc2luZyBlcnJvciB0byB0aGUgdXNlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2ZW4gdGhvdWdoIHRoZSByZXNwb25zZSBzdGF0dXMgd2FzIDJ4eCwgdGhpcyBpcyBzdGlsbCBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwYXJzZSBlcnJvciBjb250YWlucyB0aGUgdGV4dCBvZiB0aGUgYm9keSB0aGF0IGZhaWxlZCB0byBwYXJzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gLyoqIEB0eXBlIHs/fSAqLyAoeyBlcnJvcjogZXJyb3IsIHRleHQ6IGJvZHkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgc3VjY2Vzc2Z1bCByZXNwb25zZSBpcyBkZWxpdmVyZWQgb24gdGhlIGV2ZW50IHN0cmVhbS5cbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChuZXcgSHR0cFJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmdWxsIGJvZHkgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIGRlbGl2ZXJlZCwgbm8gZnVydGhlciBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHBvc3NpYmxlLiBUaGlzIHJlcXVlc3QgaXMgY29tcGxldGUuXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bnN1Y2Nlc3NmdWwgcmVxdWVzdCBpcyBkZWxpdmVyZWQgb24gdGhlIGVycm9yIGNoYW5uZWwuXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKG5ldyBIdHRwRXJyb3JSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZXJyb3IgaW4gdGhpcyBjYXNlIGlzIHRoZSByZXNwb25zZSBib2R5IChlcnJvciBmcm9tIHRoZSBzZXJ2ZXIpLlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFRoZSBvbkVycm9yIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHNvbWV0aGluZyBnb2VzIHdyb25nIGF0IHRoZSBuZXR3b3JrIGxldmVsLlxuICAgICAgICAgICAgLy8gQ29ubmVjdGlvbiB0aW1lb3V0LCBETlMgZXJyb3IsIG9mZmxpbmUsIGV0Yy4gVGhlc2UgYXJlIGFjdHVhbCBlcnJvcnMsIGFuZCBhcmVcbiAgICAgICAgICAgIC8vIHRyYW5zbWl0dGVkIG9uIHRoZSBlcnJvciBjaGFubmVsLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IG5ldyBIdHRwRXJyb3JSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0IHx8ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihyZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFRoZSBzZW50SGVhZGVycyBmbGFnIHRyYWNrcyB3aGV0aGVyIHRoZSBIdHRwUmVzcG9uc2VIZWFkZXJzIGV2ZW50XG4gICAgICAgICAgICAvLyBoYXMgYmVlbiBzZW50IG9uIHRoZSBzdHJlYW0uIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHRyYWNrIGlmIHByb2dyZXNzXG4gICAgICAgICAgICAvLyBpcyBlbmFibGVkIHNpbmNlIHRoZSBldmVudCB3aWxsIGJlIHNlbnQgb24gb25seSB0aGUgZmlyc3QgZG93bmxvYWRcbiAgICAgICAgICAgIC8vIHByb2dlcnNzIGV2ZW50LlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VudEhlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRoZSBkb3dubG9hZCBwcm9ncmVzcyBldmVudCBoYW5kbGVyLCB3aGljaCBpcyBvbmx5IHJlZ2lzdGVyZWQgaWZcbiAgICAgICAgICAgIC8vIHByb2dyZXNzIGV2ZW50cyBhcmUgZW5hYmxlZC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9uRG93blByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgSHR0cFJlc3BvbnNlSGVhZGVycyBldmVudCBpZiBpdCBoYXNuJ3QgYmVlbiBzZW50IGFscmVhZHkuXG4gICAgICAgICAgICAgICAgaWYgKCFzZW50SGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHBhcnRpYWxGcm9tWGhyKCkpO1xuICAgICAgICAgICAgICAgICAgICBzZW50SGVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGJ1aWxkaW5nIHRoZSBkb3dubG9hZCBwcm9ncmVzcyBldmVudCB0byBkZWxpdmVyIG9uIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIGV2ZW50IHN0cmVhbS5cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9ncmVzc0V2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBIdHRwRXZlbnRUeXBlLkRvd25sb2FkUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDogZXZlbnQubG9hZGVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIGV2ZW50IGlmIGl0J3MgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzRXZlbnQudG90YWwgPSBldmVudC50b3RhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3Qgd2FzIGZvciB0ZXh0IGNvbnRlbnQgYW5kIGEgcGFydGlhbCByZXNwb25zZSBpc1xuICAgICAgICAgICAgICAgIC8vIGF2YWlsYWJsZSBvbiBYTUxIdHRwUmVxdWVzdCwgaW5jbHVkZSBpdCBpbiB0aGUgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0byBhbGxvdyBmb3Igc3RyZWFtaW5nIHJlYWRzLlxuICAgICAgICAgICAgICAgIGlmIChyZXEucmVzcG9uc2VUeXBlID09PSAndGV4dCcgJiYgISF4aHIucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzRXZlbnQucGFydGlhbFRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBmaXJlIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHByb2dyZXNzRXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFRoZSB1cGxvYWQgcHJvZ3Jlc3MgZXZlbnQgaGFuZGxlciwgd2hpY2ggaXMgb25seSByZWdpc3RlcmVkIGlmXG4gICAgICAgICAgICAvLyBwcm9ncmVzcyBldmVudHMgYXJlIGVuYWJsZWQuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvblVwUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGxvYWQgcHJvZ3Jlc3MgZXZlbnRzIGFyZSBzaW1wbGVyLiBCZWdpbiBidWlsZGluZyB0aGUgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAvLyBldmVudC5cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9ncmVzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSHR0cEV2ZW50VHlwZS5VcGxvYWRQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiBldmVudC5sb2FkZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGJlaW5nIHVwbG9hZGVkIGlzIGF2YWlsYWJsZSwgaW5jbHVkZVxuICAgICAgICAgICAgICAgIC8vIGl0LlxuICAgICAgICAgICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHJlZ2lzdGVyIGZvciBsb2FkIGFuZCBlcnJvciBldmVudHMuXG4gICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgIC8vIFByb2dyZXNzIGV2ZW50cyBhcmUgb25seSBlbmFibGVkIGlmIHJlcXVlc3RlZC5cbiAgICAgICAgICAgIGlmIChyZXEucmVwb3J0UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBEb3dubG9hZCBwcm9ncmVzcyBpcyBhbHdheXMgZW5hYmxlZCBpZiByZXF1ZXN0ZWQuXG4gICAgICAgICAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgb25Eb3duUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIC8vIFVwbG9hZCBwcm9ncmVzcyBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlcmUgaXMgYSBib2R5IHRvIHVwbG9hZC5cbiAgICAgICAgICAgICAgICBpZiAocmVxQm9keSAhPT0gbnVsbCAmJiB4aHIudXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBvblVwUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcmUgdGhlIHJlcXVlc3QsIGFuZCBub3RpZnkgdGhlIGV2ZW50IHN0cmVhbSB0aGF0IGl0IHdhcyBmaXJlZC5cbiAgICAgICAgICAgIHhoci5zZW5kKHJlcUJvZHkpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7IHR5cGU6IEh0dHBFdmVudFR5cGUuU2VudCB9KTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJldHVybiBmcm9tIHRoZSBPYnNlcnZhYmxlIGZ1bmN0aW9uLCB3aGljaCBpcyB0aGVcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgY2FuY2VsbGF0aW9uIGhhbmRsZXIuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIE9uIGEgY2FuY2VsbGF0aW9uLCByZW1vdmUgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICAgIHhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIHhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnJlcG9ydFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIG9uRG93blByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcUJvZHkgIT09IG51bGwgJiYgeGhyLnVwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnVwbG9hZC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIG9uVXBQcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgYWJvcnQgdGhlIGluLWZsaWdodCByZXF1ZXN0LlxuICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdHRwWGhyQmFja2VuZC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSHR0cFhockJhY2tlbmQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogWGhyRmFjdG9yeSwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBIdHRwWGhyQmFja2VuZDtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBYU1JGX0NPT0tJRV9OQU1FID0gbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0aW9uVG9rZW4oJ1hTUkZfQ09PS0lFX05BTUUnKTtcbnZhciBYU1JGX0hFQURFUl9OQU1FID0gbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0aW9uVG9rZW4oJ1hTUkZfSEVBREVSX05BTUUnKTtcbi8qKlxuICogUmV0cmlldmVzIHRoZSBjdXJyZW50IFhTUkYgdG9rZW4gdG8gdXNlIHdpdGggdGhlIG5leHQgb3V0Z29pbmcgcmVxdWVzdC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgSHR0cFhzcmZUb2tlbkV4dHJhY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwWHNyZlRva2VuRXh0cmFjdG9yKCkge1xuICAgIH1cbiAgICByZXR1cm4gSHR0cFhzcmZUb2tlbkV4dHJhY3Rvcjtcbn0oKSk7XG4vKipcbiAqIGBIdHRwWHNyZlRva2VuRXh0cmFjdG9yYCB3aGljaCByZXRyaWV2ZXMgdGhlIHRva2VuIGZyb20gYSBjb29raWUuXG4gKi9cbnZhciBIdHRwWHNyZkNvb2tpZUV4dHJhY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwWHNyZkNvb2tpZUV4dHJhY3Rvcihkb2MsIHBsYXRmb3JtLCBjb29raWVOYW1lKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIHRoaXMuY29va2llTmFtZSA9IGNvb2tpZU5hbWU7XG4gICAgICAgIHRoaXMubGFzdENvb2tpZVN0cmluZyA9ICcnO1xuICAgICAgICB0aGlzLmxhc3RUb2tlbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbCBmb3IgdGVzdGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJzZUNvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdHRwWHNyZkNvb2tpZUV4dHJhY3Rvci5wcm90b3R5cGUuZ2V0VG9rZW4gPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0gPT09ICdzZXJ2ZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb29raWVTdHJpbmcgPSB0aGlzLmRvYy5jb29raWUgfHwgJyc7XG4gICAgICAgIGlmIChjb29raWVTdHJpbmcgIT09IHRoaXMubGFzdENvb2tpZVN0cmluZykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUNvdW50Kys7XG4gICAgICAgICAgICB0aGlzLmxhc3RUb2tlbiA9IF9hbmd1bGFyX2NvbW1vbi7JtXBhcnNlQ29va2llVmFsdWUoY29va2llU3RyaW5nLCB0aGlzLmNvb2tpZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29va2llU3RyaW5nID0gY29va2llU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RUb2tlbjtcbiAgICB9O1xuICAgIEh0dHBYc3JmQ29va2llRXh0cmFjdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBIdHRwWHNyZkNvb2tpZUV4dHJhY3Rvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29tbW9uLkRPQ1VNRU5ULF0gfSxdIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuUExBVEZPUk1fSUQsXSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbWFNSRl9DT09LSUVfTkFNRSxdIH0sXSB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIEh0dHBYc3JmQ29va2llRXh0cmFjdG9yO1xufSgpKTtcbi8qKlxuICogYEh0dHBJbnRlcmNlcHRvcmAgd2hpY2ggYWRkcyBhbiBYU1JGIHRva2VuIHRvIGVsaWdpYmxlIG91dGdvaW5nIHJlcXVlc3RzLlxuICovXG52YXIgSHR0cFhzcmZJbnRlcmNlcHRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwWHNyZkludGVyY2VwdG9yKHRva2VuU2VydmljZSwgaGVhZGVyTmFtZSkge1xuICAgICAgICB0aGlzLnRva2VuU2VydmljZSA9IHRva2VuU2VydmljZTtcbiAgICAgICAgdGhpcy5oZWFkZXJOYW1lID0gaGVhZGVyTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgKiBAcGFyYW0gez99IG5leHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBYc3JmSW50ZXJjZXB0b3IucHJvdG90eXBlLmludGVyY2VwdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHBhcmFtIHs/fSBuZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVxLCBuZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxjVXJsID0gcmVxLnVybC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBTa2lwIGJvdGggbm9uLW11dGF0aW5nIHJlcXVlc3RzIGFuZCBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAvLyBOb24tbXV0YXRpbmcgcmVxdWVzdHMgZG9uJ3QgcmVxdWlyZSBhIHRva2VuLCBhbmQgYWJzb2x1dGUgVVJMcyByZXF1aXJlIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAgICAgLy8gYW55d2F5IGFzIHRoZSBjb29raWUgc2V0XG4gICAgICAgIC8vIG9uIG91ciBvcmlnaW4gaXMgbm90IHRoZSBzYW1lIGFzIHRoZSB0b2tlbiBleHBlY3RlZCBieSBhbm90aGVyIG9yaWdpbi5cbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09ICdHRVQnIHx8IHJlcS5tZXRob2QgPT09ICdIRUFEJyB8fCBsY1VybC5zdGFydHNXaXRoKCdodHRwOi8vJykgfHxcbiAgICAgICAgICAgIGxjVXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuID0gdGhpcy50b2tlblNlcnZpY2UuZ2V0VG9rZW4oKTtcbiAgICAgICAgLy8gQmUgY2FyZWZ1bCBub3QgdG8gb3ZlcndyaXRlIGFuIGV4aXN0aW5nIGhlYWRlciBvZiB0aGUgc2FtZSBuYW1lLlxuICAgICAgICBpZiAodG9rZW4gIT09IG51bGwgJiYgIXJlcS5oZWFkZXJzLmhhcyh0aGlzLmhlYWRlck5hbWUpKSB7XG4gICAgICAgICAgICByZXEgPSByZXEuY2xvbmUoeyBoZWFkZXJzOiByZXEuaGVhZGVycy5zZXQodGhpcy5oZWFkZXJOYW1lLCB0b2tlbikgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcSk7XG4gICAgfTtcbiAgICBIdHRwWHNyZkludGVyY2VwdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBIdHRwWHNyZkludGVyY2VwdG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEh0dHBYc3JmVG9rZW5FeHRyYWN0b3IsIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW1hTUkZfSEVBREVSX05BTUUsXSB9LF0gfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBIdHRwWHNyZkludGVyY2VwdG9yO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBbiBgSHR0cEhhbmRsZXJgIHRoYXQgYXBwbGllcyBhIGJ1bmNoIG9mIGBIdHRwSW50ZXJjZXB0b3Jgc1xuICogdG8gYSByZXF1ZXN0IGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBgSHR0cEJhY2tlbmRgLlxuICpcbiAqIFRoZSBpbnRlcmNlcHRvcnMgYXJlIGxvYWRlZCBsYXppbHkgZnJvbSB0aGUgaW5qZWN0b3IsIHRvIGFsbG93XG4gKiBpbnRlcmNlcHRvcnMgdG8gdGhlbXNlbHZlcyBpbmplY3QgY2xhc3NlcyBkZXBlbmRpbmcgaW5kaXJlY3RseVxuICogb24gYEh0dHBJbnRlcmNlcHRpbmdIYW5kbGVyYCBpdHNlbGYuXG4gKi9cbnZhciBIdHRwSW50ZXJjZXB0aW5nSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwSW50ZXJjZXB0aW5nSGFuZGxlcihiYWNrZW5kLCBpbmplY3Rvcikge1xuICAgICAgICB0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMuY2hhaW4gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cEludGVyY2VwdGluZ0hhbmRsZXIucHJvdG90eXBlLmhhbmRsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYWluID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnRlcmNlcHRvcnMgPSB0aGlzLmluamVjdG9yLmdldChIVFRQX0lOVEVSQ0VQVE9SUywgW10pO1xuICAgICAgICAgICAgdGhpcy5jaGFpbiA9IGludGVyY2VwdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbiAobmV4dCwgaW50ZXJjZXB0b3IpIHsgcmV0dXJuIG5ldyBIdHRwSW50ZXJjZXB0b3JIYW5kbGVyKG5leHQsIGludGVyY2VwdG9yKTsgfSwgdGhpcy5iYWNrZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbi5oYW5kbGUocmVxKTtcbiAgICB9O1xuICAgIEh0dHBJbnRlcmNlcHRpbmdIYW5kbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBIdHRwSW50ZXJjZXB0aW5nSGFuZGxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBIdHRwQmFja2VuZCwgfSxcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdG9yLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIEh0dHBJbnRlcmNlcHRpbmdIYW5kbGVyO1xufSgpKTtcbi8qKlxuICogQ29uc3RydWN0cyBhbiBgSHR0cEhhbmRsZXJgIHRoYXQgYXBwbGllcyBhIGJ1bmNoIG9mIGBIdHRwSW50ZXJjZXB0b3Jgc1xuICogdG8gYSByZXF1ZXN0IGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBgSHR0cEJhY2tlbmRgLlxuICpcbiAqIE1lYW50IHRvIGJlIHVzZWQgYXMgYSBmYWN0b3J5IGZ1bmN0aW9uIHdpdGhpbiBgSHR0cENsaWVudE1vZHVsZWAuXG4gKlxuICogXFxAc3RhYmxlXG4gKiBAcGFyYW0gez99IGJhY2tlbmRcbiAqIEBwYXJhbSB7Pz19IGludGVyY2VwdG9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW50ZXJjZXB0aW5nSGFuZGxlcihiYWNrZW5kLCBpbnRlcmNlcHRvcnMpIHtcbiAgICBpZiAoaW50ZXJjZXB0b3JzID09PSB2b2lkIDApIHsgaW50ZXJjZXB0b3JzID0gW107IH1cbiAgICBpZiAoIWludGVyY2VwdG9ycykge1xuICAgICAgICByZXR1cm4gYmFja2VuZDtcbiAgICB9XG4gICAgcmV0dXJuIGludGVyY2VwdG9ycy5yZWR1Y2VSaWdodChmdW5jdGlvbiAobmV4dCwgaW50ZXJjZXB0b3IpIHsgcmV0dXJuIG5ldyBIdHRwSW50ZXJjZXB0b3JIYW5kbGVyKG5leHQsIGludGVyY2VwdG9yKTsgfSwgYmFja2VuZCk7XG59XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXJlIHRvIHN0b3JlIEpTT05QIGNhbGxiYWNrcy5cbiAqXG4gKiBPcmRpbmFyaWx5IEpTT05QIGNhbGxiYWNrcyBhcmUgc3RvcmVkIG9uIHRoZSBgd2luZG93YCBvYmplY3QsIGJ1dCB0aGlzIG1heSBub3QgZXhpc3RcbiAqIGluIHRlc3QgZW52aXJvbm1lbnRzLiBJbiB0aGF0IGNhc2UsIGNhbGxiYWNrcyBhcmUgc3RvcmVkIG9uIGFuIGFub255bW91cyBvYmplY3QgaW5zdGVhZC5cbiAqXG4gKiBcXEBzdGFibGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGpzb25wQ2FsbGJhY2tDb250ZXh0KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG4vKipcbiAqIGBOZ01vZHVsZWAgd2hpY2ggYWRkcyBYU1JGIHByb3RlY3Rpb24gc3VwcG9ydCB0byBvdXRnb2luZyByZXF1ZXN0cy5cbiAqXG4gKiBQcm92aWRlZCB0aGUgc2VydmVyIHN1cHBvcnRzIGEgY29va2llLWJhc2VkIFhTUkYgcHJvdGVjdGlvbiBzeXN0ZW0sIHRoaXNcbiAqIG1vZHVsZSBjYW4gYmUgdXNlZCBkaXJlY3RseSB0byBjb25maWd1cmUgWFNSRiBwcm90ZWN0aW9uIHdpdGggdGhlIGNvcnJlY3RcbiAqIGNvb2tpZSBhbmQgaGVhZGVyIG5hbWVzLlxuICpcbiAqIElmIG5vIHN1Y2ggbmFtZXMgYXJlIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyB0byB1c2UgYFgtWFNSRi1UT0tFTmAgZm9yXG4gKiB0aGUgaGVhZGVyIG5hbWUgYW5kIGBYU1JGLVRPS0VOYCBmb3IgdGhlIGNvb2tpZSBuYW1lLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgSHR0cENsaWVudFhzcmZNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cENsaWVudFhzcmZNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIGRlZmF1bHQgWFNSRiBwcm90ZWN0aW9uLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIGRlZmF1bHQgWFNSRiBwcm90ZWN0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHR0cENsaWVudFhzcmZNb2R1bGUuZGlzYWJsZSA9IC8qKlxuICAgICAqIERpc2FibGUgdGhlIGRlZmF1bHQgWFNSRiBwcm90ZWN0aW9uLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEh0dHBDbGllbnRYc3JmTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBIdHRwWHNyZkludGVyY2VwdG9yLCB1c2VDbGFzczogTm9vcEludGVyY2VwdG9yIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIFhTUkYgcHJvdGVjdGlvbiB0byB1c2UgdGhlIGdpdmVuIGNvb2tpZSBuYW1lIG9yIGhlYWRlciBuYW1lLFxuICAgICAqIG9yIHRoZSBkZWZhdWx0IG5hbWVzIChhcyBkZXNjcmliZWQgYWJvdmUpIGlmIG5vdCBwcm92aWRlZC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgWFNSRiBwcm90ZWN0aW9uIHRvIHVzZSB0aGUgZ2l2ZW4gY29va2llIG5hbWUgb3IgaGVhZGVyIG5hbWUsXG4gICAgICogb3IgdGhlIGRlZmF1bHQgbmFtZXMgKGFzIGRlc2NyaWJlZCBhYm92ZSkgaWYgbm90IHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0dHBDbGllbnRYc3JmTW9kdWxlLndpdGhPcHRpb25zID0gLyoqXG4gICAgICogQ29uZmlndXJlIFhTUkYgcHJvdGVjdGlvbiB0byB1c2UgdGhlIGdpdmVuIGNvb2tpZSBuYW1lIG9yIGhlYWRlciBuYW1lLFxuICAgICAqIG9yIHRoZSBkZWZhdWx0IG5hbWVzIChhcyBkZXNjcmliZWQgYWJvdmUpIGlmIG5vdCBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEh0dHBDbGllbnRYc3JmTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb29raWVOYW1lID8geyBwcm92aWRlOiBYU1JGX0NPT0tJRV9OQU1FLCB1c2VWYWx1ZTogb3B0aW9ucy5jb29raWVOYW1lIH0gOiBbXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlck5hbWUgPyB7IHByb3ZpZGU6IFhTUkZfSEVBREVSX05BTUUsIHVzZVZhbHVlOiBvcHRpb25zLmhlYWRlck5hbWUgfSA6IFtdLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEh0dHBDbGllbnRYc3JmTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBIdHRwWHNyZkludGVyY2VwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBIVFRQX0lOVEVSQ0VQVE9SUywgdXNlRXhpc3Rpbmc6IEh0dHBYc3JmSW50ZXJjZXB0b3IsIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEh0dHBYc3JmVG9rZW5FeHRyYWN0b3IsIHVzZUNsYXNzOiBIdHRwWHNyZkNvb2tpZUV4dHJhY3RvciB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBYU1JGX0NPT0tJRV9OQU1FLCB1c2VWYWx1ZTogJ1hTUkYtVE9LRU4nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFhTUkZfSEVBREVSX05BTUUsIHVzZVZhbHVlOiAnWC1YU1JGLVRPS0VOJyB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSHR0cENsaWVudFhzcmZNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gSHR0cENsaWVudFhzcmZNb2R1bGU7XG59KCkpO1xuLyoqXG4gKiBgTmdNb2R1bGVgIHdoaWNoIHByb3ZpZGVzIHRoZSBgSHR0cENsaWVudGAgYW5kIGFzc29jaWF0ZWQgc2VydmljZXMuXG4gKlxuICogSW50ZXJjZXB0b3JzIGNhbiBiZSBhZGRlZCB0byB0aGUgY2hhaW4gYmVoaW5kIGBIdHRwQ2xpZW50YCBieSBiaW5kaW5nIHRoZW1cbiAqIHRvIHRoZSBtdWx0aXByb3ZpZGVyIGZvciBgSFRUUF9JTlRFUkNFUFRPUlNgLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgSHR0cENsaWVudE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwQ2xpZW50TW9kdWxlKCkge1xuICAgIH1cbiAgICBIdHRwQ2xpZW50TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgSHR0cENsaWVudFhzcmZNb2R1bGUud2l0aE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIEh0dHBDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEh0dHBIYW5kbGVyLCB1c2VDbGFzczogSHR0cEludGVyY2VwdGluZ0hhbmRsZXIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEh0dHBYaHJCYWNrZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBIdHRwQmFja2VuZCwgdXNlRXhpc3Rpbmc6IEh0dHBYaHJCYWNrZW5kIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBCcm93c2VyWGhyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBYaHJGYWN0b3J5LCB1c2VFeGlzdGluZzogQnJvd3NlclhociB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgSHR0cENsaWVudE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBIdHRwQ2xpZW50TW9kdWxlO1xufSgpKTtcbi8qKlxuICogYE5nTW9kdWxlYCB3aGljaCBlbmFibGVzIEpTT05QIHN1cHBvcnQgaW4gYEh0dHBDbGllbnRgLlxuICpcbiAqIFdpdGhvdXQgdGhpcyBtb2R1bGUsIEpzb25wIHJlcXVlc3RzIHdpbGwgcmVhY2ggdGhlIGJhY2tlbmRcbiAqIHdpdGggbWV0aG9kIEpTT05QLCB3aGVyZSB0aGV5J2xsIGJlIHJlamVjdGVkLlxuICpcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgSHR0cENsaWVudEpzb25wTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHBDbGllbnRKc29ucE1vZHVsZSgpIHtcbiAgICB9XG4gICAgSHR0cENsaWVudEpzb25wTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBKc29ucENsaWVudEJhY2tlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEpzb25wQ2FsbGJhY2tDb250ZXh0LCB1c2VGYWN0b3J5OiBqc29ucENhbGxiYWNrQ29udGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBIVFRQX0lOVEVSQ0VQVE9SUywgdXNlQ2xhc3M6IEpzb25wSW50ZXJjZXB0b3IsIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBIdHRwQ2xpZW50SnNvbnBNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gSHR0cENsaWVudEpzb25wTW9kdWxlO1xufSgpKTtcblxuZXhwb3J0cy5IdHRwQmFja2VuZCA9IEh0dHBCYWNrZW5kO1xuZXhwb3J0cy5IdHRwSGFuZGxlciA9IEh0dHBIYW5kbGVyO1xuZXhwb3J0cy5IdHRwQ2xpZW50ID0gSHR0cENsaWVudDtcbmV4cG9ydHMuSHR0cEhlYWRlcnMgPSBIdHRwSGVhZGVycztcbmV4cG9ydHMuSFRUUF9JTlRFUkNFUFRPUlMgPSBIVFRQX0lOVEVSQ0VQVE9SUztcbmV4cG9ydHMuSnNvbnBDbGllbnRCYWNrZW5kID0gSnNvbnBDbGllbnRCYWNrZW5kO1xuZXhwb3J0cy5Kc29ucEludGVyY2VwdG9yID0gSnNvbnBJbnRlcmNlcHRvcjtcbmV4cG9ydHMuSHR0cENsaWVudEpzb25wTW9kdWxlID0gSHR0cENsaWVudEpzb25wTW9kdWxlO1xuZXhwb3J0cy5IdHRwQ2xpZW50TW9kdWxlID0gSHR0cENsaWVudE1vZHVsZTtcbmV4cG9ydHMuSHR0cENsaWVudFhzcmZNb2R1bGUgPSBIdHRwQ2xpZW50WHNyZk1vZHVsZTtcbmV4cG9ydHMuybVpbnRlcmNlcHRpbmdIYW5kbGVyID0gaW50ZXJjZXB0aW5nSGFuZGxlcjtcbmV4cG9ydHMuSHR0cFBhcmFtcyA9IEh0dHBQYXJhbXM7XG5leHBvcnRzLkh0dHBVcmxFbmNvZGluZ0NvZGVjID0gSHR0cFVybEVuY29kaW5nQ29kZWM7XG5leHBvcnRzLkh0dHBSZXF1ZXN0ID0gSHR0cFJlcXVlc3Q7XG5leHBvcnRzLkh0dHBFcnJvclJlc3BvbnNlID0gSHR0cEVycm9yUmVzcG9uc2U7XG5leHBvcnRzLkh0dHBFdmVudFR5cGUgPSBIdHRwRXZlbnRUeXBlO1xuZXhwb3J0cy5IdHRwSGVhZGVyUmVzcG9uc2UgPSBIdHRwSGVhZGVyUmVzcG9uc2U7XG5leHBvcnRzLkh0dHBSZXNwb25zZSA9IEh0dHBSZXNwb25zZTtcbmV4cG9ydHMuSHR0cFJlc3BvbnNlQmFzZSA9IEh0dHBSZXNwb25zZUJhc2U7XG5leHBvcnRzLkh0dHBYaHJCYWNrZW5kID0gSHR0cFhockJhY2tlbmQ7XG5leHBvcnRzLlhockZhY3RvcnkgPSBYaHJGYWN0b3J5O1xuZXhwb3J0cy5IdHRwWHNyZlRva2VuRXh0cmFjdG9yID0gSHR0cFhzcmZUb2tlbkV4dHJhY3RvcjtcbmV4cG9ydHMuybVhID0gTm9vcEludGVyY2VwdG9yO1xuZXhwb3J0cy7JtWIgPSBKc29ucENhbGxiYWNrQ29udGV4dDtcbmV4cG9ydHMuybVjID0gSHR0cEludGVyY2VwdGluZ0hhbmRsZXI7XG5leHBvcnRzLsm1ZCA9IGpzb25wQ2FsbGJhY2tDb250ZXh0O1xuZXhwb3J0cy7JtWUgPSBCcm93c2VyWGhyO1xuZXhwb3J0cy7JtWggPSBIdHRwWHNyZkNvb2tpZUV4dHJhY3RvcjtcbmV4cG9ydHMuybVpID0gSHR0cFhzcmZJbnRlcmNlcHRvcjtcbmV4cG9ydHMuybVmID0gWFNSRl9DT09LSUVfTkFNRTtcbmV4cG9ydHMuybVnID0gWFNSRl9IRUFERVJfTkFNRTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi1odHRwLnVtZC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9idW5kbGVzL2NvbW1vbi1odHRwLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IERPTUltcGxlbWVudGF0aW9uO1xuXG52YXIgRG9jdW1lbnQgPSByZXF1aXJlKCcuL0RvY3VtZW50Jyk7XG52YXIgRG9jdW1lbnRUeXBlID0gcmVxdWlyZSgnLi9Eb2N1bWVudFR5cGUnKTtcbnZhciBIVE1MUGFyc2VyID0gcmVxdWlyZSgnLi9IVE1MUGFyc2VyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgeG1sID0gcmVxdWlyZSgnLi94bWxuYW1lcycpO1xuXG4vLyBFYWNoIGRvY3VtZW50IG11c3QgaGF2ZSBpdHMgb3duIGluc3RhbmNlIG9mIHRoZSBkb21pbXBsZW1lbnRhdGlvbiBvYmplY3Rcbi8vIEV2ZW4gdGhvdWdoIHRoZXNlIG9iamVjdHMgaGF2ZSBubyBzdGF0ZVxuZnVuY3Rpb24gRE9NSW1wbGVtZW50YXRpb24oKSB7fVxuXG5cbi8vIEZlYXR1cmUvdmVyc2lvbiBwYWlycyB0aGF0IERPTUltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoKSByZXR1cm5zXG4vLyB0cnVlIGZvci4gIEl0IHJldHVybnMgZmFsc2UgZm9yIGFueXRoaW5nIGVsc2UuXG52YXIgc3VwcG9ydGVkRmVhdHVyZXMgPSB7XG4gICd4bWwnOiB7ICcnOiB0cnVlLCAnMS4wJzogdHJ1ZSwgJzIuMCc6IHRydWUgfSwgICAvLyBET00gQ29yZVxuICAnY29yZSc6IHsgJyc6IHRydWUsICcyLjAnOiB0cnVlIH0sICAgICAgICAgICAgICAgLy8gRE9NIENvcmVcbiAgJ2h0bWwnOiB7ICcnOiB0cnVlLCAnMS4wJzogdHJ1ZSwgJzIuMCc6IHRydWV9ICwgIC8vIEhUTUxcbiAgJ3hodG1sJzogeyAnJzogdHJ1ZSwgJzEuMCc6IHRydWUsICcyLjAnOiB0cnVlfSAsIC8vIEhUTUxcbn07XG5cbkRPTUltcGxlbWVudGF0aW9uLnByb3RvdHlwZSA9IHtcbiAgaGFzRmVhdHVyZTogZnVuY3Rpb24gaGFzRmVhdHVyZShmZWF0dXJlLCB2ZXJzaW9uKSB7XG4gICAgdmFyIGYgPSBzdXBwb3J0ZWRGZWF0dXJlc1soZmVhdHVyZSB8fCAnJykudG9Mb3dlckNhc2UoKV07XG4gICAgcmV0dXJuIChmICYmIGZbdmVyc2lvbiB8fCAnJ10pIHx8IGZhbHNlO1xuICB9LFxuXG4gIGNyZWF0ZURvY3VtZW50VHlwZTogZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRUeXBlKHF1YWxpZmllZE5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCkge1xuICAgIGlmICgheG1sLmlzVmFsaWROYW1lKHF1YWxpZmllZE5hbWUpKSB1dGlscy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IoKTtcbiAgICBpZiAoIXhtbC5pc1ZhbGlkUU5hbWUocXVhbGlmaWVkTmFtZSkpIHV0aWxzLk5hbWVzcGFjZUVycm9yKCk7XG5cbiAgICByZXR1cm4gbmV3IERvY3VtZW50VHlwZShxdWFsaWZpZWROYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpO1xuICB9LFxuXG4gIGNyZWF0ZURvY3VtZW50OiBmdW5jdGlvbiBjcmVhdGVEb2N1bWVudChuYW1lc3BhY2UsIHF1YWxpZmllZE5hbWUsIGRvY3R5cGUpIHtcbiAgICAvL1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgY3VycmVudCBET01Db3JlIHNwZWMgbWFrZXMgaXQgaW1wb3NzaWJsZSB0b1xuICAgIC8vIGNyZWF0ZSBhbiBIVE1MIGRvY3VtZW50IHdpdGggdGhpcyBmdW5jdGlvbiwgZXZlbiBpZiB0aGVcbiAgICAvLyBuYW1lc3BhY2UgYW5kIGRvY3R5cGUgYXJlIHByb3BlcnRseSBzZXQuICBTZWUgdGhpcyB0aHJlYWQ6XG4gICAgLy8gaHR0cDovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvd3d3LWRvbS8yMDExQXBySnVuLzAxMzIuaHRtbFxuICAgIC8vXG4gICAgdmFyIGQgPSBuZXcgRG9jdW1lbnQoZmFsc2UsIG51bGwpO1xuICAgIHZhciBlO1xuXG4gICAgaWYgKHF1YWxpZmllZE5hbWUpXG4gICAgICBlID0gZC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCBxdWFsaWZpZWROYW1lKTtcbiAgICBlbHNlXG4gICAgICBlID0gbnVsbDtcblxuICAgIGlmIChkb2N0eXBlKSB7XG4gICAgICBpZiAoZG9jdHlwZS5vd25lckRvY3VtZW50KSB1dGlscy5Xcm9uZ0RvY3VtZW50RXJyb3IoKTtcbiAgICAgIGQuYXBwZW5kQ2hpbGQoZG9jdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKGUpIGQuYXBwZW5kQ2hpbGQoZSk7XG5cbiAgICByZXR1cm4gZDtcbiAgfSxcblxuICBjcmVhdGVIVE1MRG9jdW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZUhUTUxEb2N1bWVudCh0aXRsZVRleHQpIHtcbiAgICB2YXIgZCA9IG5ldyBEb2N1bWVudCh0cnVlLCBudWxsKTtcbiAgICBkLmFwcGVuZENoaWxkKG5ldyBEb2N1bWVudFR5cGUoJ2h0bWwnKSk7XG4gICAgdmFyIGh0bWwgPSBkLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICBkLmFwcGVuZENoaWxkKGh0bWwpO1xuICAgIHZhciBoZWFkID0gZC5jcmVhdGVFbGVtZW50KCdoZWFkJyk7XG4gICAgaHRtbC5hcHBlbmRDaGlsZChoZWFkKTtcbiAgICB2YXIgdGl0bGUgPSBkLmNyZWF0ZUVsZW1lbnQoJ3RpdGxlJyk7XG4gICAgaGVhZC5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgdGl0bGUuYXBwZW5kQ2hpbGQoZC5jcmVhdGVUZXh0Tm9kZSh0aXRsZVRleHQpKTtcbiAgICBodG1sLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudCgnYm9keScpKTtcbiAgICBkLm1vZGNsb2NrID0gMTsgLy8gU3RhcnQgdHJhY2tpbmcgbW9kaWZpY2F0aW9uc1xuICAgIHJldHVybiBkO1xuICB9LFxuXG4gIG1velNldE91dHB1dE11dGF0aW9uSGFuZGxlcjogZnVuY3Rpb24oZG9jLCBoYW5kbGVyKSB7XG4gICAgZG9jLm11dGF0aW9uSGFuZGxlciA9IGhhbmRsZXI7XG4gIH0sXG5cbiAgbW96R2V0SW5wdXRNdXRhdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKGRvYykge1xuICAgIHV0aWxzLm55aSgpO1xuICB9LFxuXG4gIG1vekhUTUxQYXJzZXI6IEhUTUxQYXJzZXIsXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9ET01JbXBsZW1lbnRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVMaXN0O1xuXG5mdW5jdGlvbiBpdGVtKGkpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICByZXR1cm4gdGhpc1tpXTtcbn1cblxuZnVuY3Rpb24gTm9kZUxpc3QoYSkge1xuICBpZiAoIWEpIGEgPSBbXTtcbiAgYS5pdGVtID0gaXRlbTtcbiAgcmV0dXJuIGE7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL05vZGVMaXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQ2hhcmFjdGVyRGF0YTtcblxudmFyIExlYWYgPSByZXF1aXJlKCcuL0xlYWYnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBDaGlsZE5vZGUgPSByZXF1aXJlKCcuL0NoaWxkTm9kZScpO1xudmFyIE5vbkRvY3VtZW50VHlwZUNoaWxkTm9kZSA9IHJlcXVpcmUoJy4vTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlJyk7XG5cbmZ1bmN0aW9uIENoYXJhY3RlckRhdGEoKSB7XG59XG5cbkNoYXJhY3RlckRhdGEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMZWFmLnByb3RvdHlwZSwge1xuICAvLyBET01TdHJpbmcgc3Vic3RyaW5nRGF0YSh1bnNpZ25lZCBsb25nIG9mZnNldCxcbiAgLy8gICAgICAgICAgICAgICB1bnNpZ25lZCBsb25nIGNvdW50KTtcbiAgLy8gVGhlIHN1YnN0cmluZ0RhdGEob2Zmc2V0LCBjb3VudCkgbWV0aG9kIG11c3QgcnVuIHRoZXNlIHN0ZXBzOlxuICAvL1xuICAvLyAgICAgSWYgb2Zmc2V0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgY29udGV4dCBvYmplY3Qnc1xuICAvLyAgICAgbGVuZ3RoLCB0aHJvdyBhbiBJTkRFWF9TSVpFX0VSUiBleGNlcHRpb24gYW5kXG4gIC8vICAgICB0ZXJtaW5hdGUgdGhlc2Ugc3RlcHMuXG4gIC8vXG4gIC8vICAgICBJZiBvZmZzZXQrY291bnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBjb250ZXh0XG4gIC8vICAgICBvYmplY3QncyBsZW5ndGgsIHJldHVybiBhIERPTVN0cmluZyB3aG9zZSB2YWx1ZSBpc1xuICAvLyAgICAgdGhlIFVURi0xNiBjb2RlIHVuaXRzIGZyb20gdGhlIG9mZnNldHRoIFVURi0xNiBjb2RlXG4gIC8vICAgICB1bml0IHRvIHRoZSBlbmQgb2YgZGF0YS5cbiAgLy9cbiAgLy8gICAgIFJldHVybiBhIERPTVN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVRGLTE2IGNvZGVcbiAgLy8gICAgIHVuaXRzIGZyb20gdGhlIG9mZnNldHRoIFVURi0xNiBjb2RlIHVuaXQgdG8gdGhlXG4gIC8vICAgICBvZmZzZXQrY291bnR0aCBVVEYtMTYgY29kZSB1bml0IGluIGRhdGEuXG4gIHN1YnN0cmluZ0RhdGE6IHsgdmFsdWU6IGZ1bmN0aW9uIHN1YnN0cmluZ0RhdGEob2Zmc2V0LCBjb3VudCkge1xuICAgIGlmIChvZmZzZXQgPiB0aGlzLmRhdGEubGVuZ3RoIHx8IG9mZnNldCA8IDAgfHwgY291bnQgPCAwKSBcbiAgICAgIHV0aWxzLkluZGV4U2l6ZUVycm9yKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQrY291bnQpO1xuICB9fSxcblxuICAvLyB2b2lkIGFwcGVuZERhdGEoRE9NU3RyaW5nIGRhdGEpO1xuICAvLyBUaGUgYXBwZW5kRGF0YShkYXRhKSBtZXRob2QgbXVzdCBhcHBlbmQgZGF0YSB0byB0aGUgY29udGV4dFxuICAvLyBvYmplY3QncyBkYXRhLlxuICBhcHBlbmREYXRhOiB7IHZhbHVlOiBmdW5jdGlvbiBhcHBlbmREYXRhKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEgKyBkYXRhO1xuICB9fSxcblxuICAvLyB2b2lkIGluc2VydERhdGEodW5zaWduZWQgbG9uZyBvZmZzZXQsIERPTVN0cmluZyBkYXRhKTtcbiAgLy8gVGhlIGluc2VydERhdGEob2Zmc2V0LCBkYXRhKSBtZXRob2QgbXVzdCBydW4gdGhlc2Ugc3RlcHM6XG4gIC8vXG4gIC8vICAgICBJZiBvZmZzZXQgaXMgZ3JlYXRlciB0aGFuIHRoZSBjb250ZXh0IG9iamVjdCdzXG4gIC8vICAgICBsZW5ndGgsIHRocm93IGFuIElOREVYX1NJWkVfRVJSIGV4Y2VwdGlvbiBhbmRcbiAgLy8gICAgIHRlcm1pbmF0ZSB0aGVzZSBzdGVwcy5cbiAgLy9cbiAgLy8gICAgIEluc2VydCBkYXRhIGludG8gdGhlIGNvbnRleHQgb2JqZWN0J3MgZGF0YSBhZnRlclxuICAvLyAgICAgb2Zmc2V0IFVURi0xNiBjb2RlIHVuaXRzLlxuICAvL1xuICBpbnNlcnREYXRhOiB7IHZhbHVlOiBmdW5jdGlvbiBpbnNlcnREYXRhKG9mZnNldCwgZGF0YSkge1xuICAgIHZhciBjdXJ0ZXh0ID0gdGhpcy5kYXRhO1xuICAgIGlmIChvZmZzZXQgPiBjdXJ0ZXh0Lmxlbmd0aCB8fCBvZmZzZXQgPCAwKSB1dGlscy5JbmRleFNpemVFcnJvcigpO1xuICAgIHZhciBwcmVmaXggPSBjdXJ0ZXh0LnN1YnN0cmluZygwLCBvZmZzZXQpLFxuICAgIHN1ZmZpeCA9IGN1cnRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgdGhpcy5kYXRhID0gcHJlZml4ICsgZGF0YSArIHN1ZmZpeDtcbiAgfX0sXG5cblxuICAvLyB2b2lkIGRlbGV0ZURhdGEodW5zaWduZWQgbG9uZyBvZmZzZXQsIHVuc2lnbmVkIGxvbmcgY291bnQpO1xuICAvLyBUaGUgZGVsZXRlRGF0YShvZmZzZXQsIGNvdW50KSBtZXRob2QgbXVzdCBydW4gdGhlc2Ugc3RlcHM6XG4gIC8vXG4gIC8vICAgICBJZiBvZmZzZXQgaXMgZ3JlYXRlciB0aGFuIHRoZSBjb250ZXh0IG9iamVjdCdzXG4gIC8vICAgICBsZW5ndGgsIHRocm93IGFuIElOREVYX1NJWkVfRVJSIGV4Y2VwdGlvbiBhbmRcbiAgLy8gICAgIHRlcm1pbmF0ZSB0aGVzZSBzdGVwcy5cbiAgLy9cbiAgLy8gICAgIElmIG9mZnNldCtjb3VudCBpcyBncmVhdGVyIHRoYW4gdGhlIGNvbnRleHRcbiAgLy8gICAgIG9iamVjdCdzIGxlbmd0aCB2YXIgY291bnQgYmUgbGVuZ3RoLW9mZnNldC5cbiAgLy9cbiAgLy8gICAgIFN0YXJ0aW5nIGZyb20gb2Zmc2V0IFVURi0xNiBjb2RlIHVuaXRzIHJlbW92ZSBjb3VudFxuICAvLyAgICAgVVRGLTE2IGNvZGUgdW5pdHMgZnJvbSB0aGUgY29udGV4dCBvYmplY3QncyBkYXRhLlxuICBkZWxldGVEYXRhOiB7IHZhbHVlOiBmdW5jdGlvbiBkZWxldGVEYXRhKG9mZnNldCwgY291bnQpIHtcbiAgICB2YXIgY3VydGV4dCA9IHRoaXMuZGF0YSwgbGVuID0gY3VydGV4dC5sZW5ndGg7XG5cbiAgICBpZiAob2Zmc2V0ID4gbGVuIHx8IG9mZnNldCA8IDApIHV0aWxzLkluZGV4U2l6ZUVycm9yKCk7XG5cbiAgICBpZiAob2Zmc2V0K2NvdW50ID4gbGVuKVxuICAgICAgY291bnQgPSBsZW4gLSBvZmZzZXQ7XG5cbiAgICB2YXIgcHJlZml4ID0gY3VydGV4dC5zdWJzdHJpbmcoMCwgb2Zmc2V0KSxcbiAgICBzdWZmaXggPSBjdXJ0ZXh0LnN1YnN0cmluZyhvZmZzZXQrY291bnQpO1xuXG4gICAgdGhpcy5kYXRhID0gcHJlZml4ICsgc3VmZml4O1xuICB9fSxcblxuXG4gIC8vIHZvaWQgcmVwbGFjZURhdGEodW5zaWduZWQgbG9uZyBvZmZzZXQsIHVuc2lnbmVkIGxvbmcgY291bnQsXG4gIC8vICAgICAgICAgIERPTVN0cmluZyBkYXRhKTtcbiAgLy9cbiAgLy8gVGhlIHJlcGxhY2VEYXRhKG9mZnNldCwgY291bnQsIGRhdGEpIG1ldGhvZCBtdXN0IGFjdCBhc1xuICAvLyBpZiB0aGUgZGVsZXRlRGF0YSgpIG1ldGhvZCBpcyBpbnZva2VkIHdpdGggb2Zmc2V0IGFuZFxuICAvLyBjb3VudCBhcyBhcmd1bWVudHMgZm9sbG93ZWQgYnkgdGhlIGluc2VydERhdGEoKSBtZXRob2RcbiAgLy8gd2l0aCBvZmZzZXQgYW5kIGRhdGEgYXMgYXJndW1lbnRzIGFuZCByZS10aHJvdyBhbnlcbiAgLy8gZXhjZXB0aW9ucyB0aGVzZSBtZXRob2RzIG1pZ2h0IGhhdmUgdGhyb3duLlxuICByZXBsYWNlRGF0YTogeyB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZURhdGEob2Zmc2V0LCBjb3VudCwgZGF0YSkge1xuICAgIHZhciBjdXJ0ZXh0ID0gdGhpcy5kYXRhLCBsZW4gPSBjdXJ0ZXh0Lmxlbmd0aDtcblxuICAgIGlmIChvZmZzZXQgPiBsZW4gfHwgb2Zmc2V0IDwgMCkgdXRpbHMuSW5kZXhTaXplRXJyb3IoKTtcblxuICAgIGlmIChvZmZzZXQrY291bnQgPiBsZW4pXG4gICAgICBjb3VudCA9IGxlbiAtIG9mZnNldDtcblxuICAgIHZhciBwcmVmaXggPSBjdXJ0ZXh0LnN1YnN0cmluZygwLCBvZmZzZXQpLFxuICAgIHN1ZmZpeCA9IGN1cnRleHQuc3Vic3RyaW5nKG9mZnNldCtjb3VudCk7XG5cbiAgICB0aGlzLmRhdGEgPSBwcmVmaXggKyBkYXRhICsgc3VmZml4O1xuICB9fSxcblxuICAvLyBVdGlsaXR5IG1ldGhvZCB0aGF0IE5vZGUuaXNFcXVhbE5vZGUoKSBjYWxscyB0byB0ZXN0IFRleHQgYW5kXG4gIC8vIENvbW1lbnQgbm9kZXMgZm9yIGVxdWFsaXR5LiAgSXQgaXMgb2theSB0byBwdXQgaXQgaGVyZSwgc2luY2VcbiAgLy8gTm9kZSB3aWxsIGhhdmUgYWxyZWFkeSB2ZXJpZmllZCB0aGF0IG5vZGVUeXBlIGlzIGVxdWFsXG4gIGlzRXF1YWw6IHsgdmFsdWU6IGZ1bmN0aW9uIGlzRXF1YWwobikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhID09PSBuLl9kYXRhO1xuICB9fSxcblxuICBsZW5ndGg6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7IH19XG5cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSwgQ2hpbGROb2RlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYXJhY3RlckRhdGEucHJvdG90eXBlLCBOb25Eb2N1bWVudFR5cGVDaGlsZE5vZGUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9DaGFyYWN0ZXJEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBOb2RlRmlsdGVyID0ge1xuICAvLyBDb25zdGFudHMgZm9yIGFjY2VwdE5vZGUoKVxuICBGSUxURVJfQUNDRVBUOiAxLFxuICBGSUxURVJfUkVKRUNUOiAyLFxuICBGSUxURVJfU0tJUDogMyxcblxuICAvLyBDb25zdGFudHMgZm9yIHdoYXRUb1Nob3dcbiAgU0hPV19BTEw6IDB4RkZGRkZGRkYsXG4gIFNIT1dfRUxFTUVOVDogMHgxLFxuICBTSE9XX0FUVFJJQlVURTogMHgyLCAvLyBoaXN0b3JpY2FsXG4gIFNIT1dfVEVYVDogMHg0LFxuICBTSE9XX0NEQVRBX1NFQ1RJT046IDB4OCwgLy8gaGlzdG9yaWNhbFxuICBTSE9XX0VOVElUWV9SRUZFUkVOQ0U6IDB4MTAsIC8vIGhpc3RvcmljYWxcbiAgU0hPV19FTlRJVFk6IDB4MjAsIC8vIGhpc3RvcmljYWxcbiAgU0hPV19QUk9DRVNTSU5HX0lOU1RSVUNUSU9OOiAweDQwLFxuICBTSE9XX0NPTU1FTlQ6IDB4ODAsXG4gIFNIT1dfRE9DVU1FTlQ6IDB4MTAwLFxuICBTSE9XX0RPQ1VNRU5UX1RZUEU6IDB4MjAwLFxuICBTSE9XX0RPQ1VNRU5UX0ZSQUdNRU5UOiAweDQwMCxcbiAgU0hPV19OT1RBVElPTjogMHg4MDAgLy8gaGlzdG9yaWNhbFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoTm9kZUZpbHRlci5jb25zdHJ1Y3RvciA9IE5vZGVGaWx0ZXIucHJvdG90eXBlID0gTm9kZUZpbHRlcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL05vZGVGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUY0QUFBQWJDQU1BQUFEQ21jaURBQUFCUkZCTVZFVTJLaHRFTlNKR05pUklPQ1JFTkNKQ01pQktPQ1JBTWlBL01DQkROQ0pJTmlSQ01pRktOeVJFTkNGQU1DQktPU2JqMjhGTU9pWk1PeWhRUENkT1BDaFNRQ2xTUGlsUVBpaExPU1JZUXl4UFBpazJLUnRRUFNxN3NaZk94YXZQeDYxVFFDcE9PaWRPUENaMlpsQlFQQ2hlU0M5VVFTcFdRaXBUUHlwV1FpdlowYmVKZkdSWlJDeVRobTdGdTZLVmgyOWtVanlubklOVVFDcFlSQ3hjUmk1K2NGcGdUenBjUmkySWVtTldSakZXUmk5MFpVNTRhRkdUaFc1V1JUQmtWRDI4c3BsdFhFYXdwWTJMZkdWY1J5NVVRQ2xhU0ROYlJpNXVYVWQwWmxDcG5ZWEV1NkhQeDZ1VmlIQnBXa1IwWlZDbm00TmFSQzVLT1NTQmNWdEtPQ1ZyVzBaVlFDcWxtb0tla1hwVVBpaGVUanBpVVR0aVVUeGFSaktubTRTenA0K1JoVzZWaUcrS2UyU2NrSGlka1hxVWhXN0Z2YUZWUkM2SmVtUmFSakNCY2x1b200TXB0QXJCQUFBRUIwbEVRVlI0QVdST1NXN0RNQXprSjlpQzlVVVhhd0Y4a2dUNEF6Wnk3cVgvZjBxSG9sZ1p6WVRoTEVNRm9mM3FGN0RibU96OTJ2ZWh3VENYTGhCQzBObnQ4SVJDZkVJaVVmUWRCY3g4Q2tzdlIxK3JneGIrUjFPdVlMbTNpSTRYL1dIemNXMjh5bVZjK3RFcTFNenY5MEd0a1VpVDF0cHg2RFlqQ3RVRzhMSGtNT0lmc1ZCVzFHYTRpWkNVclFCU2toUXhnRFhCR3B6SzdKS0k4MmhVNjQzRlNkbWhqNFJLc1luRkFXa3VQYkpuKys3aTVCVFRzMHo2dnlsR3FqVXFtQ0ZNMm5hcHFaTENLemhyK1laZ2QwcUdIL3p3WFNsbnlpR0VtbXNJT1VQZUVEVkF3Yk1TQm1rWUI4OWNyekNnY0k4VWt5dVBJdzZZTFFkaUp2NWc1aS8rVkZwUVA3TmZxcVpyTjI0WUNQSVRacGNyVWxDUlFFbFBPdWpLZ3crKzRnNFk3amFRQk9tOUovLy9ucVVPTU9LUk1GdG1kcWprZkpLOEhvdmIyYUtvNmxNOFNwRmN6UGJPWkluTGRISStVbklGNExOYkFNa1dPSE0xRkxWejgyT3RGMGZBYlFZY3U2TXBNSjBuRHBpNUVuV0JFVmZPRlU3anZPWmxXZTZjOGQ1MGhWY29LYnBYL1VYeDhkYWU0NW5QL3BhWi9FRldiQ3ZmVGFmbjcrdXQvMVlYUjlNVG45V2xuMWZIVXN6NnpxdTM2K2RuOExNUFBpdUt3bmZlVzlzVmVlZU5TRzcvUno4b2liVm9iYk1vclcyaG85Z1RiRVdGWnFqYmNoNjNKNDJkNGJlZFZEWjZsU1lZN3lLYVhjbkZHbXYxaGJnVzNRYjdGdTNPZzRneFhvdm9zVENyYVFaVVdzNWdvOVR5cEpaR3hodU4zd1d4M2NWWkU4UUlHMklTQ1VHQ0NML0RwYkJ3MEJNT0R5VnpDeVpWSnRDZEN0K3JWVDl3MkljRTF2aWc4U3k0MStBdkdBM2E3UUpDTUN3bWNNNU1URTJqekx6Q0FYR2pHOXd6THpSK0E0N1l3d3RkQng1cUh2ckRjZVJmV0lWSlJVUm85V0lmckE0RnFXL01NbzIrUUlZZXdVUmx0YVRUVDdUR0h0RnBTYlFIb3J1S0R2dVNEMjh1Nld0UFZDMW9mZk5qdmF3WFVkN1FnSlhlSG1CTlQ1SEg3RlQvZEJ6VCtMMjVCckNmUGdDMDBZWXFLSzdUZEJPYjVSSTRTTFdqdXlsdyt2TjVtcjc4MTFVVjdib093ckJBV0ZrcDNjVGJwT244Rk9yL2Y4dHhiWjFjZEUxd0hNZmlGY1kvQTV1Zk1RZmZRdUhpNFdIekFzL3JtblBpZ25BRzJ0RHdtZStKTUZ6T0k5YndZREdGOW9hRzhiZlZlM1pOMjdhdlgzMXpuTGtKbUhxbkFweUsrRS81TFVBQkZ3WE11N2wvM1Z0ci9YTDBXNEtwQ0loTmczZlo4cGlKNm0yajMzeEJzK2JtMmR5ejQvSjR6aGtoQ1NlMERSSnJqSENUSmJTbW9HVlV0cHdZVElraWhVaUo1cm9VYXhkWVU4d1JmTmhTc1pKU1NUZmhFdXFCMVpkVVBCUzdGT01TaFcvdlZzcCtsbjB2OTdseDRrSnhoSTFhc092QWxGWkpBY3lLaTZHT2szODdhUDM1eVF0aXV6b29IYzNCZ2ZPdytnQ09CL2xnWDFHNVJFbFdEY1NTMVJ0VkhnMEtHRmFmejJjbDhjWUl4b1FDSGxValZ4THdtSC85aTcwd29wZ0ZhUDhDOTV2OVk3V3FwT2NBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3dyb290L2ltYWdlcy9DaGVja291dF9idXR0b24ucG5nXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFKTUFBQUFiQ0FNQUFBQlAyRTJTQUFBQk5WQk1WRVUyS2h4R05pUk1PaVpFTlNMajI4Rk9QQ2RJT0NSS09DUkVOQ0pDTWlCS09TUkFNaUEvTUNCRE5DSklOaVJTUGloUVBpaEtOeVNubTRQRnU2R1ZoMjVDTWlHN3NaZE1PU1hQeDYzWjBiZE5PaVoyWjFCMlpsQlFQQ2hRUFNxVGgyNU9QQ1pRUENlbm5JT1NoVzI4c1pmUHhhdGpVajFXUmpDeHBZMTRhRkdka1hsYVNER3BuWVNKZkdSZ1VEdXlwNDFxV2tSc1hFYWVrWG1MZkdWK2NGbEVOQ0dJZW1OYVNES1JoVzVLT1NhQmNsdUxmbVdCY1Z0MFpsQkFNQ0IwWlU1elpWQmtVangvY1ZxVmlHOVZSQytUaFc2QmMxeUllV05mVGpwa1VqdHJXa1prVVR4b1dVU3lxSStka1hxUmhXMU1PaVJXUmk5NGFGSk1PaWgwWkU1Y1JpNVNRQ2xUUHlwWVF5eFdRaXRVUUNsVVFDcFVRU3BiUlM1ZVNDOWNSeTViUmk1WlJDeGNSaTFUUUNvMktSdFdRaXBZUkN3VDZwQXpBQUFGdjBsRVFWUjRBWHlMQ3c3aklCQkQ1d2J0NVNEaGt5WnAycjMvRWRiUGlwQ290R3ZBWTN0TTdHbmZVOXBmcjExSEpvbVZ2QlRja29ld29mM2UzK3lrRmZxUEhDVkJ4aXFwSTJsTFRVWFJPeVdyUk02MUJKSmFDYUk0am5Sc3g3YWxRNFBEVklna0ZRc2lwVlo4Y0tvQkp6SVJyTXl4cEk2WTdHQmwxdFJRNUpMM2pwUnhxR1BqM09MeitVVG96bEE0OGlIUmZ0WTJJNmN5UUFVZWpqZnNYSjUvYldlY2Evd1JWbUFoNmNuMWczRnNUZ1VJaC9CSnhYREZRdWRVMDlvME40QUtFRTB5cHhLS1k5VXRVWVMxZk5leUdwNWZFZE9qekFhTCtFcFBuMFlQeFozemtYbnczODhvSmkyaUZGL1F5Ny9SZWJPRjV1QlgvaS9yUk4vZnZZUFE3UzE2NzdXRDFucXJlcFp3eDRraFpkbUd6WGcrRk84bmx6Tzlpcng1b0ZiY2lDdXNtLzFSb1JDdHgzTEZKYlNyaWhlZDF1UTBCNGgxc3BWek56eWJBaUczS2tmTlhZbzhKZXJwWjc0V0ZUTmh5MWRsSlNYSGRsa2FHeFZBTERseWpzY2pHODludG56Y3gzQkVOb2p6ek1PRGhReEhOdlVIczcrOU1YV3dOejZQdnl5T3dZcmpNQkJFZmFnK3E1Q2JZR0ZMWXdVVGNHd3dpUStCWkM3RHdNS3k3R1VQK29MNS8yL1l0c2lEN2xhWDZLSktrL2hET3FiamQyNkJVTnpGUm5zcEJWQTNBNWR2R0RZVjJCUHdYY1Yvd0d6TFdqb1lYWEptc0FmZzdsYWd6TUJlM0d4L1czRXZHSCtMc3czZDdCUjRPVURUWVZQS0dYYkVVbW9Dc3JGTTFobEp4c1N2NE9NTnd1N0UzMWI4aFhDaHYxT3Y3UFJoNzNZalB4Ryt1RjRUdHkzeWlZY0o1TkF4SlM1NDhucU9EM3lTNjBUNUE0MnpGVnROTzE3bXgwZmJwV2cyOFlucW5mSTkzS0w2RkNOakhIT01scVlSK1JFamp6SnFXTVRvY1dOV0xOS2ZXaTlleGVocVAvbFJocWs5eTJxclh5VVBxUFZtUVMralRRdzVyNU9JaHB4bGErMU9UZFRjd3pUa1BKbE5QeDNlSDdLRUR6SHFYUmFqa2JFNStocy8xYThkTlZodmQ5WlY3ZUNkYWZKU3hlRVEvWCtxeUgrMWJSZ080dUg0Q29IK2xJWmtDNFBBeHRoMEpHUlFSdnRINkNndEcyUHNCOXNqOVAyZllYY1RnZVZpU2ZoMC91UnN6U3hvcEp0Wjd0UjNOdXV0VENLTFBIbnMxTnpSSnFiZCs4Um9ub25KbmYyQi8zTWpmcUdiVGxremp0ZE9VM2J6MEc2K1UvMTl5UzRPalM4M3E2RDFRY0c1eWlmR3J3NTIrY2VxNHRXbVRtYld3RTVtNlFSaDBObU5uU2IyNVVRQ09QVkM0RnpwVkhjM091blp6bzY1VGM5dDQvb0tiZyt0UWk4SWQ1RTV2TllhMldreURmVlJTSnAzblIwUU16b3Y2dXgwUHJWT3BrekhrRTNNNGpZamVkKzU2d0JoRGhVSDZPcjZaQTg0RzdZMWJhZDFCcDRUc05Danhyc0tJTzNBUGMwSCt3SGNyU2ZzaVlZQjV3SFUwN0Fwc3RrOXNHZTZGc2s4QXVrN0tDWi8vY1IvbUdZTnlNVGtpS3Q2SVg4SXZnQUlLSXVacmFXY2s5bitBcGd0b2FRRkpVU3pKNERiSHd0TjBDemxKVEg4RFdVMUtoVWdmQmwxTm9WaC9HSFVoOCtqRURqeUJ0UktPQXFFRWJzSWd4TXhNZEwzMENiZTJNbDdOZ3ZCZTQ2Z1FXbEJ2OUVDOFBMZGs4T3M3OXU4OUx2S2c5RkhING9zRk8yVjBCa0JqeHdkbzBXTzk1NXBPcDNjazI4Ky9PMXlqSElnQ1VFZ1NzY0U3WFUwOGNPanpPK2NwdTkvaHFXcXl5WFphb0hpQ2M3Z1AzbGQ3dFhqMG12MXRSWXFoTllyZWx4ekNqYmNRcXBJZjVEcFBNakNEQjIySlRHOXR3VGY1QnhqV2JSV2w3bWJ6L2hXcERrZGZ2bHJuUzJGbmw5MVZsOWVBNjZsdVFDRTJHQmJKMWM0UnhpQkRZMEN6Zk1ZNGRHejNDNDM5K3Y5TGxKNlpJcDFaay9FU1pGY2NpbXBsQk5NdVFHZ2JrNGkvcUZ5MlNXVjhpK0tXZ3BJaFZTUzBUZ2ppZW94eXVoUmRFVk1rejlsY1ZwNUN0VksxdFphQk8weHdxenFGYm1ITENhY0Eva1FBVzN1RWhKYktkYWFqVEcrRFJxRDVYdmNJQk9GVi91Q1dHS0hnNGFZbmxVYlRJS2FsZU1xN3BRYnlUT2E3V0ZIRHc1U3hCRTZIdDcvZjZjTmN2amthWEk1akU0dXkyUmplMXUvNzN2ZkVrMldwSXdlK1Z6SmRRV1piSW9zQi9QWkpKMXZjYmQzNHQydGYwSTdjb2RRUHlqNjBtSUE2Zk1EUXJmZmVVQTVMcURvRUFuTDBmNUllTDFCY0RTRDRiOGdWamM1Um9leU1RQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3d3Jvb3QvaW1hZ2VzL0NvbnRpbnVlU2hvcHBpbmdfYnV0dG9uLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiZmYxYzgyZjMyYTQxYmJkZjAyZTUyYjZjN2I4MThjNTEucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3dyb290L2ltYWdlcy9Db29rYm9va3NfSGVhZGVyLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50O1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIE5vZGVMaXN0ID0gcmVxdWlyZSgnLi9Ob2RlTGlzdCcpO1xudmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL0VsZW1lbnQnKTtcbnZhciBUZXh0ID0gcmVxdWlyZSgnLi9UZXh0Jyk7XG52YXIgQ29tbWVudCA9IHJlcXVpcmUoJy4vQ29tbWVudCcpO1xudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xudmFyIERvY3VtZW50RnJhZ21lbnQgPSByZXF1aXJlKCcuL0RvY3VtZW50RnJhZ21lbnQnKTtcbnZhciBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSByZXF1aXJlKCcuL1Byb2Nlc3NpbmdJbnN0cnVjdGlvbicpO1xudmFyIERPTUltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9ET01JbXBsZW1lbnRhdGlvbicpO1xudmFyIFRyZWVXYWxrZXIgPSByZXF1aXJlKCcuL1RyZWVXYWxrZXInKTtcbnZhciBOb2RlSXRlcmF0b3IgPSByZXF1aXJlKCcuL05vZGVJdGVyYXRvcicpO1xudmFyIE5vZGVGaWx0ZXIgPSByZXF1aXJlKCcuL05vZGVGaWx0ZXInKTtcbnZhciBVUkwgPSByZXF1aXJlKCcuL1VSTCcpO1xudmFyIHNlbGVjdCA9IHJlcXVpcmUoJy4vc2VsZWN0Jyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcbnZhciB4bWwgPSByZXF1aXJlKCcuL3htbG5hbWVzJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vaHRtbGVsdHMnKTtcbnZhciBzdmcgPSByZXF1aXJlKCcuL3N2ZycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIE1VVEFURSA9IHJlcXVpcmUoJy4vTXV0YXRpb25Db25zdGFudHMnKTtcbnZhciBOQU1FU1BBQ0UgPSB1dGlscy5OQU1FU1BBQ0U7XG52YXIgaXNBcGlXcml0YWJsZSA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKS5pc0FwaVdyaXRhYmxlO1xuXG5mdW5jdGlvbiBEb2N1bWVudChpc0hUTUwsIGFkZHJlc3MpIHtcbiAgdGhpcy5ub2RlVHlwZSA9IE5vZGUuRE9DVU1FTlRfTk9ERTtcbiAgdGhpcy5pc0hUTUwgPSBpc0hUTUw7XG4gIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzIHx8ICdhYm91dDpibGFuayc7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdsb2FkaW5nJztcbiAgdGhpcy5pbXBsZW1lbnRhdGlvbiA9IG5ldyBET01JbXBsZW1lbnRhdGlvbigpO1xuXG4gIC8vIERPTUNvcmUgc2F5cyB0aGF0IGRvY3VtZW50cyBhcmUgYWx3YXlzIGFzc29jaWF0ZWQgd2l0aCB0aGVtc2VsdmVzXG4gIHRoaXMub3duZXJEb2N1bWVudCA9IG51bGw7IC8vIC4uLiBidXQgVzNDIHRlc3RzIGV4cGVjdCBudWxsXG5cbiAgLy8gVGhlc2Ugd2lsbCBiZSBpbml0aWFsaXplZCBieSBvdXIgY3VzdG9tIHZlcnNpb25zIG9mXG4gIC8vIGFwcGVuZENoaWxkIGFuZCBpbnNlcnRCZWZvcmUgdGhhdCBvdmVycmlkZSB0aGUgaW5oZXJpdGVkXG4gIC8vIE5vZGUgbWV0aG9kcy5cbiAgLy8gWFhYOiBvdmVycmlkZSB0aG9zZSBtZXRob2RzIVxuICB0aGlzLmRvY3R5cGUgPSBudWxsO1xuICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IG51bGw7XG4gIHRoaXMuY2hpbGROb2RlcyA9IG5ldyBOb2RlTGlzdCgpO1xuXG4gIC8vIFwiQXNzb2NpYXRlZCBpbmVydCB0ZW1wbGF0ZSBkb2N1bWVudFwiXG4gIHRoaXMuX3RlbXBsYXRlRG9jQ2FjaGUgPSBudWxsO1xuXG4gIC8vIERvY3VtZW50cyBhcmUgYWx3YXlzIHJvb3RlZCwgYnkgZGVmaW5pdGlvblxuICB0aGlzLl9uaWQgPSAxO1xuICB0aGlzLl9uZXh0bmlkID0gMjsgLy8gRm9yIG51bWJlcmluZyBjaGlsZHJlbiBvZiB0aGUgZG9jdW1lbnRcbiAgdGhpcy5fbm9kZXMgPSBbbnVsbCwgdGhpc107ICAvLyBuaWQgdG8gbm9kZSBtYXBcblxuICAvLyBUaGlzIG1haW50YWlucyB0aGUgbWFwcGluZyBmcm9tIGVsZW1lbnQgaWRzIHRvIGVsZW1lbnQgbm9kZXMuXG4gIC8vIFdlIG1heSBuZWVkIHRvIHVwZGF0ZSB0aGlzIG1hcHBpbmcgZXZlcnkgdGltZSBhIG5vZGUgaXMgcm9vdGVkXG4gIC8vIG9yIHVwcm9vdGVkLCBhbmQgYW55IHRpbWUgYW4gYXR0cmlidXRlIGlzIGFkZGVkLCByZW1vdmVkIG9yIGNoYW5nZWRcbiAgLy8gb24gYSByb290ZWQgZWxlbWVudC5cbiAgdGhpcy5ieUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvLyBUaGlzIHByb3BlcnR5IGhvbGRzIGEgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHZhbHVlIGFraW4gdG9cbiAgLy8gYSB0aW1lc3RhbXAgdXNlZCB0byByZWNvcmQgdGhlIGxhc3QgbW9kaWZpY2F0aW9uIHRpbWUgb2Ygbm9kZXNcbiAgLy8gYW5kIHRoZWlyIHN1YnRyZWVzLiBTZWUgdGhlIGxhc3RNb2RUaW1lIGF0dHJpYnV0ZSBhbmQgbW9kaWZ5KClcbiAgLy8gbWV0aG9kIG9mIHRoZSBOb2RlIGNsYXNzLiBBbmQgc2VlIEZpbHRlcmVkRWxlbWVudExpc3QgZm9yIGFuIGV4YW1wbGVcbiAgLy8gb2YgdGhlIHVzZSBvZiBsYXN0TW9kVGltZVxuICB0aGlzLm1vZGNsb2NrID0gMDtcbn1cblxuLy8gTWFwIGZyb20gbG93ZXJjYXNlIGV2ZW50IGNhdGVnb3J5IG5hbWVzICh1c2VkIGFzIGFyZ3VtZW50cyB0b1xuLy8gY3JlYXRlRXZlbnQoKSkgdG8gdGhlIHByb3BlcnR5IG5hbWUgaW4gdGhlIGltcGwgb2JqZWN0IG9mIHRoZVxuLy8gZXZlbnQgY29uc3RydWN0b3IuXG52YXIgc3VwcG9ydGVkRXZlbnRzID0ge1xuICBldmVudDogJ0V2ZW50JyxcbiAgY3VzdG9tZXZlbnQ6ICdDdXN0b21FdmVudCcsXG4gIHVpZXZlbnQ6ICdVSUV2ZW50JyxcbiAgbW91c2VldmVudDogJ01vdXNlRXZlbnQnXG59O1xuXG4vLyBDZXJ0YWluIGFyZ3VtZW50cyB0byBkb2N1bWVudC5jcmVhdGVFdmVudCgpIG11c3QgYmUgdHJlYXRlZCBzcGVjaWFsbHlcbnZhciByZXBsYWNlbWVudEV2ZW50ID0ge1xuICBldmVudHM6ICdldmVudCcsXG4gIGh0bWxldmVudHM6ICdldmVudCcsXG4gIG1vdXNlZXZlbnRzOiAnbW91c2VldmVudCcsXG4gIG11dGF0aW9uZXZlbnRzOiAnbXV0YXRpb25ldmVudCcsXG4gIHVpZXZlbnRzOiAndWlldmVudCdcbn07XG5cbnZhciBtaXJyb3JBdHRyID0gZnVuY3Rpb24oZiwgbmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvID0gZi5jYWxsKHRoaXMpO1xuICAgICAgaWYgKG8pIHsgcmV0dXJuIG9bbmFtZV07IH1cbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbyA9IGYuY2FsbCh0aGlzKTtcbiAgICAgIGlmIChvKSB7IG9bbmFtZV0gPSB2YWx1ZTsgfVxuICAgIH0sXG4gIH07XG59O1xuXG5Eb2N1bWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlLCB7XG4gIC8vIFRoaXMgbWV0aG9kIGFsbG93cyBkb20uanMgdG8gY29tbXVuaWNhdGUgd2l0aCBhIHJlbmRlcmVyXG4gIC8vIHRoYXQgZGlzcGxheXMgdGhlIGRvY3VtZW50IGluIHNvbWUgd2F5XG4gIC8vIFhYWDogSSBzaG91bGQgcHJvYmFibHkgbW92ZSB0aGlzIHRvIHRoZSB3aW5kb3cgb2JqZWN0XG4gIF9zZXRNdXRhdGlvbkhhbmRsZXI6IHsgdmFsdWU6IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB0aGlzLm11dGF0aW9uSGFuZGxlciA9IGhhbmRsZXI7XG4gIH19LFxuXG4gIC8vIFRoaXMgbWV0aG9kIGFsbG93cyBkb20uanMgdG8gcmVjZWl2ZSBldmVudCBub3RpZmljYXRpb25zXG4gIC8vIGZyb20gdGhlIHJlbmRlcmVyLlxuICAvLyBYWFg6IEkgc2hvdWxkIHByb2JhYmx5IG1vdmUgdGhpcyB0byB0aGUgd2luZG93IG9iamVjdFxuICBfZGlzcGF0Y2hSZW5kZXJlckV2ZW50OiB7IHZhbHVlOiBmdW5jdGlvbih0YXJnZXROaWQsIHR5cGUsIGRldGFpbHMpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fbm9kZXNbdGFyZ2V0TmlkXTtcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgIHRhcmdldC5fZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQodHlwZSwgZGV0YWlscyksIHRydWUpO1xuICB9fSxcblxuICBub2RlTmFtZTogeyB2YWx1ZTogJyNkb2N1bWVudCd9LFxuICBub2RlVmFsdWU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKCkge31cbiAgfSxcblxuICAvLyBYWFg6IERPTUNvcmUgbWF5IHJlbW92ZSBkb2N1bWVudFVSSSwgc28gaXQgaXMgTllJIGZvciBub3dcbiAgZG9jdW1lbnRVUkk6IHsgZ2V0OiB1dGlscy5ueWksIHNldDogdXRpbHMubnlpIH0sXG4gIGNvbXBhdE1vZGU6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGUgX3F1aXJrcyBwcm9wZXJ0eSBpcyBzZXQgYnkgdGhlIEhUTUwgcGFyc2VyXG4gICAgcmV0dXJuIHRoaXMuX3F1aXJrcyA/ICdCYWNrQ29tcGF0JyA6ICdDU1MxQ29tcGF0JztcbiAgfX0sXG4gIHBhcmVudE5vZGU6IHsgdmFsdWU6IG51bGwgfSxcblxuICBjcmVhdGVUZXh0Tm9kZTogeyB2YWx1ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiBuZXcgVGV4dCh0aGlzLCAnJyArIGRhdGEpO1xuICB9fSxcbiAgY3JlYXRlQ29tbWVudDogeyB2YWx1ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ29tbWVudCh0aGlzLCBkYXRhKTtcbiAgfX0sXG4gIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQ6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnRGcmFnbWVudCh0aGlzKTtcbiAgfX0sXG4gIGNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbjogeyB2YWx1ZTogZnVuY3Rpb24odGFyZ2V0LCBkYXRhKSB7XG4gICAgaWYgKCF4bWwuaXNWYWxpZE5hbWUodGFyZ2V0KSB8fCBkYXRhLmluZGV4T2YoJz8+JykgIT09IC0xKVxuICAgICAgdXRpbHMuSW52YWxpZENoYXJhY3RlckVycm9yKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24odGhpcywgdGFyZ2V0LCBkYXRhKTtcbiAgfX0sXG5cbiAgY3JlYXRlRWxlbWVudDogeyB2YWx1ZTogZnVuY3Rpb24obG9jYWxOYW1lKSB7XG4gICAgaWYgKCF4bWwuaXNWYWxpZE5hbWUobG9jYWxOYW1lKSkgdXRpbHMuSW52YWxpZENoYXJhY3RlckVycm9yKCk7XG4gICAgaWYgKHRoaXMuaXNIVE1MKSBsb2NhbE5hbWUgPSB1dGlscy50b0FTQ0lJTG93ZXJDYXNlKGxvY2FsTmFtZSk7XG4gICAgcmV0dXJuIGh0bWwuY3JlYXRlRWxlbWVudCh0aGlzLCBsb2NhbE5hbWUsIG51bGwpO1xuICB9LCB3cml0YWJsZTogaXNBcGlXcml0YWJsZSB9LFxuXG4gIGNyZWF0ZUVsZW1lbnROUzogeyB2YWx1ZTogZnVuY3Rpb24obmFtZXNwYWNlLCBxdWFsaWZpZWROYW1lKSB7XG4gICAgaWYgKCF4bWwuaXNWYWxpZE5hbWUocXVhbGlmaWVkTmFtZSkpIHV0aWxzLkludmFsaWRDaGFyYWN0ZXJFcnJvcigpO1xuICAgIGlmICgheG1sLmlzVmFsaWRRTmFtZShxdWFsaWZpZWROYW1lKSkgdXRpbHMuTmFtZXNwYWNlRXJyb3IoKTtcblxuICAgIHZhciBwb3MsIHByZWZpeCwgbG9jYWxOYW1lO1xuICAgIGlmICgocG9zID0gcXVhbGlmaWVkTmFtZS5pbmRleE9mKCc6JykpICE9PSAtMSkge1xuICAgICAgcHJlZml4ID0gcXVhbGlmaWVkTmFtZS5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICAgIGxvY2FsTmFtZSA9IHF1YWxpZmllZE5hbWUuc3Vic3RyaW5nKHBvcysxKTtcblxuICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gJycgfHxcbiAgICAgICAgKHByZWZpeCA9PT0gJ3htbCcgJiYgbmFtZXNwYWNlICE9PSBOQU1FU1BBQ0UuWE1MKSlcbiAgICAgICAgdXRpbHMuTmFtZXNwYWNlRXJyb3IoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwcmVmaXggPSBudWxsO1xuICAgICAgbG9jYWxOYW1lID0gcXVhbGlmaWVkTmFtZTtcbiAgICB9XG5cbiAgICBpZiAoKChxdWFsaWZpZWROYW1lID09PSAneG1sbnMnIHx8IHByZWZpeCA9PT0gJ3htbG5zJykgJiZcbiAgICAgICBuYW1lc3BhY2UgIT09IE5BTUVTUEFDRS5YTUxOUykgfHxcbiAgICAgIChuYW1lc3BhY2UgPT09IE5BTUVTUEFDRS5YTUxOUyAmJlxuICAgICAgIHF1YWxpZmllZE5hbWUgIT09ICd4bWxucycgJiZcbiAgICAgICBwcmVmaXggIT09ICd4bWxucycpKVxuICAgICAgdXRpbHMuTmFtZXNwYWNlRXJyb3IoKTtcblxuICAgIGlmIChuYW1lc3BhY2UgPT09IE5BTUVTUEFDRS5IVE1MKSB7XG4gICAgICByZXR1cm4gaHRtbC5jcmVhdGVFbGVtZW50KHRoaXMsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZXNwYWNlID09PSBOQU1FU1BBQ0UuU1ZHKSB7XG4gICAgICByZXR1cm4gc3ZnLmNyZWF0ZUVsZW1lbnQodGhpcywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRWxlbWVudCh0aGlzLCBsb2NhbE5hbWUsIG5hbWVzcGFjZSwgcHJlZml4KTtcbiAgfSwgd3JpdGFibGU6IGlzQXBpV3JpdGFibGUgfSxcblxuICBjcmVhdGVFdmVudDogeyB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRXZlbnQoaW50ZXJmYWNlTmFtZSkge1xuICAgIGludGVyZmFjZU5hbWUgPSBpbnRlcmZhY2VOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG5hbWUgPSByZXBsYWNlbWVudEV2ZW50W2ludGVyZmFjZU5hbWVdIHx8IGludGVyZmFjZU5hbWU7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gZXZlbnRzW3N1cHBvcnRlZEV2ZW50c1tuYW1lXV07XG5cbiAgICBpZiAoY29uc3RydWN0b3IpIHtcbiAgICAgIHZhciBlID0gbmV3IGNvbnN0cnVjdG9yKCk7XG4gICAgICBlLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdXRpbHMuTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICB9XG4gIH19LFxuXG4gIC8vIFNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tZG9jdW1lbnQtY3JlYXRldHJlZXdhbGtlclxuICBjcmVhdGVUcmVlV2Fsa2VyOiB7dmFsdWU6IGZ1bmN0aW9uIChyb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpIHtcbiAgICB3aGF0VG9TaG93ID0gd2hhdFRvU2hvdyA9PT0gdW5kZWZpbmVkID8gTm9kZUZpbHRlci5TSE9XX0FMTCA6IHdoYXRUb1Nob3c7XG5cbiAgICBpZiAoZmlsdGVyICYmIHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuYWNjZXB0Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmlsdGVyID0gZmlsdGVyLmFjY2VwdE5vZGUuYmluZChmaWx0ZXIpO1xuICAgICAgLy8gU3VwcG9ydCBmaWx0ZXIgYmVpbmcgYSBmdW5jdGlvblxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlclxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmlsdGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaWx0ZXIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyZWVXYWxrZXIocm9vdCwgd2hhdFRvU2hvdywgZmlsdGVyKTtcbiAgfX0sXG5cbiAgLy8gU2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS1kb2N1bWVudC1jcmVhdGVub2RlaXRlcmF0b3JcbiAgY3JlYXRlTm9kZUl0ZXJhdG9yOiB7dmFsdWU6IGZ1bmN0aW9uIChyb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpIHtcbiAgICB3aGF0VG9TaG93ID0gd2hhdFRvU2hvdyA9PT0gdW5kZWZpbmVkID8gTm9kZUZpbHRlci5TSE9XX0FMTCA6IHdoYXRUb1Nob3c7XG5cbiAgICBpZiAoZmlsdGVyICYmIHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuYWNjZXB0Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmlsdGVyID0gZmlsdGVyLmFjY2VwdE5vZGUuYmluZChmaWx0ZXIpO1xuICAgICAgLy8gU3VwcG9ydCBmaWx0ZXIgYmVpbmcgYSBmdW5jdGlvblxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yXG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbHRlciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTm9kZUl0ZXJhdG9yKHJvb3QsIHdoYXRUb1Nob3csIGZpbHRlcik7XG4gIH19LFxuXG4gIC8vIE1haW50YWluIHRoZSBkb2N1bWVudEVsZW1lbnQgYW5kXG4gIC8vIGRvY3R5cGUgcHJvcGVydGllcyBvZiB0aGUgZG9jdW1lbnQuICBFYWNoIG9mIHRoZSBmb2xsb3dpbmdcbiAgLy8gbWV0aG9kcyBjaGFpbnMgdG8gdGhlIE5vZGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIG1ldGhvZFxuICAvLyB0byBkbyB0aGUgYWN0dWFsIGluc2VydGluZywgcmVtb3ZhbCBvciByZXBsYWNlbWVudC5cblxuICBfdXBkYXRlRG9jVHlwZUVsZW1lbnQ6IHsgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVEb2NUeXBlRWxlbWVudCgpIHtcbiAgICB2YXIgaSwgbiwgbm9kZXMgPSB0aGlzLmNoaWxkTm9kZXMsIGxlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgICB0aGlzLmRvY3R5cGUgPSB0aGlzLmRvY3VtZW50RWxlbWVudCA9IG51bGw7XG4gICAgZm9yIChpPTA7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gPSBub2Rlc1tpXTtcbiAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX1RZUEVfTk9ERSlcbiAgICAgICAgdGhpcy5kb2N0eXBlID0gbjtcbiAgICAgIGVsc2UgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKVxuICAgICAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IG47XG4gICAgfVxuICB9fSxcblxuICBpbnNlcnRCZWZvcmU6IHsgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShjaGlsZCwgcmVmQ2hpbGQpIHtcbiAgICBOb2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUuY2FsbCh0aGlzLCBjaGlsZCwgcmVmQ2hpbGQpO1xuICAgIHRoaXMuX3VwZGF0ZURvY1R5cGVFbGVtZW50KCk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9fSxcblxuICByZXBsYWNlQ2hpbGQ6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VDaGlsZChub2RlLCBjaGlsZCkge1xuICAgIE5vZGUucHJvdG90eXBlLnJlcGxhY2VDaGlsZC5jYWxsKHRoaXMsIG5vZGUsIGNoaWxkKTtcbiAgICB0aGlzLl91cGRhdGVEb2NUeXBlRWxlbWVudCgpO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfX0sXG5cbiAgcmVtb3ZlQ2hpbGQ6IHsgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgTm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgdGhpcy5fdXBkYXRlRG9jVHlwZUVsZW1lbnQoKTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH19LFxuXG4gIGdldEVsZW1lbnRCeUlkOiB7IHZhbHVlOiBmdW5jdGlvbihpZCkge1xuICAgIHZhciBuID0gdGhpcy5ieUlkW2lkXTtcbiAgICBpZiAoIW4pIHJldHVybiBudWxsO1xuICAgIGlmIChuIGluc3RhbmNlb2YgTXVsdGlJZCkgeyAvLyB0aGVyZSB3YXMgbW9yZSB0aGFuIG9uZSBlbGVtZW50IHdpdGggdGhpcyBpZFxuICAgICAgcmV0dXJuIG4uZ2V0Rmlyc3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH19LFxuXG4gIF9oYXNNdWx0aXBsZUVsZW1lbnRzV2l0aElkOiB7IHZhbHVlOiBmdW5jdGlvbihpZCkge1xuICAgIC8vIFVzZWQgaW50ZXJuYWxseSBieSBxdWVyeVNlbGVjdG9yQWxsIG9wdGltaXphdGlvblxuICAgIHJldHVybiAodGhpcy5ieUlkW2lkXSBpbnN0YW5jZW9mIE11bHRpSWQpO1xuICB9fSxcblxuICAvLyBKdXN0IGNvcHkgdGhpcyBtZXRob2QgZnJvbSB0aGUgRWxlbWVudCBwcm90b3R5cGVcbiAgZ2V0RWxlbWVudHNCeU5hbWU6IHsgdmFsdWU6IEVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlOYW1lIH0sXG4gIGdldEVsZW1lbnRzQnlUYWdOYW1lOiB7IHZhbHVlOiBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZSB9LFxuICBnZXRFbGVtZW50c0J5VGFnTmFtZU5TOiB7IHZhbHVlOiBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TIH0sXG4gIGdldEVsZW1lbnRzQnlDbGFzc05hbWU6IHsgdmFsdWU6IEVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgfSxcblxuICBhZG9wdE5vZGU6IHsgdmFsdWU6IGZ1bmN0aW9uIGFkb3B0Tm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkgdXRpbHMuTm90U3VwcG9ydGVkRXJyb3IoKTtcblxuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcblxuICAgIGlmIChub2RlLm93bmVyRG9jdW1lbnQgIT09IHRoaXMpXG4gICAgICByZWN1cnNpdmVseVNldE93bmVyKG5vZGUsIHRoaXMpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH19LFxuXG4gIGltcG9ydE5vZGU6IHsgdmFsdWU6IGZ1bmN0aW9uIGltcG9ydE5vZGUobm9kZSwgZGVlcCkge1xuICAgIHJldHVybiB0aGlzLmFkb3B0Tm9kZShub2RlLmNsb25lTm9kZShkZWVwKSk7XG4gIH0sIHdyaXRhYmxlOiBpc0FwaVdyaXRhYmxlIH0sXG5cbiAgLy8gVGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzIGFuZCBtZXRob2RzIGFyZSBmcm9tIHRoZSBIVE1MIHNwZWNcbiAgVVJMOiB7IGdldDogdXRpbHMubnlpIH0sXG4gIGRvbWFpbjogeyBnZXQ6IHV0aWxzLm55aSwgc2V0OiB1dGlscy5ueWkgfSxcbiAgcmVmZXJyZXI6IHsgZ2V0OiB1dGlscy5ueWkgfSxcbiAgY29va2llOiB7IGdldDogdXRpbHMubnlpLCBzZXQ6IHV0aWxzLm55aSB9LFxuICBsYXN0TW9kaWZpZWQ6IHsgZ2V0OiB1dGlscy5ueWkgfSxcbiAgbG9jYXRpb246IHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gdGhpcy5kZWZhdWx0VmlldyA/IHRoaXMuZGVmYXVsdFZpZXcubG9jYXRpb24gOiBudWxsOyAvLyBnaCAjNzVcblx0fSxcblx0c2V0OiB1dGlscy5ueWlcbiAgfSxcbiAgX3RpdGxlRWxlbWVudDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBUaGUgdGl0bGUgZWxlbWVudCBvZiBhIGRvY3VtZW50IGlzIHRoZSBmaXJzdCB0aXRsZSBlbGVtZW50IGluIHRoZVxuICAgICAgLy8gZG9jdW1lbnQgaW4gdHJlZSBvcmRlciwgaWYgdGhlcmUgaXMgb25lLCBvciBudWxsIG90aGVyd2lzZS5cbiAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aXRsZScpLml0ZW0oMCkgfHwgbnVsbDtcbiAgICB9XG4gIH0sXG4gIHRpdGxlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbHQgPSB0aGlzLl90aXRsZUVsZW1lbnQ7XG4gICAgICAvLyBUaGUgY2hpbGQgdGV4dCBjb250ZW50IG9mIHRoZSB0aXRsZSBlbGVtZW50LCBvciAnJyBpZiBudWxsLlxuICAgICAgdmFyIHZhbHVlID0gZWx0ID8gZWx0LnRleHRDb250ZW50IDogJyc7XG4gICAgICAvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBpbiB2YWx1ZVxuICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1sgXFx0XFxuXFxyXFxmXSsvZywgJyAnKS50cmltKCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZWx0ID0gdGhpcy5fdGl0bGVFbGVtZW50O1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQ7XG4gICAgICBpZiAoIWVsdCAmJiAhaGVhZCkgeyByZXR1cm47IC8qIGFjY29yZGluZyB0byBzcGVjICovIH1cbiAgICAgIGlmICghZWx0KSB7XG4gICAgICAgIGVsdCA9IHRoaXMuY3JlYXRlRWxlbWVudCgndGl0bGUnKTtcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChlbHQpO1xuICAgICAgfVxuICAgICAgZWx0LnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBkaXI6IG1pcnJvckF0dHIoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGh0bWxFbGVtZW50ID0gdGhpcy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaWYgKGh0bWxFbGVtZW50ICYmIGh0bWxFbGVtZW50LnRhZ05hbWUgPT09ICdIVE1MJykgeyByZXR1cm4gaHRtbEVsZW1lbnQ7IH1cbiAgfSwgJ2RpcicsICcnKSxcbiAgZmdDb2xvcjogbWlycm9yQXR0cihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYm9keTsgfSwgJ3RleHQnLCAnJyksXG4gIGxpbmtDb2xvcjogbWlycm9yQXR0cihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYm9keTsgfSwgJ2xpbmsnLCAnJyksXG4gIHZsaW5rQ29sb3I6IG1pcnJvckF0dHIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmJvZHk7IH0sICd2TGluaycsICcnKSxcbiAgYWxpbmtDb2xvcjogbWlycm9yQXR0cihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYm9keTsgfSwgJ2FMaW5rJywgJycpLFxuICBiZ0NvbG9yOiBtaXJyb3JBdHRyKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ib2R5OyB9LCAnYmdDb2xvcicsICcnKSxcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IDxib2R5PiBjaGlsZCBvZiB0aGUgZG9jdW1lbnQgZWxlbWVudC5cbiAgLy8gWFhYIEZvciBub3csIHNldHRpbmcgdGhpcyBhdHRyaWJ1dGUgaXMgbm90IGltcGxlbWVudGVkLlxuICBib2R5OiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuYW1lZEhUTUxDaGlsZCh0aGlzLmRvY3VtZW50RWxlbWVudCwgJ2JvZHknKTtcbiAgICB9LFxuICAgIHNldDogdXRpbHMubnlpXG4gIH0sXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgPGhlYWQ+IGNoaWxkIG9mIHRoZSBkb2N1bWVudCBlbGVtZW50LlxuICBoZWFkOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5hbWVkSFRNTENoaWxkKHRoaXMuZG9jdW1lbnRFbGVtZW50LCAnaGVhZCcpO1xuICB9fSxcbiAgaW1hZ2VzOiB7IGdldDogdXRpbHMubnlpIH0sXG4gIGVtYmVkczogeyBnZXQ6IHV0aWxzLm55aSB9LFxuICBwbHVnaW5zOiB7IGdldDogdXRpbHMubnlpIH0sXG4gIGxpbmtzOiB7IGdldDogdXRpbHMubnlpIH0sXG4gIGZvcm1zOiB7IGdldDogdXRpbHMubnlpIH0sXG4gIHNjcmlwdHM6IHsgZ2V0OiB1dGlscy5ueWkgfSxcbiAgaW5uZXJIVE1MOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7IH0sXG4gICAgc2V0OiB1dGlscy5ueWlcbiAgfSxcbiAgb3V0ZXJIVE1MOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7IH0sXG4gICAgc2V0OiB1dGlscy5ueWlcbiAgfSxcblxuICB3cml0ZTogeyB2YWx1ZTogZnVuY3Rpb24oYXJncykge1xuICAgIGlmICghdGhpcy5pc0hUTUwpIHV0aWxzLkludmFsaWRTdGF0ZUVycm9yKCk7XG5cbiAgICAvLyBYWFg6IHN0aWxsIGhhdmUgdG8gaW1wbGVtZW50IHRoZSBpZ25vcmUgcGFydFxuICAgIGlmICghdGhpcy5fcGFyc2VyIC8qICYmIHRoaXMuX2lnbm9yZV9kZXN0cnVjdGl2ZV93cml0ZXMgPiAwICovIClcbiAgICAgIHJldHVybjtcblxuICAgIGlmICghdGhpcy5fcGFyc2VyKSB7XG4gICAgICAvLyBYWFggY2FsbCBkb2N1bWVudC5vcGVuLCBldGMuXG4gICAgfVxuXG4gICAgdmFyIHMgPSBhcmd1bWVudHMuam9pbignJyk7XG5cbiAgICAvLyBJZiB0aGUgRG9jdW1lbnQgb2JqZWN0J3MgcmVsb2FkIG92ZXJyaWRlIGZsYWcgaXMgc2V0LCB0aGVuXG4gICAgLy8gYXBwZW5kIHRoZSBzdHJpbmcgY29uc2lzdGluZyBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGhlXG4gICAgLy8gYXJndW1lbnRzIHRvIHRoZSBtZXRob2QgdG8gdGhlIERvY3VtZW50J3MgcmVsb2FkIG92ZXJyaWRlXG4gICAgLy8gYnVmZmVyLlxuICAgIC8vIFhYWDogZG9uJ3Qga25vdyB3aGF0IHRoaXMgaXMgYWJvdXQuICBTdGlsbCBoYXZlIHRvIGRvIGl0XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBwZW5kaW5nIHBhcnNpbmctYmxvY2tpbmcgc2NyaXB0LCBoYXZlIHRoZVxuICAgIC8vIHRva2VuaXplciBwcm9jZXNzIHRoZSBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBpbnNlcnRlZCwgb25lIGF0IGFcbiAgICAvLyB0aW1lLCBwcm9jZXNzaW5nIHJlc3VsdGluZyB0b2tlbnMgYXMgdGhleSBhcmUgZW1pdHRlZCwgYW5kXG4gICAgLy8gc3RvcHBpbmcgd2hlbiB0aGUgdG9rZW5pemVyIHJlYWNoZXMgdGhlIGluc2VydGlvbiBwb2ludCBvciB3aGVuXG4gICAgLy8gdGhlIHByb2Nlc3Npbmcgb2YgdGhlIHRva2VuaXplciBpcyBhYm9ydGVkIGJ5IHRoZSB0cmVlXG4gICAgLy8gY29uc3RydWN0aW9uIHN0YWdlICh0aGlzIGNhbiBoYXBwZW4gaWYgYSBzY3JpcHQgZW5kIHRhZyB0b2tlbiBpc1xuICAgIC8vIGVtaXR0ZWQgYnkgdGhlIHRva2VuaXplcikuXG5cbiAgICAvLyBYWFg6IHN0aWxsIGhhdmUgdG8gZG8gdGhlIGFib3ZlLiBTb3VuZHMgYXMgaWYgd2UgZG9uJ3RcbiAgICAvLyBhbHdheXMgY2FsbCBwYXJzZSgpIGhlcmUuICBJZiB3ZSdyZSBibG9ja2VkLCB0aGVuIHdlIGp1c3RcbiAgICAvLyBpbnNlcnQgdGhlIHRleHQgaW50byB0aGUgc3RyZWFtIGJ1dCBkb24ndCBwYXJzZSBpdCByZWVudHJhbnRseS4uLlxuXG4gICAgLy8gSW52b2tlIHRoZSBwYXJzZXIgcmVlbnRyYW50bHlcbiAgICB0aGlzLl9wYXJzZXIucGFyc2Uocyk7XG4gIH19LFxuXG4gIHdyaXRlbG46IHsgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlbG4oYXJncykge1xuICAgIHRoaXMud3JpdGUoQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcnKSArICdcXG4nKTtcbiAgfX0sXG5cbiAgb3BlbjogeyB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBudWxsO1xuICB9fSxcblxuICBjbG9zZTogeyB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2NvbXBsZXRlJztcbiAgICB2YXIgZXYgPSBuZXcgRXZlbnQoJ0RPTUNvbnRlbnRMb2FkZWQnKTtcbiAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KGV2LCB0cnVlKTtcbiAgICBpZiAodGhpcy5kZWZhdWx0Vmlldykge1xuICAgICAgZXYgPSBuZXcgRXZlbnQoJ2xvYWQnKTtcbiAgICAgIHRoaXMuZGVmYXVsdFZpZXcuX2Rpc3BhdGNoRXZlbnQoZXYsIHRydWUpO1xuICAgIH1cbiAgfX0sXG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIGNsb25lOiB7IHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAvLyBDYW4ndCBjbG9uZSBhbiBlbnRpcmUgZG9jdW1lbnRcbiAgICB1dGlscy5EYXRhQ2xvbmVFcnJvcigpO1xuICB9fSxcblxuICBpc0VxdWFsOiB7IHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsKG4pIHtcbiAgICAvLyBBbnkgdHdvIGRvY3VtZW50cyBhcmUgc2hhbGxvd2x5IGVxdWFsLlxuICAgIC8vIE5vZGUuaXNFcXVhbE5vZGUgd2lsbCBhbHNvIHRlc3QgdGhlIGNoaWxkcmVuXG4gICAgcmV0dXJuIHRydWU7XG4gIH19LFxuXG4gIC8vIEltcGxlbWVudGF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uLiAgQ2FsbGVkIHdoZW4gYSB0ZXh0LCBjb21tZW50LFxuICAvLyBvciBwaSB2YWx1ZSBjaGFuZ2VzLlxuICBtdXRhdGVWYWx1ZTogeyB2YWx1ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLm11dGF0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5tdXRhdGlvbkhhbmRsZXIoe1xuICAgICAgICB0eXBlOiBNVVRBVEUuVkFMVUUsXG4gICAgICAgIHRhcmdldDogbm9kZSxcbiAgICAgICAgZGF0YTogbm9kZS5kYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH19LFxuXG4gIC8vIEludm9rZWQgd2hlbiBhbiBhdHRyaWJ1dGUncyB2YWx1ZSBjaGFuZ2VzLiBBdHRyIGhvbGRzIHRoZSBuZXdcbiAgLy8gdmFsdWUuICBvbGR2YWwgaXMgdGhlIG9sZCB2YWx1ZS4gIEF0dHJpYnV0ZSBtdXRhdGlvbnMgY2FuIGFsc29cbiAgLy8gaW52b2x2ZSBjaGFuZ2VzIHRvIHRoZSBwcmVmaXggKGFuZCB0aGVyZWZvcmUgdGhlIHF1YWxpZmllZCBuYW1lKVxuICBtdXRhdGVBdHRyOiB7IHZhbHVlOiBmdW5jdGlvbihhdHRyLCBvbGR2YWwpIHtcbiAgICAvLyBNYW5hZ2UgaWQtPmVsZW1lbnQgbWFwcGluZyBmb3IgZ2V0RWxlbWVudHNCeUlkKClcbiAgICAvLyBYWFg6IHRoaXMgc3BlY2lhbCBjYXNlIGlkIGhhbmRsaW5nIHNob3VsZCBub3QgZ28gaGVyZSxcbiAgICAvLyBidXQgaW4gdGhlIGF0dHJpYnV0ZSBkZWNsYXJhdGlvbiBmb3IgdGhlIGlkIGF0dHJpYnV0ZVxuICAgIC8qXG4gICAgaWYgKGF0dHIubG9jYWxOYW1lID09PSAnaWQnICYmIGF0dHIubmFtZXNwYWNlVVJJID09PSBudWxsKSB7XG4gICAgICBpZiAob2xkdmFsKSBkZWxJZChvbGR2YWwsIGF0dHIub3duZXJFbGVtZW50KTtcbiAgICAgIGFkZElkKGF0dHIudmFsdWUsIGF0dHIub3duZXJFbGVtZW50KTtcbiAgICB9XG4gICAgKi9cbiAgICBpZiAodGhpcy5tdXRhdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMubXV0YXRpb25IYW5kbGVyKHtcbiAgICAgICAgdHlwZTogTVVUQVRFLkFUVFIsXG4gICAgICAgIHRhcmdldDogYXR0ci5vd25lckVsZW1lbnQsXG4gICAgICAgIGF0dHI6IGF0dHJcbiAgICAgIH0pO1xuICAgIH1cbiAgfX0sXG5cbiAgLy8gVXNlZCBieSByZW1vdmVBdHRyaWJ1dGUgYW5kIHJlbW92ZUF0dHJpYnV0ZU5TIGZvciBhdHRyaWJ1dGVzLlxuICBtdXRhdGVSZW1vdmVBdHRyOiB7IHZhbHVlOiBmdW5jdGlvbihhdHRyKSB7XG4vKlxuKiBUaGlzIGlzIG5vdyBoYW5kbGVkIGluIEF0dHJpYnV0ZXMuanNcbiAgICAvLyBNYW5hZ2UgaWQgdG8gZWxlbWVudCBtYXBwaW5nXG4gICAgaWYgKGF0dHIubG9jYWxOYW1lID09PSAnaWQnICYmIGF0dHIubmFtZXNwYWNlVVJJID09PSBudWxsKSB7XG4gICAgICB0aGlzLmRlbElkKGF0dHIudmFsdWUsIGF0dHIub3duZXJFbGVtZW50KTtcbiAgICB9XG4qL1xuICAgIGlmICh0aGlzLm11dGF0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5tdXRhdGlvbkhhbmRsZXIoe1xuICAgICAgICB0eXBlOiBNVVRBVEUuUkVNT1ZFX0FUVFIsXG4gICAgICAgIHRhcmdldDogYXR0ci5vd25lckVsZW1lbnQsXG4gICAgICAgIGF0dHI6IGF0dHJcbiAgICAgIH0pO1xuICAgIH1cbiAgfX0sXG5cbiAgLy8gQ2FsbGVkIGJ5IE5vZGUucmVtb3ZlQ2hpbGQsIGV0Yy4gdG8gcmVtb3ZlIGEgcm9vdGVkIGVsZW1lbnQgZnJvbVxuICAvLyB0aGUgdHJlZS4gT25seSBuZWVkcyB0byBnZW5lcmF0ZSBhIHNpbmdsZSBtdXRhdGlvbiBldmVudCB3aGVuIGFcbiAgLy8gbm9kZSBpcyByZW1vdmVkLCBidXQgbXVzdCByZWN1cnNpdmVseSBtYXJrIGFsbCBkZXNjZW5kYW50cyBhcyBub3RcbiAgLy8gcm9vdGVkLlxuICBtdXRhdGVSZW1vdmU6IHsgdmFsdWU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAvLyBTZW5kIGEgc2luZ2xlIG11dGF0aW9uIGV2ZW50XG4gICAgaWYgKHRoaXMubXV0YXRpb25IYW5kbGVyKSB7XG4gICAgICB0aGlzLm11dGF0aW9uSGFuZGxlcih7XG4gICAgICAgIHR5cGU6IE1VVEFURS5SRU1PVkUsXG4gICAgICAgIHRhcmdldDogbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBub2RlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBNYXJrIHRoaXMgYW5kIGFsbCBkZXNjZW5kYW50cyBhcyBub3Qgcm9vdGVkXG4gICAgcmVjdXJzaXZlbHlVcHJvb3Qobm9kZSk7XG4gIH19LFxuXG4gIC8vIENhbGxlZCB3aGVuIGEgbmV3IGVsZW1lbnQgYmVjb21lcyByb290ZWQuICBJdCBtdXN0IHJlY3Vyc2l2ZWx5XG4gIC8vIGdlbmVyYXRlIG11dGF0aW9uIGV2ZW50cyBmb3IgZWFjaCBvZiB0aGUgY2hpbGRyZW4sIGFuZCBtYXJrIHRoZW0gYWxsXG4gIC8vIGFzIHJvb3RlZC5cbiAgbXV0YXRlSW5zZXJ0OiB7IHZhbHVlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgLy8gTWFyayBub2RlIGFuZCBpdHMgZGVzY2VuZGFudHMgYXMgcm9vdGVkXG4gICAgcmVjdXJzaXZlbHlSb290KG5vZGUpO1xuXG4gICAgLy8gU2VuZCBhIHNpbmdsZSBtdXRhdGlvbiBldmVudFxuICAgIGlmICh0aGlzLm11dGF0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5tdXRhdGlvbkhhbmRsZXIoe1xuICAgICAgICB0eXBlOiBNVVRBVEUuSU5TRVJULFxuICAgICAgICB0YXJnZXQ6IG5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogbm9kZVxuICAgICAgfSk7XG4gICAgfVxuICB9fSxcblxuICAvLyBDYWxsZWQgd2hlbiBhIHJvb3RlZCBlbGVtZW50IGlzIG1vdmVkIHdpdGhpbiB0aGUgZG9jdW1lbnRcbiAgbXV0YXRlTW92ZTogeyB2YWx1ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLm11dGF0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5tdXRhdGlvbkhhbmRsZXIoe1xuICAgICAgICB0eXBlOiBNVVRBVEUuTU9WRSxcbiAgICAgICAgdGFyZ2V0OiBub2RlXG4gICAgICB9KTtcbiAgICB9XG4gIH19LFxuXG5cbiAgLy8gQWRkIGEgbWFwcGluZyBmcm9tICBpZCB0byBuIGZvciBuLm93bmVyRG9jdW1lbnRcbiAgYWRkSWQ6IHsgdmFsdWU6IGZ1bmN0aW9uIGFkZElkKGlkLCBuKSB7XG4gICAgdmFyIHZhbCA9IHRoaXMuYnlJZFtpZF07XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHRoaXMuYnlJZFtpZF0gPSBuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEFkZCBhIHdheSB0byBvcHQtb3V0IGNvbnNvbGUgd2FybmluZ3NcbiAgICAgIC8vY29uc29sZS53YXJuKCdEdXBsaWNhdGUgZWxlbWVudCBpZCAnICsgaWQpO1xuICAgICAgaWYgKCEodmFsIGluc3RhbmNlb2YgTXVsdGlJZCkpIHtcbiAgICAgICAgdmFsID0gbmV3IE11bHRpSWQodmFsKTtcbiAgICAgICAgdGhpcy5ieUlkW2lkXSA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHZhbC5hZGQobik7XG4gICAgfVxuICB9fSxcblxuICAvLyBEZWxldGUgdGhlIG1hcHBpbmcgZnJvbSBpZCB0byBuIGZvciBuLm93bmVyRG9jdW1lbnRcbiAgZGVsSWQ6IHsgdmFsdWU6IGZ1bmN0aW9uIGRlbElkKGlkLCBuKSB7XG4gICAgdmFyIHZhbCA9IHRoaXMuYnlJZFtpZF07XG4gICAgdXRpbHMuYXNzZXJ0KHZhbCk7XG5cbiAgICBpZiAodmFsIGluc3RhbmNlb2YgTXVsdGlJZCkge1xuICAgICAgdmFsLmRlbChuKTtcbiAgICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7IC8vIGNvbnZlcnQgYmFjayB0byBhIHNpbmdsZSBub2RlXG4gICAgICAgIHRoaXMuYnlJZFtpZF0gPSB2YWwuZG93bmdyYWRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5ieUlkW2lkXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH19LFxuXG4gIF9yZXNvbHZlOiB7IHZhbHVlOiBmdW5jdGlvbihocmVmKSB7XG4gICAgLy9YWFg6IENhY2hlIHRoZSBVUkxcbiAgICByZXR1cm4gbmV3IFVSTCh0aGlzLl9kb2N1bWVudEJhc2VVUkwpLnJlc29sdmUoaHJlZik7XG4gIH19LFxuXG4gIF9kb2N1bWVudEJhc2VVUkw6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBYWFg6IFRoaXMgaXMgbm90IGltcGxlbWVudGVkIGNvcnJlY3RseSB5ZXRcbiAgICB2YXIgdXJsID0gdGhpcy5fYWRkcmVzcztcbiAgICBpZiAodXJsID09PSAnYWJvdXQ6YmxhbmsnKSB1cmwgPSAnLyc7XG5cbiAgICB2YXIgYmFzZSA9IHRoaXMucXVlcnlTZWxlY3RvcignYmFzZVtocmVmXScpO1xuICAgIGlmIChiYXNlKSB7XG4gICAgICByZXR1cm4gbmV3IFVSTCh1cmwpLnJlc29sdmUoYmFzZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG5cbiAgICAvLyBUaGUgZG9jdW1lbnQgYmFzZSBVUkwgb2YgYSBEb2N1bWVudCBvYmplY3QgaXMgdGhlXG4gICAgLy8gYWJzb2x1dGUgVVJMIG9idGFpbmVkIGJ5IHJ1bm5pbmcgdGhlc2Ugc3Vic3RlcHM6XG5cbiAgICAvLyAgICAgTGV0IGZhbGxiYWNrIGJhc2UgdXJsIGJlIHRoZSBkb2N1bWVudCdzIGFkZHJlc3MuXG5cbiAgICAvLyAgICAgSWYgZmFsbGJhY2sgYmFzZSB1cmwgaXMgYWJvdXQ6YmxhbmssIGFuZCB0aGVcbiAgICAvLyAgICAgRG9jdW1lbnQncyBicm93c2luZyBjb250ZXh0IGhhcyBhIGNyZWF0b3IgYnJvd3NpbmdcbiAgICAvLyAgICAgY29udGV4dCwgdGhlbiBsZXQgZmFsbGJhY2sgYmFzZSB1cmwgYmUgdGhlIGRvY3VtZW50XG4gICAgLy8gICAgIGJhc2UgVVJMIG9mIHRoZSBjcmVhdG9yIERvY3VtZW50IGluc3RlYWQuXG5cbiAgICAvLyAgICAgSWYgdGhlIERvY3VtZW50IGlzIGFuIGlmcmFtZSBzcmNkb2MgZG9jdW1lbnQsIHRoZW5cbiAgICAvLyAgICAgbGV0IGZhbGxiYWNrIGJhc2UgdXJsIGJlIHRoZSBkb2N1bWVudCBiYXNlIFVSTCBvZlxuICAgIC8vICAgICB0aGUgRG9jdW1lbnQncyBicm93c2luZyBjb250ZXh0J3MgYnJvd3NpbmcgY29udGV4dFxuICAgIC8vICAgICBjb250YWluZXIncyBEb2N1bWVudCBpbnN0ZWFkLlxuXG4gICAgLy8gICAgIElmIHRoZXJlIGlzIG5vIGJhc2UgZWxlbWVudCB0aGF0IGhhcyBhbiBocmVmXG4gICAgLy8gICAgIGF0dHJpYnV0ZSwgdGhlbiB0aGUgZG9jdW1lbnQgYmFzZSBVUkwgaXMgZmFsbGJhY2tcbiAgICAvLyAgICAgYmFzZSB1cmw7IGFib3J0IHRoZXNlIHN0ZXBzLiBPdGhlcndpc2UsIGxldCB1cmwgYmVcbiAgICAvLyAgICAgdGhlIHZhbHVlIG9mIHRoZSBocmVmIGF0dHJpYnV0ZSBvZiB0aGUgZmlyc3Qgc3VjaFxuICAgIC8vICAgICBlbGVtZW50LlxuXG4gICAgLy8gICAgIFJlc29sdmUgdXJsIHJlbGF0aXZlIHRvIGZhbGxiYWNrIGJhc2UgdXJsICh0aHVzLFxuICAgIC8vICAgICB0aGUgYmFzZSBocmVmIGF0dHJpYnV0ZSBpc24ndCBhZmZlY3RlZCBieSB4bWw6YmFzZVxuICAgIC8vICAgICBhdHRyaWJ1dGVzKS5cblxuICAgIC8vICAgICBUaGUgZG9jdW1lbnQgYmFzZSBVUkwgaXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXNcbiAgICAvLyAgICAgc3RlcCBpZiBpdCB3YXMgc3VjY2Vzc2Z1bDsgb3RoZXJ3aXNlIGl0IGlzIGZhbGxiYWNrXG4gICAgLy8gICAgIGJhc2UgdXJsLlxuICB9fSxcblxuICBfdGVtcGxhdGVEb2M6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX3RlbXBsYXRlRG9jQ2FjaGUpIHtcbiAgICAgIC8vIFwiYXNzb2NpYXRlZCBpbmVydCB0ZW1wbGF0ZSBkb2N1bWVudFwiXG4gICAgICB2YXIgbmV3RG9jID0gbmV3IERvY3VtZW50KHRoaXMuaXNIVE1MLCB0aGlzLl9hZGRyZXNzKTtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRG9jQ2FjaGUgPSBuZXdEb2MuX3RlbXBsYXRlRG9jQ2FjaGUgPSBuZXdEb2M7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZURvY0NhY2hlO1xuICB9fSxcblxuICBxdWVyeVNlbGVjdG9yOiB7IHZhbHVlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3Qoc2VsZWN0b3IsIHRoaXMpWzBdO1xuICB9fSxcblxuICBxdWVyeVNlbGVjdG9yQWxsOiB7IHZhbHVlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBub2RlcyA9IHNlbGVjdChzZWxlY3RvciwgdGhpcyk7XG4gICAgcmV0dXJuIG5vZGVzLml0ZW0gPyBub2RlcyA6IG5ldyBOb2RlTGlzdChub2Rlcyk7XG4gIH19XG5cbn0pO1xuXG5cbnZhciBldmVudEhhbmRsZXJUeXBlcyA9IFtcbiAgJ2Fib3J0JywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAnY2hhbmdlJywgJ2NsaWNrJywgJ2NvbnRleHRtZW51JyxcbiAgJ2N1ZWNoYW5nZScsICdkYmxjbGljaycsICdkcmFnJywgJ2RyYWdlbmQnLCAnZHJhZ2VudGVyJywgJ2RyYWdsZWF2ZScsXG4gICdkcmFnb3ZlcicsICdkcmFnc3RhcnQnLCAnZHJvcCcsICdkdXJhdGlvbmNoYW5nZScsICdlbXB0aWVkJywgJ2VuZGVkJyxcbiAgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdsb2FkZWRkYXRhJyxcbiAgJ2xvYWRlZG1ldGFkYXRhJywgJ2xvYWRzdGFydCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNlb3V0JyxcbiAgJ21vdXNlb3ZlcicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJyxcbiAgJ3Byb2dyZXNzJywgJ3JhdGVjaGFuZ2UnLCAncmVhZHlzdGF0ZWNoYW5nZScsICdyZXNldCcsICdzZWVrZWQnLFxuICAnc2Vla2luZycsICdzZWxlY3QnLCAnc2hvdycsICdzdGFsbGVkJywgJ3N1Ym1pdCcsICdzdXNwZW5kJyxcbiAgJ3RpbWV1cGRhdGUnLCAndm9sdW1lY2hhbmdlJywgJ3dhaXRpbmcnLFxuXG4gICdibHVyJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2xvYWQnLCAnc2Nyb2xsJ1xuXTtcblxuLy8gQWRkIGV2ZW50IGhhbmRsZXIgaWRsIGF0dHJpYnV0ZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRvIERvY3VtZW50XG5ldmVudEhhbmRsZXJUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgLy8gRGVmaW5lIHRoZSBldmVudCBoYW5kbGVyIHJlZ2lzdHJhdGlvbiBJREwgYXR0cmlidXRlIGZvciB0aGlzIHR5cGVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY3VtZW50LnByb3RvdHlwZSwgJ29uJyArIHR5cGUsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEV2ZW50SGFuZGxlcih0eXBlKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5fc2V0RXZlbnRIYW5kbGVyKHR5cGUsIHYpO1xuICAgIH1cbiAgfSk7XG59KTtcblxuZnVuY3Rpb24gbmFtZWRIVE1MQ2hpbGQocGFyZW50LCBuYW1lKSB7XG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LmlzSFRNTCkge1xuICAgIHZhciBraWRzID0gcGFyZW50LmNoaWxkTm9kZXM7XG4gICAgZm9yKHZhciBpID0gMCwgbiA9IGtpZHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAoa2lkc1tpXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiZcbiAgICAgICAga2lkc1tpXS5sb2NhbE5hbWUgPT09IG5hbWUgJiZcbiAgICAgICAga2lkc1tpXS5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5IVE1MKSB7XG4gICAgICAgIHJldHVybiBraWRzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcm9vdChuKSB7XG4gIG4uX25pZCA9IG4ub3duZXJEb2N1bWVudC5fbmV4dG5pZCsrO1xuICBuLm93bmVyRG9jdW1lbnQuX25vZGVzW24uX25pZF0gPSBuO1xuICAvLyBNYW5hZ2UgaWQgdG8gZWxlbWVudCBtYXBwaW5nXG4gIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIHZhciBpZCA9IG4uZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgIGlmIChpZCkgbi5vd25lckRvY3VtZW50LmFkZElkKGlkLCBuKTtcblxuICAgIC8vIFNjcmlwdCBlbGVtZW50cyBuZWVkIHRvIGtub3cgd2hlbiB0aGV5J3JlIGluc2VydGVkXG4gICAgLy8gaW50byB0aGUgZG9jdW1lbnRcbiAgICBpZiAobi5fcm9vdGhvb2spIG4uX3Jvb3Rob29rKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXByb290KG4pIHtcbiAgLy8gTWFuYWdlIGlkIHRvIGVsZW1lbnQgbWFwcGluZ1xuICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICB2YXIgaWQgPSBuLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICBpZiAoaWQpIG4ub3duZXJEb2N1bWVudC5kZWxJZChpZCwgbik7XG4gIH1cbiAgbi5vd25lckRvY3VtZW50Ll9ub2Rlc1tuLl9uaWRdID0gdW5kZWZpbmVkO1xuICBuLl9uaWQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5Um9vdChub2RlKSB7XG4gIHJvb3Qobm9kZSk7XG4gIC8vIFhYWDpcbiAgLy8gYWNjZXNzaW5nIGNoaWxkTm9kZXMgb24gYSBsZWFmIG5vZGUgY3JlYXRlcyBhIG5ldyBhcnJheSB0aGVcbiAgLy8gZmlyc3QgdGltZSwgc28gYmUgY2FyZWZ1bCB0byB3cml0ZSB0aGlzIGxvb3Agc28gdGhhdCBpdFxuICAvLyBkb2Vzbid0IGRvIHRoYXQuIG5vZGUgaXMgcG9seW1vcnBoaWMsIHNvIG1heWJlIHRoaXMgaXMgaGFyZCB0b1xuICAvLyBvcHRpbWl6ZT8gIFRyeSBzd2l0Y2hpbmcgb24gbm9kZVR5cGU/XG4vKlxuICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICB2YXIga2lkcyA9IG5vZGUuY2hpbGROb2RlcztcbiAgICBmb3IodmFyIGkgPSAwLCBuID0ga2lkcy5sZW5ndGg7ICBpIDwgbjsgaSsrKVxuICAgICAgcmVjdXJzaXZlbHlSb290KGtpZHNbaV0pO1xuICB9XG4qL1xuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICB2YXIga2lkcyA9IG5vZGUuY2hpbGROb2RlcztcbiAgICBmb3IodmFyIGkgPSAwLCBuID0ga2lkcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICByZWN1cnNpdmVseVJvb3Qoa2lkc1tpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlVcHJvb3Qobm9kZSkge1xuICB1cHJvb3Qobm9kZSk7XG4gIGZvcih2YXIgaSA9IDAsIG4gPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgIHJlY3Vyc2l2ZWx5VXByb290KG5vZGUuY2hpbGROb2Rlc1tpXSk7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5U2V0T3duZXIobm9kZSwgb3duZXIpIHtcbiAgbm9kZS5vd25lckRvY3VtZW50ID0gb3duZXI7XG4gIG5vZGUuX2xhc3RNb2RUaW1lID0gdW5kZWZpbmVkOyAvLyBtb2QgdGltZXMgYXJlIGRvY3VtZW50LWJhc2VkXG4gIHZhciBraWRzID0gbm9kZS5jaGlsZE5vZGVzO1xuICBmb3IodmFyIGkgPSAwLCBuID0ga2lkcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgcmVjdXJzaXZlbHlTZXRPd25lcihraWRzW2ldLCBvd25lcik7XG59XG5cbi8vIEEgY2xhc3MgZm9yIHN0b3JpbmcgbXVsdGlwbGUgbm9kZXMgd2l0aCB0aGUgc2FtZSBJRFxuZnVuY3Rpb24gTXVsdGlJZChub2RlKSB7XG4gIHRoaXMubm9kZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLm5vZGVzW25vZGUuX25pZF0gPSBub2RlO1xuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXMuZmlyc3ROb2RlID0gdW5kZWZpbmVkO1xufVxuXG4vLyBBZGQgYSBub2RlIHRvIHRoZSBsaXN0LCB3aXRoIE8oMSkgdGltZVxuTXVsdGlJZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAoIXRoaXMubm9kZXNbbm9kZS5fbmlkXSkge1xuICAgIHRoaXMubm9kZXNbbm9kZS5fbmlkXSA9IG5vZGU7XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgICB0aGlzLmZpcnN0Tm9kZSA9IHVuZGVmaW5lZDtcbiAgfVxufTtcblxuLy8gUmVtb3ZlIGEgbm9kZSBmcm9tIHRoZSBsaXN0LCB3aXRoIE8oMSkgdGltZVxuTXVsdGlJZC5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAodGhpcy5ub2Rlc1tub2RlLl9uaWRdKSB7XG4gICAgZGVsZXRlIHRoaXMubm9kZXNbbm9kZS5fbmlkXTtcbiAgICB0aGlzLmxlbmd0aC0tO1xuICAgIHRoaXMuZmlyc3ROb2RlID0gdW5kZWZpbmVkO1xuICB9XG59O1xuXG4vLyBHZXQgdGhlIGZpcnN0IG5vZGUgZnJvbSB0aGUgbGlzdCwgaW4gdGhlIGRvY3VtZW50IG9yZGVyXG4vLyBUYWtlcyBPKE4pIHRpbWUgaW4gdGhlIHNpemUgb2YgdGhlIGxpc3QsIHdpdGggYSBjYWNoZSB0aGF0IGlzIGludmFsaWRhdGVkXG4vLyB3aGVuIHRoZSBsaXN0IGlzIG1vZGlmaWVkLlxuTXVsdGlJZC5wcm90b3R5cGUuZ2V0Rmlyc3QgPSBmdW5jdGlvbigpIHtcbiAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gIGlmICghdGhpcy5maXJzdE5vZGUpIHtcbiAgICB2YXIgbmlkO1xuICAgIGZvciAobmlkIGluIHRoaXMubm9kZXMpIHtcbiAgICAgIGlmICh0aGlzLmZpcnN0Tm9kZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHRoaXMuZmlyc3ROb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMubm9kZXNbbmlkXSkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORykge1xuICAgICAgICB0aGlzLmZpcnN0Tm9kZSA9IHRoaXMubm9kZXNbbmlkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmlyc3ROb2RlO1xufTtcblxuLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgbm9kZSBsZWZ0LCByZXR1cm4gaXQuIE90aGVyd2lzZSByZXR1cm4gXCJ0aGlzXCIuXG5NdWx0aUlkLnByb3RvdHlwZS5kb3duZ3JhZGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG5pZDtcbiAgICBmb3IgKG5pZCBpbiB0aGlzLm5vZGVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1tuaWRdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0RvY3VtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIFRoaXMgZ3JhbW1hciBpcyBmcm9tIHRoZSBYTUwgYW5kIFhNTCBOYW1lc3BhY2Ugc3BlY3MuIEl0IHNwZWNpZmllcyB3aGV0aGVyXG4vLyBhIHN0cmluZyAoc3VjaCBhcyBhbiBlbGVtZW50IG9yIGF0dHJpYnV0ZSBuYW1lKSBpcyBhIHZhbGlkIE5hbWUgb3IgUU5hbWUuXG4vL1xuLy8gTmFtZSAgICAgICAgICAgOjo9IE5hbWVTdGFydENoYXIgKE5hbWVDaGFyKSpcbi8vIE5hbWVTdGFydENoYXIgIDo6PSBcIjpcIiB8IFtBLVpdIHwgXCJfXCIgfCBbYS16XSB8XG4vLyAgICAgICAgICAgICAgICAgICAgWyN4QzAtI3hENl0gfCBbI3hEOC0jeEY2XSB8IFsjeEY4LSN4MkZGXSB8XG4vLyAgICAgICAgICAgICAgICAgICAgWyN4MzcwLSN4MzdEXSB8IFsjeDM3Ri0jeDFGRkZdIHxcbi8vICAgICAgICAgICAgICAgICAgICBbI3gyMDBDLSN4MjAwRF0gfCBbI3gyMDcwLSN4MjE4Rl0gfFxuLy8gICAgICAgICAgICAgICAgICAgIFsjeDJDMDAtI3gyRkVGXSB8IFsjeDMwMDEtI3hEN0ZGXSB8XG4vLyAgICAgICAgICAgICAgICAgICAgWyN4RjkwMC0jeEZEQ0ZdIHwgWyN4RkRGMC0jeEZGRkRdIHxcbi8vICAgICAgICAgICAgICAgICAgICBbI3gxMDAwMC0jeEVGRkZGXVxuLy9cbi8vIE5hbWVDaGFyICAgICAgIDo6PSBOYW1lU3RhcnRDaGFyIHwgXCItXCIgfCBcIi5cIiB8IFswLTldIHxcbi8vICAgICAgICAgICAgICAgICAgICAjeEI3IHwgWyN4MDMwMC0jeDAzNkZdIHwgWyN4MjAzRi0jeDIwNDBdXG4vL1xuLy8gUU5hbWUgICAgICAgICAgOjo9IFByZWZpeGVkTmFtZXwgVW5wcmVmaXhlZE5hbWVcbi8vIFByZWZpeGVkTmFtZSAgIDo6PSBQcmVmaXggJzonIExvY2FsUGFydFxuLy8gVW5wcmVmaXhlZE5hbWUgOjo9IExvY2FsUGFydFxuLy8gUHJlZml4ICAgICAgICAgOjo9IE5DTmFtZVxuLy8gTG9jYWxQYXJ0ICAgICAgOjo9IE5DTmFtZVxuLy8gTkNOYW1lICAgICAgICAgOjo9IE5hbWUgLSAoQ2hhciogJzonIENoYXIqKVxuLy8gICAgICAgICAgICAgICAgICAgICMgQW4gWE1MIE5hbWUsIG1pbnVzIHRoZSBcIjpcIlxuLy9cblxuZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGlzVmFsaWROYW1lO1xuZXhwb3J0cy5pc1ZhbGlkUU5hbWUgPSBpc1ZhbGlkUU5hbWU7XG5cbi8vIE1vc3QgbmFtZXMgd2lsbCBiZSBBU0NJSSBvbmx5LiBUcnkgbWF0Y2hpbmcgYWdhaW5zdCBzaW1wbGUgcmVnZXhwcyBmaXJzdFxudmFyIHNpbXBsZW5hbWUgPSAvXltfOkEtWmEtel1bLS46XFx3XSskLztcbnZhciBzaW1wbGVxbmFtZSA9IC9eKFtfQS1aYS16XVstLlxcd10rfFtfQS1aYS16XVstLlxcd10rOltfQS1aYS16XVstLlxcd10rKSQvO1xuXG4vLyBJZiB0aGUgcmVndWxhciBleHByZXNzaW9ucyBhYm92ZSBmYWlsLCB0cnkgbW9yZSBjb21wbGV4IG9uZXMgdGhhdCB3b3JrXG4vLyBmb3IgYW55IGlkZW50aWZpZXJzIHVzaW5nIGNvZGVwb2ludHMgZnJvbSB0aGUgVW5pY29kZSBCTVBcbnZhciBuY25hbWVzdGFydGNoYXJzID0gXCJfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMmZmXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXCI7XG52YXIgbmNuYW1lY2hhcnMgPSBcIi0uX0EtWmEtejAtOVxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyZmZcXHUwMzAwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDXFx1MjAwRFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXCI7XG5cbnZhciBuY25hbWUgPSBcIltcIiArIG5jbmFtZXN0YXJ0Y2hhcnMgKyBcIl1bXCIgKyBuY25hbWVjaGFycyArIFwiXSpcIjtcbnZhciBuYW1lc3RhcnRjaGFycyA9IG5jbmFtZXN0YXJ0Y2hhcnMgKyBcIjpcIjtcbnZhciBuYW1lY2hhcnMgPSBuY25hbWVjaGFycyArIFwiOlwiO1xudmFyIG5hbWUgPSBuZXcgUmVnRXhwKFwiXltcIiArIG5hbWVzdGFydGNoYXJzICsgXCJdXCIgKyBcIltcIiArIG5hbWVjaGFycyArIFwiXSokXCIpO1xudmFyIHFuYW1lID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBuY25hbWUgKyBcInxcIiArIG5jbmFtZSArIFwiOlwiICsgbmNuYW1lICsgXCIpJFwiKTtcblxuLy8gWE1MIHNheXMgdGhhdCB0aGVzZSBjaGFyYWN0ZXJzIGFyZSBhbHNvIGxlZ2FsOlxuLy8gWyN4MTAwMDAtI3hFRkZGRl0uICBTbyBpZiB0aGUgcGF0dGVybnMgYWJvdmUgZmFpbCwgYW5kIHRoZVxuLy8gdGFyZ2V0IHN0cmluZyBpbmNsdWRlcyBzdXJyb2dhdGVzLCB0aGVuIHRyeSB0aGUgZm9sbG93aW5nXG4vLyBwYXR0ZXJucyB0aGF0IGFsbG93IHN1cnJvZ2F0ZXMgYW5kIHRoZW4gcnVuIGFuIGV4dHJhIHZhbGlkYXRpb25cbi8vIHN0ZXAgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHN1cnJvZ2F0ZXMgYXJlIGluIHZhbGlkIHBhaXJzIGFuZCBpblxuLy8gdGhlIHJpZ2h0IHJhbmdlLiAgTm90ZSB0aGF0IHNpbmNlIHRoZSBjaGFyYWN0ZXJzIFxcdWYwMDAwIHRvIFxcdTFmMDAwMFxuLy8gYXJlIG5vdCBhbGxvd2VkLCBpdCBtZWFucyB0aGF0IHRoZSBoaWdoIHN1cnJvZ2F0ZSBjYW4gb25seSBnbyB1cCB0b1xuLy8gXFx1REI3ZiBpbnN0ZWFkIG9mIFxcdURCRkYuXG52YXIgaGFzc3Vycm9nYXRlcyA9IC9bXFx1RDgwMC1cXHVEQjdGXFx1REMwMC1cXHVERkZGXS87XG52YXIgc3Vycm9nYXRlY2hhcnMgPSAvW1xcdUQ4MDAtXFx1REI3RlxcdURDMDAtXFx1REZGRl0vZztcbnZhciBzdXJyb2dhdGVwYWlycyA9IC9bXFx1RDgwMC1cXHVEQjdGXVtcXHVEQzAwLVxcdURGRkZdL2c7XG5cbi8vIE1vZGlmeSB0aGUgdmFyaWFibGVzIGFib3ZlIHRvIGFsbG93IHN1cnJvZ2F0ZXNcbm5jbmFtZXN0YXJ0Y2hhcnMgKz0gXCJcXHVEODAwLVxcdURCN0ZcXHVEQzAwLVxcdURGRkZcIjtcbm5jbmFtZWNoYXJzICs9IFwiXFx1RDgwMC1cXHVEQjdGXFx1REMwMC1cXHVERkZGXCI7XG5uY25hbWUgPSBcIltcIiArIG5jbmFtZXN0YXJ0Y2hhcnMgKyBcIl1bXCIgKyBuY25hbWVjaGFycyArIFwiXSpcIjtcbm5hbWVzdGFydGNoYXJzID0gbmNuYW1lc3RhcnRjaGFycyArIFwiOlwiO1xubmFtZWNoYXJzID0gbmNuYW1lY2hhcnMgKyBcIjpcIjtcblxuLy8gQnVpbGQgYW5vdGhlciBzZXQgb2YgcmVnZXhwcyB0aGF0IGluY2x1ZGUgc3Vycm9nYXRlc1xudmFyIHN1cnJvZ2F0ZW5hbWUgPSBuZXcgUmVnRXhwKFwiXltcIiArIG5hbWVzdGFydGNoYXJzICsgXCJdXCIgKyBcIltcIiArIG5hbWVjaGFycyArIFwiXSokXCIpO1xudmFyIHN1cnJvZ2F0ZXFuYW1lID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBuY25hbWUgKyBcInxcIiArIG5jbmFtZSArIFwiOlwiICsgbmNuYW1lICsgXCIpJFwiKTtcblxuZnVuY3Rpb24gaXNWYWxpZE5hbWUocykge1xuICBpZiAoc2ltcGxlbmFtZS50ZXN0KHMpKSByZXR1cm4gdHJ1ZTsgLy8gUGxhaW4gQVNDSUlcbiAgaWYgKG5hbWUudGVzdChzKSkgcmV0dXJuIHRydWU7IC8vIFVuaWNvZGUgQk1QXG5cbiAgLy8gTWF5YmUgdGhlIHRlc3RzIGFib3ZlIGZhaWxlZCBiZWNhdXNlIHMgaW5jbHVkZXMgc3Vycm9nYXRlIHBhaXJzXG4gIC8vIE1vc3QgbGlrZWx5LCB0aG91Z2gsIHRoZXkgZmFpbGVkIGZvciBzb21lIG1vcmUgYmFzaWMgc3ludGF4IHByb2JsZW1cbiAgaWYgKCFoYXNzdXJyb2dhdGVzLnRlc3QocykpIHJldHVybiBmYWxzZTtcblxuICAvLyBJcyB0aGUgc3RyaW5nIGEgdmFsaWQgbmFtZSBpZiB3ZSBhbGxvdyBzdXJyb2dhdGVzP1xuICBpZiAoIXN1cnJvZ2F0ZW5hbWUudGVzdChzKSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIEZpbmFsbHksIGFyZSB0aGUgc3Vycm9nYXRlcyBhbGwgY29ycmVjdGx5IHBhaXJlZCB1cD9cbiAgdmFyIGNoYXJzID0gcy5tYXRjaChzdXJyb2dhdGVjaGFycyksIHBhaXJzID0gcy5tYXRjaChzdXJyb2dhdGVwYWlycyk7XG4gIHJldHVybiBwYWlycyAhPT0gbnVsbCAmJiAyKnBhaXJzLmxlbmd0aCA9PT0gY2hhcnMubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUU5hbWUocykge1xuICBpZiAoc2ltcGxlcW5hbWUudGVzdChzKSkgcmV0dXJuIHRydWU7IC8vIFBsYWluIEFTQ0lJXG4gIGlmIChxbmFtZS50ZXN0KHMpKSByZXR1cm4gdHJ1ZTsgLy8gVW5pY29kZSBCTVBcblxuICBpZiAoIWhhc3N1cnJvZ2F0ZXMudGVzdChzKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIXN1cnJvZ2F0ZXFuYW1lLnRlc3QocykpIHJldHVybiBmYWxzZTtcbiAgdmFyIGNoYXJzID0gcy5tYXRjaChzdXJyb2dhdGVjaGFycyksIHBhaXJzID0gcy5tYXRjaChzdXJyb2dhdGVwYWlycyk7XG4gIHJldHVybiBwYWlycyAhPT0gbnVsbCAmJiAyKnBhaXJzLmxlbmd0aCA9PT0gY2hhcnMubGVuZ3RoO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi94bWxuYW1lcy5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBqc2hpbnQgZXFudWxsOiB0cnVlICovXG4vKipcbiAqIFplc3QgKGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL3plc3QpXG4gKiBBIGNzcyBzZWxlY3RvciBlbmdpbmUuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqL1xuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuXG52YXIgd2luZG93ID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gIGxvY2F0aW9uOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3aW5kb3cubG9jYXRpb24gaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfSB9XG59KTtcblxudmFyIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYik7XG59O1xuXG52YXIgb3JkZXIgPSBmdW5jdGlvbihhLCBiKSB7XG4gIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuICByZXR1cm4gY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSwgYikgJiAyID8gMSA6IC0xO1xufTtcblxudmFyIG5leHQgPSBmdW5jdGlvbihlbCkge1xuICB3aGlsZSAoKGVsID0gZWwubmV4dFNpYmxpbmcpXG4gICAgICAgICAmJiBlbC5ub2RlVHlwZSAhPT0gMSk7XG4gIHJldHVybiBlbDtcbn07XG5cbnZhciBwcmV2ID0gZnVuY3Rpb24oZWwpIHtcbiAgd2hpbGUgKChlbCA9IGVsLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICYmIGVsLm5vZGVUeXBlICE9PSAxKTtcbiAgcmV0dXJuIGVsO1xufTtcblxudmFyIGNoaWxkID0gZnVuY3Rpb24oZWwpIHtcbiAgLypqc2hpbnQgLVcwODQgKi9cbiAgaWYgKGVsID0gZWwuZmlyc3RDaGlsZCkge1xuICAgIHdoaWxlIChlbC5ub2RlVHlwZSAhPT0gMVxuICAgICAgICAgICAmJiAoZWwgPSBlbC5uZXh0U2libGluZykpO1xuICB9XG4gIHJldHVybiBlbDtcbn07XG5cbnZhciBsYXN0Q2hpbGQgPSBmdW5jdGlvbihlbCkge1xuICAvKmpzaGludCAtVzA4NCAqL1xuICBpZiAoZWwgPSBlbC5sYXN0Q2hpbGQpIHtcbiAgICB3aGlsZSAoZWwubm9kZVR5cGUgIT09IDFcbiAgICAgICAgICAgJiYgKGVsID0gZWwucHJldmlvdXNTaWJsaW5nKSk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufTtcblxudmFyIHVucXVvdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgaWYgKCFzdHIpIHJldHVybiBzdHI7XG4gIHZhciBjaCA9IHN0clswXTtcbiAgaWYgKGNoID09PSAnXCInIHx8IGNoID09PSAnXFwnJykge1xuICAgIGlmIChzdHJbc3RyLmxlbmd0aC0xXSA9PT0gY2gpIHtcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgxLCAtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJhZCBzdHJpbmcuXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZShydWxlcy5zdHJfZXNjYXBlLCBmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgbSA9IC9eXFxcXCg/OihbMC05QS1GYS1mXSspfChbXFxyXFxuXFxmXSspKS8uZXhlYyhzKTtcbiAgICAgIGlmICghbSkgeyByZXR1cm4gcy5zbGljZSgxKTsgfVxuICAgICAgaWYgKG1bMl0pIHsgcmV0dXJuICcnOyAvKiBlc2NhcGVkIG5ld2xpbmVzIGFyZSBpZ25vcmVkIGluIHN0cmluZ3MuICovIH1cbiAgICAgIHZhciBjcCA9IHBhcnNlSW50KG1bMV0sIDE2KTtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCA/IFN0cmluZy5mcm9tQ29kZVBvaW50KGNwKSA6XG4gICAgICAgIC8vIE5vdCBhbGwgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbnMgaGF2ZSBTdHJpbmcuZnJvbUNvZGVQb2ludCB5ZXQuXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHJ1bGVzLmlkZW50LnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBkZWNvZGVpZChzdHIpO1xuICB9IGVsc2Uge1xuICAgIC8vIE5VTUJFUiwgUEVSQ0VOVEFHRSwgRElNRU5TSU9OLCBldGNcbiAgICByZXR1cm4gc3RyO1xuICB9XG59O1xuXG52YXIgZGVjb2RlaWQgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJ1bGVzLmVzY2FwZSwgZnVuY3Rpb24ocykge1xuICAgIHZhciBtID0gL15cXFxcKFswLTlBLUZhLWZdKykvLmV4ZWMocyk7XG4gICAgaWYgKCFtKSB7IHJldHVybiBzWzFdOyB9XG4gICAgdmFyIGNwID0gcGFyc2VJbnQobVsxXSwgMTYpO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCA/IFN0cmluZy5mcm9tQ29kZVBvaW50KGNwKSA6XG4gICAgICAvLyBOb3QgYWxsIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25zIGhhdmUgU3RyaW5nLmZyb21Db2RlUG9pbnQgeWV0LlxuICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShjcCk7XG4gIH0pO1xufTtcblxudmFyIGluZGV4T2YgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVtKSB7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAodGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfTtcbn0pKCk7XG5cbnZhciBtYWtlSW5zaWRlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICB2YXIgcmVnZXggPSBydWxlcy5pbnNpZGUuc291cmNlXG4gICAgLnJlcGxhY2UoLzwvZywgc3RhcnQpXG4gICAgLnJlcGxhY2UoLz4vZywgZW5kKTtcblxuICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCk7XG59O1xuXG52YXIgcmVwbGFjZSA9IGZ1bmN0aW9uKHJlZ2V4LCBuYW1lLCB2YWwpIHtcbiAgcmVnZXggPSByZWdleC5zb3VyY2U7XG4gIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwuc291cmNlIHx8IHZhbCk7XG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4KTtcbn07XG5cbnZhciB0cnVuY2F0ZVVybCA9IGZ1bmN0aW9uKHVybCwgbnVtKSB7XG4gIHJldHVybiB1cmxcbiAgICAucmVwbGFjZSgvXig/Olxcdys6XFwvXFwvfFxcLyspLywgJycpXG4gICAgLnJlcGxhY2UoLyg/OlxcLyt8XFwvKiMuKj8pJC8sICcnKVxuICAgIC5zcGxpdCgnLycsIG51bSlcbiAgICAuam9pbignLycpO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYG50aGAgU2VsZWN0b3JzXG4gKi9cblxudmFyIHBhcnNlTnRoID0gZnVuY3Rpb24ocGFyYW1fLCB0ZXN0KSB7XG4gIHZhciBwYXJhbSA9IHBhcmFtXy5yZXBsYWNlKC9cXHMrL2csICcnKVxuICAgICwgY2FwO1xuXG4gIGlmIChwYXJhbSA9PT0gJ2V2ZW4nKSB7XG4gICAgcGFyYW0gPSAnMm4rMCc7XG4gIH0gZWxzZSBpZiAocGFyYW0gPT09ICdvZGQnKSB7XG4gICAgcGFyYW0gPSAnMm4rMSc7XG4gIH0gZWxzZSBpZiAocGFyYW0uaW5kZXhPZignbicpID09PSAtMSkge1xuICAgIHBhcmFtID0gJzBuJyArIHBhcmFtO1xuICB9XG5cbiAgY2FwID0gL14oWystXSk/KFxcZCspP24oWystXSk/KFxcZCspPyQvLmV4ZWMocGFyYW0pO1xuXG4gIHJldHVybiB7XG4gICAgZ3JvdXA6IGNhcFsxXSA9PT0gJy0nXG4gICAgICA/IC0oY2FwWzJdIHx8IDEpXG4gICAgICA6ICsoY2FwWzJdIHx8IDEpLFxuICAgIG9mZnNldDogY2FwWzRdXG4gICAgICA/IChjYXBbM10gPT09ICctJyA/IC1jYXBbNF0gOiArY2FwWzRdKVxuICAgICAgOiAwXG4gIH07XG59O1xuXG52YXIgbnRoID0gZnVuY3Rpb24ocGFyYW1fLCB0ZXN0LCBsYXN0KSB7XG4gIHZhciBwYXJhbSA9IHBhcnNlTnRoKHBhcmFtXylcbiAgICAsIGdyb3VwID0gcGFyYW0uZ3JvdXBcbiAgICAsIG9mZnNldCA9IHBhcmFtLm9mZnNldFxuICAgICwgZmluZCA9ICFsYXN0ID8gY2hpbGQgOiBsYXN0Q2hpbGRcbiAgICAsIGFkdmFuY2UgPSAhbGFzdCA/IG5leHQgOiBwcmV2O1xuXG4gIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSAxKSByZXR1cm47XG5cbiAgICB2YXIgcmVsID0gZmluZChlbC5wYXJlbnROb2RlKVxuICAgICAgLCBwb3MgPSAwO1xuXG4gICAgd2hpbGUgKHJlbCkge1xuICAgICAgaWYgKHRlc3QocmVsLCBlbCkpIHBvcysrO1xuICAgICAgaWYgKHJlbCA9PT0gZWwpIHtcbiAgICAgICAgcG9zIC09IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGdyb3VwICYmIHBvc1xuICAgICAgICAgID8gKHBvcyAlIGdyb3VwKSA9PT0gMCAmJiAocG9zIDwgMCA9PT0gZ3JvdXAgPCAwKVxuICAgICAgICAgIDogIXBvcztcbiAgICAgIH1cbiAgICAgIHJlbCA9IGFkdmFuY2UocmVsKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFNpbXBsZSBTZWxlY3RvcnNcbiAqL1xuXG52YXIgc2VsZWN0b3JzID0ge1xuICAnKic6IChmdW5jdGlvbigpIHtcbiAgICBpZiAoZmFsc2UvKmZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKSk7XG4gICAgICByZXR1cm4gISFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpWzBdO1xuICAgIH0oKSovKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKCksXG4gICd0eXBlJzogZnVuY3Rpb24odHlwZSkge1xuICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdHlwZTtcbiAgICB9O1xuICB9LFxuICAnYXR0cic6IGZ1bmN0aW9uKGtleSwgb3AsIHZhbCwgaSkge1xuICAgIG9wID0gb3BlcmF0b3JzW29wXTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBhdHRyO1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAnZm9yJzpcbiAgICAgICAgICBhdHRyID0gZWwuaHRtbEZvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgIC8vIGNsYXNzTmFtZSBpcyAnJyB3aGVuIG5vbi1leGlzdGVudFxuICAgICAgICAgIC8vIGdldEF0dHJpYnV0ZSgnY2xhc3MnKSBpcyBudWxsXG4gICAgICAgICAgYXR0ciA9IGVsLmNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAoYXR0ciA9PT0gJycgJiYgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpID09IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaHJlZic6XG4gICAgICAgICAgYXR0ciA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicsIDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aXRsZSc6XG4gICAgICAgICAgLy8gZ2V0QXR0cmlidXRlKCd0aXRsZScpIGNhbiBiZSAnJyB3aGVuIG5vbi1leGlzdGVudCBzb21ldGltZXM/XG4gICAgICAgICAgYXR0ciA9IGVsLmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBjYXJlZnVsIHdpdGggYXR0cmlidXRlcyB3aXRoIHNwZWNpYWwgZ2V0dGVyIGZ1bmN0aW9uc1xuICAgICAgICBjYXNlICdpZCc6XG4gICAgICAgIGNhc2UgJ2xhbmcnOlxuICAgICAgICBjYXNlICdkaXInOlxuICAgICAgICBjYXNlICdhY2Nlc3NLZXknOlxuICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICBjYXNlICd0YWJJbmRleCc6XG4gICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICBhdHRyID0gZWwuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlICYmICFlbC5oYXNBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHIgPSBlbFtrZXldICE9IG51bGxcbiAgICAgICAgICAgID8gZWxba2V5XVxuICAgICAgICAgICAgOiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoYXR0ciA9PSBudWxsKSByZXR1cm47XG4gICAgICBhdHRyID0gYXR0ciArICcnO1xuICAgICAgaWYgKGkpIHtcbiAgICAgICAgYXR0ciA9IGF0dHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFsID0gdmFsLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3AoYXR0ciwgdmFsKTtcbiAgICB9O1xuICB9LFxuICAnOmZpcnN0LWNoaWxkJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gIXByZXYoZWwpICYmIGVsLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDE7XG4gIH0sXG4gICc6bGFzdC1jaGlsZCc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuICFuZXh0KGVsKSAmJiBlbC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxO1xuICB9LFxuICAnOm9ubHktY2hpbGQnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiAhcHJldihlbCkgJiYgIW5leHQoZWwpXG4gICAgICAmJiBlbC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxO1xuICB9LFxuICAnOm50aC1jaGlsZCc6IGZ1bmN0aW9uKHBhcmFtLCBsYXN0KSB7XG4gICAgcmV0dXJuIG50aChwYXJhbSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBsYXN0KTtcbiAgfSxcbiAgJzpudGgtbGFzdC1jaGlsZCc6IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yc1snOm50aC1jaGlsZCddKHBhcmFtLCB0cnVlKTtcbiAgfSxcbiAgJzpyb290JzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZWwub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPT09IGVsO1xuICB9LFxuICAnOmVtcHR5JzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gIWVsLmZpcnN0Q2hpbGQ7XG4gIH0sXG4gICc6bm90JzogZnVuY3Rpb24oc2VsKSB7XG4gICAgdmFyIHRlc3QgPSBjb21waWxlR3JvdXAoc2VsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiAhdGVzdChlbCk7XG4gICAgfTtcbiAgfSxcbiAgJzpmaXJzdC1vZi10eXBlJzogZnVuY3Rpb24oZWwpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuO1xuICAgIHZhciB0eXBlID0gZWwubm9kZU5hbWU7XG4gICAgLypqc2hpbnQgLVcwODQgKi9cbiAgICB3aGlsZSAoZWwgPSBwcmV2KGVsKSkge1xuICAgICAgaWYgKGVsLm5vZGVOYW1lID09PSB0eXBlKSByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAnOmxhc3Qtb2YtdHlwZSc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUubm9kZVR5cGUgIT09IDEpIHJldHVybjtcbiAgICB2YXIgdHlwZSA9IGVsLm5vZGVOYW1lO1xuICAgIC8qanNoaW50IC1XMDg0ICovXG4gICAgd2hpbGUgKGVsID0gbmV4dChlbCkpIHtcbiAgICAgIGlmIChlbC5ub2RlTmFtZSA9PT0gdHlwZSkgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgJzpvbmx5LW9mLXR5cGUnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiBzZWxlY3RvcnNbJzpmaXJzdC1vZi10eXBlJ10oZWwpXG4gICAgICAgICYmIHNlbGVjdG9yc1snOmxhc3Qtb2YtdHlwZSddKGVsKTtcbiAgfSxcbiAgJzpudGgtb2YtdHlwZSc6IGZ1bmN0aW9uKHBhcmFtLCBsYXN0KSB7XG4gICAgcmV0dXJuIG50aChwYXJhbSwgZnVuY3Rpb24ocmVsLCBlbCkge1xuICAgICAgcmV0dXJuIHJlbC5ub2RlTmFtZSA9PT0gZWwubm9kZU5hbWU7XG4gICAgfSwgbGFzdCk7XG4gIH0sXG4gICc6bnRoLWxhc3Qtb2YtdHlwZSc6IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yc1snOm50aC1vZi10eXBlJ10ocGFyYW0sIHRydWUpO1xuICB9LFxuICAnOmNoZWNrZWQnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiAhIShlbC5jaGVja2VkIHx8IGVsLnNlbGVjdGVkKTtcbiAgfSxcbiAgJzppbmRldGVybWluYXRlJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gIXNlbGVjdG9yc1snOmNoZWNrZWQnXShlbCk7XG4gIH0sXG4gICc6ZW5hYmxlZCc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuICFlbC5kaXNhYmxlZCAmJiBlbC50eXBlICE9PSAnaGlkZGVuJztcbiAgfSxcbiAgJzpkaXNhYmxlZCc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuICEhZWwuZGlzYWJsZWQ7XG4gIH0sXG4gICc6dGFyZ2V0JzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZWwuaWQgPT09IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKTtcbiAgfSxcbiAgJzpmb2N1cyc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGVsID09PSBlbC5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIH0sXG4gICc6bWF0Y2hlcyc6IGZ1bmN0aW9uKHNlbCkge1xuICAgIHJldHVybiBjb21waWxlR3JvdXAoc2VsKTtcbiAgfSxcbiAgJzpudGgtbWF0Y2gnOiBmdW5jdGlvbihwYXJhbSwgbGFzdCkge1xuICAgIHZhciBhcmdzID0gcGFyYW0uc3BsaXQoL1xccyosXFxzKi8pXG4gICAgICAsIGFyZyA9IGFyZ3Muc2hpZnQoKVxuICAgICAgLCB0ZXN0ID0gY29tcGlsZUdyb3VwKGFyZ3Muam9pbignLCcpKTtcblxuICAgIHJldHVybiBudGgoYXJnLCB0ZXN0LCBsYXN0KTtcbiAgfSxcbiAgJzpudGgtbGFzdC1tYXRjaCc6IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yc1snOm50aC1tYXRjaCddKHBhcmFtLCB0cnVlKTtcbiAgfSxcbiAgJzpsaW5rcy1oZXJlJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZWwgKyAnJyA9PT0gd2luZG93LmxvY2F0aW9uICsgJyc7XG4gIH0sXG4gICc6bGFuZyc6IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgaWYgKGVsLmxhbmcpIHJldHVybiBlbC5sYW5nLmluZGV4T2YocGFyYW0pID09PSAwO1xuICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgJzpkaXInOiBmdW5jdGlvbihwYXJhbSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgIGlmIChlbC5kaXIpIHJldHVybiBlbC5kaXIgPT09IHBhcmFtO1xuICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgJzpzY29wZSc6IGZ1bmN0aW9uKGVsLCBjb24pIHtcbiAgICB2YXIgY29udGV4dCA9IGNvbiB8fCBlbC5vd25lckRvY3VtZW50O1xuICAgIGlmIChjb250ZXh0Lm5vZGVUeXBlID09PSA5KSB7XG4gICAgICByZXR1cm4gZWwgPT09IGNvbnRleHQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZWwgPT09IGNvbnRleHQ7XG4gIH0sXG4gICc6YW55LWxpbmsnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiB0eXBlb2YgZWwuaHJlZiA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gICc6bG9jYWwtbGluayc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgaWYgKGVsLm5vZGVOYW1lKSB7XG4gICAgICByZXR1cm4gZWwuaHJlZiAmJiBlbC5ob3N0ID09PSB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgICB9XG4gICAgdmFyIHBhcmFtID0gK2VsICsgMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICAgIGlmICghZWwuaHJlZikgcmV0dXJuO1xuXG4gICAgICB2YXIgdXJsID0gd2luZG93LmxvY2F0aW9uICsgJydcbiAgICAgICAgLCBocmVmID0gZWwgKyAnJztcblxuICAgICAgcmV0dXJuIHRydW5jYXRlVXJsKHVybCwgcGFyYW0pID09PSB0cnVuY2F0ZVVybChocmVmLCBwYXJhbSk7XG4gICAgfTtcbiAgfSxcbiAgJzpkZWZhdWx0JzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gISFlbC5kZWZhdWx0U2VsZWN0ZWQ7XG4gIH0sXG4gICc6dmFsaWQnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiBlbC53aWxsVmFsaWRhdGUgfHwgKGVsLnZhbGlkaXR5ICYmIGVsLnZhbGlkaXR5LnZhbGlkKTtcbiAgfSxcbiAgJzppbnZhbGlkJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gIXNlbGVjdG9yc1snOnZhbGlkJ10oZWwpO1xuICB9LFxuICAnOmluLXJhbmdlJzogZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZWwudmFsdWUgPiBlbC5taW4gJiYgZWwudmFsdWUgPD0gZWwubWF4O1xuICB9LFxuICAnOm91dC1vZi1yYW5nZSc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuICFzZWxlY3RvcnNbJzppbi1yYW5nZSddKGVsKTtcbiAgfSxcbiAgJzpyZXF1aXJlZCc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuICEhZWwucmVxdWlyZWQ7XG4gIH0sXG4gICc6b3B0aW9uYWwnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiAhZWwucmVxdWlyZWQ7XG4gIH0sXG4gICc6cmVhZC1vbmx5JzogZnVuY3Rpb24oZWwpIHtcbiAgICBpZiAoZWwucmVhZE9ubHkpIHJldHVybiB0cnVlO1xuXG4gICAgdmFyIGF0dHIgPSBlbC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpXG4gICAgICAsIHByb3AgPSBlbC5jb250ZW50RWRpdGFibGVcbiAgICAgICwgbmFtZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBuYW1lID0gbmFtZSAhPT0gJ2lucHV0JyAmJiBuYW1lICE9PSAndGV4dGFyZWEnO1xuXG4gICAgcmV0dXJuIChuYW1lIHx8IGVsLmRpc2FibGVkKSAmJiBhdHRyID09IG51bGwgJiYgcHJvcCAhPT0gJ3RydWUnO1xuICB9LFxuICAnOnJlYWQtd3JpdGUnOiBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiAhc2VsZWN0b3JzWyc6cmVhZC1vbmx5J10oZWwpO1xuICB9LFxuICAnOmhvdmVyJzogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc6aG92ZXIgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfSxcbiAgJzphY3RpdmUnOiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzphY3RpdmUgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfSxcbiAgJzpsaW5rJzogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc6bGluayBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9LFxuICAnOnZpc2l0ZWQnOiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzp2aXNpdGVkIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gIH0sXG4gICc6Y29sdW1uJzogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc6Y29sdW1uIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gIH0sXG4gICc6bnRoLWNvbHVtbic6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignOm50aC1jb2x1bW4gaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfSxcbiAgJzpudGgtbGFzdC1jb2x1bW4nOiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzpudGgtbGFzdC1jb2x1bW4gaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfSxcbiAgJzpjdXJyZW50JzogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc6Y3VycmVudCBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9LFxuICAnOnBhc3QnOiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzpwYXN0IGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gIH0sXG4gICc6ZnV0dXJlJzogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc6ZnV0dXJlIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gIH0sXG4gIC8vIE5vbi1zdGFuZGFyZCwgZm9yIGNvbXBhdGliaWxpdHkgcHVycG9zZXMuXG4gICc6Y29udGFpbnMnOiBmdW5jdGlvbihwYXJhbSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIHRleHQgPSBlbC5pbm5lclRleHQgfHwgZWwudGV4dENvbnRlbnQgfHwgZWwudmFsdWUgfHwgJyc7XG4gICAgICByZXR1cm4gdGV4dC5pbmRleE9mKHBhcmFtKSAhPT0gLTE7XG4gICAgfTtcbiAgfSxcbiAgJzpoYXMnOiBmdW5jdGlvbihwYXJhbSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIGZpbmQocGFyYW0sIGVsKS5sZW5ndGggPiAwO1xuICAgIH07XG4gIH1cbiAgLy8gUG90ZW50aWFsbHkgYWRkIG1vcmUgcHNldWRvIHNlbGVjdG9ycyBmb3JcbiAgLy8gY29tcGF0aWJpbGl0eSB3aXRoIHNpenpsZSBhbmQgbW9zdCBvdGhlclxuICAvLyBzZWxlY3RvciBlbmdpbmVzICg/KS5cbn07XG5cbi8qKlxuICogQXR0cmlidXRlIE9wZXJhdG9yc1xuICovXG5cbnZhciBvcGVyYXRvcnMgPSB7XG4gICctJzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gICc9JzogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG4gICAgcmV0dXJuIGF0dHIgPT09IHZhbDtcbiAgfSxcbiAgJyo9JzogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG4gICAgcmV0dXJuIGF0dHIuaW5kZXhPZih2YWwpICE9PSAtMTtcbiAgfSxcbiAgJ349JzogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG4gICAgdmFyIGkgPSBhdHRyLmluZGV4T2YodmFsKVxuICAgICAgLCBmXG4gICAgICAsIGw7XG5cbiAgICBpZiAoaSA9PT0gLTEpIHJldHVybjtcbiAgICBmID0gYXR0cltpIC0gMV07XG4gICAgbCA9IGF0dHJbaSArIHZhbC5sZW5ndGhdO1xuXG4gICAgcmV0dXJuICghZiB8fCBmID09PSAnICcpICYmICghbCB8fCBsID09PSAnICcpO1xuICB9LFxuICAnfD0nOiBmdW5jdGlvbihhdHRyLCB2YWwpIHtcbiAgICB2YXIgaSA9IGF0dHIuaW5kZXhPZih2YWwpXG4gICAgICAsIGw7XG5cbiAgICBpZiAoaSAhPT0gMCkgcmV0dXJuO1xuICAgIGwgPSBhdHRyW2kgKyB2YWwubGVuZ3RoXTtcblxuICAgIHJldHVybiBsID09PSAnLScgfHwgIWw7XG4gIH0sXG4gICdePSc6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgIHJldHVybiBhdHRyLmluZGV4T2YodmFsKSA9PT0gMDtcbiAgfSxcbiAgJyQ9JzogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG4gICAgcmV0dXJuIGF0dHIuaW5kZXhPZih2YWwpICsgdmFsLmxlbmd0aCA9PT0gYXR0ci5sZW5ndGg7XG4gIH0sXG4gIC8vIG5vbi1zdGFuZGFyZFxuICAnIT0nOiBmdW5jdGlvbihhdHRyLCB2YWwpIHtcbiAgICByZXR1cm4gYXR0ciAhPT0gdmFsO1xuICB9XG59O1xuXG4vKipcbiAqIENvbWJpbmF0b3IgTG9naWNcbiAqL1xuXG52YXIgY29tYmluYXRvcnMgPSB7XG4gICcgJzogZnVuY3Rpb24odGVzdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgLypqc2hpbnQgLVcwODQgKi9cbiAgICAgIHdoaWxlIChlbCA9IGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKHRlc3QoZWwpKSByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgJz4nOiBmdW5jdGlvbih0ZXN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAvKmpzaGludCAtVzA4NCAqL1xuICAgICAgaWYgKGVsID0gZWwucGFyZW50Tm9kZSkge1xuICAgICAgICByZXR1cm4gdGVzdChlbCkgJiYgZWw7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgJysnOiBmdW5jdGlvbih0ZXN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAvKmpzaGludCAtVzA4NCAqL1xuICAgICAgaWYgKGVsID0gcHJldihlbCkpIHtcbiAgICAgICAgcmV0dXJuIHRlc3QoZWwpICYmIGVsO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gICd+JzogZnVuY3Rpb24odGVzdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgLypqc2hpbnQgLVcwODQgKi9cbiAgICAgIHdoaWxlIChlbCA9IHByZXYoZWwpKSB7XG4gICAgICAgIGlmICh0ZXN0KGVsKSkgcmV0dXJuIGVsO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gICdub29wJzogZnVuY3Rpb24odGVzdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIHRlc3QoZWwpICYmIGVsO1xuICAgIH07XG4gIH0sXG4gICdyZWYnOiBmdW5jdGlvbih0ZXN0LCBuYW1lKSB7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBmdW5jdGlvbiByZWYoZWwpIHtcbiAgICAgIHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50XG4gICAgICAgICwgbm9kZXMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKVxuICAgICAgICAsIGkgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAocmVmLnRlc3QoZWwpKSB7XG4gICAgICAgICAgbm9kZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmVmLmNvbWJpbmF0b3IgPSBmdW5jdGlvbihlbCkge1xuICAgICAgaWYgKCFub2RlIHx8ICFub2RlLmdldEF0dHJpYnV0ZSkgcmV0dXJuO1xuXG4gICAgICB2YXIgYXR0ciA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpIHx8ICcnO1xuICAgICAgaWYgKGF0dHJbMF0gPT09ICcjJykgYXR0ciA9IGF0dHIuc3Vic3RyaW5nKDEpO1xuXG4gICAgICBpZiAoYXR0ciA9PT0gZWwuaWQgJiYgdGVzdChub2RlKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlZjtcbiAgfVxufTtcblxuLyoqXG4gKiBHcmFtbWFyXG4gKi9cblxudmFyIHJ1bGVzID0ge1xuICBlc2NhcGU6IC9cXFxcKD86W14wLTlBLUZhLWZcXHJcXG5dfFswLTlBLUZhLWZdezEsNn1bXFxyXFxuXFx0IF0/KS9nLFxuICBzdHJfZXNjYXBlOiAvKGVzY2FwZSl8XFxcXChcXG58XFxyXFxuP3xcXGYpL2csXG4gIG5vbmFzY2lpOiAvW1xcdTAwQTAtXFx1RkZGRl0vLFxuICBjc3NpZDogLyg/Oig/IS0/WzAtOV0pKD86ZXNjYXBlfG5vbmFzY2lpfFstX2EtekEtWjAtOV0pKykvLFxuICBxbmFtZTogL14gKihjc3NpZHxcXCopLyxcbiAgc2ltcGxlOiAvXig/OihbLiNdY3NzaWQpfHBzZXVkb3xhdHRyKS8sXG4gIHJlZjogL14gKlxcLyhjc3NpZClcXC8gKi8sXG4gIGNvbWJpbmF0b3I6IC9eKD86ICsoW14gXFx3Ki4jXFxcXF0pICt8KCApK3woW14gXFx3Ki4jXFxcXF0pKSg/ISAqJCkvLFxuICBhdHRyOiAvXlxcWyhjc3NpZCkoPzooW15cXHddPz0pKGluc2lkZSkpP1xcXS8sXG4gIHBzZXVkbzogL14oOmNzc2lkKSg/OlxcKChpbnNpZGUpXFwpKT8vLFxuICBpbnNpZGU6IC8oPzpcIig/OlxcXFxcInxbXlwiXSkqXCJ8Jyg/OlxcXFwnfFteJ10pKid8PFteXCInPl0qPnxcXFxcW1wiJz5dfFteXCInPl0pKi8sXG4gIGlkZW50OiAvXihjc3NpZCkkL1xufTtcblxucnVsZXMuY3NzaWQgPSByZXBsYWNlKHJ1bGVzLmNzc2lkLCAnbm9uYXNjaWknLCBydWxlcy5ub25hc2NpaSk7XG5ydWxlcy5jc3NpZCA9IHJlcGxhY2UocnVsZXMuY3NzaWQsICdlc2NhcGUnLCBydWxlcy5lc2NhcGUpO1xucnVsZXMucW5hbWUgPSByZXBsYWNlKHJ1bGVzLnFuYW1lLCAnY3NzaWQnLCBydWxlcy5jc3NpZCk7XG5ydWxlcy5zaW1wbGUgPSByZXBsYWNlKHJ1bGVzLnNpbXBsZSwgJ2Nzc2lkJywgcnVsZXMuY3NzaWQpO1xucnVsZXMucmVmID0gcmVwbGFjZShydWxlcy5yZWYsICdjc3NpZCcsIHJ1bGVzLmNzc2lkKTtcbnJ1bGVzLmF0dHIgPSByZXBsYWNlKHJ1bGVzLmF0dHIsICdjc3NpZCcsIHJ1bGVzLmNzc2lkKTtcbnJ1bGVzLnBzZXVkbyA9IHJlcGxhY2UocnVsZXMucHNldWRvLCAnY3NzaWQnLCBydWxlcy5jc3NpZCk7XG5ydWxlcy5pbnNpZGUgPSByZXBsYWNlKHJ1bGVzLmluc2lkZSwgJ1teXCJcXCc+XSonLCBydWxlcy5pbnNpZGUpO1xucnVsZXMuYXR0ciA9IHJlcGxhY2UocnVsZXMuYXR0ciwgJ2luc2lkZScsIG1ha2VJbnNpZGUoJ1xcXFxbJywgJ1xcXFxdJykpO1xucnVsZXMucHNldWRvID0gcmVwbGFjZShydWxlcy5wc2V1ZG8sICdpbnNpZGUnLCBtYWtlSW5zaWRlKCdcXFxcKCcsICdcXFxcKScpKTtcbnJ1bGVzLnNpbXBsZSA9IHJlcGxhY2UocnVsZXMuc2ltcGxlLCAncHNldWRvJywgcnVsZXMucHNldWRvKTtcbnJ1bGVzLnNpbXBsZSA9IHJlcGxhY2UocnVsZXMuc2ltcGxlLCAnYXR0cicsIHJ1bGVzLmF0dHIpO1xucnVsZXMuaWRlbnQgPSByZXBsYWNlKHJ1bGVzLmlkZW50LCAnY3NzaWQnLCBydWxlcy5jc3NpZCk7XG5ydWxlcy5zdHJfZXNjYXBlID0gcmVwbGFjZShydWxlcy5zdHJfZXNjYXBlLCAnZXNjYXBlJywgcnVsZXMuZXNjYXBlKTtcblxuLyoqXG4gKiBDb21waWxpbmdcbiAqL1xuXG52YXIgY29tcGlsZSA9IGZ1bmN0aW9uKHNlbF8pIHtcbiAgdmFyIHNlbCA9IHNlbF8ucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG4gICAgLCB0ZXN0XG4gICAgLCBmaWx0ZXIgPSBbXVxuICAgICwgYnVmZiA9IFtdXG4gICAgLCBzdWJqZWN0XG4gICAgLCBxbmFtZVxuICAgICwgY2FwXG4gICAgLCBvcFxuICAgICwgcmVmO1xuXG4gIC8qanNoaW50IC1XMDg0ICovXG4gIHdoaWxlIChzZWwpIHtcbiAgICBpZiAoY2FwID0gcnVsZXMucW5hbWUuZXhlYyhzZWwpKSB7XG4gICAgICBzZWwgPSBzZWwuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgcW5hbWUgPSBjYXBbMV07XG4gICAgICBidWZmLnB1c2godG9rKHFuYW1lLCB0cnVlKSk7XG4gICAgfSBlbHNlIGlmIChjYXAgPSBydWxlcy5zaW1wbGUuZXhlYyhzZWwpKSB7XG4gICAgICBzZWwgPSBzZWwuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgcW5hbWUgPSAnKic7XG4gICAgICBidWZmLnB1c2godG9rKHFuYW1lLCB0cnVlKSk7XG4gICAgICBidWZmLnB1c2godG9rKGNhcCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgc2VsZWN0b3IuJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNhcCA9IHJ1bGVzLnNpbXBsZS5leGVjKHNlbCkpIHtcbiAgICAgIHNlbCA9IHNlbC5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBidWZmLnB1c2godG9rKGNhcCkpO1xuICAgIH1cblxuICAgIGlmIChzZWxbMF0gPT09ICchJykge1xuICAgICAgc2VsID0gc2VsLnN1YnN0cmluZygxKTtcbiAgICAgIHN1YmplY3QgPSBtYWtlU3ViamVjdCgpO1xuICAgICAgc3ViamVjdC5xbmFtZSA9IHFuYW1lO1xuICAgICAgYnVmZi5wdXNoKHN1YmplY3Quc2ltcGxlKTtcbiAgICB9XG5cbiAgICBpZiAoY2FwID0gcnVsZXMucmVmLmV4ZWMoc2VsKSkge1xuICAgICAgc2VsID0gc2VsLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHJlZiA9IGNvbWJpbmF0b3JzLnJlZihtYWtlU2ltcGxlKGJ1ZmYpLCBkZWNvZGVpZChjYXBbMV0pKTtcbiAgICAgIGZpbHRlci5wdXNoKHJlZi5jb21iaW5hdG9yKTtcbiAgICAgIGJ1ZmYgPSBbXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjYXAgPSBydWxlcy5jb21iaW5hdG9yLmV4ZWMoc2VsKSkge1xuICAgICAgc2VsID0gc2VsLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG9wID0gY2FwWzFdIHx8IGNhcFsyXSB8fCBjYXBbM107XG4gICAgICBpZiAob3AgPT09ICcsJykge1xuICAgICAgICBmaWx0ZXIucHVzaChjb21iaW5hdG9ycy5ub29wKG1ha2VTaW1wbGUoYnVmZikpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wID0gJ25vb3AnO1xuICAgIH1cblxuICAgIGlmICghY29tYmluYXRvcnNbb3BdKSB7IHRocm93IG5ldyBTeW50YXhFcnJvcignQmFkIGNvbWJpbmF0b3IuJyk7IH1cbiAgICBmaWx0ZXIucHVzaChjb21iaW5hdG9yc1tvcF0obWFrZVNpbXBsZShidWZmKSkpO1xuICAgIGJ1ZmYgPSBbXTtcbiAgfVxuXG4gIHRlc3QgPSBtYWtlVGVzdChmaWx0ZXIpO1xuICB0ZXN0LnFuYW1lID0gcW5hbWU7XG4gIHRlc3Quc2VsID0gc2VsO1xuXG4gIGlmIChzdWJqZWN0KSB7XG4gICAgc3ViamVjdC5sbmFtZSA9IHRlc3QucW5hbWU7XG5cbiAgICBzdWJqZWN0LnRlc3QgPSB0ZXN0O1xuICAgIHN1YmplY3QucW5hbWUgPSBzdWJqZWN0LnFuYW1lO1xuICAgIHN1YmplY3Quc2VsID0gdGVzdC5zZWw7XG4gICAgdGVzdCA9IHN1YmplY3Q7XG4gIH1cblxuICBpZiAocmVmKSB7XG4gICAgcmVmLnRlc3QgPSB0ZXN0O1xuICAgIHJlZi5xbmFtZSA9IHRlc3QucW5hbWU7XG4gICAgcmVmLnNlbCA9IHRlc3Quc2VsO1xuICAgIHRlc3QgPSByZWY7XG4gIH1cblxuICByZXR1cm4gdGVzdDtcbn07XG5cbnZhciB0b2sgPSBmdW5jdGlvbihjYXAsIHFuYW1lKSB7XG4gIC8vIHFuYW1lXG4gIGlmIChxbmFtZSkge1xuICAgIHJldHVybiBjYXAgPT09ICcqJ1xuICAgICAgPyBzZWxlY3RvcnNbJyonXVxuICAgICAgOiBzZWxlY3RvcnMudHlwZShkZWNvZGVpZChjYXApKTtcbiAgfVxuXG4gIC8vIGNsYXNzL2lkXG4gIGlmIChjYXBbMV0pIHtcbiAgICByZXR1cm4gY2FwWzFdWzBdID09PSAnLidcblx0ICAvLyBYWFggdW5lc2NhcGUgaGVyZT8gIG9yIGluIGF0dHI/XG4gICAgICA/IHNlbGVjdG9ycy5hdHRyKCdjbGFzcycsICd+PScsIGRlY29kZWlkKGNhcFsxXS5zdWJzdHJpbmcoMSkpKVxuICAgICAgOiBzZWxlY3RvcnMuYXR0cignaWQnLCAnPScsIGRlY29kZWlkKGNhcFsxXS5zdWJzdHJpbmcoMSkpKTtcbiAgfVxuXG4gIC8vIHBzZXVkby1uYW1lXG4gIC8vIGluc2lkZS1wc2V1ZG9cbiAgaWYgKGNhcFsyXSkge1xuICAgIHJldHVybiBjYXBbM11cbiAgICAgID8gc2VsZWN0b3JzW2RlY29kZWlkKGNhcFsyXSldKHVucXVvdGUoY2FwWzNdKSlcbiAgICAgIDogc2VsZWN0b3JzW2RlY29kZWlkKGNhcFsyXSldO1xuICB9XG5cbiAgLy8gYXR0ciBuYW1lXG4gIC8vIGF0dHIgb3BcbiAgLy8gYXR0ciB2YWx1ZVxuICBpZiAoY2FwWzRdKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9ycy5hdHRyKGRlY29kZWlkKGNhcFs0XSksIGNhcFs1XSB8fCAnLScsIHVucXVvdGUoY2FwWzZdKSwgZmFsc2UpO1xuICB9XG5cbiAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmtub3duIFNlbGVjdG9yLicpO1xufTtcblxudmFyIG1ha2VTaW1wbGUgPSBmdW5jdGlvbihmdW5jKSB7XG4gIHZhciBsID0gZnVuYy5sZW5ndGhcbiAgICAsIGk7XG5cbiAgLy8gUG90ZW50aWFsbHkgbWFrZSBzdXJlXG4gIC8vIGBlbGAgaXMgdHJ1dGh5LlxuICBpZiAobCA8IDIpIHJldHVybiBmdW5jWzBdO1xuXG4gIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoIWZ1bmNbaV0oZWwpKSByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufTtcblxudmFyIG1ha2VUZXN0ID0gZnVuY3Rpb24oZnVuYykge1xuICBpZiAoZnVuYy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gISFmdW5jWzBdKGVsKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihlbCkge1xuICAgIHZhciBpID0gZnVuYy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKCEoZWwgPSBmdW5jW2ldKGVsKSkpIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59O1xuXG52YXIgbWFrZVN1YmplY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRhcmdldDtcblxuICBmdW5jdGlvbiBzdWJqZWN0KGVsKSB7XG4gICAgdmFyIG5vZGUgPSBlbC5vd25lckRvY3VtZW50XG4gICAgICAsIHNjb3BlID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShzdWJqZWN0LmxuYW1lKVxuICAgICAgLCBpID0gc2NvcGUubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKHN1YmplY3QudGVzdChzY29wZVtpXSkgJiYgdGFyZ2V0ID09PSBlbCkge1xuICAgICAgICB0YXJnZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0YXJnZXQgPSBudWxsO1xuICB9XG5cbiAgc3ViamVjdC5zaW1wbGUgPSBmdW5jdGlvbihlbCkge1xuICAgIHRhcmdldCA9IGVsO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHJldHVybiBzdWJqZWN0O1xufTtcblxudmFyIGNvbXBpbGVHcm91cCA9IGZ1bmN0aW9uKHNlbCkge1xuICB2YXIgdGVzdCA9IGNvbXBpbGUoc2VsKVxuICAgICwgdGVzdHMgPSBbIHRlc3QgXTtcblxuICB3aGlsZSAodGVzdC5zZWwpIHtcbiAgICB0ZXN0ID0gY29tcGlsZSh0ZXN0LnNlbCk7XG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcbiAgfVxuXG4gIGlmICh0ZXN0cy5sZW5ndGggPCAyKSByZXR1cm4gdGVzdDtcblxuICByZXR1cm4gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgbCA9IHRlc3RzLmxlbmd0aFxuICAgICAgLCBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVzdHNbaV0oZWwpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFNlbGVjdGlvblxuICovXG5cbnZhciBmaW5kID0gZnVuY3Rpb24oc2VsLCBub2RlKSB7XG4gIHZhciByZXN1bHRzID0gW11cbiAgICAsIHRlc3QgPSBjb21waWxlKHNlbClcbiAgICAsIHNjb3BlID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0ZXN0LnFuYW1lKVxuICAgICwgaSA9IDBcbiAgICAsIGVsO1xuXG4gIC8qanNoaW50IC1XMDg0ICovXG4gIHdoaWxlIChlbCA9IHNjb3BlW2krK10pIHtcbiAgICBpZiAodGVzdChlbCkpIHJlc3VsdHMucHVzaChlbCk7XG4gIH1cblxuICBpZiAodGVzdC5zZWwpIHtcbiAgICB3aGlsZSAodGVzdC5zZWwpIHtcbiAgICAgIHRlc3QgPSBjb21waWxlKHRlc3Quc2VsKTtcbiAgICAgIHNjb3BlID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0ZXN0LnFuYW1lKTtcbiAgICAgIGkgPSAwO1xuICAgICAgLypqc2hpbnQgLVcwODQgKi9cbiAgICAgIHdoaWxlIChlbCA9IHNjb3BlW2krK10pIHtcbiAgICAgICAgaWYgKHRlc3QoZWwpICYmIGluZGV4T2YuY2FsbChyZXN1bHRzLCBlbCkgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHRzLnNvcnQob3JkZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbCwgY29udGV4dCkge1xuICAvKiB3aGVuIGNvbnRleHQgaXNuJ3QgYSBEb2N1bWVudEZyYWdtZW50IGFuZCB0aGUgc2VsZWN0b3IgaXMgc2ltcGxlOiAqL1xuICB2YXIgaWQsIHI7XG4gIGlmIChjb250ZXh0Lm5vZGVUeXBlICE9PSAxMSAmJiBzZWwuaW5kZXhPZignICcpID09PSAtMSkge1xuICAgIGlmIChzZWxbMF0gPT09ICcjJyAmJiBjb250ZXh0LnJvb3RlZCAmJiAvXiNbQS1aX11bLUEtWjAtOV9dKiQvaS50ZXN0KHNlbCkpIHtcbiAgICAgIGlmIChjb250ZXh0LmRvYy5faGFzTXVsdGlwbGVFbGVtZW50c1dpdGhJZCkge1xuICAgICAgICBpZCA9IHNlbC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmICghY29udGV4dC5kb2MuX2hhc011bHRpcGxlRWxlbWVudHNXaXRoSWQoaWQpKSB7XG4gICAgICAgICAgciA9IGNvbnRleHQuZG9jLmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICByZXR1cm4gciA/IFtyXSA6IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxbMF0gPT09ICcuJyAmJiAvXlxcLlxcdyskLy50ZXN0KHNlbCkpIHtcbiAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoc2VsLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIGlmICgvXlxcdyskLy50ZXN0KHNlbCkpIHtcbiAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbCk7XG4gICAgfVxuICB9XG4gIC8qIGRvIHRoaW5ncyB0aGUgaGFyZC9zbG93IHdheSAqL1xuICByZXR1cm4gZmluZChzZWwsIGNvbnRleHQpO1xufTtcblxuZXhwb3J0cy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG5leHBvcnRzLm9wZXJhdG9ycyA9IG9wZXJhdG9ycztcbmV4cG9ydHMuY29tYmluYXRvcnMgPSBjb21iaW5hdG9ycztcblxuZXhwb3J0cy5tYXRjaGVzID0gZnVuY3Rpb24oZWwsIHNlbCkge1xuICB2YXIgdGVzdCA9IHsgc2VsOiBzZWwgfTtcbiAgZG8ge1xuICAgIHRlc3QgPSBjb21waWxlKHRlc3Quc2VsKTtcbiAgICBpZiAodGVzdChlbCkpIHsgcmV0dXJuIHRydWU7IH1cbiAgfSB3aGlsZSAodGVzdC5zZWwpO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9zZWxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xuXG52YXIgY3JlYXRlRG9jdW1lbnRGcmFnbWVudEZyb21Bcmd1bWVudHMgPSBmdW5jdGlvbihkb2N1bWVudCwgYXJncykge1xuICB2YXIgZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBmb3IgKHZhciBpPTA7IGk8YXJncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhcmdJdGVtID0gYXJnc1tpXTtcbiAgICB2YXIgaXNOb2RlID0gYXJnSXRlbSBpbnN0YW5jZW9mIE5vZGU7XG4gICAgZG9jRnJhZy5hcHBlbmRDaGlsZChpc05vZGUgPyBhcmdJdGVtIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhhcmdJdGVtKSkpO1xuICB9XG5cbiAgcmV0dXJuIGRvY0ZyYWc7XG59O1xuXG4vLyBUaGUgQ2hpbGROb2RlIGludGVyZmFjZSBjb250YWlucyBtZXRob2RzIHRoYXQgYXJlIHBhcnRpY3VsYXIgdG8gYE5vZGVgXG4vLyBvYmplY3RzIHRoYXQgY2FuIGhhdmUgYSBwYXJlbnQuICBJdCBpcyBpbXBsZW1lbnRlZCBieSBgRWxlbWVudGAsXG4vLyBgRG9jdW1lbnRUeXBlYCwgYW5kIGBDaGFyYWN0ZXJEYXRhYCBvYmplY3RzLlxudmFyIENoaWxkTm9kZSA9IHtcblxuICAvLyBJbnNlcnRzIGEgc2V0IG9mIE5vZGUgb3IgU3RyaW5nIG9iamVjdHMgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgb2YgdGhpc1xuICAvLyBDaGlsZE5vZGUncyBwYXJlbnQsIGp1c3QgYWZ0ZXIgdGhpcyBDaGlsZE5vZGUuICBTdHJpbmcgb2JqZWN0cyBhcmVcbiAgLy8gaW5zZXJ0ZWQgYXMgdGhlIGVxdWl2YWxlbnQgVGV4dCBub2Rlcy5cbiAgYWZ0ZXI6IHsgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyKCkge1xuICAgIHZhciBhcmdBcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnROb2RlLCBuZXh0U2libGluZyA9IHRoaXMubmV4dFNpYmxpbmc7XG4gICAgaWYgKHBhcmVudE5vZGUgPT09IG51bGwpIHsgcmV0dXJuOyB9XG4gICAgLy8gRmluZCBcInZpYWJsZSBuZXh0IHNpYmxpbmdcIjsgdGhhdCBpcywgbmV4dCBvbmUgbm90IGluIGFyZ0FyclxuICAgIHdoaWxlIChuZXh0U2libGluZyAmJiBhcmdBcnIuc29tZShmdW5jdGlvbih2KSB7IHJldHVybiB2PT09bmV4dFNpYmxpbmc7IH0pKVxuICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5uZXh0U2libGluZztcbiAgICAvLyBvaywgcGFyZW50IGFuZCBzaWJsaW5nIGFyZSBzYXZlZCBhd2F5IHNpbmNlIHRoaXMgbm9kZSBjb3VsZCBpdHNlbGZcbiAgICAvLyBhcHBlYXIgaW4gYXJnQXJyIGFuZCB3ZSdyZSBhYm91dCB0byBtb3ZlIGFyZ0FyciB0byBhIGRvY3VtZW50IGZyYWdtZW50LlxuICAgIHZhciBkb2NGcmFnID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudEZyb21Bcmd1bWVudHModGhpcy5kb2MsIGFyZ0Fycik7XG5cbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShkb2NGcmFnLCBuZXh0U2libGluZyk7XG4gIH19LFxuXG4gIC8vIEluc2VydHMgYSBzZXQgb2YgTm9kZSBvciBTdHJpbmcgb2JqZWN0cyBpbiB0aGUgY2hpbGRyZW4gbGlzdCBvZiB0aGlzXG4gIC8vIENoaWxkTm9kZSdzIHBhcmVudCwganVzdCBiZWZvcmUgdGhpcyBDaGlsZE5vZGUuICBTdHJpbmcgb2JqZWN0cyBhcmVcbiAgLy8gaW5zZXJ0ZWQgYXMgdGhlIGVxdWl2YWxlbnQgVGV4dCBub2Rlcy5cbiAgYmVmb3JlOiB7IHZhbHVlOiBmdW5jdGlvbiBiZWZvcmUoKSB7XG4gICAgdmFyIGFyZ0FyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudE5vZGUsIHByZXZTaWJsaW5nID0gdGhpcy5wcmV2aW91c1NpYmxpbmc7XG4gICAgaWYgKHBhcmVudE5vZGUgPT09IG51bGwpIHsgcmV0dXJuOyB9XG4gICAgLy8gRmluZCBcInZpYWJsZSBwcmV2IHNpYmxpbmdcIjsgdGhhdCBpcywgcHJldiBvbmUgbm90IGluIGFyZ0FyclxuICAgIHdoaWxlIChwcmV2U2libGluZyAmJiBhcmdBcnIuc29tZShmdW5jdGlvbih2KSB7IHJldHVybiB2PT09cHJldlNpYmxpbmc7IH0pKVxuICAgICAgcHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5wcmV2aW91c1NpYmxpbmc7XG4gICAgLy8gb2ssIHBhcmVudCBhbmQgc2libGluZyBhcmUgc2F2ZWQgYXdheSBzaW5jZSB0aGlzIG5vZGUgY291bGQgaXRzZWxmXG4gICAgLy8gYXBwZWFyIGluIGFyZ0FyciBhbmQgd2UncmUgYWJvdXQgdG8gbW92ZSBhcmdBcnIgdG8gYSBkb2N1bWVudCBmcmFnbWVudC5cbiAgICB2YXIgZG9jRnJhZyA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnRGcm9tQXJndW1lbnRzKHRoaXMuZG9jLCBhcmdBcnIpO1xuXG4gICAgdmFyIG5leHRTaWJsaW5nID1cbiAgICAgICAgcHJldlNpYmxpbmcgPyBwcmV2U2libGluZy5uZXh0U2libGluZyA6IHBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShkb2NGcmFnLCBuZXh0U2libGluZyk7XG4gIH19LFxuXG4gIC8vIFJlbW92ZSB0aGlzIG5vZGUgZnJvbSBpdHMgcGFyZW50XG4gIHJlbW92ZTogeyB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybjtcblxuICAgIC8vIFNlbmQgbXV0YXRpb24gZXZlbnRzIGlmIG5lY2Vzc2FyeVxuICAgIGlmICh0aGlzLnJvb3RlZCAmJiB0aGlzLmRvYykgdGhpcy5kb2MubXV0YXRlUmVtb3ZlKHRoaXMpO1xuXG4gICAgLy8gUmVtb3ZlIHRoaXMgbm9kZSBmcm9tIGl0cyBwYXJlbnRzIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgdGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXMuc3BsaWNlKHRoaXMuaW5kZXgsIDEpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBzdHJ1Y3R1cmUgaWQgZm9yIGFsbCBhbmNlc3RvcnNcbiAgICB0aGlzLnBhcmVudE5vZGUubW9kaWZ5KCk7XG5cbiAgICAvLyBGb3JnZXQgdGhpcyBub2RlJ3MgcGFyZW50XG4gICAgdGhpcy5wYXJlbnROb2RlID0gbnVsbDtcbiAgfX0sXG5cbiAgLy8gUmVwbGFjZSB0aGlzIG5vZGUgd2l0aCB0aGUgbm9kZXMgb3Igc3RyaW5ncyBwcm92aWRlZCBhcyBhcmd1bWVudHMuXG4gIHJlcGxhY2VXaXRoOiB7IHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlV2l0aCgpIHtcbiAgICB2YXIgYXJnQXJyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZSwgbmV4dFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nO1xuICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsKSB7IHJldHVybjsgfVxuICAgIC8vIEZpbmQgXCJ2aWFibGUgbmV4dCBzaWJsaW5nXCI7IHRoYXQgaXMsIG5leHQgb25lIG5vdCBpbiBhcmdBcnJcbiAgICB3aGlsZSAobmV4dFNpYmxpbmcgJiYgYXJnQXJyLnNvbWUoZnVuY3Rpb24odikgeyByZXR1cm4gdj09PW5leHRTaWJsaW5nOyB9KSlcbiAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgLy8gb2ssIHBhcmVudCBhbmQgc2libGluZyBhcmUgc2F2ZWQgYXdheSBzaW5jZSB0aGlzIG5vZGUgY291bGQgaXRzZWxmXG4gICAgLy8gYXBwZWFyIGluIGFyZ0FyciBhbmQgd2UncmUgYWJvdXQgdG8gbW92ZSBhcmdBcnIgdG8gYSBkb2N1bWVudCBmcmFnbWVudC5cbiAgICB2YXIgZG9jRnJhZyA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnRGcm9tQXJndW1lbnRzKHRoaXMuZG9jLCBhcmdBcnIpO1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUgPT09IHBhcmVudE5vZGUpIHtcbiAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGRvY0ZyYWcsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBgdGhpc2Agd2FzIGluc2VydGVkIGludG8gZG9jRnJhZ1xuICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jRnJhZywgbmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgfX0sXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hpbGROb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9DaGlsZE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBVUkw7XG5cbmZ1bmN0aW9uIFVSTCh1cmwpIHtcbiAgaWYgKCF1cmwpIHJldHVybiBPYmplY3QuY3JlYXRlKFVSTC5wcm90b3R5cGUpO1xuICAvLyBDYW4ndCB1c2UgU3RyaW5nLnRyaW0oKSBzaW5jZSBpdCBkZWZpbmVzIHdoaXRlc3BhY2UgZGlmZmVyZW50bHkgdGhhbiBIVE1MXG4gIHRoaXMudXJsID0gdXJsLnJlcGxhY2UoL15bIFxcdFxcblxcclxcZl0rfFsgXFx0XFxuXFxyXFxmXSskL2csIFwiXCIpO1xuXG4gIC8vIFNlZSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I2FwcGVuZGl4LUJcbiAgLy8gYW5kIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jcGFyc2luZ1xuICB2YXIgbWF0Y2ggPSBVUkwucGF0dGVybi5leGVjKHRoaXMudXJsKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgaWYgKG1hdGNoWzJdKSB0aGlzLnNjaGVtZSA9IG1hdGNoWzJdO1xuICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgLy8gcGFyc2UgdXNlcm5hbWUvcGFzc3dvcmRcbiAgICAgIHZhciB1c2VyaW5mbyA9IG1hdGNoWzRdLm1hdGNoKFVSTC51c2VyaW5mb1BhdHRlcm4pO1xuICAgICAgaWYgKHVzZXJpbmZvKSB7XG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyaW5mb1sxXTtcbiAgICAgICAgdGhpcy5wYXNzd29yZCA9IHVzZXJpbmZvWzNdO1xuICAgICAgICBtYXRjaFs0XSA9IG1hdGNoWzRdLnN1YnN0cmluZyh1c2VyaW5mb1swXS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoWzRdLm1hdGNoKFVSTC5wb3J0UGF0dGVybikpIHtcbiAgICAgICAgdmFyIHBvcyA9IG1hdGNoWzRdLmxhc3RJbmRleE9mKCc6Jyk7XG4gICAgICAgIHRoaXMuaG9zdCA9IG1hdGNoWzRdLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICB0aGlzLnBvcnQgPSBtYXRjaFs0XS5zdWJzdHJpbmcocG9zKzEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IG1hdGNoWzRdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2hbNV0pIHRoaXMucGF0aCA9IG1hdGNoWzVdO1xuICAgIGlmIChtYXRjaFs2XSkgdGhpcy5xdWVyeSA9IG1hdGNoWzddO1xuICAgIGlmIChtYXRjaFs4XSkgdGhpcy5mcmFnbWVudCA9IG1hdGNoWzldO1xuICB9XG59XG5cblVSTC5wYXR0ZXJuID0gL14oKFteOlxcLz8jXSspOik/KFxcL1xcLyhbXlxcLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpPyQvO1xuVVJMLnVzZXJpbmZvUGF0dGVybiA9IC9eKFteQDpdKikoOihbXkBdKikpP0AvO1xuVVJMLnBvcnRQYXR0ZXJuID0gLzpcXGQrJC87XG5VUkwuYXV0aG9yaXR5UGF0dGVybiA9IC9eW146XFwvPyNdKzpcXC9cXC8vO1xuVVJMLmhpZXJhcmNoeVBhdHRlcm4gPSAvXlteOlxcLz8jXSs6XFwvLztcblxuLy8gUmV0dXJuIGEgcGVyY2VudEVuY29kZWQgdmVyc2lvbiBvZiBzLlxuLy8gUyBzaG91bGQgYmUgYSBzaW5nbGUtY2hhcmFjdGVyIHN0cmluZ1xuLy8gWFhYOiBuZWVkcyB0byBkbyB1dGYtOCBlbmNvZGluZz9cblVSTC5wZXJjZW50RW5jb2RlID0gZnVuY3Rpb24gcGVyY2VudEVuY29kZShzKSB7XG4gIHZhciBjID0gcy5jaGFyQ29kZUF0KDApO1xuICBpZiAoYyA8IDI1NikgcmV0dXJuIFwiJVwiICsgYy50b1N0cmluZygxNik7XG4gIGVsc2UgdGhyb3cgRXJyb3IoXCJjYW4ndCBwZXJjZW50LWVuY29kZSBjb2RlcG9pbnRzID4gMjU1IHlldFwiKTtcbn07XG5cblVSTC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBVUkwsXG5cbiAgLy8gWFhYOiBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBwcmVjaXNlIGRlZmluaXRpb24gb2YgYWJzb2x1dGVcbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24oKSB7IHJldHVybiAhIXRoaXMuc2NoZW1lOyB9LFxuICBpc0F1dGhvcml0eUJhc2VkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gVVJMLmF1dGhvcml0eVBhdHRlcm4udGVzdCh0aGlzLnVybCk7XG4gIH0sXG4gIGlzSGllcmFyY2hpY2FsOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gVVJMLmhpZXJhcmNoeVBhdHRlcm4udGVzdCh0aGlzLnVybCk7XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzID0gXCJcIjtcbiAgICBpZiAodGhpcy5zY2hlbWUgIT09IHVuZGVmaW5lZCkgcyArPSB0aGlzLnNjaGVtZSArIFwiOlwiO1xuICAgIGlmICh0aGlzLmlzQWJzb2x1dGUoKSkge1xuICAgICAgcyArPSAnLy8nO1xuICAgICAgaWYgKHRoaXMudXNlcm5hbWUgfHwgdGhpcy5wYXNzd29yZCkge1xuICAgICAgICBzICs9IHRoaXMudXNlcm5hbWUgfHwgJyc7XG4gICAgICAgIGlmICh0aGlzLnBhc3N3b3JkKSB7XG4gICAgICAgICAgcyArPSAnOicgKyB0aGlzLnBhc3N3b3JkO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gJ0AnO1xuICAgICAgfVxuICAgICAgcyArPSB0aGlzLmhvc3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLnBvcnQgIT09IHVuZGVmaW5lZCkgcyArPSBcIjpcIiArIHRoaXMucG9ydDtcbiAgICBpZiAodGhpcy5wYXRoICE9PSB1bmRlZmluZWQpIHMgKz0gdGhpcy5wYXRoO1xuICAgIGlmICh0aGlzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHMgKz0gXCI/XCIgKyB0aGlzLnF1ZXJ5O1xuICAgIGlmICh0aGlzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHMgKz0gXCIjXCIgKyB0aGlzLmZyYWdtZW50O1xuICAgIHJldHVybiBzO1xuICB9LFxuXG4gIC8vIFNlZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMlxuICAvLyBhbmQgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25zdHJ1Y3RvcnNcbiAgcmVzb2x2ZTogZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgICB2YXIgYmFzZSA9IHRoaXM7ICAgICAgICAgICAvLyBUaGUgYmFzZSB1cmwgd2UncmUgcmVzb2x2aW5nIGFnYWluc3RcbiAgICB2YXIgciA9IG5ldyBVUkwocmVsYXRpdmUpOyAvLyBUaGUgcmVsYXRpdmUgcmVmZXJlbmNlIHVybCB0byByZXNvbHZlXG4gICAgdmFyIHQgPSBuZXcgVVJMKCk7ICAgICAgICAgLy8gVGhlIGFic29sdXRlIHRhcmdldCB1cmwgd2Ugd2lsbCByZXR1cm5cblxuICAgIGlmIChyLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0LnNjaGVtZSA9IHIuc2NoZW1lO1xuICAgICAgdC51c2VybmFtZSA9IHIudXNlcm5hbWU7XG4gICAgICB0LnBhc3N3b3JkID0gci5wYXNzd29yZDtcbiAgICAgIHQuaG9zdCA9IHIuaG9zdDtcbiAgICAgIHQucG9ydCA9IHIucG9ydDtcbiAgICAgIHQucGF0aCA9IHJlbW92ZV9kb3Rfc2VnbWVudHMoci5wYXRoKTtcbiAgICAgIHQucXVlcnkgPSByLnF1ZXJ5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHQuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICAgICBpZiAoci5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdC51c2VybmFtZSA9IHIudXNlcm5hbWU7XG4gICAgICAgIHQucGFzc3dvcmQgPSByLnBhc3N3b3JkO1xuICAgICAgICB0Lmhvc3QgPSByLmhvc3Q7XG4gICAgICAgIHQucG9ydCA9IHIucG9ydDtcbiAgICAgICAgdC5wYXRoID0gcmVtb3ZlX2RvdF9zZWdtZW50cyhyLnBhdGgpO1xuICAgICAgICB0LnF1ZXJ5ID0gci5xdWVyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0LnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgdC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgIHQuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgdC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICBpZiAoIXIucGF0aCkgeyAvLyB1bmRlZmluZWQgb3IgZW1wdHlcbiAgICAgICAgICB0LnBhdGggPSBiYXNlLnBhdGg7XG4gICAgICAgICAgaWYgKHIucXVlcnkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHQucXVlcnkgPSByLnF1ZXJ5O1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHQucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChyLnBhdGguY2hhckF0KDApID09PSBcIi9cIikge1xuICAgICAgICAgICAgdC5wYXRoID0gcmVtb3ZlX2RvdF9zZWdtZW50cyhyLnBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHQucGF0aCA9IG1lcmdlKGJhc2UucGF0aCwgci5wYXRoKTtcbiAgICAgICAgICAgIHQucGF0aCA9IHJlbW92ZV9kb3Rfc2VnbWVudHModC5wYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdC5xdWVyeSA9IHIucXVlcnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdC5mcmFnbWVudCA9IHIuZnJhZ21lbnQ7XG5cbiAgICByZXR1cm4gdC50b1N0cmluZygpO1xuXG5cbiAgICBmdW5jdGlvbiBtZXJnZShiYXNlcGF0aCwgcmVmcGF0aCkge1xuICAgICAgaWYgKGJhc2UuaG9zdCAhPT0gdW5kZWZpbmVkICYmICFiYXNlLnBhdGgpXG4gICAgICAgIHJldHVybiBcIi9cIiArIHJlZnBhdGg7XG5cbiAgICAgIHZhciBsYXN0c2xhc2ggPSBiYXNlcGF0aC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICBpZiAobGFzdHNsYXNoID09PSAtMSlcbiAgICAgICAgcmV0dXJuIHJlZnBhdGg7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBiYXNlcGF0aC5zdWJzdHJpbmcoMCwgbGFzdHNsYXNoKzEpICsgcmVmcGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVfZG90X3NlZ21lbnRzKHBhdGgpIHtcbiAgICAgIGlmICghcGF0aCkgcmV0dXJuIHBhdGg7IC8vIEZvciBcIlwiIG9yIHVuZGVmaW5lZFxuXG4gICAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICAgIHdoaWxlKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAocGF0aCA9PT0gXCIuXCIgfHwgcGF0aCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgcGF0aCA9IFwiXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHdvY2hhcnMgPSBwYXRoLnN1YnN0cmluZygwLDIpO1xuICAgICAgICB2YXIgdGhyZWVjaGFycyA9IHBhdGguc3Vic3RyaW5nKDAsMyk7XG4gICAgICAgIHZhciBmb3VyY2hhcnMgPSBwYXRoLnN1YnN0cmluZygwLDQpO1xuICAgICAgICBpZiAodGhyZWVjaGFycyA9PT0gXCIuLi9cIikge1xuICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0d29jaGFycyA9PT0gXCIuL1wiKSB7XG4gICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRocmVlY2hhcnMgPT09IFwiLy4vXCIpIHtcbiAgICAgICAgICBwYXRoID0gXCIvXCIgKyBwYXRoLnN1YnN0cmluZygzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0d29jaGFycyA9PT0gXCIvLlwiICYmIHBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgcGF0aCA9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvdXJjaGFycyA9PT0gXCIvLi4vXCIgfHxcbiAgICAgICAgICAgICAodGhyZWVjaGFycyA9PT0gXCIvLi5cIiAmJiBwYXRoLmxlbmd0aCA9PT0gMykpIHtcbiAgICAgICAgICBwYXRoID0gXCIvXCIgKyBwYXRoLnN1YnN0cmluZyg0KTtcblxuICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXC8/W15cXC9dKiQvLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IHBhdGgubWF0Y2goLyhcXC8/KFteXFwvXSopKS8pWzBdO1xuICAgICAgICAgIG91dHB1dCArPSBzZWdtZW50O1xuICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZyhzZWdtZW50Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gIH0sXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9VUkwuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi9FbGVtZW50Jyk7XG52YXIgQ1NTU3R5bGVEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vQ1NTU3R5bGVEZWNsYXJhdGlvbicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIFVSTFV0aWxzID0gcmVxdWlyZSgnLi9VUkxVdGlscycpO1xudmFyIGRlZmluZUVsZW1lbnQgPSByZXF1aXJlKCcuL2RlZmluZUVsZW1lbnQnKTtcblxudmFyIGh0bWxFbGVtZW50cyA9IGV4cG9ydHMuZWxlbWVudHMgPSB7fTtcbnZhciBodG1sTmFtZVRvSW1wbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgdmFyIGltcGwgPSBodG1sTmFtZVRvSW1wbFtsb2NhbE5hbWVdIHx8IEhUTUxVbmtub3duRWxlbWVudDtcbiAgcmV0dXJuIG5ldyBpbXBsKGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xufTtcblxuZnVuY3Rpb24gZGVmaW5lKHNwZWMpIHtcbiAgcmV0dXJuIGRlZmluZUVsZW1lbnQoc3BlYywgSFRNTEVsZW1lbnQsIGh0bWxFbGVtZW50cywgaHRtbE5hbWVUb0ltcGwpO1xufVxuXG5mdW5jdGlvbiBVUkwoYXR0cikge1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHRoaXMuX2dldGF0dHIoYXR0cik7XG4gICAgICBpZiAodiA9PT0gbnVsbCkgeyByZXR1cm4gJyc7IH1cbiAgICAgIHZhciB1cmwgPSB0aGlzLmRvYy5fcmVzb2x2ZSh2KTtcbiAgICAgIHJldHVybiAodXJsID09PSBudWxsKSA/IHYgOiB1cmw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRhdHRyKGF0dHIsIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIENPUlMoYXR0cikge1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHRoaXMuX2dldGF0dHIoYXR0cik7XG4gICAgICBpZiAodiA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgaWYgKHYudG9Mb3dlckNhc2UoKSA9PT0gJ3VzZS1jcmVkZW50aWFscycpIHsgcmV0dXJuICd1c2UtY3JlZGVudGlhbHMnOyB9XG4gICAgICByZXR1cm4gJ2Fub255bW91cyc7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWU9PT1udWxsIHx8IHZhbHVlPT09dW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0YXR0cihhdHRyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgUkVGRVJSRVIgPSB7XG4gIHR5cGU6IFtcIlwiLCBcIm5vLXJlZmVycmVyXCIsIFwibm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGVcIiwgXCJzYW1lLW9yaWdpblwiLCBcIm9yaWdpblwiLCBcInN0cmljdC1vcmlnaW5cIiwgXCJvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIiwgXCJzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsIFwidW5zYWZlLXVybFwiXSxcbiAgbWlzc2luZzogJycsXG59O1xuXG5cbi8vIFhYWDogdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRhYkluZGV4IHNob3VsZCBiZSAwIGlmIHRoZSBlbGVtZW50IGlzXG4vLyBmb2N1c2FibGUgYW5kIC0xIGlmIGl0IGlzIG5vdC4gIEJ1dCB0aGUgZnVsbCBkZWZpbml0aW9uIG9mIGZvY3VzYWJsZVxuLy8gaXMgYWN0dWFsbHkgaGFyZCB0byBjb21wdXRlLCBzbyBmb3Igbm93LCBJJ2xsIGZvbGxvdyBGaXJlZm94IGFuZFxuLy8ganVzdCBiYXNlIHRoZSBkZWZhdWx0IHZhbHVlIG9uIHRoZSB0eXBlIG9mIHRoZSBlbGVtZW50LlxudmFyIGZvY3VzYWJsZUVsZW1lbnRzID0ge1xuICBcIkFcIjp0cnVlLCBcIkxJTktcIjp0cnVlLCBcIkJVVFRPTlwiOnRydWUsIFwiSU5QVVRcIjp0cnVlLFxuICBcIlNFTEVDVFwiOnRydWUsIFwiVEVYVEFSRUFcIjp0cnVlLCBcIkNPTU1BTkRcIjp0cnVlXG59O1xuXG52YXIgSFRNTEZvcm1FbGVtZW50ID0gZnVuY3Rpb24oZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB0aGlzLl9mb3JtID0gbnVsbDsgLy8gUHJldmVudCBsYXRlciBkZW9wdGltaXphdGlvblxufTtcblxudmFyIEhUTUxFbGVtZW50ID0gZXhwb3J0cy5IVE1MRWxlbWVudCA9IGRlZmluZSh7XG4gIHN1cGVyY2xhc3M6IEVsZW1lbnQsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHV0aWxzLk5BTUVTUEFDRS5IVE1MLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIGlubmVySFRNTDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBwYXJzZXIgPSB0aGlzLm93bmVyRG9jdW1lbnQuaW1wbGVtZW50YXRpb24ubW96SFRNTFBhcnNlcihcbiAgICAgICAgICB0aGlzLm93bmVyRG9jdW1lbnQuX2FkZHJlc3MsXG4gICAgICAgICAgdGhpcyk7XG4gICAgICAgIHBhcnNlci5wYXJzZSh2LCB0cnVlKTtcbiAgICAgICAgdmFyIHRtcGRvYyA9IHBhcnNlci5kb2N1bWVudCgpO1xuICAgICAgICB2YXIgcm9vdCA9IHRtcGRvYy5maXJzdENoaWxkO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gKHRoaXMgaW5zdGFuY2VvZiBodG1sTmFtZVRvSW1wbC50ZW1wbGF0ZSkgP1xuICAgICAgICAgICAgdGhpcy5jb250ZW50IDogdGhpcztcblxuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNoaWxkcmVuIG9mIHRoaXMgbm9kZVxuICAgICAgICB3aGlsZSh0YXJnZXQuaGFzQ2hpbGROb2RlcygpKVxuICAgICAgICAgIHRhcmdldC5yZW1vdmVDaGlsZCh0YXJnZXQuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgLy8gTm93IGNvcHkgbmV3bHkgcGFyc2VkIGNoaWxkcmVuIGZyb20gdGhlIHJvb3QgdG8gdGhpcyBub2RlXG4gICAgICAgIHRhcmdldC5kb2MuYWRvcHROb2RlKHJvb3QpO1xuICAgICAgICB3aGlsZShyb290Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChyb290LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzdHlsZTogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9zdHlsZSlcbiAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgQ1NTU3R5bGVEZWNsYXJhdGlvbih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgICB9fSxcblxuICAgIGNsaWNrOiB7IHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9jbGlja19pbl9wcm9ncmVzcykgcmV0dXJuO1xuICAgICAgdGhpcy5fY2xpY2tfaW5fcHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuX3ByZV9jbGlja19hY3RpdmF0aW9uX3N0ZXBzKVxuICAgICAgICAgIHRoaXMuX3ByZV9jbGlja19hY3RpdmF0aW9uX3N0ZXBzKCk7XG5cbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcbiAgICAgICAgZXZlbnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLFxuICAgICAgICAgIHRoaXMub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldywgMSxcbiAgICAgICAgICAwLCAwLCAwLCAwLFxuICAgICAgICAgIC8vIFRoZXNlIDQgc2hvdWxkIGJlIGluaXRpYWxpemVkIHdpdGhcbiAgICAgICAgICAvLyB0aGUgYWN0dWFsbHkgY3VycmVudCBrZXlib2FyZCBzdGF0ZVxuICAgICAgICAgIC8vIHNvbWVob3cuLi5cbiAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSxcbiAgICAgICAgICAwLCBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRGlzcGF0Y2ggdGhpcyBhcyBhbiB1bnRydXN0ZWQgZXZlbnQgc2luY2UgaXQgaXMgc3ludGhldGljXG4gICAgICAgIHZhciBzdWNjZXNzID0gdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIGlmICh0aGlzLl9wb3N0X2NsaWNrX2FjdGl2YXRpb25fc3RlcHMpXG4gICAgICAgICAgICB0aGlzLl9wb3N0X2NsaWNrX2FjdGl2YXRpb25fc3RlcHMoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLl9jYW5jZWxsZWRfYWN0aXZhdGlvbl9zdGVwcylcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbGxlZF9hY3RpdmF0aW9uX3N0ZXBzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9jbGlja19pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH19XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIGxhbmc6IFN0cmluZyxcbiAgICBkaXI6IHt0eXBlOiBbXCJsdHJcIiwgXCJydGxcIiwgXCJhdXRvXCJdLCBtaXNzaW5nOiAnJ30sXG4gICAgYWNjZXNzS2V5OiBTdHJpbmcsXG4gICAgaGlkZGVuOiBCb29sZWFuLFxuICAgIHRhYkluZGV4OiB7dHlwZTogXCJsb25nXCIsIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMudGFnTmFtZSBpbiBmb2N1c2FibGVFbGVtZW50cyB8fFxuICAgICAgICB0aGlzLmNvbnRlbnRFZGl0YWJsZSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9fVxuICB9LFxuICBldmVudHM6IFtcbiAgICBcImFib3J0XCIsIFwiY2FucGxheVwiLCBcImNhbnBsYXl0aHJvdWdoXCIsIFwiY2hhbmdlXCIsIFwiY2xpY2tcIiwgXCJjb250ZXh0bWVudVwiLFxuICAgIFwiY3VlY2hhbmdlXCIsIFwiZGJsY2xpY2tcIiwgXCJkcmFnXCIsIFwiZHJhZ2VuZFwiLCBcImRyYWdlbnRlclwiLCBcImRyYWdsZWF2ZVwiLFxuICAgIFwiZHJhZ292ZXJcIiwgXCJkcmFnc3RhcnRcIiwgXCJkcm9wXCIsIFwiZHVyYXRpb25jaGFuZ2VcIiwgXCJlbXB0aWVkXCIsIFwiZW5kZWRcIixcbiAgICBcImlucHV0XCIsIFwiaW52YWxpZFwiLCBcImtleWRvd25cIiwgXCJrZXlwcmVzc1wiLCBcImtleXVwXCIsIFwibG9hZGVkZGF0YVwiLFxuICAgIFwibG9hZGVkbWV0YWRhdGFcIiwgXCJsb2Fkc3RhcnRcIiwgXCJtb3VzZWRvd25cIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZW91dFwiLFxuICAgIFwibW91c2VvdmVyXCIsIFwibW91c2V1cFwiLCBcIm1vdXNld2hlZWxcIiwgXCJwYXVzZVwiLCBcInBsYXlcIiwgXCJwbGF5aW5nXCIsXG4gICAgXCJwcm9ncmVzc1wiLCBcInJhdGVjaGFuZ2VcIiwgXCJyZWFkeXN0YXRlY2hhbmdlXCIsIFwicmVzZXRcIiwgXCJzZWVrZWRcIixcbiAgICBcInNlZWtpbmdcIiwgXCJzZWxlY3RcIiwgXCJzaG93XCIsIFwic3RhbGxlZFwiLCBcInN1Ym1pdFwiLCBcInN1c3BlbmRcIixcbiAgICBcInRpbWV1cGRhdGVcIiwgXCJ2b2x1bWVjaGFuZ2VcIiwgXCJ3YWl0aW5nXCIsXG5cbiAgICAvLyBUaGVzZSBsYXN0IDUgZXZlbnQgdHlwZXMgd2lsbCBiZSBvdmVycmlkZW4gYnkgSFRNTEJvZHlFbGVtZW50XG4gICAgXCJibHVyXCIsIFwiZXJyb3JcIiwgXCJmb2N1c1wiLCBcImxvYWRcIiwgXCJzY3JvbGxcIlxuICBdXG59KTtcblxuXG4vLyBYWFg6IHJlZmxlY3QgY29udGV4dG1lbnUgYXMgY29udGV4dE1lbnUsIHdpdGggZWxlbWVudCB0eXBlXG5cblxuLy8gc3R5bGU6IHRoZSBzcGVjIGRvZXNuJ3QgY2FsbCB0aGlzIGEgcmVmbGVjdGVkIGF0dHJpYnV0ZS5cbi8vICAgbWF5IHdhbnQgdG8gaGFuZGxlIGl0IG1hbnVhbGx5LlxuXG4vLyBjb250ZW50RWRpdGFibGU6IGVudW1lcmF0ZWQsIG5vdCBjbGVhciBpZiBpdCBpcyBhY3R1YWxseVxuLy8gcmVmbGVjdGVkIG9yIHJlcXVpcmVzIGN1c3RvbSBnZXR0ZXIvc2V0dGVyLiBOb3QgbGlzdGVkIGFzXG4vLyBcImxpbWl0ZWQgdG8ga25vd24gdmFsdWVzXCIuICBSYWlzZXMgc3ludGF4X2VyciBvbiBiYWQgc2V0dGluZyxcbi8vIHNvIEkgdGhpbmsgdGhpcyBpcyBjdXN0b20uXG5cbi8vIGNvbnRleHRtZW51OiBjb250ZW50IGlzIGVsZW1lbnQgaWQsIGlkbCB0eXBlIGlzIGFuIGVsZW1lbnRcbi8vIGRyYWdnYWJsZTogYm9vbGVhbiwgYnV0IG5vdCBhIHJlZmxlY3RlZCBhdHRyaWJ1dGVcbi8vIGRyb3B6b25lOiByZWZsZWN0ZWQgU2V0dGFibGVUb2tlbkxpc3QsIGV4cGVyaW1lbnRhbCwgc28gZG9uJ3Rcbi8vICAgaW1wbGVtZW50IGl0IHJpZ2h0IGF3YXkuXG5cbi8vIGRhdGEtKiBhdHRyaWJ1dGVzOiBuZWVkIHNwZWNpYWwgaGFuZGxpbmcgaW4gc2V0QXR0cmlidXRlP1xuLy8gT3IgbWF5YmUgdGhhdCBpc24ndCBuZWNlc3NhcnkuIENhbiBJIGp1c3Qgc2NhbiB0aGUgYXR0cmlidXRlIGxpc3Rcbi8vIHdoZW4gYnVpbGRpbmcgdGhlIGRhdGFzZXQ/ICBMaXZlbmVzcyBhbmQgY2FjaGluZyBpc3N1ZXM/XG5cbi8vIG1pY3JvZGF0YSBhdHRyaWJ1dGVzOiBtYW55IGFyZSBzaW1wbGUgcmVmbGVjdGVkIGF0dHJpYnV0ZXMsIGJ1dFxuLy8gSSdtIG5vdCBnb2luZyB0byBpbXBsZW1lbnQgdGhpcyBub3cuXG5cblxudmFyIEhUTUxVbmtub3duRWxlbWVudCA9IGRlZmluZSh7XG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxVbmtub3duRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfVxufSk7XG5cblxudmFyIGZvcm1Bc3NvY2lhdGVkUHJvcHMgPSB7XG4gIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9hc3NvY2lhdGlvbi1vZi1jb250cm9scy1hbmQtZm9ybXMuaHRtbCNmb3JtLW93bmVyXG4gIGZvcm06IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9ybTtcbiAgfX1cbn07XG5cbmRlZmluZSh7XG4gIHRhZzogJ2EnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MQW5jaG9yRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBfcG9zdF9jbGlja19hY3RpdmF0aW9uX3N0ZXBzOiB7IHZhbHVlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5ocmVmKSB7XG4gICAgICAgIC8vIEZvbGxvdyB0aGUgbGlua1xuICAgICAgICAvLyBYWFg6IHRoaXMgaXMganVzdCBhIHF1aWNrIGhhY2tcbiAgICAgICAgLy8gWFhYOiB0aGUgSFRNTCBzcGVjIHByb2JhYmx5IHJlcXVpcmVzIG1vcmUgdGhhbiB0aGlzXG4gICAgICAgIHRoaXMub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5sb2NhdGlvbiA9IHRoaXMuaHJlZjtcbiAgICAgIH1cbiAgICB9fSxcbiAgICBibHVyOiB7IHZhbHVlOiBmdW5jdGlvbigpIHt9fSxcbiAgICBmb2N1czogeyB2YWx1ZTogZnVuY3Rpb24oKSB7fX1cbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIGhyZWY6IFVSTCxcbiAgICBwaW5nOiBTdHJpbmcsXG4gICAgZG93bmxvYWQ6IFN0cmluZyxcbiAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICByZWw6IFN0cmluZyxcbiAgICBtZWRpYTogU3RyaW5nLFxuICAgIGhyZWZsYW5nOiBTdHJpbmcsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIHJlZmVycmVyUG9saWN5OiBSRUZFUlJFUixcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGNvb3JkczogU3RyaW5nLFxuICAgIGNoYXJzZXQ6IFN0cmluZyxcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgcmV2OiBTdHJpbmcsXG4gICAgc2hhcGU6IFN0cmluZyxcbiAgfVxufSk7XG5VUkxVdGlscy5faW5oZXJpdChodG1sTmFtZVRvSW1wbC5hLnByb3RvdHlwZSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2FyZWEnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MQXJlYUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBhbHQ6IFN0cmluZyxcbiAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICBkb3dubG9hZDogU3RyaW5nLFxuICAgIHJlbDogU3RyaW5nLFxuICAgIG1lZGlhOiBTdHJpbmcsXG4gICAgaHJlZjogVVJMLFxuICAgIGhyZWZsYW5nOiBTdHJpbmcsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIHNoYXBlOiBTdHJpbmcsXG4gICAgY29vcmRzOiBTdHJpbmcsXG4gICAgcGluZzogU3RyaW5nLFxuICAgIC8vIFhYWDogYWxzbyByZWZsZWN0IHJlbExpc3RcbiAgICByZWZlcnJlclBvbGljeTogUkVGRVJSRVIsXG4gICAgLy8gT2Jzb2xldGVcbiAgICBub0hyZWY6IEJvb2xlYW4sXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdicicsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxCUkVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGNsZWFyOiBTdHJpbmdcbiAgfSxcbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdiYXNlJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEJhc2VFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgXCJ0YXJnZXRcIjogU3RyaW5nXG4gIH1cbn0pO1xuXG5cbmRlZmluZSh7XG4gIHRhZzogJ2JvZHknLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MQm9keUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIC8vIENlcnRhaW4gZXZlbnQgaGFuZGxlciBhdHRyaWJ1dGVzIG9uIGEgPGJvZHk+IHRhZyBhY3R1YWxseSBzZXRcbiAgLy8gaGFuZGxlcnMgZm9yIHRoZSB3aW5kb3cgcmF0aGVyIHRoYW4ganVzdCB0aGF0IGVsZW1lbnQuICBEZWZpbmVcbiAgLy8gZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgdGhvc2UgaGVyZS4gIE5vdGUgdGhhdCBzb21lIG9mIHRoZXNlIG92ZXJyaWRlXG4gIC8vIHByb3BlcnRpZXMgb24gSFRNTEVsZW1lbnQucHJvdG90eXBlLlxuICAvLyBYWFg6IElmIEkgYWRkIHN1cHBvcnQgZm9yIDxmcmFtZXNldD4sIHRoZXNlIGhhdmUgdG8gZ28gdGhlcmUsIHRvb1xuICAvLyBYWFhcbiAgLy8gV2hlbiB0aGUgV2luZG93IG9iamVjdCBpcyBpbXBsZW1lbnRlZCwgdGhlc2UgYXR0cmlidXRlIHdpbGwgaGF2ZVxuICAvLyB0byB3b3JrIHdpdGggdGhlIHNhbWUtbmFtZWQgYXR0cmlidXRlcyBvbiB0aGUgV2luZG93LlxuICBldmVudHM6IFtcbiAgICBcImFmdGVycHJpbnRcIiwgXCJiZWZvcmVwcmludFwiLCBcImJlZm9yZXVubG9hZFwiLCBcImJsdXJcIiwgXCJlcnJvclwiLFxuICAgIFwiZm9jdXNcIixcImhhc2hjaGFuZ2VcIiwgXCJsb2FkXCIsIFwibWVzc2FnZVwiLCBcIm9mZmxpbmVcIiwgXCJvbmxpbmVcIixcbiAgICBcInBhZ2VoaWRlXCIsIFwicGFnZXNob3dcIixcInBvcHN0YXRlXCIsXCJyZXNpemVcIixcInNjcm9sbFwiLFwic3RvcmFnZVwiLFwidW5sb2FkXCIsXG4gIF0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBPYnNvbGV0ZVxuICAgIHRleHQ6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXG4gICAgbGluazogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgICB2TGluazogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgICBhTGluazogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgICBiZ0NvbG9yOiB7IHR5cGU6IFN0cmluZywgdHJlYXROdWxsQXNFbXB0eVN0cmluZzogdHJ1ZSB9LFxuICAgIGJhY2tncm91bmQ6IFN0cmluZyxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2J1dHRvbicsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxCdXR0b25FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRm9ybUVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IGZvcm1Bc3NvY2lhdGVkUHJvcHMsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBhdXRvZm9jdXM6IEJvb2xlYW4sXG4gICAgdHlwZTogeyB0eXBlOltcInN1Ym1pdFwiLCBcInJlc2V0XCIsIFwiYnV0dG9uXCIsIFwibWVudVwiXSwgbWlzc2luZzogJ3N1Ym1pdCcgfSxcbiAgICBmb3JtVGFyZ2V0OiBTdHJpbmcsXG4gICAgZm9ybU5vVmFsaWRhdGU6IEJvb2xlYW4sXG4gICAgZm9ybU1ldGhvZDogeyB0eXBlOiBbXCJnZXRcIiwgXCJwb3N0XCIsIFwiZGlhbG9nXCJdLCBpbnZhbGlkOiAnZ2V0JywgbWlzc2luZzogJycgfSxcbiAgICBmb3JtRW5jdHlwZTogeyB0eXBlOiBbXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsIFwidGV4dC9wbGFpblwiXSwgaW52YWxpZDogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgbWlzc2luZzogJycgfSxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2RsJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTERMaXN0RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIE9ic29sZXRlXG4gICAgY29tcGFjdDogQm9vbGVhbixcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2RhdGEnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRGF0YUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnZGF0YWxpc3QnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRGF0YUxpc3RFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnZGV0YWlscycsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxEZXRhaWxzRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIFwib3BlblwiOiBCb29sZWFuXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdkaXYnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRGl2RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIE9ic29sZXRlXG4gICAgYWxpZ246IFN0cmluZ1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnZW1iZWQnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRW1iZWRFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgc3JjOiBVUkwsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIHdpZHRoOiBTdHJpbmcsXG4gICAgaGVpZ2h0OiBTdHJpbmcsXG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nLFxuICAgIG5hbWU6IFN0cmluZyxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2ZpZWxkc2V0JyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEZpZWxkU2V0RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEZvcm1FbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiBmb3JtQXNzb2NpYXRlZFByb3BzLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbmFtZTogU3RyaW5nXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdmb3JtJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEZvcm1FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgYWN0aW9uOiBTdHJpbmcsXG4gICAgYXV0b2NvbXBsZXRlOiB7dHlwZTpbJ29uJywgJ29mZiddLCBtaXNzaW5nOiAnb24nfSxcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgYWNjZXB0Q2hhcnNldDoge25hbWU6IFwiYWNjZXB0LWNoYXJzZXRcIn0sXG4gICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgbm9WYWxpZGF0ZTogQm9vbGVhbixcbiAgICBtZXRob2Q6IHsgdHlwZTogW1wiZ2V0XCIsIFwicG9zdFwiLCBcImRpYWxvZ1wiXSwgaW52YWxpZDogJ2dldCcsIG1pc3Npbmc6ICdnZXQnIH0sXG4gICAgLy8gQm90aCBlbmN0eXBlIGFuZCBlbmNvZGluZyByZWZsZWN0IHRoZSBlbmN0eXBlIGNvbnRlbnQgYXR0cmlidXRlXG4gICAgZW5jdHlwZTogeyB0eXBlOiBbXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsIFwidGV4dC9wbGFpblwiXSwgaW52YWxpZDogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgbWlzc2luZzogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiB9LFxuICAgIGVuY29kaW5nOiB7bmFtZTogJ2VuY3R5cGUnLCB0eXBlOiBbXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsIFwidGV4dC9wbGFpblwiXSwgaW52YWxpZDogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgbWlzc2luZzogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiB9LFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnaHInLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MSFJFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nLFxuICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgbm9TaGFkZTogQm9vbGVhbixcbiAgICBzaXplOiBTdHJpbmcsXG4gICAgd2lkdGg6IFN0cmluZyxcbiAgfSxcbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdoZWFkJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEhlYWRFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnczogWydoMScsJ2gyJywnaDMnLCdoNCcsJ2g1JywnaDYnXSxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEhlYWRpbmdFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nLFxuICB9LFxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2h0bWwnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MSHRtbEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBPYnNvbGV0ZVxuICAgIHZlcnNpb246IFN0cmluZ1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnaWZyYW1lJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTElGcmFtZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gICAgdmFyIFdpbmRvdyA9IHJlcXVpcmUoJy4vV2luZG93Jyk7IC8vIEF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICB0aGlzLl9jb250ZW50V2luZG93ID0gbmV3IFdpbmRvdygpO1xuICB9LFxuICBwcm9wczoge1xuICAgIGNvbnRlbnRXaW5kb3c6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50V2luZG93O1xuICAgIH0gfSxcbiAgICBjb250ZW50RG9jdW1lbnQ6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgfSB9LFxuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgc3JjOiBVUkwsXG4gICAgc3JjZG9jOiBTdHJpbmcsXG4gICAgbmFtZTogU3RyaW5nLFxuICAgIHdpZHRoOiBTdHJpbmcsXG4gICAgaGVpZ2h0OiBTdHJpbmcsXG4gICAgLy8gWFhYOiBzYW5kYm94IGlzIGEgcmVmbGVjdGVkIHNldHRhYmxlIHRva2VuIGxpc3RcbiAgICBzZWFtbGVzczogQm9vbGVhbixcbiAgICBhbGxvd0Z1bGxzY3JlZW46IEJvb2xlYW4sXG4gICAgYWxsb3dVc2VyTWVkaWE6IEJvb2xlYW4sXG4gICAgYWxsb3dQYXltZW50UmVxdWVzdDogQm9vbGVhbixcbiAgICByZWZlcnJlclBvbGljeTogUkVGRVJSRVIsXG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nLFxuICAgIHNjcm9sbGluZzogU3RyaW5nLFxuICAgIGZyYW1lQm9yZGVyOiBTdHJpbmcsXG4gICAgbG9uZ0Rlc2M6IFVSTCxcbiAgICBtYXJnaW5IZWlnaHQ6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXG4gICAgbWFyZ2luV2lkdGg6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdpbWcnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MSW1hZ2VFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgYWx0OiBTdHJpbmcsXG4gICAgc3JjOiBVUkwsXG4gICAgc3Jjc2V0OiBTdHJpbmcsXG4gICAgY3Jvc3NPcmlnaW46IENPUlMsXG4gICAgdXNlTWFwOiBTdHJpbmcsXG4gICAgaXNNYXA6IEJvb2xlYW4sXG4gICAgaGVpZ2h0OiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAwIH0sXG4gICAgd2lkdGg6IHsgdHlwZTogXCJ1bnNpZ25lZCBsb25nXCIsIGRlZmF1bHQ6IDAgfSxcbiAgICByZWZlcnJlclBvbGljeTogUkVGRVJSRVIsXG4gICAgLy8gT2Jzb2xldGU6XG4gICAgbmFtZTogU3RyaW5nLFxuICAgIGxvd3NyYzogVVJMLFxuICAgIGFsaWduOiBTdHJpbmcsXG4gICAgaHNwYWNlOiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAwIH0sXG4gICAgdnNwYWNlOiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAwIH0sXG4gICAgbG9uZ0Rlc2M6IFVSTCxcbiAgICBib3JkZXI6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdpbnB1dCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxJbnB1dEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxGb3JtRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIGZvcm06IGZvcm1Bc3NvY2lhdGVkUHJvcHMuZm9ybSxcbiAgICBfcG9zdF9jbGlja19hY3RpdmF0aW9uX3N0ZXBzOiB7IHZhbHVlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5mb3JtLmdldEVsZW1lbnRzQnlOYW1lKHRoaXMubmFtZSk7XG4gICAgICAgIGZvciAodmFyIGk9Z3JvdXAubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGVsID0gZ3JvdXBbaV07XG4gICAgICAgICAgZWwuY2hlY2tlZCA9IChlbCA9PT0gdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9fSxcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBhdXRvZm9jdXM6IEJvb2xlYW4sXG4gICAgYWNjZXB0OiBTdHJpbmcsXG4gICAgYWx0OiBTdHJpbmcsXG4gICAgbWF4OiBTdHJpbmcsXG4gICAgbWluOiBTdHJpbmcsXG4gICAgcGF0dGVybjogU3RyaW5nLFxuICAgIHBsYWNlaG9sZGVyOiBTdHJpbmcsXG4gICAgc3RlcDogU3RyaW5nLFxuICAgIGRpck5hbWU6IFN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6IHtuYW1lOiAndmFsdWUnfSxcbiAgICBtdWx0aXBsZTogQm9vbGVhbixcbiAgICByZXF1aXJlZDogQm9vbGVhbixcbiAgICByZWFkT25seTogQm9vbGVhbixcbiAgICBjaGVja2VkOiBCb29sZWFuLFxuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgc3JjOiBVUkwsXG4gICAgZGVmYXVsdENoZWNrZWQ6IHtuYW1lOiAnY2hlY2tlZCcsIHR5cGU6IEJvb2xlYW59LFxuICAgIHNpemU6IHt0eXBlOiAndW5zaWduZWQgbG9uZycsIGRlZmF1bHQ6IDIwLCBtaW46IDEsIHNldG1pbjogMX0sXG4gICAgbWF4TGVuZ3RoOiB7dHlwZTogJ3Vuc2lnbmVkIGxvbmcnLCBtaW46IDAsIHNldG1pbjogMCwgZGVmYXVsdDogLTF9LFxuICAgIGF1dG9jb21wbGV0ZTogU3RyaW5nLCAvLyBJdCdzIGNvbXBsaWNhdGVkXG4gICAgdHlwZTogeyB0eXBlOlxuICAgICAgICAgICAgW1widGV4dFwiLCBcImhpZGRlblwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiLCBcImVtYWlsXCIsIFwicGFzc3dvcmRcIixcbiAgICAgICAgICAgICBcImRhdGV0aW1lXCIsIFwiZGF0ZVwiLCBcIm1vbnRoXCIsIFwid2Vla1wiLCBcInRpbWVcIiwgXCJkYXRldGltZS1sb2NhbFwiLFxuICAgICAgICAgICAgIFwibnVtYmVyXCIsIFwicmFuZ2VcIiwgXCJjb2xvclwiLCBcImNoZWNrYm94XCIsIFwicmFkaW9cIiwgXCJmaWxlXCIsIFwic3VibWl0XCIsXG4gICAgICAgICAgICAgXCJpbWFnZVwiLCBcInJlc2V0XCIsIFwiYnV0dG9uXCJdLFxuICAgICAgICAgICAgbWlzc2luZzogJ3RleHQnIH0sXG4gICAgZm9ybVRhcmdldDogU3RyaW5nLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBCb29sZWFuLFxuICAgIGZvcm1NZXRob2Q6IHsgdHlwZTogW1wiZ2V0XCIsIFwicG9zdFwiXSwgaW52YWxpZDogJ2dldCcsIG1pc3Npbmc6ICcnIH0sXG4gICAgZm9ybUVuY3R5cGU6IHsgdHlwZTogW1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBcInRleHQvcGxhaW5cIl0sIGludmFsaWQ6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIG1pc3Npbmc6ICcnIH0sXG4gICAgaW5wdXRNb2RlOiB7IHR5cGU6IFsgXCJ2ZXJiYXRpbVwiLCBcImxhdGluXCIsIFwibGF0aW4tbmFtZVwiLCBcImxhdGluLXByb3NlXCIsIFwiZnVsbC13aWR0aC1sYXRpblwiLCBcImthbmFcIiwgXCJrYW5hLW5hbWVcIiwgXCJrYXRha2FuYVwiLCBcIm51bWVyaWNcIiwgXCJ0ZWxcIiwgXCJlbWFpbFwiLCBcInVybFwiIF0sIG1pc3Npbmc6ICcnIH0sXG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nLFxuICAgIHVzZU1hcDogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAna2V5Z2VuJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTEtleWdlbkVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxGb3JtRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczogZm9ybUFzc29jaWF0ZWRQcm9wcyxcbiAgYXR0cmlidXRlczoge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBhdXRvZm9jdXM6IEJvb2xlYW4sXG4gICAgY2hhbGxlbmdlOiBTdHJpbmcsXG4gICAga2V5dHlwZTogeyB0eXBlOltcInJzYVwiXSwgbWlzc2luZzogJycgfSxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2xpJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTExJRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIHZhbHVlOiB7dHlwZTogXCJsb25nXCIsIGRlZmF1bHQ6IDB9LFxuICAgIC8vIE9ic29sZXRlXG4gICAgdHlwZTogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnbGFiZWwnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTGFiZWxFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRm9ybUVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IGZvcm1Bc3NvY2lhdGVkUHJvcHMsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBodG1sRm9yOiB7bmFtZTogJ2ZvcicsIHR5cGU6IFN0cmluZ31cbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2xlZ2VuZCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxMZWdlbmRFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nXG4gIH0sXG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnbGluaycsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxMaW5rRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIFhYWCBSZWZsZWN0IERPTVNldHRhYmxlVG9rZW5MaXN0IHNpemVzIGFsc28gRE9NVG9rZW5MaXN0IHJlbExpc3RcbiAgICBocmVmOiBVUkwsXG4gICAgcmVsOiBTdHJpbmcsXG4gICAgbWVkaWE6IFN0cmluZyxcbiAgICBocmVmbGFuZzogU3RyaW5nLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBjcm9zc09yaWdpbjogQ09SUyxcbiAgICBub25jZTogU3RyaW5nLFxuICAgIGludGVncml0eTogU3RyaW5nLFxuICAgIHJlZmVycmVyUG9saWN5OiBSRUZFUlJFUixcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGNoYXJzZXQ6IFN0cmluZyxcbiAgICByZXY6IFN0cmluZyxcbiAgICB0YXJnZXQ6IFN0cmluZyxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ21hcCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxNYXBFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgbmFtZTogU3RyaW5nXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdtZW51JyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTE1lbnVFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgLy8gWFhYOiBub3QgcXVpdGUgcmlnaHQsIGRlZmF1bHQgc2hvdWxkIGJlIHBvcHVwIGlmIHBhcmVudCBlbGVtZW50IGlzXG4gICAgLy8gcG9wdXAuXG4gICAgdHlwZTogeyB0eXBlOiBbICdjb250ZXh0JywgJ3BvcHVwJywgJ3Rvb2xiYXInIF0sIG1pc3Npbmc6ICd0b29sYmFyJyB9LFxuICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgLy8gT2Jzb2xldGVcbiAgICBjb21wYWN0OiBCb29sZWFuLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnbWV0YScsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxNZXRhRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICBjb250ZW50OiBTdHJpbmcsXG4gICAgaHR0cEVxdWl2OiB7bmFtZTogJ2h0dHAtZXF1aXYnLCB0eXBlOiBTdHJpbmd9LFxuICAgIC8vIE9ic29sZXRlXG4gICAgc2NoZW1lOiBTdHJpbmcsXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdtZXRlcicsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxNZXRlckVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxGb3JtRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczogZm9ybUFzc29jaWF0ZWRQcm9wc1xufSk7XG5cbmRlZmluZSh7XG4gIHRhZ3M6IFsnaW5zJywgJ2RlbCddLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MTW9kRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIGNpdGU6IFVSTCxcbiAgICBkYXRlVGltZTogU3RyaW5nXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdvbCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxPTGlzdEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgLy8gVXRpbGl0eSBmdW5jdGlvbiAoc2VlIHRoZSBzdGFydCBhdHRyaWJ1dGUgZGVmYXVsdCB2YWx1ZSkuIFJldHVybnNcbiAgICAvLyB0aGUgbnVtYmVyIG9mIDxsaT4gY2hpbGRyZW4gb2YgdGhpcyBlbGVtZW50XG4gICAgX251bWl0ZW1zOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlbXMgPSAwO1xuICAgICAgdGhpcy5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgICAgICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgbi50YWdOYW1lID09PSBcIkxJXCIpXG4gICAgICAgICAgaXRlbXMrKztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH19XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgcmV2ZXJzZWQ6IEJvb2xlYW4sXG4gICAgc3RhcnQ6IHtcbiAgICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIHN0YXJ0IGF0dHJpYnV0ZSBpcyAxIHVubGVzcyB0aGUgbGlzdCBpc1xuICAgICAgIC8vIHJldmVyc2VkLiBUaGVuIGl0IGlzIHRoZSAjIG9mIGxpIGNoaWxkcmVuXG4gICAgICAgaWYgKHRoaXMucmV2ZXJzZWQpXG4gICAgICAgICByZXR1cm4gdGhpcy5fbnVtaXRlbXM7XG4gICAgICAgZWxzZVxuICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGNvbXBhY3Q6IEJvb2xlYW4sXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdvYmplY3QnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MT2JqZWN0RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEZvcm1FbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiBmb3JtQXNzb2NpYXRlZFByb3BzLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgZGF0YTogVVJMLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgdXNlTWFwOiBTdHJpbmcsXG4gICAgdHlwZU11c3RNYXRjaDogQm9vbGVhbixcbiAgICB3aWR0aDogU3RyaW5nLFxuICAgIGhlaWdodDogU3RyaW5nLFxuICAgIC8vIE9ic29sZXRlXG4gICAgYWxpZ246IFN0cmluZyxcbiAgICBhcmNoaXZlOiBTdHJpbmcsXG4gICAgY29kZTogU3RyaW5nLFxuICAgIGRlY2xhcmU6IEJvb2xlYW4sXG4gICAgaHNwYWNlOiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAwIH0sXG4gICAgc3RhbmRieTogU3RyaW5nLFxuICAgIHZzcGFjZTogeyB0eXBlOiBcInVuc2lnbmVkIGxvbmdcIiwgZGVmYXVsdDogMCB9LFxuICAgIGNvZGVCYXNlOiBVUkwsXG4gICAgY29kZVR5cGU6IFN0cmluZyxcbiAgICBib3JkZXI6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdvcHRncm91cCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxPcHRHcm91cEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBsYWJlbDogU3RyaW5nXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdvcHRpb24nLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MT3B0aW9uRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBmb3JtOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgIHdoaWxlIChwICYmIHAubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGlmIChwLmxvY2FsTmFtZSA9PT0gJ3NlbGVjdCcpIHJldHVybiBwLmZvcm07XG4gICAgICAgIHAgPSBwLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfX1cbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGRlZmF1bHRTZWxlY3RlZDoge25hbWU6ICdzZWxlY3RlZCcsIHR5cGU6IEJvb2xlYW59LFxuICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgdmFsdWU6IFN0cmluZyxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ291dHB1dCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxPdXRwdXRFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRm9ybUVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IGZvcm1Bc3NvY2lhdGVkUHJvcHMsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBYWFggUmVmbGVjdCBmb3IvaHRtbEZvciBhcyBhIHNldHRhYmxlIHRva2VuIGxpc3RcbiAgICBuYW1lOiBTdHJpbmdcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ3AnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MUGFyYWdyYXBoRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIE9ic29sZXRlXG4gICAgYWxpZ246IFN0cmluZ1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAncGFyYW0nLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MUGFyYW1FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgbmFtZTogU3RyaW5nLFxuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgLy8gT2Jzb2xldGVcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgdmFsdWVUeXBlOiBTdHJpbmcsXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWdzOiBbJ3ByZScsLypsZWdhY3kgZWxlbWVudHM6Ki8nbGlzdGluZycsJ3htcCddLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MUHJlRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIE9ic29sZXRlXG4gICAgd2lkdGg6IHsgdHlwZTogXCJsb25nXCIsIGRlZmF1bHQ6IDAgfSxcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ3Byb2dyZXNzJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFByb2dyZXNzRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEZvcm1FbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiBmb3JtQXNzb2NpYXRlZFByb3BzLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgbWF4OiB7dHlwZTogTnVtYmVyLCBmbG9hdDogdHJ1ZSwgZGVmYXVsdDogMS4wLCBtaW46IDB9XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWdzOiBbJ3EnLCAnYmxvY2txdW90ZSddLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MUXVvdGVFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgY2l0ZTogVVJMXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdzY3JpcHQnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MU2NyaXB0RWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICB0ZXh0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIG4gPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpXG4gICAgICAgICAgICBzICs9IGNoaWxkLl9kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZHJlbigpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgc3JjOiBVUkwsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGNoYXJzZXQ6IFN0cmluZyxcbiAgICBkZWZlcjogQm9vbGVhbixcbiAgICBhc3luYzogQm9vbGVhbixcbiAgICBjcm9zc09yaWdpbjogQ09SUyxcbiAgICBub25jZTogU3RyaW5nLFxuICAgIGludGVncml0eTogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnc2VsZWN0JyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFNlbGVjdEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxGb3JtRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIGZvcm06IGZvcm1Bc3NvY2lhdGVkUHJvcHMuZm9ybSxcbiAgICBvcHRpb25zOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnb3B0aW9uJyk7XG4gICAgfX1cbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBhdXRvZm9jdXM6IEJvb2xlYW4sXG4gICAgbXVsdGlwbGU6IEJvb2xlYW4sXG4gICAgcmVxdWlyZWQ6IEJvb2xlYW4sXG4gICAgc2l6ZToge3R5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAwfVxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnc291cmNlJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFNvdXJjZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBzcmM6IFVSTCxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgbWVkaWE6IFN0cmluZ1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnc3BhbicsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxTcGFuRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ3N0eWxlJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFN0eWxlRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIG1lZGlhOiBTdHJpbmcsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIHNjb3BlZDogQm9vbGVhblxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnY2FwdGlvbicsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUYWJsZUNhcHRpb25FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nLFxuICB9XG59KTtcblxuXG5kZWZpbmUoe1xuICBjdG9yOiBmdW5jdGlvbiBIVE1MVGFibGVDZWxsRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIGNvbFNwYW46IHt0eXBlOiBcInVuc2lnbmVkIGxvbmdcIiwgZGVmYXVsdDogMX0sXG4gICAgcm93U3Bhbjoge3R5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAxfSxcbiAgICAvL1hYWCBBbHNvIHJlZmxlY3Qgc2V0dGFibGUgdG9rZW4gbGlzdCBoZWFkZXJzXG4gICAgc2NvcGU6IHsgdHlwZTogWydyb3cnLCdjb2wnLCdyb3dncm91cCcsJ2NvbGdyb3VwJ10sIG1pc3Npbmc6ICcnIH0sXG4gICAgYWJicjogU3RyaW5nLFxuICAgIC8vIE9ic29sZXRlXG4gICAgYWxpZ246IFN0cmluZyxcbiAgICBheGlzOiBTdHJpbmcsXG4gICAgaGVpZ2h0OiBTdHJpbmcsXG4gICAgd2lkdGg6IFN0cmluZyxcbiAgICBjaDogeyBuYW1lOiAnY2hhcicsIHR5cGU6IFN0cmluZyB9LFxuICAgIGNoT2ZmOiB7IG5hbWU6ICdjaGFyb2ZmJywgdHlwZTogU3RyaW5nIH0sXG4gICAgbm9XcmFwOiBCb29sZWFuLFxuICAgIHZBbGlnbjogU3RyaW5nLFxuICAgIGJnQ29sb3I6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWdzOiBbJ2NvbCcsICdjb2xncm91cCddLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVGFibGVDb2xFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgc3Bhbjoge3R5cGU6ICdsaW1pdGVkIHVuc2lnbmVkIGxvbmcgd2l0aCBmYWxsYmFjaycsIGRlZmF1bHQ6IDEsIG1pbjogMX0sXG4gICAgLy8gT2Jzb2xldGVcbiAgICBhbGlnbjogU3RyaW5nLFxuICAgIGNoOiB7IG5hbWU6ICdjaGFyJywgdHlwZTogU3RyaW5nIH0sXG4gICAgY2hPZmY6IHsgbmFtZTogJ2NoYXJvZmYnLCB0eXBlOiBTdHJpbmcgfSxcbiAgICB2QWxpZ246IFN0cmluZyxcbiAgICB3aWR0aDogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAndGFibGUnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVGFibGVFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIHJvd3M6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0cicpO1xuICAgIH19XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGFsaWduOiBTdHJpbmcsXG4gICAgYm9yZGVyOiBTdHJpbmcsXG4gICAgZnJhbWU6IFN0cmluZyxcbiAgICBydWxlczogU3RyaW5nLFxuICAgIHN1bW1hcnk6IFN0cmluZyxcbiAgICB3aWR0aDogU3RyaW5nLFxuICAgIGJnQ29sb3I6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXG4gICAgY2VsbFBhZGRpbmc6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXG4gICAgY2VsbFNwYWNpbmc6IHsgdHlwZTogU3RyaW5nLCB0cmVhdE51bGxBc0VtcHR5U3RyaW5nOiB0cnVlIH0sXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICd0ZW1wbGF0ZScsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUZW1wbGF0ZUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gICAgdGhpcy5fY29udGVudEZyYWdtZW50ID0gZG9jLl90ZW1wbGF0ZURvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgY29udGVudDogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fY29udGVudEZyYWdtZW50OyB9IH0sXG4gICAgc2VyaWFsaXplOiB7IHZhbHVlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29udGVudC5zZXJpYWxpemUoKTsgfSB9XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICd0cicsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUYWJsZVJvd0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgY2VsbHM6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RkLHRoJyk7XG4gICAgfX1cbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIC8vIE9ic29sZXRlXG4gICAgYWxpZ246IFN0cmluZyxcbiAgICBjaDogeyBuYW1lOiAnY2hhcicsIHR5cGU6IFN0cmluZyB9LFxuICAgIGNoT2ZmOiB7IG5hbWU6ICdjaGFyb2ZmJywgdHlwZTogU3RyaW5nIH0sXG4gICAgdkFsaWduOiBTdHJpbmcsXG4gICAgYmdDb2xvcjogeyB0eXBlOiBTdHJpbmcsIHRyZWF0TnVsbEFzRW1wdHlTdHJpbmc6IHRydWUgfSxcbiAgfSxcbn0pO1xuXG5kZWZpbmUoe1xuICB0YWdzOiBbJ3RoZWFkJywgJ3Rmb290JywgJ3Rib2R5J10sXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIHJvd3M6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0cicpO1xuICAgIH19XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICAvLyBPYnNvbGV0ZVxuICAgIGFsaWduOiBTdHJpbmcsXG4gICAgY2g6IHsgbmFtZTogJ2NoYXInLCB0eXBlOiBTdHJpbmcgfSxcbiAgICBjaE9mZjogeyBuYW1lOiAnY2hhcm9mZicsIHR5cGU6IFN0cmluZyB9LFxuICAgIHZBbGlnbjogU3RyaW5nLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAndGV4dGFyZWEnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVGV4dEFyZWFFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRm9ybUVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IGZvcm1Bc3NvY2lhdGVkUHJvcHMsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBhdXRvY29tcGxldGU6IFN0cmluZywgLy8gSXQncyBjb21wbGljYXRlZFxuICAgIG5hbWU6IFN0cmluZyxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBhdXRvZm9jdXM6IEJvb2xlYW4sXG4gICAgcGxhY2Vob2xkZXI6IFN0cmluZyxcbiAgICB3cmFwOiBTdHJpbmcsXG4gICAgZGlyTmFtZTogU3RyaW5nLFxuICAgIHJlcXVpcmVkOiBCb29sZWFuLFxuICAgIHJlYWRPbmx5OiBCb29sZWFuLFxuICAgIHJvd3M6IHt0eXBlOiAnbGltaXRlZCB1bnNpZ25lZCBsb25nIHdpdGggZmFsbGJhY2snLCBkZWZhdWx0OiAyIH0sXG4gICAgY29sczoge3R5cGU6ICdsaW1pdGVkIHVuc2lnbmVkIGxvbmcgd2l0aCBmYWxsYmFjaycsIGRlZmF1bHQ6IDIwIH0sXG4gICAgbWF4TGVuZ3RoOiB7dHlwZTogJ3Vuc2lnbmVkIGxvbmcnLCBtaW46IDAsIHNldG1pbjogMCwgZGVmYXVsdDogLTF9LFxuICAgIGlucHV0TW9kZTogeyB0eXBlOiBbIFwidmVyYmF0aW1cIiwgXCJsYXRpblwiLCBcImxhdGluLW5hbWVcIiwgXCJsYXRpbi1wcm9zZVwiLCBcImZ1bGwtd2lkdGgtbGF0aW5cIiwgXCJrYW5hXCIsIFwia2FuYS1uYW1lXCIsIFwia2F0YWthbmFcIiwgXCJudW1lcmljXCIsIFwidGVsXCIsIFwiZW1haWxcIiwgXCJ1cmxcIiBdLCBtaXNzaW5nOiAnJyB9LFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAndGltZScsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxUaW1lRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIGRhdGVUaW1lOiBTdHJpbmcsXG4gICAgcHViRGF0ZTogQm9vbGVhblxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAndGl0bGUnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVGl0bGVFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIHRleHQ6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHRDb250ZW50O1xuICAgIH19XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICd1bCcsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxVTGlzdEVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgLy8gT2Jzb2xldGVcbiAgICBjb21wYWN0OiBCb29sZWFuLFxuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgY3RvcjogZnVuY3Rpb24gSFRNTE1lZGlhRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIHNyYzogVVJMLFxuICAgIGNyb3NzT3JpZ2luOiBDT1JTLFxuICAgIHByZWxvYWQ6IHsgdHlwZTpbXCJtZXRhZGF0YVwiLCBcIm5vbmVcIiwgXCJhdXRvXCIsIHt2YWx1ZTogXCJcIiwgYWxpYXM6IFwiYXV0b1wifV0sIG1pc3Npbmc6ICdhdXRvJyB9LFxuICAgIGxvb3A6IEJvb2xlYW4sXG4gICAgYXV0b3BsYXk6IEJvb2xlYW4sXG4gICAgbWVkaWFHcm91cDogU3RyaW5nLFxuICAgIGNvbnRyb2xzOiBCb29sZWFuLFxuICAgIGRlZmF1bHRNdXRlZDoge25hbWU6IFwibXV0ZWRcIiwgdHlwZTogQm9vbGVhbn1cbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ2F1ZGlvJyxcbiAgc3VwZXJjbGFzczogaHRtbEVsZW1lbnRzLkhUTUxNZWRpYUVsZW1lbnQsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxBdWRpb0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIGh0bWxFbGVtZW50cy5IVE1MTWVkaWFFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICd2aWRlbycsXG4gIHN1cGVyY2xhc3M6IGh0bWxFbGVtZW50cy5IVE1MTWVkaWFFbGVtZW50LFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVmlkZW9FbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBodG1sRWxlbWVudHMuSFRNTE1lZGlhRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgcG9zdGVyOiBVUkwsXG4gICAgd2lkdGg6IHt0eXBlOiBcInVuc2lnbmVkIGxvbmdcIiwgbWluOiAwLCBkZWZhdWx0OiAwIH0sXG4gICAgaGVpZ2h0OiB7dHlwZTogXCJ1bnNpZ25lZCBsb25nXCIsIG1pbjogMCwgZGVmYXVsdDogMCB9XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICd0ZCcsXG4gIHN1cGVyY2xhc3M6IGh0bWxFbGVtZW50cy5IVE1MVGFibGVDZWxsRWxlbWVudCxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBodG1sRWxlbWVudHMuSFRNTFRhYmxlQ2VsbEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ3RoJyxcbiAgc3VwZXJjbGFzczogaHRtbEVsZW1lbnRzLkhUTUxUYWJsZUNlbGxFbGVtZW50LFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgaHRtbEVsZW1lbnRzLkhUTUxUYWJsZUNlbGxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnZnJhbWVzZXQnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRnJhbWVTZXRFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnZnJhbWUnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRnJhbWVFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBIVE1MRWxlbWVudC5jYWxsKHRoaXMsIGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpO1xuICB9XG59KTtcblxuZGVmaW5lKHtcbiAgdGFnOiAnY2FudmFzJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTENhbnZhc0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgZ2V0Q29udGV4dDogeyB2YWx1ZTogdXRpbHMubnlpIH0sXG4gICAgcHJvYmFibHlTdXBwb3J0c0NvbnRleHQ6IHsgdmFsdWU6IHV0aWxzLm55aSB9LFxuICAgIHNldENvbnRleHQ6IHsgdmFsdWU6IHV0aWxzLm55aSB9LFxuICAgIHRyYW5zZmVyQ29udHJvbFRvUHJveHk6IHsgdmFsdWU6IHV0aWxzLm55aSB9LFxuICAgIHRvRGF0YVVSTDogeyB2YWx1ZTogdXRpbHMubnlpIH0sXG4gICAgdG9CbG9iOiB7IHZhbHVlOiB1dGlscy5ueWkgfVxuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgd2lkdGg6IHsgdHlwZTogXCJ1bnNpZ25lZCBsb25nXCIsIGRlZmF1bHQ6IDMwMH0sXG4gICAgaGVpZ2h0OiB7IHR5cGU6IFwidW5zaWduZWQgbG9uZ1wiLCBkZWZhdWx0OiAxNTB9XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdkaWFsb2cnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MRGlhbG9nRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBzaG93OiB7IHZhbHVlOiB1dGlscy5ueWkgfSxcbiAgICBzaG93TW9kYWw6IHsgdmFsdWU6IHV0aWxzLm55aSB9LFxuICAgIGNsb3NlOiB7IHZhbHVlOiB1dGlscy5ueWkgfVxuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgb3BlbjogQm9vbGVhbixcbiAgICByZXR1cm5WYWx1ZTogU3RyaW5nXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdtZW51aXRlbScsXG4gIGN0b3I6IGZ1bmN0aW9uIEhUTUxNZW51SXRlbUVsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIEhUTUxFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgLy8gVGhlIG1lbnVpdGVtJ3MgbGFiZWxcbiAgICBfbGFiZWw6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLl9nZXRhdHRyKCdsYWJlbCcpO1xuICAgICAgICBpZiAodmFsICE9PSBudWxsICYmIHZhbCAhPT0gJycpIHsgcmV0dXJuIHZhbDsgfVxuICAgICAgICB2YWwgPSB0aGlzLnRleHRDb250ZW50O1xuICAgICAgICAvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuICAgICAgICByZXR1cm4gdmFsLnJlcGxhY2UoL1sgXFx0XFxuXFxmXFxyXSsvZywgJyAnKS50cmltKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBUaGUgbWVudWl0ZW0gbGFiZWwgSURMIGF0dHJpYnV0ZVxuICAgIGxhYmVsOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5fZ2V0YXR0cignbGFiZWwnKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkgeyByZXR1cm4gdmFsOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sYWJlbDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdGhpcy5fc2V0YXR0cignbGFiZWwnLCB2KTtcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgdHlwZTogeyB0eXBlOiBbXCJjb21tYW5kXCIsXCJjaGVja2JveFwiLFwicmFkaW9cIl0sIG1pc3Npbmc6ICdjb21tYW5kJyB9LFxuICAgIGljb246IFVSTCxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBjaGVja2VkOiBCb29sZWFuLFxuICAgIHJhZGlvZ3JvdXA6IFN0cmluZyxcbiAgICBkZWZhdWx0OiBCb29sZWFuXG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWc6ICdzb3VyY2UnLFxuICBjdG9yOiBmdW5jdGlvbiBIVE1MU291cmNlRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIHNyY3NldDogU3RyaW5nLFxuICAgIHNpemVzOiBTdHJpbmcsXG4gICAgbWVkaWE6IFN0cmluZyxcbiAgICBzcmM6IFVSTCxcbiAgICB0eXBlOiBTdHJpbmdcbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZzogJ3RyYWNrJyxcbiAgY3RvcjogZnVuY3Rpb24gSFRNTFRyYWNrRWxlbWVudChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gICAgSFRNTEVsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgYXR0cmlidXRlczoge1xuICAgIHNyYzogVVJMLFxuICAgIHNyY2xhbmc6IFN0cmluZyxcbiAgICBsYWJlbDogU3RyaW5nLFxuICAgIGRlZmF1bHQ6IEJvb2xlYW4sXG4gICAga2luZDogeyB0eXBlOiBbXCJzdWJ0aXRsZXNcIiwgXCJjYXB0aW9uc1wiLCBcImRlc2NyaXB0aW9uc1wiLCBcImNoYXB0ZXJzXCIsIFwibWV0YWRhdGFcIl0sIG1pc3Npbmc6ICdzdWJ0aXRsZXMnLCBpbnZhbGlkOiAnbWV0YWRhdGEnIH0sXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgTk9ORTogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfSB9LFxuICAgIExPQURJTkc6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH0gfSxcbiAgICBMT0FERUQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIDI7IH0gfSxcbiAgICBFUlJPUjogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gMzsgfSB9LFxuICAgIHJlYWR5U3RhdGU6IHsgZ2V0OiB1dGlscy5ueWkgfSxcbiAgICB0cmFjazogeyBnZXQ6IHV0aWxzLm55aSB9XG4gIH1cbn0pO1xuXG5kZWZpbmUoe1xuICB0YWdzOiBbXG4gICAgXCJhYmJyXCIsIFwiYWRkcmVzc1wiLCBcImFydGljbGVcIiwgXCJhc2lkZVwiLCBcImJcIiwgXCJiZGlcIiwgXCJiZG9cIixcbiAgICBcImNpdGVcIiwgXCJjb2RlXCIsIFwiZGRcIiwgXCJkZm5cIiwgXCJkdFwiLCBcImVtXCIsIFwiZmlnY2FwdGlvblwiLCBcImZpZ3VyZVwiLFxuICAgIFwiZm9vdGVyXCIsIFwiaGVhZGVyXCIsIFwiaGdyb3VwXCIsIFwiaVwiLCBcImtiZFwiLCBcIm1haW5cIiwgXCJtYXJrXCIsIFwibmF2XCIsIFwibm9zY3JpcHRcIixcbiAgICBcInJiXCIsIFwicnBcIiwgXCJydFwiLCBcInJ0Y1wiLCBcInJ1YnlcIiwgXCJzXCIsIFwic2FtcFwiLCBcInNlY3Rpb25cIiwgXCJzbWFsbFwiLCBcInN0cm9uZ1wiLFxuICAgIFwic3ViXCIsIFwic3VtbWFyeVwiLCBcInN1cFwiLCBcInVcIiwgXCJ2YXJcIiwgXCJ3YnJcIixcbiAgICAvLyBMZWdhY3kgZWxlbWVudHNcbiAgICBcImFjcm9ueW1cIiwgXCJiYXNlZm9udFwiLCBcImJpZ1wiLCBcImNlbnRlclwiLCBcIm5vYnJcIiwgXCJub2VtYmVkXCIsIFwibm9mcmFtZXNcIixcbiAgICBcInBsYWludGV4dFwiLCBcInN0cmlrZVwiLCBcInR0XCJcbiAgXVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2h0bWxlbHRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBwYXJzZXJsaWIgPSByZXF1aXJlKCcuL2Nzc3BhcnNlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1N0eWxlRGVjbGFyYXRpb247XG5cbmZ1bmN0aW9uIENTU1N0eWxlRGVjbGFyYXRpb24oZWx0KSB7XG4gIHRoaXMuX2VsZW1lbnQgPSBlbHQ7XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHBhcnNpbmcgc3R5bGUgZGVjbGFyYXRpb25zXG4vLyBQYXNzIGluIGEgc3RyaW5nIGxpa2UgXCJtYXJnaW4tbGVmdDogNXB4OyBib3JkZXItc3R5bGU6IHNvbGlkXCJcbi8vIGFuZCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gb2JqZWN0IGxpa2Vcbi8vIHtcIm1hcmdpbi1sZWZ0XCI6XCI1cHhcIiwgXCJib3JkZXItc3R5bGVcIjpcInNvbGlkXCJ9XG5mdW5jdGlvbiBwYXJzZVN0eWxlcyhzKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgcGFyc2VybGliLmNzcy5QYXJzZXIoKTtcbiAgdmFyIHJlc3VsdCA9IHsgcHJvcGVydHk6IE9iamVjdC5jcmVhdGUobnVsbCksIHByaW9yaXR5OiBPYmplY3QuY3JlYXRlKG51bGwpIH07XG4gIHBhcnNlci5hZGRMaXN0ZW5lcihcInByb3BlcnR5XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS5pbnZhbGlkKSByZXR1cm47IC8vIFNraXAgZXJyb3JzXG4gICAgcmVzdWx0LnByb3BlcnR5W2UucHJvcGVydHkudGV4dF0gPSBlLnZhbHVlLnRleHQ7XG4gICAgaWYgKGUuaW1wb3J0YW50KSByZXN1bHQucHJpb3JpdHlbZS5wcm9wZXJ0eS50ZXh0XSA9ICdpbXBvcnRhbnQnO1xuICB9KTtcbiAgcyA9ICgnJytzKS5yZXBsYWNlKC9eOy8sICcnKTtcbiAgcGFyc2VyLnBhcnNlU3R5bGVBdHRyaWJ1dGUocyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBOT19DSEFOR0UgPSB7fTsgLy8gUHJpdmF0ZSBtYXJrZXIgb2JqZWN0XG5cbkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlLCB7XG5cbiAgLy8gUmV0dXJuIHRoZSBwYXJzZWQgZm9ybSBvZiB0aGUgZWxlbWVudCdzIHN0eWxlIGF0dHJpYnV0ZS5cbiAgLy8gSWYgdGhlIGVsZW1lbnQncyBzdHlsZSBhdHRyaWJ1dGUgaGFzIG5ldmVyIGJlZW4gcGFyc2VkXG4gIC8vIG9yIGlmIGl0IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHBhcnNlLCB0aGVuIHJlcGFyc2UgaXRcbiAgLy8gTm90ZSB0aGF0IHRoZSBzdHlsZXMgZG9uJ3QgZ2V0IHBhcnNlZCB1bnRpbCB0aGV5J3JlIGFjdHVhbGx5IG5lZWRlZFxuICBfcGFyc2VkOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9wYXJzZWRTdHlsZXMgfHwgdGhpcy5jc3NUZXh0ICE9PSB0aGlzLl9sYXN0UGFyc2VkVGV4dCkge1xuICAgICAgdmFyIHRleHQgPSB0aGlzLmNzc1RleHQ7XG4gICAgICB0aGlzLl9wYXJzZWRTdHlsZXMgPSBwYXJzZVN0eWxlcyh0ZXh0KTtcbiAgICAgIHRoaXMuX2xhc3RQYXJzZWRUZXh0ID0gdGV4dDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9uYW1lcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZFN0eWxlcztcbiAgfX0sXG5cbiAgLy8gQ2FsbCB0aGlzIG1ldGhvZCBhbnkgdGltZSB0aGUgcGFyc2VkIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAvLyBzdHlsZSBjaGFuZ2VzLiAgSXQgY29udmVydHMgdGhlIHN0eWxlIHByb3BlcnRpZXMgdG8gYSBzdHJpbmcgYW5kXG4gIC8vIHNldHMgY3NzVGV4dCBhbmQgdGhlIGVsZW1lbnQncyBzdHlsZSBhdHRyaWJ1dGVcbiAgX3NlcmlhbGl6ZTogeyB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0eWxlcyA9IHRoaXMuX3BhcnNlZDtcbiAgICB2YXIgcyA9IFwiXCI7XG5cbiAgICBmb3IodmFyIG5hbWUgaW4gc3R5bGVzLnByb3BlcnR5KSB7XG4gICAgICBpZiAocykgcyArPSBcIiBcIjtcbiAgICAgIHMgKz0gbmFtZSArIFwiOiBcIiArIHN0eWxlcy5wcm9wZXJ0eVtuYW1lXTtcbiAgICAgIGlmIChzdHlsZXMucHJpb3JpdHlbbmFtZV0pIHtcbiAgICAgICAgcyArPSBcIiAhXCIgKyBzdHlsZXMucHJpb3JpdHlbbmFtZV07XG4gICAgICB9XG4gICAgICBzICs9IFwiO1wiO1xuICAgIH1cblxuICAgIHRoaXMuY3NzVGV4dCA9IHM7ICAgICAgLy8gYWxzbyBzZXRzIHRoZSBzdHlsZSBhdHRyaWJ1dGVcbiAgICB0aGlzLl9sYXN0UGFyc2VkVGV4dCA9IHM7ICAvLyBzbyB3ZSBkb24ndCByZXBhcnNlXG4gICAgZGVsZXRlIHRoaXMuX25hbWVzO1xuICB9fSxcblxuICBjc3NUZXh0OiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFhYWDogdGhpcyBpcyBhIENTU1N0eWxlRGVjbGFyYXRpb24gZm9yIGFuIGVsZW1lbnQuXG4gICAgICAvLyBBIGRpZmZlcmVudCBpbXBsIG1pZ2h0IGJlIG5lY2Vzc2FyeSBmb3IgYSBzZXQgb2Ygc3R5bGVzXG4gICAgICAvLyBhc3NvY2lhdGVkIHJldHVybmVkIGJ5IGdldENvbXB1dGVkU3R5bGUoKSwgZS5nLlxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAvLyBYWFg6IEkgc2hvdWxkIHBhcnNlIGFuZCBzZXJpYWxpemUgdGhlIHZhbHVlIHRvXG4gICAgICAvLyBub3JtYWxpemUgaXQgYW5kIHJlbW92ZSBlcnJvcnMuIEZGIGFuZCBjaHJvbWUgZG8gdGhhdC5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBsZW5ndGg6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX25hbWVzKVxuICAgICAgdGhpcy5fbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9wYXJzZWQucHJvcGVydHkpO1xuICAgIHJldHVybiB0aGlzLl9uYW1lcy5sZW5ndGg7XG4gIH19LFxuXG4gIGl0ZW06IHsgdmFsdWU6IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAoIXRoaXMuX25hbWVzKVxuICAgICAgdGhpcy5fbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9wYXJzZWQucHJvcGVydHkpO1xuICAgIHJldHVybiB0aGlzLl9uYW1lc1tuXTtcbiAgfX0sXG5cbiAgZ2V0UHJvcGVydHlWYWx1ZTogeyB2YWx1ZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5wcm9wZXJ0eVtwcm9wZXJ0eV0gfHwgXCJcIjtcbiAgfX0sXG5cbiAgZ2V0UHJvcGVydHlQcmlvcml0eTogeyB2YWx1ZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZC5wcmlvcml0eVtwcm9wZXJ0eV0gfHwgXCJcIjtcbiAgfX0sXG5cbiAgc2V0UHJvcGVydHk6IHsgdmFsdWU6IGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKHByaW9yaXR5ID09PSBudWxsIHx8IHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByaW9yaXR5ID0gXCJcIjtcbiAgICB9XG5cbiAgICAvLyBTdHJpbmcgY29lcmNpb25cbiAgICBpZiAodmFsdWUgIT09IE5PX0NIQU5HRSkge1xuICAgICAgdmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICB0aGlzLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJpb3JpdHkgIT09IFwiXCIgJiYgcHJpb3JpdHkgIT09IE5PX0NIQU5HRSAmJlxuICAgICAgICAhL15pbXBvcnRhbnQkL2kudGVzdChwcmlvcml0eSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVzID0gdGhpcy5fcGFyc2VkO1xuICAgIGlmICh2YWx1ZSA9PT0gTk9fQ0hBTkdFKSB7XG4gICAgICBpZiAoIXN0eWxlcy5wcm9wZXJ0eVtwcm9wZXJ0eV0pIHtcbiAgICAgICAgcmV0dXJuOyAvLyBOb3QgYSB2YWxpZCBwcm9wZXJ0eSBuYW1lLlxuICAgICAgfVxuICAgICAgaWYgKHByaW9yaXR5ICE9PSBcIlwiKSB7XG4gICAgICAgIHN0eWxlcy5wcmlvcml0eVtwcm9wZXJ0eV0gPSBcImltcG9ydGFudFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHN0eWxlcy5wcmlvcml0eVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIGRvbid0IGp1c3QgYWNjZXB0IHRoZSBwcm9wZXJ0eSB2YWx1ZS4gIEluc3RlYWRcbiAgICAgIC8vIHdlIHBhcnNlIGl0IHRvIGVuc3VyZSB0aGF0IGl0IGlzIHNvbWV0aGluZyB2YWxpZC5cbiAgICAgIC8vIElmIGl0IGNvbnRhaW5zIGEgc2VtaWNvbG9uIGl0IGlzIGludmFsaWRcbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKFwiO1wiKSAhPT0gLTEpIHJldHVybjtcblxuICAgICAgdmFyIG5ld3Byb3BzID0gcGFyc2VTdHlsZXMocHJvcGVydHkgKyBcIjpcIiArIHZhbHVlKTtcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuZXdwcm9wcy5wcm9wZXJ0eSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjsgLy8gbm8gdmFsaWQgcHJvcGVydHkgZm91bmRcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuZXdwcm9wcy5wcmlvcml0eSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybjsgLy8gaWYgdGhlIHZhbHVlIGluY2x1ZGVkICchaW1wb3J0YW50JyBpdCB3YXNuJ3QgdmFsaWQuXG4gICAgICB9XG5cbiAgICAgIC8vIFhYWCBoYW5kbGUgc2hvcnRoYW5kIHByb3BlcnRpZXNcblxuICAgICAgZm9yICh2YXIgcCBpbiBuZXdwcm9wcy5wcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZXMucHJvcGVydHlbcF0gPSBuZXdwcm9wcy5wcm9wZXJ0eVtwXTtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSBOT19DSEFOR0UpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmlvcml0eSAhPT0gXCJcIikge1xuICAgICAgICAgIHN0eWxlcy5wcmlvcml0eVtwXSA9IFwiaW1wb3J0YW50XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGVzLnByaW9yaXR5W3BdKSB7XG4gICAgICAgICAgZGVsZXRlIHN0eWxlcy5wcmlvcml0eVtwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNlcmlhbGl6ZSBhbmQgdXBkYXRlIGNzc1RleHQgYW5kIGVsZW1lbnQuc3R5bGUhXG4gICAgdGhpcy5fc2VyaWFsaXplKCk7XG4gIH19LFxuXG4gIHNldFByb3BlcnR5VmFsdWU6IHsgdmFsdWU6IGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgTk9fQ0hBTkdFKTtcbiAgfX0sXG5cbiAgc2V0UHJvcGVydHlQcmlvcml0eTogeyB2YWx1ZTogZnVuY3Rpb24ocHJvcGVydHksIHByaW9yaXR5KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0UHJvcGVydHkocHJvcGVydHksIE5PX0NIQU5HRSwgcHJpb3JpdHkpO1xuICB9fSxcblxuICByZW1vdmVQcm9wZXJ0eTogeyB2YWx1ZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHN0eWxlcyA9IHRoaXMuX3BhcnNlZDtcbiAgICBpZiAocHJvcGVydHkgaW4gc3R5bGVzLnByb3BlcnR5KSB7XG4gICAgICBkZWxldGUgc3R5bGVzLnByb3BlcnR5W3Byb3BlcnR5XTtcbiAgICAgIGRlbGV0ZSBzdHlsZXMucHJpb3JpdHlbcHJvcGVydHldO1xuXG4gICAgICAvLyBTZXJpYWxpemUgYW5kIHVwZGF0ZSBjc3NUZXh0IGFuZCBlbGVtZW50LnN0eWxlIVxuICAgICAgdGhpcy5fc2VyaWFsaXplKCk7XG4gICAgfVxuICB9fSxcbn0pO1xuXG52YXIgY3NzUHJvcGVydGllcyA9IHtcbiAgYmFja2dyb3VuZDogXCJiYWNrZ3JvdW5kXCIsXG4gIGJhY2tncm91bmRBdHRhY2htZW50OiBcImJhY2tncm91bmQtYXR0YWNobWVudFwiLFxuICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmFja2dyb3VuZC1jb2xvclwiLFxuICBiYWNrZ3JvdW5kSW1hZ2U6IFwiYmFja2dyb3VuZC1pbWFnZVwiLFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IFwiYmFja2dyb3VuZC1wb3NpdGlvblwiLFxuICBiYWNrZ3JvdW5kUmVwZWF0OiBcImJhY2tncm91bmQtcmVwZWF0XCIsXG4gIGJvcmRlcjogXCJib3JkZXJcIixcbiAgYm9yZGVyQ29sbGFwc2U6IFwiYm9yZGVyLWNvbGxhcHNlXCIsXG4gIGJvcmRlckNvbG9yOiBcImJvcmRlci1jb2xvclwiLFxuICBib3JkZXJTcGFjaW5nOiBcImJvcmRlci1zcGFjaW5nXCIsXG4gIGJvcmRlclN0eWxlOiBcImJvcmRlci1zdHlsZVwiLFxuICBib3JkZXJUb3A6IFwiYm9yZGVyLXRvcFwiLFxuICBib3JkZXJSaWdodDogXCJib3JkZXItcmlnaHRcIixcbiAgYm9yZGVyQm90dG9tOiBcImJvcmRlci1ib3R0b21cIixcbiAgYm9yZGVyTGVmdDogXCJib3JkZXItbGVmdFwiLFxuICBib3JkZXJUb3BDb2xvcjogXCJib3JkZXItdG9wLWNvbG9yXCIsXG4gIGJvcmRlclJpZ2h0Q29sb3I6IFwiYm9yZGVyLXJpZ2h0LWNvbG9yXCIsXG4gIGJvcmRlckJvdHRvbUNvbG9yOiBcImJvcmRlci1ib3R0b20tY29sb3JcIixcbiAgYm9yZGVyTGVmdENvbG9yOiBcImJvcmRlci1sZWZ0LWNvbG9yXCIsXG4gIGJvcmRlclRvcFN0eWxlOiBcImJvcmRlci10b3Atc3R5bGVcIixcbiAgYm9yZGVyUmlnaHRTdHlsZTogXCJib3JkZXItcmlnaHQtc3R5bGVcIixcbiAgYm9yZGVyQm90dG9tU3R5bGU6IFwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiLFxuICBib3JkZXJMZWZ0U3R5bGU6IFwiYm9yZGVyLWxlZnQtc3R5bGVcIixcbiAgYm9yZGVyVG9wV2lkdGg6IFwiYm9yZGVyLXRvcC13aWR0aFwiLFxuICBib3JkZXJSaWdodFdpZHRoOiBcImJvcmRlci1yaWdodC13aWR0aFwiLFxuICBib3JkZXJCb3R0b21XaWR0aDogXCJib3JkZXItYm90dG9tLXdpZHRoXCIsXG4gIGJvcmRlckxlZnRXaWR0aDogXCJib3JkZXItbGVmdC13aWR0aFwiLFxuICBib3JkZXJXaWR0aDogXCJib3JkZXItd2lkdGhcIixcbiAgYm90dG9tOiBcImJvdHRvbVwiLFxuICBjYXB0aW9uU2lkZTogXCJjYXB0aW9uLXNpZGVcIixcbiAgY2xlYXI6IFwiY2xlYXJcIixcbiAgY2xpcDogXCJjbGlwXCIsXG4gIGNvbG9yOiBcImNvbG9yXCIsXG4gIGNvbnRlbnQ6IFwiY29udGVudFwiLFxuICBjb3VudGVySW5jcmVtZW50OiBcImNvdW50ZXItaW5jcmVtZW50XCIsXG4gIGNvdW50ZXJSZXNldDogXCJjb3VudGVyLXJlc2V0XCIsXG4gIGN1cnNvcjogXCJjdXJzb3JcIixcbiAgZGlyZWN0aW9uOiBcImRpcmVjdGlvblwiLFxuICBkaXNwbGF5OiBcImRpc3BsYXlcIixcbiAgZW1wdHlDZWxsczogXCJlbXB0eS1jZWxsc1wiLFxuICBjc3NGbG9hdDogXCJmbG9hdFwiLFxuICBmb250OiBcImZvbnRcIixcbiAgZm9udEZhbWlseTogXCJmb250LWZhbWlseVwiLFxuICBmb250U2l6ZTogXCJmb250LXNpemVcIixcbiAgZm9udFNpemVBZGp1c3Q6IFwiZm9udC1zaXplLWFkanVzdFwiLFxuICBmb250U3RyZXRjaDogXCJmb250LXN0cmV0Y2hcIixcbiAgZm9udFN0eWxlOiBcImZvbnQtc3R5bGVcIixcbiAgZm9udFZhcmlhbnQ6IFwiZm9udC12YXJpYW50XCIsXG4gIGZvbnRXZWlnaHQ6IFwiZm9udC13ZWlnaHRcIixcbiAgaGVpZ2h0OiBcImhlaWdodFwiLFxuICBsZWZ0OiBcImxlZnRcIixcbiAgbGV0dGVyU3BhY2luZzogXCJsZXR0ZXItc3BhY2luZ1wiLFxuICBsaW5lSGVpZ2h0OiBcImxpbmUtaGVpZ2h0XCIsXG4gIGxpc3RTdHlsZTogXCJsaXN0LXN0eWxlXCIsXG4gIGxpc3RTdHlsZUltYWdlOiBcImxpc3Qtc3R5bGUtaW1hZ2VcIixcbiAgbGlzdFN0eWxlUG9zaXRpb246IFwibGlzdC1zdHlsZS1wb3NpdGlvblwiLFxuICBsaXN0U3R5bGVUeXBlOiBcImxpc3Qtc3R5bGUtdHlwZVwiLFxuICBtYXJnaW46IFwibWFyZ2luXCIsXG4gIG1hcmdpblRvcDogXCJtYXJnaW4tdG9wXCIsXG4gIG1hcmdpblJpZ2h0OiBcIm1hcmdpbi1yaWdodFwiLFxuICBtYXJnaW5Cb3R0b206IFwibWFyZ2luLWJvdHRvbVwiLFxuICBtYXJnaW5MZWZ0OiBcIm1hcmdpbi1sZWZ0XCIsXG4gIG1hcmtlck9mZnNldDogXCJtYXJrZXItb2Zmc2V0XCIsXG4gIG1hcmtzOiBcIm1hcmtzXCIsXG4gIG1heEhlaWdodDogXCJtYXgtaGVpZ2h0XCIsXG4gIG1heFdpZHRoOiBcIm1heC13aWR0aFwiLFxuICBtaW5IZWlnaHQ6IFwibWluLWhlaWdodFwiLFxuICBtaW5XaWR0aDogXCJtaW4td2lkdGhcIixcbiAgb3BhY2l0eTogXCJvcGFjaXR5XCIsXG4gIG9ycGhhbnM6IFwib3JwaGFuc1wiLFxuICBvdXRsaW5lOiBcIm91dGxpbmVcIixcbiAgb3V0bGluZUNvbG9yOiBcIm91dGxpbmUtY29sb3JcIixcbiAgb3V0bGluZVN0eWxlOiBcIm91dGxpbmUtc3R5bGVcIixcbiAgb3V0bGluZVdpZHRoOiBcIm91dGxpbmUtd2lkdGhcIixcbiAgb3ZlcmZsb3c6IFwib3ZlcmZsb3dcIixcbiAgcGFkZGluZzogXCJwYWRkaW5nXCIsXG4gIHBhZGRpbmdUb3A6IFwicGFkZGluZy10b3BcIixcbiAgcGFkZGluZ1JpZ2h0OiBcInBhZGRpbmctcmlnaHRcIixcbiAgcGFkZGluZ0JvdHRvbTogXCJwYWRkaW5nLWJvdHRvbVwiLFxuICBwYWRkaW5nTGVmdDogXCJwYWRkaW5nLWxlZnRcIixcbiAgcGFnZTogXCJwYWdlXCIsXG4gIHBhZ2VCcmVha0FmdGVyOiBcInBhZ2UtYnJlYWstYWZ0ZXJcIixcbiAgcGFnZUJyZWFrQmVmb3JlOiBcInBhZ2UtYnJlYWstYmVmb3JlXCIsXG4gIHBhZ2VCcmVha0luc2lkZTogXCJwYWdlLWJyZWFrLWluc2lkZVwiLFxuICBwb3NpdGlvbjogXCJwb3NpdGlvblwiLFxuICBxdW90ZXM6IFwicXVvdGVzXCIsXG4gIHJpZ2h0OiBcInJpZ2h0XCIsXG4gIHNpemU6IFwic2l6ZVwiLFxuICB0YWJsZUxheW91dDogXCJ0YWJsZS1sYXlvdXRcIixcbiAgdGV4dEFsaWduOiBcInRleHQtYWxpZ25cIixcbiAgdGV4dERlY29yYXRpb246IFwidGV4dC1kZWNvcmF0aW9uXCIsXG4gIHRleHRJbmRlbnQ6IFwidGV4dC1pbmRlbnRcIixcbiAgdGV4dFNoYWRvdzogXCJ0ZXh0LXNoYWRvd1wiLFxuICB0ZXh0VHJhbnNmb3JtOiBcInRleHQtdHJhbnNmb3JtXCIsXG4gIHRvcDogXCJ0b3BcIixcbiAgdW5pY29kZUJpZGk6IFwidW5pY29kZS1iaWRpXCIsXG4gIHZlcnRpY2FsQWxpZ246IFwidmVydGljYWwtYWxpZ25cIixcbiAgdmlzaWJpbGl0eTogXCJ2aXNpYmlsaXR5XCIsXG4gIHdoaXRlU3BhY2U6IFwid2hpdGUtc3BhY2VcIixcbiAgd2lkb3dzOiBcIndpZG93c1wiLFxuICB3aWR0aDogXCJ3aWR0aFwiLFxuICB3b3JkU3BhY2luZzogXCJ3b3JkLXNwYWNpbmdcIixcbiAgekluZGV4OiBcInotaW5kZXhcIixcbn07XG5cbmZvcih2YXIgcHJvcCBpbiBjc3NQcm9wZXJ0aWVzKSBkZWZpbmVTdHlsZVByb3BlcnR5KHByb3ApO1xuXG5mdW5jdGlvbiBkZWZpbmVTdHlsZVByb3BlcnR5KGpzbmFtZSkge1xuICB2YXIgY3NzbmFtZSA9IGNzc1Byb3BlcnRpZXNbanNuYW1lXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLCBqc25hbWUsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvcGVydHlWYWx1ZShjc3NuYW1lKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0UHJvcGVydHkoY3NzbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0NTU1N0eWxlRGVjbGFyYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIERPTUltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9ET01JbXBsZW1lbnRhdGlvbicpO1xudmFyIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9FdmVudFRhcmdldCcpO1xudmFyIExvY2F0aW9uID0gcmVxdWlyZSgnLi9Mb2NhdGlvbicpO1xudmFyIHNsb3BweSA9IHJlcXVpcmUoJy4vc2xvcHB5Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2luZG93O1xuXG5mdW5jdGlvbiBXaW5kb3coZG9jdW1lbnQpIHtcbiAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50IHx8IG5ldyBET01JbXBsZW1lbnRhdGlvbigpLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKTtcbiAgdGhpcy5kb2N1bWVudC5fc2NyaXB0aW5nX2VuYWJsZWQgPSB0cnVlO1xuICB0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3ID0gdGhpcztcbiAgdGhpcy5sb2NhdGlvbiA9IG5ldyBMb2NhdGlvbih0aGlzLCB0aGlzLmRvY3VtZW50Ll9hZGRyZXNzIHx8ICdhYm91dDpibGFuaycpO1xufVxuXG5XaW5kb3cucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudFRhcmdldC5wcm90b3R5cGUsIHtcbiAgX3J1bjogeyB2YWx1ZTogc2xvcHB5LldpbmRvd19ydW4gfSxcbiAgY29uc29sZTogeyB2YWx1ZTogY29uc29sZSB9LFxuICBoaXN0b3J5OiB7IHZhbHVlOiB7XG4gICAgYmFjazogdXRpbHMubnlpLFxuICAgIGZvcndhcmQ6IHV0aWxzLm55aSxcbiAgICBnbzogdXRpbHMubnlpXG4gIH19LFxuICBuYXZpZ2F0b3I6IHsgdmFsdWU6IHJlcXVpcmUoXCIuL05hdmlnYXRvcklEXCIpIH0sXG5cbiAgLy8gU2VsZi1yZWZlcmVudGlhbCBwcm9wZXJ0aWVzXG4gIHdpbmRvdzogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfX0sXG4gIHNlbGY6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH19LFxuICBmcmFtZXM6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH19LFxuXG4gIC8vIFNlbGYtcmVmZXJlbnRpYWwgcHJvcGVydGllcyBmb3IgYSB0b3AtbGV2ZWwgd2luZG93XG4gIHBhcmVudDogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfX0sXG4gIHRvcDogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfX0sXG5cbiAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBhbnkgb3RoZXIgd2luZG93cyBmb3Igbm93XG4gIGxlbmd0aDogeyB2YWx1ZTogMCB9LCAgICAgICAgICAgLy8gbm8gZnJhbWVzXG4gIGZyYW1lRWxlbWVudDogeyB2YWx1ZTogbnVsbCB9LCAgLy8gbm90IHBhcnQgb2YgYSBmcmFtZVxuICBvcGVuZXI6IHsgdmFsdWU6IG51bGwgfSwgICAgICAgIC8vIG5vdCBvcGVuZWQgYnkgYW5vdGhlciB3aW5kb3dcblxuICAvLyBUaGUgb25sb2FkIGV2ZW50IGhhbmRsZXIuXG4gIC8vIFhYWDogbmVlZCB0byBzdXBwb3J0IGEgYnVuY2ggb2Ygb3RoZXIgZXZlbnQgdHlwZXMsIHRvbyxcbiAgLy8gYW5kIGhhdmUgdGhlbSBpbnRlcm9wZXJhdGUgd2l0aCBkb2N1bWVudC5ib2R5LlxuXG4gIG9ubG9hZDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RXZlbnRIYW5kbGVyKFwibG9hZFwiKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5fc2V0RXZlbnRIYW5kbGVyKFwibG9hZFwiLCB2KTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gWFhYIFRoaXMgaXMgYSBjb21wbGV0ZWx5IGJyb2tlbiBpbXBsZW1lbnRhdGlvblxuICBnZXRDb21wdXRlZFN0eWxlOiB7IHZhbHVlOiBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsdCkge1xuICAgIHJldHVybiBlbHQuc3R5bGU7XG4gIH19XG5cbn0pO1xuXG51dGlscy5leHBvc2UocmVxdWlyZSgnLi9XaW5kb3dUaW1lcnMnKSwgV2luZG93KTtcbnV0aWxzLmV4cG9zZShyZXF1aXJlKCcuL2ltcGwnKSwgV2luZG93KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvV2luZG93LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnRUeXBlO1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIExlYWYgPSByZXF1aXJlKCcuL0xlYWYnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBDaGlsZE5vZGUgPSByZXF1aXJlKCcuL0NoaWxkTm9kZScpO1xuXG5mdW5jdGlvbiBEb2N1bWVudFR5cGUobmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKSB7XG4gIC8vIFVubGlrZSBvdGhlciBub2RlcywgZG9jdHlwZSBub2RlcyBhbHdheXMgc3RhcnQgb2ZmIHVub3duZWRcbiAgLy8gdW50aWwgaW5zZXJ0ZWRcbiAgdGhpcy5ub2RlVHlwZSA9IE5vZGUuRE9DVU1FTlRfVFlQRV9OT0RFO1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBudWxsO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnB1YmxpY0lkID0gcHVibGljSWQgfHwgXCJcIjtcbiAgdGhpcy5zeXN0ZW1JZCA9IHN5c3RlbUlkIHx8IFwiXCI7XG59XG5cbkRvY3VtZW50VHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExlYWYucHJvdG90eXBlLCB7XG4gIG5vZGVOYW1lOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5hbWU7IH19LFxuICBub2RlVmFsdWU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKCkge31cbiAgfSxcblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgY2xvbmU6IHsgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHV0aWxzLkRhdGFDbG9uZUVycm9yKCk7XG4gIH19LFxuXG4gIGlzRXF1YWw6IHsgdmFsdWU6IGZ1bmN0aW9uIGlzRXF1YWwobikge1xuICAgIHJldHVybiB0aGlzLm5hbWUgPT09IG4ubmFtZSAmJlxuICAgICAgdGhpcy5wdWJsaWNJZCA9PT0gbi5wdWJsaWNJZCAmJlxuICAgICAgdGhpcy5zeXN0ZW1JZCA9PT0gbi5zeXN0ZW1JZDtcbiAgfX1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEb2N1bWVudFR5cGUucHJvdG90eXBlLCBDaGlsZE5vZGUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Eb2N1bWVudFR5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBIVE1MUGFyc2VyO1xuXG52YXIgRG9jdW1lbnQgPSByZXF1aXJlKCcuL0RvY3VtZW50Jyk7XG52YXIgRG9jdW1lbnRUeXBlID0gcmVxdWlyZSgnLi9Eb2N1bWVudFR5cGUnKTtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XG52YXIgTkFNRVNQQUNFID0gcmVxdWlyZSgnLi91dGlscycpLk5BTUVTUEFDRTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9odG1sZWx0cycpO1xudmFyIGltcGwgPSBodG1sLmVsZW1lbnRzO1xuXG52YXIgcHVzaEFsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5iaW5kKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcblxuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSFRNTCBwYXJzaW5nIGFsZ29yaXRobS5cbiAqIFRoZSBhbGdvcml0aG0gYW5kIHRoZSBpbXBsZW1lbnRhdGlvbiBhcmUgY29tcGxleCBiZWNhdXNlIEhUTUxcbiAqIGV4cGxpY2l0bHkgZGVmaW5lcyBob3cgdGhlIHBhcnNlciBzaG91bGQgYmVoYXZlIGZvciBhbGwgcG9zc2libGVcbiAqIHZhbGlkIGFuZCBpbnZhbGlkIGlucHV0cy5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiBUaGUgZmlsZSBkZWZpbmVzIGEgc2luZ2xlIEhUTUxQYXJzZXIoKSBmdW5jdGlvbiwgd2hpY2ggZG9tLmpzIGV4cG9zZXNcbiAqIHB1YmxpY2x5IGFzIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLm1vekhUTUxQYXJzZXIoKS4gVGhpcyBpcyBhXG4gKiBmYWN0b3J5IGZ1bmN0aW9uLCBub3QgYSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBXaGVuIHlvdSBjYWxsIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLm1vekhUTUxQYXJzZXIoKSwgaXQgcmV0dXJuc1xuICogYW4gb2JqZWN0IHRoYXQgaGFzIHBhcnNlKCkgYW5kIGRvY3VtZW50KCkgbWV0aG9kcy4gVG8gcGFyc2UgSFRNTCB0ZXh0LFxuICogcGFzcyB0aGUgdGV4dCAoaW4gb25lIG9yIG1vcmUgY2h1bmtzKSB0byB0aGUgcGFyc2UoKSBtZXRob2QuICBXaGVuXG4gKiB5b3UndmUgcGFzc2VkIGFsbCB0aGUgdGV4dCAob24gdGhlIGxhc3QgY2h1bmssIG9yIGFmdGVyd2FyZCkgcGFzc1xuICogdHJ1ZSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHBhcnNlKCkgdG8gdGVsbCB0aGUgcGFyc2VyIHRoYXQgdGhlcmVcbiAqIGlzIG5vIG1vcmUgY29taW5nLiBDYWxsIGRvY3VtZW50KCkgdG8gZ2V0IHRoZSBkb2N1bWVudCBvYmplY3QgdGhhdFxuICogdGhlIHBhcnNlciBpcyBwYXJzaW5nIGludG8uICBZb3UgY2FuIGNhbGwgdGhpcyBhdCBhbnkgdGltZSwgYmVmb3JlXG4gKiBvciBhZnRlciBjYWxsaW5nIHBhcnNlKCkuXG4gKlxuICogVGhlIGZpcnN0IGFyZ3VtZW50IHRvIG1vekhUTUxQYXJzZXIgaXMgdGhlIGFic29sdXRlIFVSTCBvZiB0aGUgZG9jdW1lbnQuXG4gKlxuICogVGhlIHNlY29uZCBhcmd1bWVudCBpcyBvcHRpb25hbCBhbmQgaXMgZm9yIGludGVybmFsIHVzZSBvbmx5LiAgUGFzcyBhblxuICogZWxlbWVudCBhcyB0aGUgZnJhZ21lbnRDb250ZXh0IHRvIGRvIGlubmVySFRNTCBwYXJzaW5nIGZvciB0aGVcbiAqIGVsZW1lbnQuICBUbyBkbyBpbm5lckhUTUwgcGFyc2luZyBvbiBhIGRvY3VtZW50LCBwYXNzIG51bGwuIE90aGVyd2lzZSxcbiAqIG9taXQgdGhlIDJuZCBhcmd1bWVudC4gU2VlIEhUTUxFbGVtZW50LmlubmVySFRNTCBmb3IgYW4gZXhhbXBsZS4gIE5vdGVcbiAqIHRoYXQgaWYgeW91IHBhc3MgYSBjb250ZXh0IGVsZW1lbnQsIHRoZSBlbmQoKSBtZXRob2Qgd2lsbCByZXR1cm4gYW5cbiAqIHVud3JhcHBlZCBkb2N1bWVudCBpbnN0ZWFkIG9mIGEgd3JhcHBlZCBvbmUuXG4gKlxuICogSW1wbGVtZW50YXRpb24gZGV0YWlsczpcbiAqXG4gKiBUaGlzIGlzIGEgbG9uZyBmaWxlIG9mIGFsbW9zdCA3MDAwIGxpbmVzLiBJdCBpcyBzdHJ1Y3R1cmVkIGFzIG9uZVxuICogYmlnIGZ1bmN0aW9uIG5lc3RlZCB3aXRoaW4gYW5vdGhlciBiaWcgZnVuY3Rpb24uICBUaGUgb3V0ZXJcbiAqIGZ1bmN0aW9uIGRlZmluZXMgYSBidW5jaCBvZiBjb25zdGFudCBkYXRhLCB1dGlsaXR5IGZ1bmN0aW9uc1xuICogdGhhdCB1c2UgdGhhdCBkYXRhLCBhbmQgYSBjb3VwbGUgb2YgY2xhc3NlcyB1c2VkIGJ5IHRoZSBwYXJzZXIuXG4gKiBUaGUgb3V0ZXIgZnVuY3Rpb24gYWxzbyBkZWZpbmVzIGFuZCByZXR1cm5zIHRoZVxuICogaW5uZXIgZnVuY3Rpb24uIFRoaXMgaW5uZXIgZnVuY3Rpb24gaXMgdGhlIEhUTUxQYXJzZXIgZmFjdG9yeVxuICogZnVuY3Rpb24gdGhhdCBpbXBsZW1lbnRzIHRoZSBwYXJzZXIgYW5kIGhvbGRzIGFsbCB0aGUgcGFyc2VyIHN0YXRlXG4gKiBhcyBsb2NhbCB2YXJpYWJsZXMuICBUaGUgSFRNTFBhcnNlciBmdW5jdGlvbiBpcyBxdWl0ZSBiaWcgYmVjYXVzZVxuICogaXQgZGVmaW5lcyBtYW55IG5lc3RlZCBmdW5jdGlvbnMgdGhhdCB1c2UgdGhvc2UgbG9jYWwgdmFyaWFibGVzLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSB0aWdodGx5IGNvdXBsZWQgcGFyc2VyIHN0YWdlczogYSBzY2FubmVyLCBhXG4gKiB0b2tlbml6ZXIgYW5kIGEgdHJlZSBidWlsZGVyLiBJbiBhIChwb3NzaWJseSBtaXNndWlkZWQpIGF0dGVtcHQgYXRcbiAqIGVmZmljaWVuY3ksIHRoZSBzdGFnZXMgYXJlIG5vdCBpbXBsZW1lbnRlZCBhcyBzZXBhcmF0ZSBjbGFzc2VzOlxuICogZXZlcnl0aGluZyBzaGFyZXMgc3RhdGUgYW5kIGlzIChtb3N0bHkpIGltcGxlbWVudGVkIGluIGltcGVyYXRpdmVcbiAqIChyYXRoZXIgdGhhbiBPTykgc3R5bGUuXG4gKlxuICogVGhlIHN0YWdlcyBvZiB0aGUgcGFyc2VyIHdvcmsgbGlrZSB0aGlzOiBXaGVuIHRoZSBjbGllbnQgY29kZSBjYWxsc1xuICogdGhlIHBhcnNlcidzIHBhcnNlKCkgbWV0aG9kLCB0aGUgc3BlY2lmaWVkIHN0cmluZyBpcyBwYXNzZWQgdG9cbiAqIHNjYW5DaGFycygpLiBUaGUgc2Nhbm5lciBsb29wcyB0aHJvdWdoIHRoYXQgc3RyaW5nIGFuZCBwYXNzZXMgY2hhcmFjdGVyc1xuICogKHNvbWV0aW1lcyBvbmUgYXQgYSB0aW1lLCBzb21ldGltZXMgaW4gY2h1bmtzKSB0byB0aGUgdG9rZW5pemVyIHN0YWdlLlxuICogVGhlIHRva2VuaXplciBncm91cHMgdGhlIGNoYXJhY3RlcnMgaW50byB0b2tlbnM6IHRhZ3MsIGVuZHRhZ3MsIHJ1bnNcbiAqIG9mIHRleHQsIGNvbW1lbnRzLCBkb2N0eXBlIGRlY2xhcmF0aW9ucywgYW5kIHRoZSBlbmQtb2YtZmlsZSAoRU9GKVxuICogdG9rZW4uICBUaGVzZSB0b2tlbnMgYXJlIHRoZW4gcGFzc2VkIHRvIHRoZSB0cmVlIGJ1aWxkaW5nIHN0YWdlIHZpYVxuICogdGhlIGluc2VydFRva2VuKCkgZnVuY3Rpb24uICBUaGUgdHJlZSBidWlsZGluZyBzdGFnZSBidWlsZHMgdXAgdGhlXG4gKiBkb2N1bWVudCB0cmVlLlxuICpcbiAqIFRoZSB0b2tlbml6ZXIgc3RhZ2UgaXMgYSBmaW5pdGUgc3RhdGUgbWFjaGluZS4gIEVhY2ggc3RhdGUgaXNcbiAqIGltcGxlbWVudGVkIGFzIGEgZnVuY3Rpb24gd2l0aCBhIG5hbWUgdGhhdCBlbmRzIGluIFwiX3N0YXRlXCIuICBUaGVcbiAqIGluaXRpYWwgc3RhdGUgaXMgZGF0YV9zdGF0ZSgpLiBUaGUgY3VycmVudCB0b2tlbml6ZXIgc3RhdGUgaXMgc3RvcmVkXG4gKiBpbiB0aGUgdmFyaWFibGUgJ3Rva2VuaXplcicuICBNb3N0IHN0YXRlIGZ1bmN0aW9ucyBleHBlY3QgYSBzaW5nbGVcbiAqIGludGVnZXIgYXJndW1lbnQgd2hpY2ggcmVwcmVzZW50cyBhIHNpbmdsZSBVVEYtMTYgY29kZXBvaW50LiAgU29tZVxuICogc3RhdGVzIHdhbnQgbW9yZSBjaGFyYWN0ZXJzIGFuZCBzZXQgYSBsb29rYWhlYWQgcHJvcGVydHkgb25cbiAqIHRoZW1zZWx2ZXMuICBUaGUgc2NhbkNoYXJzKCkgZnVuY3Rpb24gaW4gdGhlIHNjYW5uZXIgY2hlY2tzIGZvciB0aGlzXG4gKiBsb29rYWhlYWQgcHJvcGVydHkuICBJZiBpdCBkb2Vzbid0IGV4aXN0LCB0aGVuIHNjYW5DaGFycygpIGp1c3QgcGFzc2VzXG4gKiB0aGUgbmV4dCBpbnB1dCBjaGFyYWN0ZXIgdG8gdGhlIGN1cnJlbnQgdG9rZW5pemVyIHN0YXRlIGZ1bmN0aW9uLlxuICogT3RoZXJ3aXNlLCBzY2FuQ2hhcnMoKSBsb29rcyBhaGVhZCAoYSBnaXZlbiAjIG9mIGNoYXJhY3RlcnMsIG9yIGZvciBhXG4gKiBtYXRjaGluZyBzdHJpbmcsIG9yIGZvciBhIG1hdGNoaW5nIHJlZ2V4cCkgYW5kIHBhc3NlcyBhIHN0cmluZyBvZlxuICogY2hhcmFjdGVycyB0byB0aGUgY3VycmVudCB0b2tlbml6ZXIgc3RhdGUgZnVuY3Rpb24uXG4gKlxuICogQXMgYSBzaG9ydGN1dCwgY2VydGFpbiBzdGF0ZXMgb2YgdGhlIHRva2VuaXplciB1c2UgcmVndWxhciBleHByZXNzaW9uc1xuICogdG8gbG9vayBhaGVhZCBpbiB0aGUgc2Nhbm5lcidzIGlucHV0IGJ1ZmZlciBmb3IgcnVucyBvZiB0ZXh0LCBzaW1wbGVcbiAqIHRhZ3MgYW5kIGF0dHJpYnV0ZXMuICBGb3Igd2VsbC1mb3JtZWQgaW5wdXQsIHRoZXNlIHNob3J0Y3V0cyBza2lwIGFcbiAqIGxvdCBvZiBzdGF0ZSB0cmFuc2l0aW9ucyBhbmQgc3BlZWQgdGhpbmdzIHVwIGEgYml0LlxuICpcbiAqIFdoZW4gYSB0b2tlbml6ZXIgc3RhdGUgZnVuY3Rpb24gaGFzIGNvbnN1bWVkIGEgY29tcGxldGUgdG9rZW4sIGl0XG4gKiBlbWl0cyB0aGF0IHRva2VuLCBieSBjYWxsaW5nIGluc2VydFRva2VuKCksIG9yIGJ5IGNhbGxpbmcgYSB1dGlsaXR5XG4gKiBmdW5jdGlvbiB0aGF0IGl0c2VsZiBjYWxscyBpbnNlcnRUb2tlbigpLiAgVGhlc2UgdG9rZW5zIGFyZSBwYXNzZWQgdG9cbiAqIHRoZSB0cmVlIGJ1aWxkaW5nIHN0YWdlLCB3aGljaCBpcyBhbHNvIGEgc3RhdGUgbWFjaGluZS4gIExpa2UgdGhlXG4gKiB0b2tlbml6ZXIsIHRoZSB0cmVlIGJ1aWxkaW5nIHN0YXRlcyBhcmUgaW1wbGVtZW50ZWQgYXMgZnVuY3Rpb25zLCBhbmRcbiAqIHRoZXNlIGZ1bmN0aW9ucyBoYXZlIG5hbWVzIHRoYXQgZW5kIHdpdGggX21vZGUgKGJlY2F1c2UgdGhlIEhUTUwgc3BlY1xuICogcmVmZXJzIHRvIHRoZW0gYXMgaW5zZXJ0aW9uIG1vZGVzKS4gVGhlIGN1cnJlbnQgaW5zZXJ0aW9uIG1vZGUgaXMgaGVsZFxuICogYnkgdGhlICdwYXJzZXInIHZhcmlhYmxlLiAgRWFjaCBpbnNlcnRpb24gbW9kZSBmdW5jdGlvbiB0YWtlcyB1cCB0byA0XG4gKiBhcmd1bWVudHMuICBUaGUgZmlyc3QgaXMgYSB0b2tlbiB0eXBlLCByZXByZXNlbnRlZCBieSB0aGUgY29uc3RhbnRzXG4gKiBUQUcsIEVORFRBRywgVEVYVCwgQ09NTUVOVCwgRE9DVFlQRSBhbmQgRU9GLiAgVGhlIHNlY29uZCBhcmd1bWVudCBpc1xuICogdGhlIHZhbHVlIG9mIHRoZSB0b2tlbjogdGhlIHRleHQgb3IgY29tbWVudCBkYXRhLCBvciB0YWduYW1lIG9yXG4gKiBkb2N0eXBlLiAgRm9yIHRhZ3MsIHRoZSAzcmQgYXJndW1lbnQgaXMgYW4gYXJyYXkgb2YgYXR0cmlidXRlcy4gIEZvclxuICogRE9DVFlQRVMgaXQgaXMgdGhlIG9wdGlvbmFsIHB1YmxpYyBpZC4gIEZvciB0YWdzLCB0aGUgNHRoIGFyZ3VtZW50IGlzXG4gKiB0cnVlIGlmIHRoZSB0YWcgaXMgc2VsZi1jbG9zaW5nLiBGb3IgZG9jdHlwZXMsIHRoZSA0dGggYXJndW1lbnQgaXMgdGhlXG4gKiBvcHRpb25hbCBzeXN0ZW0gaWQuXG4gKlxuICogU2VhcmNoIGZvciBcIioqKlwiIHRvIGZpbmQgdGhlIG1ham9yIHN1Yi1kaXZpc2lvbnMgaW4gdGhlIGNvZGUuXG4gKi9cblxuXG4vKioqXG4gKiBEYXRhIHByb2xvZy4gIExvdHMgb2YgY29uc3RhbnRzIGRlY2xhcmVkIGhlcmUsIGluY2x1ZGluZyBzb21lXG4gKiB2ZXJ5IGxhcmdlIG9iamVjdHMuICBUaGV5J3JlIHVzZWQgdGhyb3VnaG91dCB0aGUgY29kZSB0aGF0IGZvbGxvd3NcbiAqL1xuLy8gVG9rZW4gdHlwZXMgZm9yIHRoZSB0cmVlIGJ1aWxkZXIuXG52YXIgRU9GID0gLTE7XG52YXIgVEVYVCA9IDE7XG52YXIgVEFHID0gMjtcbnZhciBFTkRUQUcgPSAzO1xudmFyIENPTU1FTlQgPSA0O1xudmFyIERPQ1RZUEUgPSA1O1xuXG4vLyBBIHJlLXVzYWJsZSBlbXB0eSBhcnJheVxudmFyIE5PQVRUUlMgPSBbXTtcblxuLy8gVGhlc2UgRFREIHB1YmxpYyBpZHMgcHV0IHRoZSBicm93c2VyIGluIHF1aXJrcyBtb2RlXG52YXIgcXVpcmt5UHVibGljSWRzID0gL15IVE1MJHxeLVxcL1xcL1czT1xcL1xcL0RURCBXMyBIVE1MIFN0cmljdCAzXFwuMFxcL1xcL0VOXFwvXFwvJHxeLVxcL1czQ1xcL0RURCBIVE1MIDRcXC4wIFRyYW5zaXRpb25hbFxcL0VOJHxeXFwrXFwvXFwvU2lsbWFyaWxcXC9cXC9kdGQgaHRtbCBQcm8gdjByMTEgMTk5NzAxMDFcXC9cXC98Xi1cXC9cXC9BZHZhU29mdCBMdGRcXC9cXC9EVEQgSFRNTCAzXFwuMCBhc1dlZGl0IFxcKyBleHRlbnNpb25zXFwvXFwvfF4tXFwvXFwvQVNcXC9cXC9EVEQgSFRNTCAzXFwuMCBhc1dlZGl0IFxcKyBleHRlbnNpb25zXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDJcXC4wIExldmVsIDFcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgMlxcLjAgTGV2ZWwgMlxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCAyXFwuMCBTdHJpY3QgTGV2ZWwgMVxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCAyXFwuMCBTdHJpY3QgTGV2ZWwgMlxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCAyXFwuMCBTdHJpY3RcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgMlxcLjBcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgMlxcLjFFXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDNcXC4wXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDNcXC4yIEZpbmFsXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDNcXC4yXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIDNcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgTGV2ZWwgMFxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBMZXZlbCAxXFwvXFwvfF4tXFwvXFwvSUVURlxcL1xcL0RURCBIVE1MIExldmVsIDJcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUwgTGV2ZWwgM1xcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBTdHJpY3QgTGV2ZWwgMFxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBTdHJpY3QgTGV2ZWwgMVxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBTdHJpY3QgTGV2ZWwgMlxcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBTdHJpY3QgTGV2ZWwgM1xcL1xcL3xeLVxcL1xcL0lFVEZcXC9cXC9EVEQgSFRNTCBTdHJpY3RcXC9cXC98Xi1cXC9cXC9JRVRGXFwvXFwvRFREIEhUTUxcXC9cXC98Xi1cXC9cXC9NZXRyaXVzXFwvXFwvRFREIE1ldHJpdXMgUHJlc2VudGF0aW9uYWxcXC9cXC98Xi1cXC9cXC9NaWNyb3NvZnRcXC9cXC9EVEQgSW50ZXJuZXQgRXhwbG9yZXIgMlxcLjAgSFRNTCBTdHJpY3RcXC9cXC98Xi1cXC9cXC9NaWNyb3NvZnRcXC9cXC9EVEQgSW50ZXJuZXQgRXhwbG9yZXIgMlxcLjAgSFRNTFxcL1xcL3xeLVxcL1xcL01pY3Jvc29mdFxcL1xcL0RURCBJbnRlcm5ldCBFeHBsb3JlciAyXFwuMCBUYWJsZXNcXC9cXC98Xi1cXC9cXC9NaWNyb3NvZnRcXC9cXC9EVEQgSW50ZXJuZXQgRXhwbG9yZXIgM1xcLjAgSFRNTCBTdHJpY3RcXC9cXC98Xi1cXC9cXC9NaWNyb3NvZnRcXC9cXC9EVEQgSW50ZXJuZXQgRXhwbG9yZXIgM1xcLjAgSFRNTFxcL1xcL3xeLVxcL1xcL01pY3Jvc29mdFxcL1xcL0RURCBJbnRlcm5ldCBFeHBsb3JlciAzXFwuMCBUYWJsZXNcXC9cXC98Xi1cXC9cXC9OZXRzY2FwZSBDb21tXFwuIENvcnBcXC5cXC9cXC9EVEQgSFRNTFxcL1xcL3xeLVxcL1xcL05ldHNjYXBlIENvbW1cXC4gQ29ycFxcLlxcL1xcL0RURCBTdHJpY3QgSFRNTFxcL1xcL3xeLVxcL1xcL08nUmVpbGx5IGFuZCBBc3NvY2lhdGVzXFwvXFwvRFREIEhUTUwgMlxcLjBcXC9cXC98Xi1cXC9cXC9PJ1JlaWxseSBhbmQgQXNzb2NpYXRlc1xcL1xcL0RURCBIVE1MIEV4dGVuZGVkIDFcXC4wXFwvXFwvfF4tXFwvXFwvTydSZWlsbHkgYW5kIEFzc29jaWF0ZXNcXC9cXC9EVEQgSFRNTCBFeHRlbmRlZCBSZWxheGVkIDFcXC4wXFwvXFwvfF4tXFwvXFwvU29mdFF1YWQgU29mdHdhcmVcXC9cXC9EVEQgSG9UTWV0YUwgUFJPIDZcXC4wOjoxOTk5MDYwMTo6ZXh0ZW5zaW9ucyB0byBIVE1MIDRcXC4wXFwvXFwvfF4tXFwvXFwvU29mdFF1YWRcXC9cXC9EVEQgSG9UTWV0YUwgUFJPIDRcXC4wOjoxOTk3MTAxMDo6ZXh0ZW5zaW9ucyB0byBIVE1MIDRcXC4wXFwvXFwvfF4tXFwvXFwvU3B5Z2xhc3NcXC9cXC9EVEQgSFRNTCAyXFwuMCBFeHRlbmRlZFxcL1xcL3xeLVxcL1xcL1NRXFwvXFwvRFREIEhUTUwgMlxcLjAgSG9UTWV0YUwgXFwrIGV4dGVuc2lvbnNcXC9cXC98Xi1cXC9cXC9TdW4gTWljcm9zeXN0ZW1zIENvcnBcXC5cXC9cXC9EVEQgSG90SmF2YSBIVE1MXFwvXFwvfF4tXFwvXFwvU3VuIE1pY3Jvc3lzdGVtcyBDb3JwXFwuXFwvXFwvRFREIEhvdEphdmEgU3RyaWN0IEhUTUxcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCAzIDE5OTUtMDMtMjRcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCAzXFwuMiBEcmFmdFxcL1xcL3xeLVxcL1xcL1czQ1xcL1xcL0RURCBIVE1MIDNcXC4yIEZpbmFsXFwvXFwvfF4tXFwvXFwvVzNDXFwvXFwvRFREIEhUTUwgM1xcLjJcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCAzXFwuMlMgRHJhZnRcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgSFRNTCA0XFwuMCBGcmFtZXNldFxcL1xcL3xeLVxcL1xcL1czQ1xcL1xcL0RURCBIVE1MIDRcXC4wIFRyYW5zaXRpb25hbFxcL1xcL3xeLVxcL1xcL1czQ1xcL1xcL0RURCBIVE1MIEV4cGVyaW1lbnRhbCAxOTk2MDcxMlxcL1xcL3xeLVxcL1xcL1czQ1xcL1xcL0RURCBIVE1MIEV4cGVyaW1lbnRhbCA5NzA0MjFcXC9cXC98Xi1cXC9cXC9XM0NcXC9cXC9EVEQgVzMgSFRNTFxcL1xcL3xeLVxcL1xcL1czT1xcL1xcL0RURCBXMyBIVE1MIDNcXC4wXFwvXFwvfF4tXFwvXFwvV2ViVGVjaHNcXC9cXC9EVEQgTW96aWxsYSBIVE1MIDJcXC4wXFwvXFwvfF4tXFwvXFwvV2ViVGVjaHNcXC9cXC9EVEQgTW96aWxsYSBIVE1MXFwvXFwvL2k7XG5cbnZhciBxdWlya3lTeXN0ZW1JZCA9IFwiaHR0cDovL3d3dy5pYm0uY29tL2RhdGEvZHRkL3YxMS9pYm14aHRtbDEtdHJhbnNpdGlvbmFsLmR0ZFwiO1xuXG52YXIgY29uZGl0aW9uYWxseVF1aXJreVB1YmxpY0lkcyA9IC9eLVxcL1xcL1czQ1xcL1xcL0RURCBIVE1MIDRcXC4wMSBGcmFtZXNldFxcL1xcL3xeLVxcL1xcL1czQ1xcL1xcL0RURCBIVE1MIDRcXC4wMSBUcmFuc2l0aW9uYWxcXC9cXC8vaTtcblxuLy8gVGhlc2UgRFREIHB1YmxpYyBpZHMgcHV0IHRoZSBicm93c2VyIGluIGxpbWl0ZWQgcXVpcmtzIG1vZGVcbnZhciBsaW1pdGVkUXVpcmt5UHVibGljSWRzID0gL14tXFwvXFwvVzNDXFwvXFwvRFREIFhIVE1MIDFcXC4wIEZyYW1lc2V0XFwvXFwvfF4tXFwvXFwvVzNDXFwvXFwvRFREIFhIVE1MIDFcXC4wIFRyYW5zaXRpb25hbFxcL1xcLy9pO1xuXG5cbi8vIEVsZW1lbnQgc2V0cyBiZWxvdy4gU2VlIHRoZSBpc0EoKSBmdW5jdGlvbiBmb3IgYSB3YXkgdG8gdGVzdFxuLy8gd2hldGhlciBhbiBlbGVtZW50IGlzIGEgbWVtYmVyIG9mIGEgc2V0XG52YXIgc3BlY2lhbFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5zcGVjaWFsU2V0W05BTUVTUEFDRS5IVE1MXSA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBcImFkZHJlc3NcIjp0cnVlLCBcImFwcGxldFwiOnRydWUsIFwiYXJlYVwiOnRydWUsIFwiYXJ0aWNsZVwiOnRydWUsXG4gIFwiYXNpZGVcIjp0cnVlLCBcImJhc2VcIjp0cnVlLCBcImJhc2Vmb250XCI6dHJ1ZSwgXCJiZ3NvdW5kXCI6dHJ1ZSxcbiAgXCJibG9ja3F1b3RlXCI6dHJ1ZSwgXCJib2R5XCI6dHJ1ZSwgXCJiclwiOnRydWUsIFwiYnV0dG9uXCI6dHJ1ZSxcbiAgXCJjYXB0aW9uXCI6dHJ1ZSwgXCJjZW50ZXJcIjp0cnVlLCBcImNvbFwiOnRydWUsIFwiY29sZ3JvdXBcIjp0cnVlLFxuICBcImRkXCI6dHJ1ZSwgXCJkZXRhaWxzXCI6dHJ1ZSwgXCJkaXJcIjp0cnVlLFxuICBcImRpdlwiOnRydWUsIFwiZGxcIjp0cnVlLCBcImR0XCI6dHJ1ZSwgXCJlbWJlZFwiOnRydWUsXG4gIFwiZmllbGRzZXRcIjp0cnVlLCBcImZpZ2NhcHRpb25cIjp0cnVlLCBcImZpZ3VyZVwiOnRydWUsIFwiZm9vdGVyXCI6dHJ1ZSxcbiAgXCJmb3JtXCI6dHJ1ZSwgXCJmcmFtZVwiOnRydWUsIFwiZnJhbWVzZXRcIjp0cnVlLCBcImgxXCI6dHJ1ZSxcbiAgXCJoMlwiOnRydWUsIFwiaDNcIjp0cnVlLCBcImg0XCI6dHJ1ZSwgXCJoNVwiOnRydWUsXG4gIFwiaDZcIjp0cnVlLCBcImhlYWRcIjp0cnVlLCBcImhlYWRlclwiOnRydWUsIFwiaGdyb3VwXCI6dHJ1ZSxcbiAgXCJoclwiOnRydWUsIFwiaHRtbFwiOnRydWUsIFwiaWZyYW1lXCI6dHJ1ZSwgXCJpbWdcIjp0cnVlLFxuICBcImlucHV0XCI6dHJ1ZSwgXCJsaVwiOnRydWUsIFwibGlua1wiOnRydWUsXG4gIFwibGlzdGluZ1wiOnRydWUsIFwibWFpblwiOnRydWUsIFwibWFycXVlZVwiOnRydWUsIFwibWVudVwiOnRydWUsIFwibWV0YVwiOnRydWUsXG4gIFwibmF2XCI6dHJ1ZSwgXCJub2VtYmVkXCI6dHJ1ZSwgXCJub2ZyYW1lc1wiOnRydWUsIFwibm9zY3JpcHRcIjp0cnVlLFxuICBcIm9iamVjdFwiOnRydWUsIFwib2xcIjp0cnVlLCBcInBcIjp0cnVlLCBcInBhcmFtXCI6dHJ1ZSxcbiAgXCJwbGFpbnRleHRcIjp0cnVlLCBcInByZVwiOnRydWUsIFwic2NyaXB0XCI6dHJ1ZSwgXCJzZWN0aW9uXCI6dHJ1ZSxcbiAgXCJzZWxlY3RcIjp0cnVlLCBcInNvdXJjZVwiOnRydWUsIFwic3R5bGVcIjp0cnVlLCBcInN1bW1hcnlcIjp0cnVlLCBcInRhYmxlXCI6dHJ1ZSxcbiAgXCJ0Ym9keVwiOnRydWUsIFwidGRcIjp0cnVlLCBcInRlbXBsYXRlXCI6dHJ1ZSwgXCJ0ZXh0YXJlYVwiOnRydWUsIFwidGZvb3RcIjp0cnVlLFxuICBcInRoXCI6dHJ1ZSwgXCJ0aGVhZFwiOnRydWUsIFwidGl0bGVcIjp0cnVlLCBcInRyXCI6dHJ1ZSwgXCJ0cmFja1wiOnRydWUsXG4gIC8vIE5vdGUgdGhhdCBcInhtcFwiIHdhcyByZW1vdmVkIGZyb20gdGhlIFwic3BlY2lhbFwiIHNldCBpbiB0aGUgbGF0ZXN0XG4gIC8vIHNwZWMsIGFwcGFyZW50bHkgYnkgYWNjaWRlbnQ7IHNlZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvcHVsbC8xOTE5XG4gIFwidWxcIjp0cnVlLCBcIndiclwiOnRydWUsIFwieG1wXCI6dHJ1ZVxufTtcbnNwZWNpYWxTZXRbTkFNRVNQQUNFLlNWR10gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJmb3JlaWduT2JqZWN0XCI6IHRydWUsIFwiZGVzY1wiOiB0cnVlLCBcInRpdGxlXCI6IHRydWVcbn07XG5zcGVjaWFsU2V0W05BTUVTUEFDRS5NQVRITUxdID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFwibWlcIjp0cnVlLCBcIm1vXCI6dHJ1ZSwgXCJtblwiOnRydWUsIFwibXNcIjp0cnVlLFxuICBcIm10ZXh0XCI6dHJ1ZSwgXCJhbm5vdGF0aW9uLXhtbFwiOnRydWVcbn07XG5cbi8vIFRoZSBzZXQgb2YgYWRkcmVzcywgZGl2LCBhbmQgcCBIVE1MIHRhZ3NcbnZhciBhZGRyZXNzZGl2cFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5hZGRyZXNzZGl2cFNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJhZGRyZXNzXCI6dHJ1ZSwgXCJkaXZcIjp0cnVlLCBcInBcIjp0cnVlXG59O1xuXG52YXIgZGRkdFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5kZGR0U2V0W05BTUVTUEFDRS5IVE1MXSA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBcImRkXCI6dHJ1ZSwgXCJkdFwiOnRydWVcbn07XG5cbnZhciB0YWJsZXNlY3Rpb25yb3dTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xudGFibGVzZWN0aW9ucm93U2V0W05BTUVTUEFDRS5IVE1MXSA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBcInRhYmxlXCI6dHJ1ZSwgXCJ0aGVhZFwiOnRydWUsIFwidGJvZHlcIjp0cnVlLCBcInRmb290XCI6dHJ1ZSwgXCJ0clwiOnRydWVcbn07XG5cbnZhciBpbXBsaWVkRW5kVGFnc1NldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5pbXBsaWVkRW5kVGFnc1NldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJkZFwiOiB0cnVlLCBcImR0XCI6IHRydWUsIFwibGlcIjogdHJ1ZSwgXCJtZW51aXRlbVwiOiB0cnVlLCBcIm9wdGdyb3VwXCI6IHRydWUsXG4gIFwib3B0aW9uXCI6IHRydWUsIFwicFwiOiB0cnVlLCBcInJiXCI6IHRydWUsIFwicnBcIjogdHJ1ZSwgXCJydFwiOiB0cnVlLCBcInJ0Y1wiOiB0cnVlXG59O1xuXG52YXIgdGhvcm91Z2hJbXBsaWVkRW5kVGFnc1NldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG50aG9yb3VnaEltcGxpZWRFbmRUYWdzU2V0W05BTUVTUEFDRS5IVE1MXSA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBcImNhcHRpb25cIjogdHJ1ZSwgXCJjb2xncm91cFwiOiB0cnVlLCBcImRkXCI6IHRydWUsIFwiZHRcIjogdHJ1ZSwgXCJsaVwiOiB0cnVlLFxuICBcIm9wdGdyb3VwXCI6IHRydWUsIFwib3B0aW9uXCI6IHRydWUsIFwicFwiOiB0cnVlLCBcInJiXCI6IHRydWUsIFwicnBcIjogdHJ1ZSxcbiAgXCJydFwiOiB0cnVlLCBcInJ0Y1wiOiB0cnVlLCBcInRib2R5XCI6IHRydWUsIFwidGRcIjogdHJ1ZSwgXCJ0Zm9vdFwiOiB0cnVlLFxuICBcInRoXCI6IHRydWUsIFwidGhlYWRcIjogdHJ1ZSwgXCJ0clwiOiB0cnVlXG59O1xuXG52YXIgdGFibGVDb250ZXh0U2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnRhYmxlQ29udGV4dFNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJ0YWJsZVwiOiB0cnVlLCBcInRlbXBsYXRlXCI6IHRydWUsIFwiaHRtbFwiOiB0cnVlXG59O1xuXG52YXIgdGFibGVCb2R5Q29udGV4dFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG50YWJsZUJvZHlDb250ZXh0U2V0W05BTUVTUEFDRS5IVE1MXSA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBcInRib2R5XCI6IHRydWUsIFwidGZvb3RcIjogdHJ1ZSwgXCJ0aGVhZFwiOiB0cnVlLCBcInRlbXBsYXRlXCI6IHRydWUsIFwiaHRtbFwiOiB0cnVlXG59O1xuXG52YXIgdGFibGVSb3dDb250ZXh0U2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnRhYmxlUm93Q29udGV4dFNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJ0clwiOiB0cnVlLCBcInRlbXBsYXRlXCI6IHRydWUsIFwiaHRtbFwiOiB0cnVlXG59O1xuXG4vLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNmb3JtLWFzc29jaWF0ZWQtZWxlbWVudFxudmFyIGZvcm1hc3NvY2lhdGVkU2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZvcm1hc3NvY2lhdGVkU2V0W05BTUVTUEFDRS5IVE1MXSA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBcImJ1dHRvblwiOiB0cnVlLCBcImZpZWxkc2V0XCI6IHRydWUsIFwiaW5wdXRcIjogdHJ1ZSwgXCJrZXlnZW5cIjogdHJ1ZSxcbiAgXCJvYmplY3RcIjogdHJ1ZSwgXCJvdXRwdXRcIjogdHJ1ZSwgXCJzZWxlY3RcIjogdHJ1ZSwgXCJ0ZXh0YXJlYVwiOiB0cnVlLFxuICBcImltZ1wiOiB0cnVlXG59O1xuXG52YXIgaW5TY29wZVNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5pblNjb3BlU2V0W05BTUVTUEFDRS5IVE1MXT0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFwiYXBwbGV0XCI6dHJ1ZSwgXCJjYXB0aW9uXCI6dHJ1ZSwgXCJodG1sXCI6dHJ1ZSwgXCJ0YWJsZVwiOnRydWUsXG4gIFwidGRcIjp0cnVlLCBcInRoXCI6dHJ1ZSwgXCJtYXJxdWVlXCI6dHJ1ZSwgXCJvYmplY3RcIjp0cnVlLFxuICBcInRlbXBsYXRlXCI6dHJ1ZVxufTtcbmluU2NvcGVTZXRbTkFNRVNQQUNFLk1BVEhNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJtaVwiOnRydWUsIFwibW9cIjp0cnVlLCBcIm1uXCI6dHJ1ZSwgXCJtc1wiOnRydWUsXG4gIFwibXRleHRcIjp0cnVlLCBcImFubm90YXRpb24teG1sXCI6dHJ1ZVxufTtcbmluU2NvcGVTZXRbTkFNRVNQQUNFLlNWR10gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJmb3JlaWduT2JqZWN0XCI6dHJ1ZSwgXCJkZXNjXCI6dHJ1ZSwgXCJ0aXRsZVwiOnRydWVcbn07XG5cbnZhciBpbkxpc3RJdGVtU2NvcGVTZXQgPSBPYmplY3QuY3JlYXRlKGluU2NvcGVTZXQpO1xuaW5MaXN0SXRlbVNjb3BlU2V0W05BTUVTUEFDRS5IVE1MXSA9XG4gIE9iamVjdC5jcmVhdGUoaW5TY29wZVNldFtOQU1FU1BBQ0UuSFRNTF0pO1xuaW5MaXN0SXRlbVNjb3BlU2V0W05BTUVTUEFDRS5IVE1MXS5vbCA9IHRydWU7XG5pbkxpc3RJdGVtU2NvcGVTZXRbTkFNRVNQQUNFLkhUTUxdLnVsID0gdHJ1ZTtcblxudmFyIGluQnV0dG9uU2NvcGVTZXQgPSBPYmplY3QuY3JlYXRlKGluU2NvcGVTZXQpO1xuaW5CdXR0b25TY29wZVNldFtOQU1FU1BBQ0UuSFRNTF0gPVxuICBPYmplY3QuY3JlYXRlKGluU2NvcGVTZXRbTkFNRVNQQUNFLkhUTUxdKTtcbmluQnV0dG9uU2NvcGVTZXRbTkFNRVNQQUNFLkhUTUxdLmJ1dHRvbiA9IHRydWU7XG5cbnZhciBpblRhYmxlU2NvcGVTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuaW5UYWJsZVNjb3BlU2V0W05BTUVTUEFDRS5IVE1MXSA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBcImh0bWxcIjp0cnVlLCBcInRhYmxlXCI6dHJ1ZSwgXCJ0ZW1wbGF0ZVwiOnRydWVcbn07XG5cbi8vIFRoZSBzZXQgb2YgZWxlbWVudHMgZm9yIHNlbGVjdCBzY29wZSBpcyB0aGUgZXZlcnl0aGluZyAqZXhjZXB0KiB0aGVzZVxudmFyIGludmVydGVkU2VsZWN0U2NvcGVTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuaW52ZXJ0ZWRTZWxlY3RTY29wZVNldFtOQU1FU1BBQ0UuSFRNTF0gPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJvcHRncm91cFwiOnRydWUsIFwib3B0aW9uXCI6dHJ1ZVxufTtcblxudmFyIG1hdGhtbFRleHRJbnRlZ3JhdGlvblBvaW50U2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbm1hdGhtbFRleHRJbnRlZ3JhdGlvblBvaW50U2V0W05BTUVTUEFDRS5NQVRITUxdID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIG1pOiB0cnVlLFxuICBtbzogdHJ1ZSxcbiAgbW46IHRydWUsXG4gIG1zOiB0cnVlLFxuICBtdGV4dDogdHJ1ZVxufTtcblxudmFyIGh0bWxJbnRlZ3JhdGlvblBvaW50U2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmh0bWxJbnRlZ3JhdGlvblBvaW50U2V0W05BTUVTUEFDRS5TVkddID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGZvcmVpZ25PYmplY3Q6IHRydWUsXG4gIGRlc2M6IHRydWUsXG4gIHRpdGxlOiB0cnVlXG59O1xuXG52YXIgZm9yZWlnbkF0dHJpYnV0ZXMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgXCJ4bGluazphY3R1YXRlXCI6IE5BTUVTUEFDRS5YTElOSywgXCJ4bGluazphcmNyb2xlXCI6IE5BTUVTUEFDRS5YTElOSyxcbiAgXCJ4bGluazpocmVmXCI6ICAgTkFNRVNQQUNFLlhMSU5LLCAgXCJ4bGluazpyb2xlXCI6ICAgIE5BTUVTUEFDRS5YTElOSyxcbiAgXCJ4bGluazpzaG93XCI6ICAgTkFNRVNQQUNFLlhMSU5LLCAgXCJ4bGluazp0aXRsZVwiOiAgIE5BTUVTUEFDRS5YTElOSyxcbiAgXCJ4bGluazp0eXBlXCI6ICAgTkFNRVNQQUNFLlhMSU5LLCAgXCJ4bWw6YmFzZVwiOiAgICAgIE5BTUVTUEFDRS5YTUwsXG4gIFwieG1sOmxhbmdcIjogICAgIE5BTUVTUEFDRS5YTUwsICAgIFwieG1sOnNwYWNlXCI6ICAgICBOQU1FU1BBQ0UuWE1MLFxuICBcInhtbG5zXCI6ICAgICAgICBOQU1FU1BBQ0UuWE1MTlMsICBcInhtbG5zOnhsaW5rXCI6ICAgTkFNRVNQQUNFLlhNTE5TXG59O1xuXG5cbi8vIExvd2VyY2FzZSB0byBtaXhlZCBjYXNlIG1hcHBpbmcgZm9yIFNWRyBhdHRyaWJ1dGVzIGFuZCB0YWduYW1lc1xudmFyIHN2Z0F0dHJBZGp1c3RtZW50cyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhdHRyaWJ1dGVuYW1lOiBcImF0dHJpYnV0ZU5hbWVcIiwgYXR0cmlidXRldHlwZTogXCJhdHRyaWJ1dGVUeXBlXCIsXG4gIGJhc2VmcmVxdWVuY3k6IFwiYmFzZUZyZXF1ZW5jeVwiLCBiYXNlcHJvZmlsZTogXCJiYXNlUHJvZmlsZVwiLFxuICBjYWxjbW9kZTogXCJjYWxjTW9kZVwiLCBjbGlwcGF0aHVuaXRzOiBcImNsaXBQYXRoVW5pdHNcIixcbiAgZGlmZnVzZWNvbnN0YW50OiBcImRpZmZ1c2VDb25zdGFudFwiLFxuICBlZGdlbW9kZTogXCJlZGdlTW9kZVwiLFxuICBmaWx0ZXJ1bml0czogXCJmaWx0ZXJVbml0c1wiLFxuICBnbHlwaHJlZjogXCJnbHlwaFJlZlwiLCBncmFkaWVudHRyYW5zZm9ybTogXCJncmFkaWVudFRyYW5zZm9ybVwiLFxuICBncmFkaWVudHVuaXRzOiBcImdyYWRpZW50VW5pdHNcIiwga2VybmVsbWF0cml4OiBcImtlcm5lbE1hdHJpeFwiLFxuICBrZXJuZWx1bml0bGVuZ3RoOiBcImtlcm5lbFVuaXRMZW5ndGhcIiwga2V5cG9pbnRzOiBcImtleVBvaW50c1wiLFxuICBrZXlzcGxpbmVzOiBcImtleVNwbGluZXNcIiwga2V5dGltZXM6IFwia2V5VGltZXNcIixcbiAgbGVuZ3RoYWRqdXN0OiBcImxlbmd0aEFkanVzdFwiLCBsaW1pdGluZ2NvbmVhbmdsZTogXCJsaW1pdGluZ0NvbmVBbmdsZVwiLFxuICBtYXJrZXJoZWlnaHQ6IFwibWFya2VySGVpZ2h0XCIsIG1hcmtlcnVuaXRzOiBcIm1hcmtlclVuaXRzXCIsXG4gIG1hcmtlcndpZHRoOiBcIm1hcmtlcldpZHRoXCIsIG1hc2tjb250ZW50dW5pdHM6IFwibWFza0NvbnRlbnRVbml0c1wiLFxuICBtYXNrdW5pdHM6IFwibWFza1VuaXRzXCIsIG51bW9jdGF2ZXM6IFwibnVtT2N0YXZlc1wiLFxuICBwYXRobGVuZ3RoOiBcInBhdGhMZW5ndGhcIiwgcGF0dGVybmNvbnRlbnR1bml0czogXCJwYXR0ZXJuQ29udGVudFVuaXRzXCIsXG4gIHBhdHRlcm50cmFuc2Zvcm06IFwicGF0dGVyblRyYW5zZm9ybVwiLCBwYXR0ZXJudW5pdHM6IFwicGF0dGVyblVuaXRzXCIsXG4gIHBvaW50c2F0eDogXCJwb2ludHNBdFhcIiwgcG9pbnRzYXR5OiBcInBvaW50c0F0WVwiLFxuICBwb2ludHNhdHo6IFwicG9pbnRzQXRaXCIsIHByZXNlcnZlYWxwaGE6IFwicHJlc2VydmVBbHBoYVwiLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiBcInByZXNlcnZlQXNwZWN0UmF0aW9cIixcbiAgcHJpbWl0aXZldW5pdHM6IFwicHJpbWl0aXZlVW5pdHNcIiwgcmVmeDogXCJyZWZYXCIsXG4gIHJlZnk6IFwicmVmWVwiLCByZXBlYXRjb3VudDogXCJyZXBlYXRDb3VudFwiLFxuICByZXBlYXRkdXI6IFwicmVwZWF0RHVyXCIsIHJlcXVpcmVkZXh0ZW5zaW9uczogXCJyZXF1aXJlZEV4dGVuc2lvbnNcIixcbiAgcmVxdWlyZWRmZWF0dXJlczogXCJyZXF1aXJlZEZlYXR1cmVzXCIsXG4gIHNwZWN1bGFyY29uc3RhbnQ6IFwic3BlY3VsYXJDb25zdGFudFwiLFxuICBzcGVjdWxhcmV4cG9uZW50OiBcInNwZWN1bGFyRXhwb25lbnRcIiwgc3ByZWFkbWV0aG9kOiBcInNwcmVhZE1ldGhvZFwiLFxuICBzdGFydG9mZnNldDogXCJzdGFydE9mZnNldFwiLCBzdGRkZXZpYXRpb246IFwic3RkRGV2aWF0aW9uXCIsXG4gIHN0aXRjaHRpbGVzOiBcInN0aXRjaFRpbGVzXCIsIHN1cmZhY2VzY2FsZTogXCJzdXJmYWNlU2NhbGVcIixcbiAgc3lzdGVtbGFuZ3VhZ2U6IFwic3lzdGVtTGFuZ3VhZ2VcIiwgdGFibGV2YWx1ZXM6IFwidGFibGVWYWx1ZXNcIixcbiAgdGFyZ2V0eDogXCJ0YXJnZXRYXCIsIHRhcmdldHk6IFwidGFyZ2V0WVwiLFxuICB0ZXh0bGVuZ3RoOiBcInRleHRMZW5ndGhcIiwgdmlld2JveDogXCJ2aWV3Qm94XCIsXG4gIHZpZXd0YXJnZXQ6IFwidmlld1RhcmdldFwiLCB4Y2hhbm5lbHNlbGVjdG9yOiBcInhDaGFubmVsU2VsZWN0b3JcIixcbiAgeWNoYW5uZWxzZWxlY3RvcjogXCJ5Q2hhbm5lbFNlbGVjdG9yXCIsIHpvb21hbmRwYW46IFwiem9vbUFuZFBhblwiXG59O1xuXG52YXIgc3ZnVGFnTmFtZUFkanVzdG1lbnRzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFsdGdseXBoOiBcImFsdEdseXBoXCIsIGFsdGdseXBoZGVmOiBcImFsdEdseXBoRGVmXCIsXG4gIGFsdGdseXBoaXRlbTogXCJhbHRHbHlwaEl0ZW1cIiwgYW5pbWF0ZWNvbG9yOiBcImFuaW1hdGVDb2xvclwiLFxuICBhbmltYXRlbW90aW9uOiBcImFuaW1hdGVNb3Rpb25cIiwgYW5pbWF0ZXRyYW5zZm9ybTogXCJhbmltYXRlVHJhbnNmb3JtXCIsXG4gIGNsaXBwYXRoOiBcImNsaXBQYXRoXCIsIGZlYmxlbmQ6IFwiZmVCbGVuZFwiLFxuICBmZWNvbG9ybWF0cml4OiBcImZlQ29sb3JNYXRyaXhcIixcbiAgZmVjb21wb25lbnR0cmFuc2ZlcjogXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIsIGZlY29tcG9zaXRlOiBcImZlQ29tcG9zaXRlXCIsXG4gIGZlY29udm9sdmVtYXRyaXg6IFwiZmVDb252b2x2ZU1hdHJpeFwiLFxuICBmZWRpZmZ1c2VsaWdodGluZzogXCJmZURpZmZ1c2VMaWdodGluZ1wiLFxuICBmZWRpc3BsYWNlbWVudG1hcDogXCJmZURpc3BsYWNlbWVudE1hcFwiLFxuICBmZWRpc3RhbnRsaWdodDogXCJmZURpc3RhbnRMaWdodFwiLCBmZWZsb29kOiBcImZlRmxvb2RcIixcbiAgZmVmdW5jYTogXCJmZUZ1bmNBXCIsIGZlZnVuY2I6IFwiZmVGdW5jQlwiLFxuICBmZWZ1bmNnOiBcImZlRnVuY0dcIiwgZmVmdW5jcjogXCJmZUZ1bmNSXCIsXG4gIGZlZ2F1c3NpYW5ibHVyOiBcImZlR2F1c3NpYW5CbHVyXCIsIGZlaW1hZ2U6IFwiZmVJbWFnZVwiLFxuICBmZW1lcmdlOiBcImZlTWVyZ2VcIiwgZmVtZXJnZW5vZGU6IFwiZmVNZXJnZU5vZGVcIixcbiAgZmVtb3JwaG9sb2d5OiBcImZlTW9ycGhvbG9neVwiLCBmZW9mZnNldDogXCJmZU9mZnNldFwiLFxuICBmZXBvaW50bGlnaHQ6IFwiZmVQb2ludExpZ2h0XCIsIGZlc3BlY3VsYXJsaWdodGluZzogXCJmZVNwZWN1bGFyTGlnaHRpbmdcIixcbiAgZmVzcG90bGlnaHQ6IFwiZmVTcG90TGlnaHRcIiwgZmV0aWxlOiBcImZlVGlsZVwiLFxuICBmZXR1cmJ1bGVuY2U6IFwiZmVUdXJidWxlbmNlXCIsIGZvcmVpZ25vYmplY3Q6IFwiZm9yZWlnbk9iamVjdFwiLFxuICBnbHlwaHJlZjogXCJnbHlwaFJlZlwiLCBsaW5lYXJncmFkaWVudDogXCJsaW5lYXJHcmFkaWVudFwiLFxuICByYWRpYWxncmFkaWVudDogXCJyYWRpYWxHcmFkaWVudFwiLCB0ZXh0cGF0aDogXCJ0ZXh0UGF0aFwiXG59O1xuXG5cbi8vIERhdGEgZm9yIHBhcnNpbmcgbnVtZXJpYyBhbmQgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXNcbi8vIFRoZXNlIG5leHQgMyBvYmplY3RzIGFyZSBkaXJlY3QgdHJhbnNsYXRpb25zIG9mIHRhYmxlc1xuLy8gaW4gdGhlIEhUTUwgc3BlYyBpbnRvIEphdmFTY3JpcHQgb2JqZWN0IGZvcm1hdFxudmFyIG51bWVyaWNDaGFyUmVmUmVwbGFjZW1lbnRzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIDB4MDA6MHhGRkZELCAweDgwOjB4MjBBQywgMHg4MjoweDIwMUEsIDB4ODM6MHgwMTkyLCAweDg0OjB4MjAxRSxcbiAgMHg4NToweDIwMjYsIDB4ODY6MHgyMDIwLCAweDg3OjB4MjAyMSwgMHg4ODoweDAyQzYsIDB4ODk6MHgyMDMwLFxuICAweDhBOjB4MDE2MCwgMHg4QjoweDIwMzksIDB4OEM6MHgwMTUyLCAweDhFOjB4MDE3RCwgMHg5MToweDIwMTgsXG4gIDB4OTI6MHgyMDE5LCAweDkzOjB4MjAxQywgMHg5NDoweDIwMUQsIDB4OTU6MHgyMDIyLCAweDk2OjB4MjAxMyxcbiAgMHg5NzoweDIwMTQsIDB4OTg6MHgwMkRDLCAweDk5OjB4MjEyMiwgMHg5QToweDAxNjEsIDB4OUI6MHgyMDNBLFxuICAweDlDOjB4MDE1MywgMHg5RToweDAxN0UsIDB4OUY6MHgwMTc4XG59O1xuXG4vKlxuICogVGhpcyB0YWJsZSBpcyBnZW5lcmF0ZWQgd2l0aCB0ZXN0L3Rvb2xzL3VwZGF0ZS1lbnRpdGllcy5qc1xuICovXG52YXIgbmFtZWRDaGFyUmVmcyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBcIkFFbGlnXCI6MHhjNiwgXCJBRWxpZztcIjoweGM2LFxuICBcIkFNUFwiOjB4MjYsIFwiQU1QO1wiOjB4MjYsXG4gIFwiQWFjdXRlXCI6MHhjMSwgXCJBYWN1dGU7XCI6MHhjMSxcbiAgXCJBYnJldmU7XCI6MHgxMDIsIFwiQWNpcmNcIjoweGMyLFxuICBcIkFjaXJjO1wiOjB4YzIsIFwiQWN5O1wiOjB4NDEwLFxuICBcIkFmcjtcIjpbMHhkODM1LDB4ZGQwNF0sIFwiQWdyYXZlXCI6MHhjMCxcbiAgXCJBZ3JhdmU7XCI6MHhjMCwgXCJBbHBoYTtcIjoweDM5MSxcbiAgXCJBbWFjcjtcIjoweDEwMCwgXCJBbmQ7XCI6MHgyYTUzLFxuICBcIkFvZ29uO1wiOjB4MTA0LCBcIkFvcGY7XCI6WzB4ZDgzNSwweGRkMzhdLFxuICBcIkFwcGx5RnVuY3Rpb247XCI6MHgyMDYxLCBcIkFyaW5nXCI6MHhjNSxcbiAgXCJBcmluZztcIjoweGM1LCBcIkFzY3I7XCI6WzB4ZDgzNSwweGRjOWNdLFxuICBcIkFzc2lnbjtcIjoweDIyNTQsIFwiQXRpbGRlXCI6MHhjMyxcbiAgXCJBdGlsZGU7XCI6MHhjMywgXCJBdW1sXCI6MHhjNCxcbiAgXCJBdW1sO1wiOjB4YzQsIFwiQmFja3NsYXNoO1wiOjB4MjIxNixcbiAgXCJCYXJ2O1wiOjB4MmFlNywgXCJCYXJ3ZWQ7XCI6MHgyMzA2LFxuICBcIkJjeTtcIjoweDQxMSwgXCJCZWNhdXNlO1wiOjB4MjIzNSxcbiAgXCJCZXJub3VsbGlzO1wiOjB4MjEyYywgXCJCZXRhO1wiOjB4MzkyLFxuICBcIkJmcjtcIjpbMHhkODM1LDB4ZGQwNV0sIFwiQm9wZjtcIjpbMHhkODM1LDB4ZGQzOV0sXG4gIFwiQnJldmU7XCI6MHgyZDgsIFwiQnNjcjtcIjoweDIxMmMsXG4gIFwiQnVtcGVxO1wiOjB4MjI0ZSwgXCJDSGN5O1wiOjB4NDI3LFxuICBcIkNPUFlcIjoweGE5LCBcIkNPUFk7XCI6MHhhOSxcbiAgXCJDYWN1dGU7XCI6MHgxMDYsIFwiQ2FwO1wiOjB4MjJkMixcbiAgXCJDYXBpdGFsRGlmZmVyZW50aWFsRDtcIjoweDIxNDUsIFwiQ2F5bGV5cztcIjoweDIxMmQsXG4gIFwiQ2Nhcm9uO1wiOjB4MTBjLCBcIkNjZWRpbFwiOjB4YzcsXG4gIFwiQ2NlZGlsO1wiOjB4YzcsIFwiQ2NpcmM7XCI6MHgxMDgsXG4gIFwiQ2NvbmludDtcIjoweDIyMzAsIFwiQ2RvdDtcIjoweDEwYSxcbiAgXCJDZWRpbGxhO1wiOjB4YjgsIFwiQ2VudGVyRG90O1wiOjB4YjcsXG4gIFwiQ2ZyO1wiOjB4MjEyZCwgXCJDaGk7XCI6MHgzYTcsXG4gIFwiQ2lyY2xlRG90O1wiOjB4MjI5OSwgXCJDaXJjbGVNaW51cztcIjoweDIyOTYsXG4gIFwiQ2lyY2xlUGx1cztcIjoweDIyOTUsIFwiQ2lyY2xlVGltZXM7XCI6MHgyMjk3LFxuICBcIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDtcIjoweDIyMzIsIFwiQ2xvc2VDdXJseURvdWJsZVF1b3RlO1wiOjB4MjAxZCxcbiAgXCJDbG9zZUN1cmx5UXVvdGU7XCI6MHgyMDE5LCBcIkNvbG9uO1wiOjB4MjIzNyxcbiAgXCJDb2xvbmU7XCI6MHgyYTc0LCBcIkNvbmdydWVudDtcIjoweDIyNjEsXG4gIFwiQ29uaW50O1wiOjB4MjIyZiwgXCJDb250b3VySW50ZWdyYWw7XCI6MHgyMjJlLFxuICBcIkNvcGY7XCI6MHgyMTAyLCBcIkNvcHJvZHVjdDtcIjoweDIyMTAsXG4gIFwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDtcIjoweDIyMzMsIFwiQ3Jvc3M7XCI6MHgyYTJmLFxuICBcIkNzY3I7XCI6WzB4ZDgzNSwweGRjOWVdLCBcIkN1cDtcIjoweDIyZDMsXG4gIFwiQ3VwQ2FwO1wiOjB4MjI0ZCwgXCJERDtcIjoweDIxNDUsXG4gIFwiRERvdHJhaGQ7XCI6MHgyOTExLCBcIkRKY3k7XCI6MHg0MDIsXG4gIFwiRFNjeTtcIjoweDQwNSwgXCJEWmN5O1wiOjB4NDBmLFxuICBcIkRhZ2dlcjtcIjoweDIwMjEsIFwiRGFycjtcIjoweDIxYTEsXG4gIFwiRGFzaHY7XCI6MHgyYWU0LCBcIkRjYXJvbjtcIjoweDEwZSxcbiAgXCJEY3k7XCI6MHg0MTQsIFwiRGVsO1wiOjB4MjIwNyxcbiAgXCJEZWx0YTtcIjoweDM5NCwgXCJEZnI7XCI6WzB4ZDgzNSwweGRkMDddLFxuICBcIkRpYWNyaXRpY2FsQWN1dGU7XCI6MHhiNCwgXCJEaWFjcml0aWNhbERvdDtcIjoweDJkOSxcbiAgXCJEaWFjcml0aWNhbERvdWJsZUFjdXRlO1wiOjB4MmRkLCBcIkRpYWNyaXRpY2FsR3JhdmU7XCI6MHg2MCxcbiAgXCJEaWFjcml0aWNhbFRpbGRlO1wiOjB4MmRjLCBcIkRpYW1vbmQ7XCI6MHgyMmM0LFxuICBcIkRpZmZlcmVudGlhbEQ7XCI6MHgyMTQ2LCBcIkRvcGY7XCI6WzB4ZDgzNSwweGRkM2JdLFxuICBcIkRvdDtcIjoweGE4LCBcIkRvdERvdDtcIjoweDIwZGMsXG4gIFwiRG90RXF1YWw7XCI6MHgyMjUwLCBcIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbDtcIjoweDIyMmYsXG4gIFwiRG91YmxlRG90O1wiOjB4YTgsIFwiRG91YmxlRG93bkFycm93O1wiOjB4MjFkMyxcbiAgXCJEb3VibGVMZWZ0QXJyb3c7XCI6MHgyMWQwLCBcIkRvdWJsZUxlZnRSaWdodEFycm93O1wiOjB4MjFkNCxcbiAgXCJEb3VibGVMZWZ0VGVlO1wiOjB4MmFlNCwgXCJEb3VibGVMb25nTGVmdEFycm93O1wiOjB4MjdmOCxcbiAgXCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3c7XCI6MHgyN2ZhLCBcIkRvdWJsZUxvbmdSaWdodEFycm93O1wiOjB4MjdmOSxcbiAgXCJEb3VibGVSaWdodEFycm93O1wiOjB4MjFkMiwgXCJEb3VibGVSaWdodFRlZTtcIjoweDIyYTgsXG4gIFwiRG91YmxlVXBBcnJvdztcIjoweDIxZDEsIFwiRG91YmxlVXBEb3duQXJyb3c7XCI6MHgyMWQ1LFxuICBcIkRvdWJsZVZlcnRpY2FsQmFyO1wiOjB4MjIyNSwgXCJEb3duQXJyb3c7XCI6MHgyMTkzLFxuICBcIkRvd25BcnJvd0JhcjtcIjoweDI5MTMsIFwiRG93bkFycm93VXBBcnJvdztcIjoweDIxZjUsXG4gIFwiRG93bkJyZXZlO1wiOjB4MzExLCBcIkRvd25MZWZ0UmlnaHRWZWN0b3I7XCI6MHgyOTUwLFxuICBcIkRvd25MZWZ0VGVlVmVjdG9yO1wiOjB4Mjk1ZSwgXCJEb3duTGVmdFZlY3RvcjtcIjoweDIxYmQsXG4gIFwiRG93bkxlZnRWZWN0b3JCYXI7XCI6MHgyOTU2LCBcIkRvd25SaWdodFRlZVZlY3RvcjtcIjoweDI5NWYsXG4gIFwiRG93blJpZ2h0VmVjdG9yO1wiOjB4MjFjMSwgXCJEb3duUmlnaHRWZWN0b3JCYXI7XCI6MHgyOTU3LFxuICBcIkRvd25UZWU7XCI6MHgyMmE0LCBcIkRvd25UZWVBcnJvdztcIjoweDIxYTcsXG4gIFwiRG93bmFycm93O1wiOjB4MjFkMywgXCJEc2NyO1wiOlsweGQ4MzUsMHhkYzlmXSxcbiAgXCJEc3Ryb2s7XCI6MHgxMTAsIFwiRU5HO1wiOjB4MTRhLFxuICBcIkVUSFwiOjB4ZDAsIFwiRVRIO1wiOjB4ZDAsXG4gIFwiRWFjdXRlXCI6MHhjOSwgXCJFYWN1dGU7XCI6MHhjOSxcbiAgXCJFY2Fyb247XCI6MHgxMWEsIFwiRWNpcmNcIjoweGNhLFxuICBcIkVjaXJjO1wiOjB4Y2EsIFwiRWN5O1wiOjB4NDJkLFxuICBcIkVkb3Q7XCI6MHgxMTYsIFwiRWZyO1wiOlsweGQ4MzUsMHhkZDA4XSxcbiAgXCJFZ3JhdmVcIjoweGM4LCBcIkVncmF2ZTtcIjoweGM4LFxuICBcIkVsZW1lbnQ7XCI6MHgyMjA4LCBcIkVtYWNyO1wiOjB4MTEyLFxuICBcIkVtcHR5U21hbGxTcXVhcmU7XCI6MHgyNWZiLCBcIkVtcHR5VmVyeVNtYWxsU3F1YXJlO1wiOjB4MjVhYixcbiAgXCJFb2dvbjtcIjoweDExOCwgXCJFb3BmO1wiOlsweGQ4MzUsMHhkZDNjXSxcbiAgXCJFcHNpbG9uO1wiOjB4Mzk1LCBcIkVxdWFsO1wiOjB4MmE3NSxcbiAgXCJFcXVhbFRpbGRlO1wiOjB4MjI0MiwgXCJFcXVpbGlicml1bTtcIjoweDIxY2MsXG4gIFwiRXNjcjtcIjoweDIxMzAsIFwiRXNpbTtcIjoweDJhNzMsXG4gIFwiRXRhO1wiOjB4Mzk3LCBcIkV1bWxcIjoweGNiLFxuICBcIkV1bWw7XCI6MHhjYiwgXCJFeGlzdHM7XCI6MHgyMjAzLFxuICBcIkV4cG9uZW50aWFsRTtcIjoweDIxNDcsIFwiRmN5O1wiOjB4NDI0LFxuICBcIkZmcjtcIjpbMHhkODM1LDB4ZGQwOV0sIFwiRmlsbGVkU21hbGxTcXVhcmU7XCI6MHgyNWZjLFxuICBcIkZpbGxlZFZlcnlTbWFsbFNxdWFyZTtcIjoweDI1YWEsIFwiRm9wZjtcIjpbMHhkODM1LDB4ZGQzZF0sXG4gIFwiRm9yQWxsO1wiOjB4MjIwMCwgXCJGb3VyaWVydHJmO1wiOjB4MjEzMSxcbiAgXCJGc2NyO1wiOjB4MjEzMSwgXCJHSmN5O1wiOjB4NDAzLFxuICBcIkdUXCI6MHgzZSwgXCJHVDtcIjoweDNlLFxuICBcIkdhbW1hO1wiOjB4MzkzLCBcIkdhbW1hZDtcIjoweDNkYyxcbiAgXCJHYnJldmU7XCI6MHgxMWUsIFwiR2NlZGlsO1wiOjB4MTIyLFxuICBcIkdjaXJjO1wiOjB4MTFjLCBcIkdjeTtcIjoweDQxMyxcbiAgXCJHZG90O1wiOjB4MTIwLCBcIkdmcjtcIjpbMHhkODM1LDB4ZGQwYV0sXG4gIFwiR2c7XCI6MHgyMmQ5LCBcIkdvcGY7XCI6WzB4ZDgzNSwweGRkM2VdLFxuICBcIkdyZWF0ZXJFcXVhbDtcIjoweDIyNjUsIFwiR3JlYXRlckVxdWFsTGVzcztcIjoweDIyZGIsXG4gIFwiR3JlYXRlckZ1bGxFcXVhbDtcIjoweDIyNjcsIFwiR3JlYXRlckdyZWF0ZXI7XCI6MHgyYWEyLFxuICBcIkdyZWF0ZXJMZXNzO1wiOjB4MjI3NywgXCJHcmVhdGVyU2xhbnRFcXVhbDtcIjoweDJhN2UsXG4gIFwiR3JlYXRlclRpbGRlO1wiOjB4MjI3MywgXCJHc2NyO1wiOlsweGQ4MzUsMHhkY2EyXSxcbiAgXCJHdDtcIjoweDIyNmIsIFwiSEFSRGN5O1wiOjB4NDJhLFxuICBcIkhhY2VrO1wiOjB4MmM3LCBcIkhhdDtcIjoweDVlLFxuICBcIkhjaXJjO1wiOjB4MTI0LCBcIkhmcjtcIjoweDIxMGMsXG4gIFwiSGlsYmVydFNwYWNlO1wiOjB4MjEwYiwgXCJIb3BmO1wiOjB4MjEwZCxcbiAgXCJIb3Jpem9udGFsTGluZTtcIjoweDI1MDAsIFwiSHNjcjtcIjoweDIxMGIsXG4gIFwiSHN0cm9rO1wiOjB4MTI2LCBcIkh1bXBEb3duSHVtcDtcIjoweDIyNGUsXG4gIFwiSHVtcEVxdWFsO1wiOjB4MjI0ZiwgXCJJRWN5O1wiOjB4NDE1LFxuICBcIklKbGlnO1wiOjB4MTMyLCBcIklPY3k7XCI6MHg0MDEsXG4gIFwiSWFjdXRlXCI6MHhjZCwgXCJJYWN1dGU7XCI6MHhjZCxcbiAgXCJJY2lyY1wiOjB4Y2UsIFwiSWNpcmM7XCI6MHhjZSxcbiAgXCJJY3k7XCI6MHg0MTgsIFwiSWRvdDtcIjoweDEzMCxcbiAgXCJJZnI7XCI6MHgyMTExLCBcIklncmF2ZVwiOjB4Y2MsXG4gIFwiSWdyYXZlO1wiOjB4Y2MsIFwiSW07XCI6MHgyMTExLFxuICBcIkltYWNyO1wiOjB4MTJhLCBcIkltYWdpbmFyeUk7XCI6MHgyMTQ4LFxuICBcIkltcGxpZXM7XCI6MHgyMWQyLCBcIkludDtcIjoweDIyMmMsXG4gIFwiSW50ZWdyYWw7XCI6MHgyMjJiLCBcIkludGVyc2VjdGlvbjtcIjoweDIyYzIsXG4gIFwiSW52aXNpYmxlQ29tbWE7XCI6MHgyMDYzLCBcIkludmlzaWJsZVRpbWVzO1wiOjB4MjA2MixcbiAgXCJJb2dvbjtcIjoweDEyZSwgXCJJb3BmO1wiOlsweGQ4MzUsMHhkZDQwXSxcbiAgXCJJb3RhO1wiOjB4Mzk5LCBcIklzY3I7XCI6MHgyMTEwLFxuICBcIkl0aWxkZTtcIjoweDEyOCwgXCJJdWtjeTtcIjoweDQwNixcbiAgXCJJdW1sXCI6MHhjZiwgXCJJdW1sO1wiOjB4Y2YsXG4gIFwiSmNpcmM7XCI6MHgxMzQsIFwiSmN5O1wiOjB4NDE5LFxuICBcIkpmcjtcIjpbMHhkODM1LDB4ZGQwZF0sIFwiSm9wZjtcIjpbMHhkODM1LDB4ZGQ0MV0sXG4gIFwiSnNjcjtcIjpbMHhkODM1LDB4ZGNhNV0sIFwiSnNlcmN5O1wiOjB4NDA4LFxuICBcIkp1a2N5O1wiOjB4NDA0LCBcIktIY3k7XCI6MHg0MjUsXG4gIFwiS0pjeTtcIjoweDQwYywgXCJLYXBwYTtcIjoweDM5YSxcbiAgXCJLY2VkaWw7XCI6MHgxMzYsIFwiS2N5O1wiOjB4NDFhLFxuICBcIktmcjtcIjpbMHhkODM1LDB4ZGQwZV0sIFwiS29wZjtcIjpbMHhkODM1LDB4ZGQ0Ml0sXG4gIFwiS3NjcjtcIjpbMHhkODM1LDB4ZGNhNl0sIFwiTEpjeTtcIjoweDQwOSxcbiAgXCJMVFwiOjB4M2MsIFwiTFQ7XCI6MHgzYyxcbiAgXCJMYWN1dGU7XCI6MHgxMzksIFwiTGFtYmRhO1wiOjB4MzliLFxuICBcIkxhbmc7XCI6MHgyN2VhLCBcIkxhcGxhY2V0cmY7XCI6MHgyMTEyLFxuICBcIkxhcnI7XCI6MHgyMTllLCBcIkxjYXJvbjtcIjoweDEzZCxcbiAgXCJMY2VkaWw7XCI6MHgxM2IsIFwiTGN5O1wiOjB4NDFiLFxuICBcIkxlZnRBbmdsZUJyYWNrZXQ7XCI6MHgyN2U4LCBcIkxlZnRBcnJvdztcIjoweDIxOTAsXG4gIFwiTGVmdEFycm93QmFyO1wiOjB4MjFlNCwgXCJMZWZ0QXJyb3dSaWdodEFycm93O1wiOjB4MjFjNixcbiAgXCJMZWZ0Q2VpbGluZztcIjoweDIzMDgsIFwiTGVmdERvdWJsZUJyYWNrZXQ7XCI6MHgyN2U2LFxuICBcIkxlZnREb3duVGVlVmVjdG9yO1wiOjB4Mjk2MSwgXCJMZWZ0RG93blZlY3RvcjtcIjoweDIxYzMsXG4gIFwiTGVmdERvd25WZWN0b3JCYXI7XCI6MHgyOTU5LCBcIkxlZnRGbG9vcjtcIjoweDIzMGEsXG4gIFwiTGVmdFJpZ2h0QXJyb3c7XCI6MHgyMTk0LCBcIkxlZnRSaWdodFZlY3RvcjtcIjoweDI5NGUsXG4gIFwiTGVmdFRlZTtcIjoweDIyYTMsIFwiTGVmdFRlZUFycm93O1wiOjB4MjFhNCxcbiAgXCJMZWZ0VGVlVmVjdG9yO1wiOjB4Mjk1YSwgXCJMZWZ0VHJpYW5nbGU7XCI6MHgyMmIyLFxuICBcIkxlZnRUcmlhbmdsZUJhcjtcIjoweDI5Y2YsIFwiTGVmdFRyaWFuZ2xlRXF1YWw7XCI6MHgyMmI0LFxuICBcIkxlZnRVcERvd25WZWN0b3I7XCI6MHgyOTUxLCBcIkxlZnRVcFRlZVZlY3RvcjtcIjoweDI5NjAsXG4gIFwiTGVmdFVwVmVjdG9yO1wiOjB4MjFiZiwgXCJMZWZ0VXBWZWN0b3JCYXI7XCI6MHgyOTU4LFxuICBcIkxlZnRWZWN0b3I7XCI6MHgyMWJjLCBcIkxlZnRWZWN0b3JCYXI7XCI6MHgyOTUyLFxuICBcIkxlZnRhcnJvdztcIjoweDIxZDAsIFwiTGVmdHJpZ2h0YXJyb3c7XCI6MHgyMWQ0LFxuICBcIkxlc3NFcXVhbEdyZWF0ZXI7XCI6MHgyMmRhLCBcIkxlc3NGdWxsRXF1YWw7XCI6MHgyMjY2LFxuICBcIkxlc3NHcmVhdGVyO1wiOjB4MjI3NiwgXCJMZXNzTGVzcztcIjoweDJhYTEsXG4gIFwiTGVzc1NsYW50RXF1YWw7XCI6MHgyYTdkLCBcIkxlc3NUaWxkZTtcIjoweDIyNzIsXG4gIFwiTGZyO1wiOlsweGQ4MzUsMHhkZDBmXSwgXCJMbDtcIjoweDIyZDgsXG4gIFwiTGxlZnRhcnJvdztcIjoweDIxZGEsIFwiTG1pZG90O1wiOjB4MTNmLFxuICBcIkxvbmdMZWZ0QXJyb3c7XCI6MHgyN2Y1LCBcIkxvbmdMZWZ0UmlnaHRBcnJvdztcIjoweDI3ZjcsXG4gIFwiTG9uZ1JpZ2h0QXJyb3c7XCI6MHgyN2Y2LCBcIkxvbmdsZWZ0YXJyb3c7XCI6MHgyN2Y4LFxuICBcIkxvbmdsZWZ0cmlnaHRhcnJvdztcIjoweDI3ZmEsIFwiTG9uZ3JpZ2h0YXJyb3c7XCI6MHgyN2Y5LFxuICBcIkxvcGY7XCI6WzB4ZDgzNSwweGRkNDNdLCBcIkxvd2VyTGVmdEFycm93O1wiOjB4MjE5OSxcbiAgXCJMb3dlclJpZ2h0QXJyb3c7XCI6MHgyMTk4LCBcIkxzY3I7XCI6MHgyMTEyLFxuICBcIkxzaDtcIjoweDIxYjAsIFwiTHN0cm9rO1wiOjB4MTQxLFxuICBcIkx0O1wiOjB4MjI2YSwgXCJNYXA7XCI6MHgyOTA1LFxuICBcIk1jeTtcIjoweDQxYywgXCJNZWRpdW1TcGFjZTtcIjoweDIwNWYsXG4gIFwiTWVsbGludHJmO1wiOjB4MjEzMywgXCJNZnI7XCI6WzB4ZDgzNSwweGRkMTBdLFxuICBcIk1pbnVzUGx1cztcIjoweDIyMTMsIFwiTW9wZjtcIjpbMHhkODM1LDB4ZGQ0NF0sXG4gIFwiTXNjcjtcIjoweDIxMzMsIFwiTXU7XCI6MHgzOWMsXG4gIFwiTkpjeTtcIjoweDQwYSwgXCJOYWN1dGU7XCI6MHgxNDMsXG4gIFwiTmNhcm9uO1wiOjB4MTQ3LCBcIk5jZWRpbDtcIjoweDE0NSxcbiAgXCJOY3k7XCI6MHg0MWQsIFwiTmVnYXRpdmVNZWRpdW1TcGFjZTtcIjoweDIwMGIsXG4gIFwiTmVnYXRpdmVUaGlja1NwYWNlO1wiOjB4MjAwYiwgXCJOZWdhdGl2ZVRoaW5TcGFjZTtcIjoweDIwMGIsXG4gIFwiTmVnYXRpdmVWZXJ5VGhpblNwYWNlO1wiOjB4MjAwYiwgXCJOZXN0ZWRHcmVhdGVyR3JlYXRlcjtcIjoweDIyNmIsXG4gIFwiTmVzdGVkTGVzc0xlc3M7XCI6MHgyMjZhLCBcIk5ld0xpbmU7XCI6MHhhLFxuICBcIk5mcjtcIjpbMHhkODM1LDB4ZGQxMV0sIFwiTm9CcmVhaztcIjoweDIwNjAsXG4gIFwiTm9uQnJlYWtpbmdTcGFjZTtcIjoweGEwLCBcIk5vcGY7XCI6MHgyMTE1LFxuICBcIk5vdDtcIjoweDJhZWMsIFwiTm90Q29uZ3J1ZW50O1wiOjB4MjI2MixcbiAgXCJOb3RDdXBDYXA7XCI6MHgyMjZkLCBcIk5vdERvdWJsZVZlcnRpY2FsQmFyO1wiOjB4MjIyNixcbiAgXCJOb3RFbGVtZW50O1wiOjB4MjIwOSwgXCJOb3RFcXVhbDtcIjoweDIyNjAsXG4gIFwiTm90RXF1YWxUaWxkZTtcIjpbMHgyMjQyLDB4MzM4XSwgXCJOb3RFeGlzdHM7XCI6MHgyMjA0LFxuICBcIk5vdEdyZWF0ZXI7XCI6MHgyMjZmLCBcIk5vdEdyZWF0ZXJFcXVhbDtcIjoweDIyNzEsXG4gIFwiTm90R3JlYXRlckZ1bGxFcXVhbDtcIjpbMHgyMjY3LDB4MzM4XSwgXCJOb3RHcmVhdGVyR3JlYXRlcjtcIjpbMHgyMjZiLDB4MzM4XSxcbiAgXCJOb3RHcmVhdGVyTGVzcztcIjoweDIyNzksIFwiTm90R3JlYXRlclNsYW50RXF1YWw7XCI6WzB4MmE3ZSwweDMzOF0sXG4gIFwiTm90R3JlYXRlclRpbGRlO1wiOjB4MjI3NSwgXCJOb3RIdW1wRG93bkh1bXA7XCI6WzB4MjI0ZSwweDMzOF0sXG4gIFwiTm90SHVtcEVxdWFsO1wiOlsweDIyNGYsMHgzMzhdLCBcIk5vdExlZnRUcmlhbmdsZTtcIjoweDIyZWEsXG4gIFwiTm90TGVmdFRyaWFuZ2xlQmFyO1wiOlsweDI5Y2YsMHgzMzhdLCBcIk5vdExlZnRUcmlhbmdsZUVxdWFsO1wiOjB4MjJlYyxcbiAgXCJOb3RMZXNzO1wiOjB4MjI2ZSwgXCJOb3RMZXNzRXF1YWw7XCI6MHgyMjcwLFxuICBcIk5vdExlc3NHcmVhdGVyO1wiOjB4MjI3OCwgXCJOb3RMZXNzTGVzcztcIjpbMHgyMjZhLDB4MzM4XSxcbiAgXCJOb3RMZXNzU2xhbnRFcXVhbDtcIjpbMHgyYTdkLDB4MzM4XSwgXCJOb3RMZXNzVGlsZGU7XCI6MHgyMjc0LFxuICBcIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyO1wiOlsweDJhYTIsMHgzMzhdLCBcIk5vdE5lc3RlZExlc3NMZXNzO1wiOlsweDJhYTEsMHgzMzhdLFxuICBcIk5vdFByZWNlZGVzO1wiOjB4MjI4MCwgXCJOb3RQcmVjZWRlc0VxdWFsO1wiOlsweDJhYWYsMHgzMzhdLFxuICBcIk5vdFByZWNlZGVzU2xhbnRFcXVhbDtcIjoweDIyZTAsIFwiTm90UmV2ZXJzZUVsZW1lbnQ7XCI6MHgyMjBjLFxuICBcIk5vdFJpZ2h0VHJpYW5nbGU7XCI6MHgyMmViLCBcIk5vdFJpZ2h0VHJpYW5nbGVCYXI7XCI6WzB4MjlkMCwweDMzOF0sXG4gIFwiTm90UmlnaHRUcmlhbmdsZUVxdWFsO1wiOjB4MjJlZCwgXCJOb3RTcXVhcmVTdWJzZXQ7XCI6WzB4MjI4ZiwweDMzOF0sXG4gIFwiTm90U3F1YXJlU3Vic2V0RXF1YWw7XCI6MHgyMmUyLCBcIk5vdFNxdWFyZVN1cGVyc2V0O1wiOlsweDIyOTAsMHgzMzhdLFxuICBcIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWw7XCI6MHgyMmUzLCBcIk5vdFN1YnNldDtcIjpbMHgyMjgyLDB4MjBkMl0sXG4gIFwiTm90U3Vic2V0RXF1YWw7XCI6MHgyMjg4LCBcIk5vdFN1Y2NlZWRzO1wiOjB4MjI4MSxcbiAgXCJOb3RTdWNjZWVkc0VxdWFsO1wiOlsweDJhYjAsMHgzMzhdLCBcIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbDtcIjoweDIyZTEsXG4gIFwiTm90U3VjY2VlZHNUaWxkZTtcIjpbMHgyMjdmLDB4MzM4XSwgXCJOb3RTdXBlcnNldDtcIjpbMHgyMjgzLDB4MjBkMl0sXG4gIFwiTm90U3VwZXJzZXRFcXVhbDtcIjoweDIyODksIFwiTm90VGlsZGU7XCI6MHgyMjQxLFxuICBcIk5vdFRpbGRlRXF1YWw7XCI6MHgyMjQ0LCBcIk5vdFRpbGRlRnVsbEVxdWFsO1wiOjB4MjI0NyxcbiAgXCJOb3RUaWxkZVRpbGRlO1wiOjB4MjI0OSwgXCJOb3RWZXJ0aWNhbEJhcjtcIjoweDIyMjQsXG4gIFwiTnNjcjtcIjpbMHhkODM1LDB4ZGNhOV0sIFwiTnRpbGRlXCI6MHhkMSxcbiAgXCJOdGlsZGU7XCI6MHhkMSwgXCJOdTtcIjoweDM5ZCxcbiAgXCJPRWxpZztcIjoweDE1MiwgXCJPYWN1dGVcIjoweGQzLFxuICBcIk9hY3V0ZTtcIjoweGQzLCBcIk9jaXJjXCI6MHhkNCxcbiAgXCJPY2lyYztcIjoweGQ0LCBcIk9jeTtcIjoweDQxZSxcbiAgXCJPZGJsYWM7XCI6MHgxNTAsIFwiT2ZyO1wiOlsweGQ4MzUsMHhkZDEyXSxcbiAgXCJPZ3JhdmVcIjoweGQyLCBcIk9ncmF2ZTtcIjoweGQyLFxuICBcIk9tYWNyO1wiOjB4MTRjLCBcIk9tZWdhO1wiOjB4M2E5LFxuICBcIk9taWNyb247XCI6MHgzOWYsIFwiT29wZjtcIjpbMHhkODM1LDB4ZGQ0Nl0sXG4gIFwiT3BlbkN1cmx5RG91YmxlUXVvdGU7XCI6MHgyMDFjLCBcIk9wZW5DdXJseVF1b3RlO1wiOjB4MjAxOCxcbiAgXCJPcjtcIjoweDJhNTQsIFwiT3NjcjtcIjpbMHhkODM1LDB4ZGNhYV0sXG4gIFwiT3NsYXNoXCI6MHhkOCwgXCJPc2xhc2g7XCI6MHhkOCxcbiAgXCJPdGlsZGVcIjoweGQ1LCBcIk90aWxkZTtcIjoweGQ1LFxuICBcIk90aW1lcztcIjoweDJhMzcsIFwiT3VtbFwiOjB4ZDYsXG4gIFwiT3VtbDtcIjoweGQ2LCBcIk92ZXJCYXI7XCI6MHgyMDNlLFxuICBcIk92ZXJCcmFjZTtcIjoweDIzZGUsIFwiT3ZlckJyYWNrZXQ7XCI6MHgyM2I0LFxuICBcIk92ZXJQYXJlbnRoZXNpcztcIjoweDIzZGMsIFwiUGFydGlhbEQ7XCI6MHgyMjAyLFxuICBcIlBjeTtcIjoweDQxZiwgXCJQZnI7XCI6WzB4ZDgzNSwweGRkMTNdLFxuICBcIlBoaTtcIjoweDNhNiwgXCJQaTtcIjoweDNhMCxcbiAgXCJQbHVzTWludXM7XCI6MHhiMSwgXCJQb2luY2FyZXBsYW5lO1wiOjB4MjEwYyxcbiAgXCJQb3BmO1wiOjB4MjExOSwgXCJQcjtcIjoweDJhYmIsXG4gIFwiUHJlY2VkZXM7XCI6MHgyMjdhLCBcIlByZWNlZGVzRXF1YWw7XCI6MHgyYWFmLFxuICBcIlByZWNlZGVzU2xhbnRFcXVhbDtcIjoweDIyN2MsIFwiUHJlY2VkZXNUaWxkZTtcIjoweDIyN2UsXG4gIFwiUHJpbWU7XCI6MHgyMDMzLCBcIlByb2R1Y3Q7XCI6MHgyMjBmLFxuICBcIlByb3BvcnRpb247XCI6MHgyMjM3LCBcIlByb3BvcnRpb25hbDtcIjoweDIyMWQsXG4gIFwiUHNjcjtcIjpbMHhkODM1LDB4ZGNhYl0sIFwiUHNpO1wiOjB4M2E4LFxuICBcIlFVT1RcIjoweDIyLCBcIlFVT1Q7XCI6MHgyMixcbiAgXCJRZnI7XCI6WzB4ZDgzNSwweGRkMTRdLCBcIlFvcGY7XCI6MHgyMTFhLFxuICBcIlFzY3I7XCI6WzB4ZDgzNSwweGRjYWNdLCBcIlJCYXJyO1wiOjB4MjkxMCxcbiAgXCJSRUdcIjoweGFlLCBcIlJFRztcIjoweGFlLFxuICBcIlJhY3V0ZTtcIjoweDE1NCwgXCJSYW5nO1wiOjB4MjdlYixcbiAgXCJSYXJyO1wiOjB4MjFhMCwgXCJSYXJydGw7XCI6MHgyOTE2LFxuICBcIlJjYXJvbjtcIjoweDE1OCwgXCJSY2VkaWw7XCI6MHgxNTYsXG4gIFwiUmN5O1wiOjB4NDIwLCBcIlJlO1wiOjB4MjExYyxcbiAgXCJSZXZlcnNlRWxlbWVudDtcIjoweDIyMGIsIFwiUmV2ZXJzZUVxdWlsaWJyaXVtO1wiOjB4MjFjYixcbiAgXCJSZXZlcnNlVXBFcXVpbGlicml1bTtcIjoweDI5NmYsIFwiUmZyO1wiOjB4MjExYyxcbiAgXCJSaG87XCI6MHgzYTEsIFwiUmlnaHRBbmdsZUJyYWNrZXQ7XCI6MHgyN2U5LFxuICBcIlJpZ2h0QXJyb3c7XCI6MHgyMTkyLCBcIlJpZ2h0QXJyb3dCYXI7XCI6MHgyMWU1LFxuICBcIlJpZ2h0QXJyb3dMZWZ0QXJyb3c7XCI6MHgyMWM0LCBcIlJpZ2h0Q2VpbGluZztcIjoweDIzMDksXG4gIFwiUmlnaHREb3VibGVCcmFja2V0O1wiOjB4MjdlNywgXCJSaWdodERvd25UZWVWZWN0b3I7XCI6MHgyOTVkLFxuICBcIlJpZ2h0RG93blZlY3RvcjtcIjoweDIxYzIsIFwiUmlnaHREb3duVmVjdG9yQmFyO1wiOjB4Mjk1NSxcbiAgXCJSaWdodEZsb29yO1wiOjB4MjMwYiwgXCJSaWdodFRlZTtcIjoweDIyYTIsXG4gIFwiUmlnaHRUZWVBcnJvdztcIjoweDIxYTYsIFwiUmlnaHRUZWVWZWN0b3I7XCI6MHgyOTViLFxuICBcIlJpZ2h0VHJpYW5nbGU7XCI6MHgyMmIzLCBcIlJpZ2h0VHJpYW5nbGVCYXI7XCI6MHgyOWQwLFxuICBcIlJpZ2h0VHJpYW5nbGVFcXVhbDtcIjoweDIyYjUsIFwiUmlnaHRVcERvd25WZWN0b3I7XCI6MHgyOTRmLFxuICBcIlJpZ2h0VXBUZWVWZWN0b3I7XCI6MHgyOTVjLCBcIlJpZ2h0VXBWZWN0b3I7XCI6MHgyMWJlLFxuICBcIlJpZ2h0VXBWZWN0b3JCYXI7XCI6MHgyOTU0LCBcIlJpZ2h0VmVjdG9yO1wiOjB4MjFjMCxcbiAgXCJSaWdodFZlY3RvckJhcjtcIjoweDI5NTMsIFwiUmlnaHRhcnJvdztcIjoweDIxZDIsXG4gIFwiUm9wZjtcIjoweDIxMWQsIFwiUm91bmRJbXBsaWVzO1wiOjB4Mjk3MCxcbiAgXCJScmlnaHRhcnJvdztcIjoweDIxZGIsIFwiUnNjcjtcIjoweDIxMWIsXG4gIFwiUnNoO1wiOjB4MjFiMSwgXCJSdWxlRGVsYXllZDtcIjoweDI5ZjQsXG4gIFwiU0hDSGN5O1wiOjB4NDI5LCBcIlNIY3k7XCI6MHg0MjgsXG4gIFwiU09GVGN5O1wiOjB4NDJjLCBcIlNhY3V0ZTtcIjoweDE1YSxcbiAgXCJTYztcIjoweDJhYmMsIFwiU2Nhcm9uO1wiOjB4MTYwLFxuICBcIlNjZWRpbDtcIjoweDE1ZSwgXCJTY2lyYztcIjoweDE1YyxcbiAgXCJTY3k7XCI6MHg0MjEsIFwiU2ZyO1wiOlsweGQ4MzUsMHhkZDE2XSxcbiAgXCJTaG9ydERvd25BcnJvdztcIjoweDIxOTMsIFwiU2hvcnRMZWZ0QXJyb3c7XCI6MHgyMTkwLFxuICBcIlNob3J0UmlnaHRBcnJvdztcIjoweDIxOTIsIFwiU2hvcnRVcEFycm93O1wiOjB4MjE5MSxcbiAgXCJTaWdtYTtcIjoweDNhMywgXCJTbWFsbENpcmNsZTtcIjoweDIyMTgsXG4gIFwiU29wZjtcIjpbMHhkODM1LDB4ZGQ0YV0sIFwiU3FydDtcIjoweDIyMWEsXG4gIFwiU3F1YXJlO1wiOjB4MjVhMSwgXCJTcXVhcmVJbnRlcnNlY3Rpb247XCI6MHgyMjkzLFxuICBcIlNxdWFyZVN1YnNldDtcIjoweDIyOGYsIFwiU3F1YXJlU3Vic2V0RXF1YWw7XCI6MHgyMjkxLFxuICBcIlNxdWFyZVN1cGVyc2V0O1wiOjB4MjI5MCwgXCJTcXVhcmVTdXBlcnNldEVxdWFsO1wiOjB4MjI5MixcbiAgXCJTcXVhcmVVbmlvbjtcIjoweDIyOTQsIFwiU3NjcjtcIjpbMHhkODM1LDB4ZGNhZV0sXG4gIFwiU3RhcjtcIjoweDIyYzYsIFwiU3ViO1wiOjB4MjJkMCxcbiAgXCJTdWJzZXQ7XCI6MHgyMmQwLCBcIlN1YnNldEVxdWFsO1wiOjB4MjI4NixcbiAgXCJTdWNjZWVkcztcIjoweDIyN2IsIFwiU3VjY2VlZHNFcXVhbDtcIjoweDJhYjAsXG4gIFwiU3VjY2VlZHNTbGFudEVxdWFsO1wiOjB4MjI3ZCwgXCJTdWNjZWVkc1RpbGRlO1wiOjB4MjI3ZixcbiAgXCJTdWNoVGhhdDtcIjoweDIyMGIsIFwiU3VtO1wiOjB4MjIxMSxcbiAgXCJTdXA7XCI6MHgyMmQxLCBcIlN1cGVyc2V0O1wiOjB4MjI4MyxcbiAgXCJTdXBlcnNldEVxdWFsO1wiOjB4MjI4NywgXCJTdXBzZXQ7XCI6MHgyMmQxLFxuICBcIlRIT1JOXCI6MHhkZSwgXCJUSE9STjtcIjoweGRlLFxuICBcIlRSQURFO1wiOjB4MjEyMiwgXCJUU0hjeTtcIjoweDQwYixcbiAgXCJUU2N5O1wiOjB4NDI2LCBcIlRhYjtcIjoweDksXG4gIFwiVGF1O1wiOjB4M2E0LCBcIlRjYXJvbjtcIjoweDE2NCxcbiAgXCJUY2VkaWw7XCI6MHgxNjIsIFwiVGN5O1wiOjB4NDIyLFxuICBcIlRmcjtcIjpbMHhkODM1LDB4ZGQxN10sIFwiVGhlcmVmb3JlO1wiOjB4MjIzNCxcbiAgXCJUaGV0YTtcIjoweDM5OCwgXCJUaGlja1NwYWNlO1wiOlsweDIwNWYsMHgyMDBhXSxcbiAgXCJUaGluU3BhY2U7XCI6MHgyMDA5LCBcIlRpbGRlO1wiOjB4MjIzYyxcbiAgXCJUaWxkZUVxdWFsO1wiOjB4MjI0MywgXCJUaWxkZUZ1bGxFcXVhbDtcIjoweDIyNDUsXG4gIFwiVGlsZGVUaWxkZTtcIjoweDIyNDgsIFwiVG9wZjtcIjpbMHhkODM1LDB4ZGQ0Yl0sXG4gIFwiVHJpcGxlRG90O1wiOjB4MjBkYiwgXCJUc2NyO1wiOlsweGQ4MzUsMHhkY2FmXSxcbiAgXCJUc3Ryb2s7XCI6MHgxNjYsIFwiVWFjdXRlXCI6MHhkYSxcbiAgXCJVYWN1dGU7XCI6MHhkYSwgXCJVYXJyO1wiOjB4MjE5ZixcbiAgXCJVYXJyb2NpcjtcIjoweDI5NDksIFwiVWJyY3k7XCI6MHg0MGUsXG4gIFwiVWJyZXZlO1wiOjB4MTZjLCBcIlVjaXJjXCI6MHhkYixcbiAgXCJVY2lyYztcIjoweGRiLCBcIlVjeTtcIjoweDQyMyxcbiAgXCJVZGJsYWM7XCI6MHgxNzAsIFwiVWZyO1wiOlsweGQ4MzUsMHhkZDE4XSxcbiAgXCJVZ3JhdmVcIjoweGQ5LCBcIlVncmF2ZTtcIjoweGQ5LFxuICBcIlVtYWNyO1wiOjB4MTZhLCBcIlVuZGVyQmFyO1wiOjB4NWYsXG4gIFwiVW5kZXJCcmFjZTtcIjoweDIzZGYsIFwiVW5kZXJCcmFja2V0O1wiOjB4MjNiNSxcbiAgXCJVbmRlclBhcmVudGhlc2lzO1wiOjB4MjNkZCwgXCJVbmlvbjtcIjoweDIyYzMsXG4gIFwiVW5pb25QbHVzO1wiOjB4MjI4ZSwgXCJVb2dvbjtcIjoweDE3MixcbiAgXCJVb3BmO1wiOlsweGQ4MzUsMHhkZDRjXSwgXCJVcEFycm93O1wiOjB4MjE5MSxcbiAgXCJVcEFycm93QmFyO1wiOjB4MjkxMiwgXCJVcEFycm93RG93bkFycm93O1wiOjB4MjFjNSxcbiAgXCJVcERvd25BcnJvdztcIjoweDIxOTUsIFwiVXBFcXVpbGlicml1bTtcIjoweDI5NmUsXG4gIFwiVXBUZWU7XCI6MHgyMmE1LCBcIlVwVGVlQXJyb3c7XCI6MHgyMWE1LFxuICBcIlVwYXJyb3c7XCI6MHgyMWQxLCBcIlVwZG93bmFycm93O1wiOjB4MjFkNSxcbiAgXCJVcHBlckxlZnRBcnJvdztcIjoweDIxOTYsIFwiVXBwZXJSaWdodEFycm93O1wiOjB4MjE5NyxcbiAgXCJVcHNpO1wiOjB4M2QyLCBcIlVwc2lsb247XCI6MHgzYTUsXG4gIFwiVXJpbmc7XCI6MHgxNmUsIFwiVXNjcjtcIjpbMHhkODM1LDB4ZGNiMF0sXG4gIFwiVXRpbGRlO1wiOjB4MTY4LCBcIlV1bWxcIjoweGRjLFxuICBcIlV1bWw7XCI6MHhkYywgXCJWRGFzaDtcIjoweDIyYWIsXG4gIFwiVmJhcjtcIjoweDJhZWIsIFwiVmN5O1wiOjB4NDEyLFxuICBcIlZkYXNoO1wiOjB4MjJhOSwgXCJWZGFzaGw7XCI6MHgyYWU2LFxuICBcIlZlZTtcIjoweDIyYzEsIFwiVmVyYmFyO1wiOjB4MjAxNixcbiAgXCJWZXJ0O1wiOjB4MjAxNiwgXCJWZXJ0aWNhbEJhcjtcIjoweDIyMjMsXG4gIFwiVmVydGljYWxMaW5lO1wiOjB4N2MsIFwiVmVydGljYWxTZXBhcmF0b3I7XCI6MHgyNzU4LFxuICBcIlZlcnRpY2FsVGlsZGU7XCI6MHgyMjQwLCBcIlZlcnlUaGluU3BhY2U7XCI6MHgyMDBhLFxuICBcIlZmcjtcIjpbMHhkODM1LDB4ZGQxOV0sIFwiVm9wZjtcIjpbMHhkODM1LDB4ZGQ0ZF0sXG4gIFwiVnNjcjtcIjpbMHhkODM1LDB4ZGNiMV0sIFwiVnZkYXNoO1wiOjB4MjJhYSxcbiAgXCJXY2lyYztcIjoweDE3NCwgXCJXZWRnZTtcIjoweDIyYzAsXG4gIFwiV2ZyO1wiOlsweGQ4MzUsMHhkZDFhXSwgXCJXb3BmO1wiOlsweGQ4MzUsMHhkZDRlXSxcbiAgXCJXc2NyO1wiOlsweGQ4MzUsMHhkY2IyXSwgXCJYZnI7XCI6WzB4ZDgzNSwweGRkMWJdLFxuICBcIlhpO1wiOjB4MzllLCBcIlhvcGY7XCI6WzB4ZDgzNSwweGRkNGZdLFxuICBcIlhzY3I7XCI6WzB4ZDgzNSwweGRjYjNdLCBcIllBY3k7XCI6MHg0MmYsXG4gIFwiWUljeTtcIjoweDQwNywgXCJZVWN5O1wiOjB4NDJlLFxuICBcIllhY3V0ZVwiOjB4ZGQsIFwiWWFjdXRlO1wiOjB4ZGQsXG4gIFwiWWNpcmM7XCI6MHgxNzYsIFwiWWN5O1wiOjB4NDJiLFxuICBcIllmcjtcIjpbMHhkODM1LDB4ZGQxY10sIFwiWW9wZjtcIjpbMHhkODM1LDB4ZGQ1MF0sXG4gIFwiWXNjcjtcIjpbMHhkODM1LDB4ZGNiNF0sIFwiWXVtbDtcIjoweDE3OCxcbiAgXCJaSGN5O1wiOjB4NDE2LCBcIlphY3V0ZTtcIjoweDE3OSxcbiAgXCJaY2Fyb247XCI6MHgxN2QsIFwiWmN5O1wiOjB4NDE3LFxuICBcIlpkb3Q7XCI6MHgxN2IsIFwiWmVyb1dpZHRoU3BhY2U7XCI6MHgyMDBiLFxuICBcIlpldGE7XCI6MHgzOTYsIFwiWmZyO1wiOjB4MjEyOCxcbiAgXCJab3BmO1wiOjB4MjEyNCwgXCJac2NyO1wiOlsweGQ4MzUsMHhkY2I1XSxcbiAgXCJhYWN1dGVcIjoweGUxLCBcImFhY3V0ZTtcIjoweGUxLFxuICBcImFicmV2ZTtcIjoweDEwMywgXCJhYztcIjoweDIyM2UsXG4gIFwiYWNFO1wiOlsweDIyM2UsMHgzMzNdLCBcImFjZDtcIjoweDIyM2YsXG4gIFwiYWNpcmNcIjoweGUyLCBcImFjaXJjO1wiOjB4ZTIsXG4gIFwiYWN1dGVcIjoweGI0LCBcImFjdXRlO1wiOjB4YjQsXG4gIFwiYWN5O1wiOjB4NDMwLCBcImFlbGlnXCI6MHhlNixcbiAgXCJhZWxpZztcIjoweGU2LCBcImFmO1wiOjB4MjA2MSxcbiAgXCJhZnI7XCI6WzB4ZDgzNSwweGRkMWVdLCBcImFncmF2ZVwiOjB4ZTAsXG4gIFwiYWdyYXZlO1wiOjB4ZTAsIFwiYWxlZnN5bTtcIjoweDIxMzUsXG4gIFwiYWxlcGg7XCI6MHgyMTM1LCBcImFscGhhO1wiOjB4M2IxLFxuICBcImFtYWNyO1wiOjB4MTAxLCBcImFtYWxnO1wiOjB4MmEzZixcbiAgXCJhbXBcIjoweDI2LCBcImFtcDtcIjoweDI2LFxuICBcImFuZDtcIjoweDIyMjcsIFwiYW5kYW5kO1wiOjB4MmE1NSxcbiAgXCJhbmRkO1wiOjB4MmE1YywgXCJhbmRzbG9wZTtcIjoweDJhNTgsXG4gIFwiYW5kdjtcIjoweDJhNWEsIFwiYW5nO1wiOjB4MjIyMCxcbiAgXCJhbmdlO1wiOjB4MjlhNCwgXCJhbmdsZTtcIjoweDIyMjAsXG4gIFwiYW5nbXNkO1wiOjB4MjIyMSwgXCJhbmdtc2RhYTtcIjoweDI5YTgsXG4gIFwiYW5nbXNkYWI7XCI6MHgyOWE5LCBcImFuZ21zZGFjO1wiOjB4MjlhYSxcbiAgXCJhbmdtc2RhZDtcIjoweDI5YWIsIFwiYW5nbXNkYWU7XCI6MHgyOWFjLFxuICBcImFuZ21zZGFmO1wiOjB4MjlhZCwgXCJhbmdtc2RhZztcIjoweDI5YWUsXG4gIFwiYW5nbXNkYWg7XCI6MHgyOWFmLCBcImFuZ3J0O1wiOjB4MjIxZixcbiAgXCJhbmdydHZiO1wiOjB4MjJiZSwgXCJhbmdydHZiZDtcIjoweDI5OWQsXG4gIFwiYW5nc3BoO1wiOjB4MjIyMiwgXCJhbmdzdDtcIjoweGM1LFxuICBcImFuZ3phcnI7XCI6MHgyMzdjLCBcImFvZ29uO1wiOjB4MTA1LFxuICBcImFvcGY7XCI6WzB4ZDgzNSwweGRkNTJdLCBcImFwO1wiOjB4MjI0OCxcbiAgXCJhcEU7XCI6MHgyYTcwLCBcImFwYWNpcjtcIjoweDJhNmYsXG4gIFwiYXBlO1wiOjB4MjI0YSwgXCJhcGlkO1wiOjB4MjI0YixcbiAgXCJhcG9zO1wiOjB4MjcsIFwiYXBwcm94O1wiOjB4MjI0OCxcbiAgXCJhcHByb3hlcTtcIjoweDIyNGEsIFwiYXJpbmdcIjoweGU1LFxuICBcImFyaW5nO1wiOjB4ZTUsIFwiYXNjcjtcIjpbMHhkODM1LDB4ZGNiNl0sXG4gIFwiYXN0O1wiOjB4MmEsIFwiYXN5bXA7XCI6MHgyMjQ4LFxuICBcImFzeW1wZXE7XCI6MHgyMjRkLCBcImF0aWxkZVwiOjB4ZTMsXG4gIFwiYXRpbGRlO1wiOjB4ZTMsIFwiYXVtbFwiOjB4ZTQsXG4gIFwiYXVtbDtcIjoweGU0LCBcImF3Y29uaW50O1wiOjB4MjIzMyxcbiAgXCJhd2ludDtcIjoweDJhMTEsIFwiYk5vdDtcIjoweDJhZWQsXG4gIFwiYmFja2Nvbmc7XCI6MHgyMjRjLCBcImJhY2tlcHNpbG9uO1wiOjB4M2Y2LFxuICBcImJhY2twcmltZTtcIjoweDIwMzUsIFwiYmFja3NpbTtcIjoweDIyM2QsXG4gIFwiYmFja3NpbWVxO1wiOjB4MjJjZCwgXCJiYXJ2ZWU7XCI6MHgyMmJkLFxuICBcImJhcndlZDtcIjoweDIzMDUsIFwiYmFyd2VkZ2U7XCI6MHgyMzA1LFxuICBcImJicms7XCI6MHgyM2I1LCBcImJicmt0YnJrO1wiOjB4MjNiNixcbiAgXCJiY29uZztcIjoweDIyNGMsIFwiYmN5O1wiOjB4NDMxLFxuICBcImJkcXVvO1wiOjB4MjAxZSwgXCJiZWNhdXM7XCI6MHgyMjM1LFxuICBcImJlY2F1c2U7XCI6MHgyMjM1LCBcImJlbXB0eXY7XCI6MHgyOWIwLFxuICBcImJlcHNpO1wiOjB4M2Y2LCBcImJlcm5vdTtcIjoweDIxMmMsXG4gIFwiYmV0YTtcIjoweDNiMiwgXCJiZXRoO1wiOjB4MjEzNixcbiAgXCJiZXR3ZWVuO1wiOjB4MjI2YywgXCJiZnI7XCI6WzB4ZDgzNSwweGRkMWZdLFxuICBcImJpZ2NhcDtcIjoweDIyYzIsIFwiYmlnY2lyYztcIjoweDI1ZWYsXG4gIFwiYmlnY3VwO1wiOjB4MjJjMywgXCJiaWdvZG90O1wiOjB4MmEwMCxcbiAgXCJiaWdvcGx1cztcIjoweDJhMDEsIFwiYmlnb3RpbWVzO1wiOjB4MmEwMixcbiAgXCJiaWdzcWN1cDtcIjoweDJhMDYsIFwiYmlnc3RhcjtcIjoweDI2MDUsXG4gIFwiYmlndHJpYW5nbGVkb3duO1wiOjB4MjViZCwgXCJiaWd0cmlhbmdsZXVwO1wiOjB4MjViMyxcbiAgXCJiaWd1cGx1cztcIjoweDJhMDQsIFwiYmlndmVlO1wiOjB4MjJjMSxcbiAgXCJiaWd3ZWRnZTtcIjoweDIyYzAsIFwiYmthcm93O1wiOjB4MjkwZCxcbiAgXCJibGFja2xvemVuZ2U7XCI6MHgyOWViLCBcImJsYWNrc3F1YXJlO1wiOjB4MjVhYSxcbiAgXCJibGFja3RyaWFuZ2xlO1wiOjB4MjViNCwgXCJibGFja3RyaWFuZ2xlZG93bjtcIjoweDI1YmUsXG4gIFwiYmxhY2t0cmlhbmdsZWxlZnQ7XCI6MHgyNWMyLCBcImJsYWNrdHJpYW5nbGVyaWdodDtcIjoweDI1YjgsXG4gIFwiYmxhbms7XCI6MHgyNDIzLCBcImJsazEyO1wiOjB4MjU5MixcbiAgXCJibGsxNDtcIjoweDI1OTEsIFwiYmxrMzQ7XCI6MHgyNTkzLFxuICBcImJsb2NrO1wiOjB4MjU4OCwgXCJibmU7XCI6WzB4M2QsMHgyMGU1XSxcbiAgXCJibmVxdWl2O1wiOlsweDIyNjEsMHgyMGU1XSwgXCJibm90O1wiOjB4MjMxMCxcbiAgXCJib3BmO1wiOlsweGQ4MzUsMHhkZDUzXSwgXCJib3Q7XCI6MHgyMmE1LFxuICBcImJvdHRvbTtcIjoweDIyYTUsIFwiYm93dGllO1wiOjB4MjJjOCxcbiAgXCJib3hETDtcIjoweDI1NTcsIFwiYm94RFI7XCI6MHgyNTU0LFxuICBcImJveERsO1wiOjB4MjU1NiwgXCJib3hEcjtcIjoweDI1NTMsXG4gIFwiYm94SDtcIjoweDI1NTAsIFwiYm94SEQ7XCI6MHgyNTY2LFxuICBcImJveEhVO1wiOjB4MjU2OSwgXCJib3hIZDtcIjoweDI1NjQsXG4gIFwiYm94SHU7XCI6MHgyNTY3LCBcImJveFVMO1wiOjB4MjU1ZCxcbiAgXCJib3hVUjtcIjoweDI1NWEsIFwiYm94VWw7XCI6MHgyNTVjLFxuICBcImJveFVyO1wiOjB4MjU1OSwgXCJib3hWO1wiOjB4MjU1MSxcbiAgXCJib3hWSDtcIjoweDI1NmMsIFwiYm94Vkw7XCI6MHgyNTYzLFxuICBcImJveFZSO1wiOjB4MjU2MCwgXCJib3hWaDtcIjoweDI1NmIsXG4gIFwiYm94Vmw7XCI6MHgyNTYyLCBcImJveFZyO1wiOjB4MjU1ZixcbiAgXCJib3hib3g7XCI6MHgyOWM5LCBcImJveGRMO1wiOjB4MjU1NSxcbiAgXCJib3hkUjtcIjoweDI1NTIsIFwiYm94ZGw7XCI6MHgyNTEwLFxuICBcImJveGRyO1wiOjB4MjUwYywgXCJib3hoO1wiOjB4MjUwMCxcbiAgXCJib3hoRDtcIjoweDI1NjUsIFwiYm94aFU7XCI6MHgyNTY4LFxuICBcImJveGhkO1wiOjB4MjUyYywgXCJib3hodTtcIjoweDI1MzQsXG4gIFwiYm94bWludXM7XCI6MHgyMjlmLCBcImJveHBsdXM7XCI6MHgyMjllLFxuICBcImJveHRpbWVzO1wiOjB4MjJhMCwgXCJib3h1TDtcIjoweDI1NWIsXG4gIFwiYm94dVI7XCI6MHgyNTU4LCBcImJveHVsO1wiOjB4MjUxOCxcbiAgXCJib3h1cjtcIjoweDI1MTQsIFwiYm94djtcIjoweDI1MDIsXG4gIFwiYm94dkg7XCI6MHgyNTZhLCBcImJveHZMO1wiOjB4MjU2MSxcbiAgXCJib3h2UjtcIjoweDI1NWUsIFwiYm94dmg7XCI6MHgyNTNjLFxuICBcImJveHZsO1wiOjB4MjUyNCwgXCJib3h2cjtcIjoweDI1MWMsXG4gIFwiYnByaW1lO1wiOjB4MjAzNSwgXCJicmV2ZTtcIjoweDJkOCxcbiAgXCJicnZiYXJcIjoweGE2LCBcImJydmJhcjtcIjoweGE2LFxuICBcImJzY3I7XCI6WzB4ZDgzNSwweGRjYjddLCBcImJzZW1pO1wiOjB4MjA0ZixcbiAgXCJic2ltO1wiOjB4MjIzZCwgXCJic2ltZTtcIjoweDIyY2QsXG4gIFwiYnNvbDtcIjoweDVjLCBcImJzb2xiO1wiOjB4MjljNSxcbiAgXCJic29saHN1YjtcIjoweDI3YzgsIFwiYnVsbDtcIjoweDIwMjIsXG4gIFwiYnVsbGV0O1wiOjB4MjAyMiwgXCJidW1wO1wiOjB4MjI0ZSxcbiAgXCJidW1wRTtcIjoweDJhYWUsIFwiYnVtcGU7XCI6MHgyMjRmLFxuICBcImJ1bXBlcTtcIjoweDIyNGYsIFwiY2FjdXRlO1wiOjB4MTA3LFxuICBcImNhcDtcIjoweDIyMjksIFwiY2FwYW5kO1wiOjB4MmE0NCxcbiAgXCJjYXBicmN1cDtcIjoweDJhNDksIFwiY2FwY2FwO1wiOjB4MmE0YixcbiAgXCJjYXBjdXA7XCI6MHgyYTQ3LCBcImNhcGRvdDtcIjoweDJhNDAsXG4gIFwiY2FwcztcIjpbMHgyMjI5LDB4ZmUwMF0sIFwiY2FyZXQ7XCI6MHgyMDQxLFxuICBcImNhcm9uO1wiOjB4MmM3LCBcImNjYXBzO1wiOjB4MmE0ZCxcbiAgXCJjY2Fyb247XCI6MHgxMGQsIFwiY2NlZGlsXCI6MHhlNyxcbiAgXCJjY2VkaWw7XCI6MHhlNywgXCJjY2lyYztcIjoweDEwOSxcbiAgXCJjY3VwcztcIjoweDJhNGMsIFwiY2N1cHNzbTtcIjoweDJhNTAsXG4gIFwiY2RvdDtcIjoweDEwYiwgXCJjZWRpbFwiOjB4YjgsXG4gIFwiY2VkaWw7XCI6MHhiOCwgXCJjZW1wdHl2O1wiOjB4MjliMixcbiAgXCJjZW50XCI6MHhhMiwgXCJjZW50O1wiOjB4YTIsXG4gIFwiY2VudGVyZG90O1wiOjB4YjcsIFwiY2ZyO1wiOlsweGQ4MzUsMHhkZDIwXSxcbiAgXCJjaGN5O1wiOjB4NDQ3LCBcImNoZWNrO1wiOjB4MjcxMyxcbiAgXCJjaGVja21hcms7XCI6MHgyNzEzLCBcImNoaTtcIjoweDNjNyxcbiAgXCJjaXI7XCI6MHgyNWNiLCBcImNpckU7XCI6MHgyOWMzLFxuICBcImNpcmM7XCI6MHgyYzYsIFwiY2lyY2VxO1wiOjB4MjI1NyxcbiAgXCJjaXJjbGVhcnJvd2xlZnQ7XCI6MHgyMWJhLCBcImNpcmNsZWFycm93cmlnaHQ7XCI6MHgyMWJiLFxuICBcImNpcmNsZWRSO1wiOjB4YWUsIFwiY2lyY2xlZFM7XCI6MHgyNGM4LFxuICBcImNpcmNsZWRhc3Q7XCI6MHgyMjliLCBcImNpcmNsZWRjaXJjO1wiOjB4MjI5YSxcbiAgXCJjaXJjbGVkZGFzaDtcIjoweDIyOWQsIFwiY2lyZTtcIjoweDIyNTcsXG4gIFwiY2lyZm5pbnQ7XCI6MHgyYTEwLCBcImNpcm1pZDtcIjoweDJhZWYsXG4gIFwiY2lyc2NpcjtcIjoweDI5YzIsIFwiY2x1YnM7XCI6MHgyNjYzLFxuICBcImNsdWJzdWl0O1wiOjB4MjY2MywgXCJjb2xvbjtcIjoweDNhLFxuICBcImNvbG9uZTtcIjoweDIyNTQsIFwiY29sb25lcTtcIjoweDIyNTQsXG4gIFwiY29tbWE7XCI6MHgyYywgXCJjb21tYXQ7XCI6MHg0MCxcbiAgXCJjb21wO1wiOjB4MjIwMSwgXCJjb21wZm47XCI6MHgyMjE4LFxuICBcImNvbXBsZW1lbnQ7XCI6MHgyMjAxLCBcImNvbXBsZXhlcztcIjoweDIxMDIsXG4gIFwiY29uZztcIjoweDIyNDUsIFwiY29uZ2RvdDtcIjoweDJhNmQsXG4gIFwiY29uaW50O1wiOjB4MjIyZSwgXCJjb3BmO1wiOlsweGQ4MzUsMHhkZDU0XSxcbiAgXCJjb3Byb2Q7XCI6MHgyMjEwLCBcImNvcHlcIjoweGE5LFxuICBcImNvcHk7XCI6MHhhOSwgXCJjb3B5c3I7XCI6MHgyMTE3LFxuICBcImNyYXJyO1wiOjB4MjFiNSwgXCJjcm9zcztcIjoweDI3MTcsXG4gIFwiY3NjcjtcIjpbMHhkODM1LDB4ZGNiOF0sIFwiY3N1YjtcIjoweDJhY2YsXG4gIFwiY3N1YmU7XCI6MHgyYWQxLCBcImNzdXA7XCI6MHgyYWQwLFxuICBcImNzdXBlO1wiOjB4MmFkMiwgXCJjdGRvdDtcIjoweDIyZWYsXG4gIFwiY3VkYXJybDtcIjoweDI5MzgsIFwiY3VkYXJycjtcIjoweDI5MzUsXG4gIFwiY3VlcHI7XCI6MHgyMmRlLCBcImN1ZXNjO1wiOjB4MjJkZixcbiAgXCJjdWxhcnI7XCI6MHgyMWI2LCBcImN1bGFycnA7XCI6MHgyOTNkLFxuICBcImN1cDtcIjoweDIyMmEsIFwiY3VwYnJjYXA7XCI6MHgyYTQ4LFxuICBcImN1cGNhcDtcIjoweDJhNDYsIFwiY3VwY3VwO1wiOjB4MmE0YSxcbiAgXCJjdXBkb3Q7XCI6MHgyMjhkLCBcImN1cG9yO1wiOjB4MmE0NSxcbiAgXCJjdXBzO1wiOlsweDIyMmEsMHhmZTAwXSwgXCJjdXJhcnI7XCI6MHgyMWI3LFxuICBcImN1cmFycm07XCI6MHgyOTNjLCBcImN1cmx5ZXFwcmVjO1wiOjB4MjJkZSxcbiAgXCJjdXJseWVxc3VjYztcIjoweDIyZGYsIFwiY3VybHl2ZWU7XCI6MHgyMmNlLFxuICBcImN1cmx5d2VkZ2U7XCI6MHgyMmNmLCBcImN1cnJlblwiOjB4YTQsXG4gIFwiY3VycmVuO1wiOjB4YTQsIFwiY3VydmVhcnJvd2xlZnQ7XCI6MHgyMWI2LFxuICBcImN1cnZlYXJyb3dyaWdodDtcIjoweDIxYjcsIFwiY3V2ZWU7XCI6MHgyMmNlLFxuICBcImN1d2VkO1wiOjB4MjJjZiwgXCJjd2NvbmludDtcIjoweDIyMzIsXG4gIFwiY3dpbnQ7XCI6MHgyMjMxLCBcImN5bGN0eTtcIjoweDIzMmQsXG4gIFwiZEFycjtcIjoweDIxZDMsIFwiZEhhcjtcIjoweDI5NjUsXG4gIFwiZGFnZ2VyO1wiOjB4MjAyMCwgXCJkYWxldGg7XCI6MHgyMTM4LFxuICBcImRhcnI7XCI6MHgyMTkzLCBcImRhc2g7XCI6MHgyMDEwLFxuICBcImRhc2h2O1wiOjB4MjJhMywgXCJkYmthcm93O1wiOjB4MjkwZixcbiAgXCJkYmxhYztcIjoweDJkZCwgXCJkY2Fyb247XCI6MHgxMGYsXG4gIFwiZGN5O1wiOjB4NDM0LCBcImRkO1wiOjB4MjE0NixcbiAgXCJkZGFnZ2VyO1wiOjB4MjAyMSwgXCJkZGFycjtcIjoweDIxY2EsXG4gIFwiZGRvdHNlcTtcIjoweDJhNzcsIFwiZGVnXCI6MHhiMCxcbiAgXCJkZWc7XCI6MHhiMCwgXCJkZWx0YTtcIjoweDNiNCxcbiAgXCJkZW1wdHl2O1wiOjB4MjliMSwgXCJkZmlzaHQ7XCI6MHgyOTdmLFxuICBcImRmcjtcIjpbMHhkODM1LDB4ZGQyMV0sIFwiZGhhcmw7XCI6MHgyMWMzLFxuICBcImRoYXJyO1wiOjB4MjFjMiwgXCJkaWFtO1wiOjB4MjJjNCxcbiAgXCJkaWFtb25kO1wiOjB4MjJjNCwgXCJkaWFtb25kc3VpdDtcIjoweDI2NjYsXG4gIFwiZGlhbXM7XCI6MHgyNjY2LCBcImRpZTtcIjoweGE4LFxuICBcImRpZ2FtbWE7XCI6MHgzZGQsIFwiZGlzaW47XCI6MHgyMmYyLFxuICBcImRpdjtcIjoweGY3LCBcImRpdmlkZVwiOjB4ZjcsXG4gIFwiZGl2aWRlO1wiOjB4ZjcsIFwiZGl2aWRlb250aW1lcztcIjoweDIyYzcsXG4gIFwiZGl2b254O1wiOjB4MjJjNywgXCJkamN5O1wiOjB4NDUyLFxuICBcImRsY29ybjtcIjoweDIzMWUsIFwiZGxjcm9wO1wiOjB4MjMwZCxcbiAgXCJkb2xsYXI7XCI6MHgyNCwgXCJkb3BmO1wiOlsweGQ4MzUsMHhkZDU1XSxcbiAgXCJkb3Q7XCI6MHgyZDksIFwiZG90ZXE7XCI6MHgyMjUwLFxuICBcImRvdGVxZG90O1wiOjB4MjI1MSwgXCJkb3RtaW51cztcIjoweDIyMzgsXG4gIFwiZG90cGx1cztcIjoweDIyMTQsIFwiZG90c3F1YXJlO1wiOjB4MjJhMSxcbiAgXCJkb3VibGViYXJ3ZWRnZTtcIjoweDIzMDYsIFwiZG93bmFycm93O1wiOjB4MjE5MyxcbiAgXCJkb3duZG93bmFycm93cztcIjoweDIxY2EsIFwiZG93bmhhcnBvb25sZWZ0O1wiOjB4MjFjMyxcbiAgXCJkb3duaGFycG9vbnJpZ2h0O1wiOjB4MjFjMiwgXCJkcmJrYXJvdztcIjoweDI5MTAsXG4gIFwiZHJjb3JuO1wiOjB4MjMxZiwgXCJkcmNyb3A7XCI6MHgyMzBjLFxuICBcImRzY3I7XCI6WzB4ZDgzNSwweGRjYjldLCBcImRzY3k7XCI6MHg0NTUsXG4gIFwiZHNvbDtcIjoweDI5ZjYsIFwiZHN0cm9rO1wiOjB4MTExLFxuICBcImR0ZG90O1wiOjB4MjJmMSwgXCJkdHJpO1wiOjB4MjViZixcbiAgXCJkdHJpZjtcIjoweDI1YmUsIFwiZHVhcnI7XCI6MHgyMWY1LFxuICBcImR1aGFyO1wiOjB4Mjk2ZiwgXCJkd2FuZ2xlO1wiOjB4MjlhNixcbiAgXCJkemN5O1wiOjB4NDVmLCBcImR6aWdyYXJyO1wiOjB4MjdmZixcbiAgXCJlRERvdDtcIjoweDJhNzcsIFwiZURvdDtcIjoweDIyNTEsXG4gIFwiZWFjdXRlXCI6MHhlOSwgXCJlYWN1dGU7XCI6MHhlOSxcbiAgXCJlYXN0ZXI7XCI6MHgyYTZlLCBcImVjYXJvbjtcIjoweDExYixcbiAgXCJlY2lyO1wiOjB4MjI1NiwgXCJlY2lyY1wiOjB4ZWEsXG4gIFwiZWNpcmM7XCI6MHhlYSwgXCJlY29sb247XCI6MHgyMjU1LFxuICBcImVjeTtcIjoweDQ0ZCwgXCJlZG90O1wiOjB4MTE3LFxuICBcImVlO1wiOjB4MjE0NywgXCJlZkRvdDtcIjoweDIyNTIsXG4gIFwiZWZyO1wiOlsweGQ4MzUsMHhkZDIyXSwgXCJlZztcIjoweDJhOWEsXG4gIFwiZWdyYXZlXCI6MHhlOCwgXCJlZ3JhdmU7XCI6MHhlOCxcbiAgXCJlZ3M7XCI6MHgyYTk2LCBcImVnc2RvdDtcIjoweDJhOTgsXG4gIFwiZWw7XCI6MHgyYTk5LCBcImVsaW50ZXJzO1wiOjB4MjNlNyxcbiAgXCJlbGw7XCI6MHgyMTEzLCBcImVscztcIjoweDJhOTUsXG4gIFwiZWxzZG90O1wiOjB4MmE5NywgXCJlbWFjcjtcIjoweDExMyxcbiAgXCJlbXB0eTtcIjoweDIyMDUsIFwiZW1wdHlzZXQ7XCI6MHgyMjA1LFxuICBcImVtcHR5djtcIjoweDIyMDUsIFwiZW1zcDEzO1wiOjB4MjAwNCxcbiAgXCJlbXNwMTQ7XCI6MHgyMDA1LCBcImVtc3A7XCI6MHgyMDAzLFxuICBcImVuZztcIjoweDE0YiwgXCJlbnNwO1wiOjB4MjAwMixcbiAgXCJlb2dvbjtcIjoweDExOSwgXCJlb3BmO1wiOlsweGQ4MzUsMHhkZDU2XSxcbiAgXCJlcGFyO1wiOjB4MjJkNSwgXCJlcGFyc2w7XCI6MHgyOWUzLFxuICBcImVwbHVzO1wiOjB4MmE3MSwgXCJlcHNpO1wiOjB4M2I1LFxuICBcImVwc2lsb247XCI6MHgzYjUsIFwiZXBzaXY7XCI6MHgzZjUsXG4gIFwiZXFjaXJjO1wiOjB4MjI1NiwgXCJlcWNvbG9uO1wiOjB4MjI1NSxcbiAgXCJlcXNpbTtcIjoweDIyNDIsIFwiZXFzbGFudGd0cjtcIjoweDJhOTYsXG4gIFwiZXFzbGFudGxlc3M7XCI6MHgyYTk1LCBcImVxdWFscztcIjoweDNkLFxuICBcImVxdWVzdDtcIjoweDIyNWYsIFwiZXF1aXY7XCI6MHgyMjYxLFxuICBcImVxdWl2REQ7XCI6MHgyYTc4LCBcImVxdnBhcnNsO1wiOjB4MjllNSxcbiAgXCJlckRvdDtcIjoweDIyNTMsIFwiZXJhcnI7XCI6MHgyOTcxLFxuICBcImVzY3I7XCI6MHgyMTJmLCBcImVzZG90O1wiOjB4MjI1MCxcbiAgXCJlc2ltO1wiOjB4MjI0MiwgXCJldGE7XCI6MHgzYjcsXG4gIFwiZXRoXCI6MHhmMCwgXCJldGg7XCI6MHhmMCxcbiAgXCJldW1sXCI6MHhlYiwgXCJldW1sO1wiOjB4ZWIsXG4gIFwiZXVybztcIjoweDIwYWMsIFwiZXhjbDtcIjoweDIxLFxuICBcImV4aXN0O1wiOjB4MjIwMywgXCJleHBlY3RhdGlvbjtcIjoweDIxMzAsXG4gIFwiZXhwb25lbnRpYWxlO1wiOjB4MjE0NywgXCJmYWxsaW5nZG90c2VxO1wiOjB4MjI1MixcbiAgXCJmY3k7XCI6MHg0NDQsIFwiZmVtYWxlO1wiOjB4MjY0MCxcbiAgXCJmZmlsaWc7XCI6MHhmYjAzLCBcImZmbGlnO1wiOjB4ZmIwMCxcbiAgXCJmZmxsaWc7XCI6MHhmYjA0LCBcImZmcjtcIjpbMHhkODM1LDB4ZGQyM10sXG4gIFwiZmlsaWc7XCI6MHhmYjAxLCBcImZqbGlnO1wiOlsweDY2LDB4NmFdLFxuICBcImZsYXQ7XCI6MHgyNjZkLCBcImZsbGlnO1wiOjB4ZmIwMixcbiAgXCJmbHRucztcIjoweDI1YjEsIFwiZm5vZjtcIjoweDE5MixcbiAgXCJmb3BmO1wiOlsweGQ4MzUsMHhkZDU3XSwgXCJmb3JhbGw7XCI6MHgyMjAwLFxuICBcImZvcms7XCI6MHgyMmQ0LCBcImZvcmt2O1wiOjB4MmFkOSxcbiAgXCJmcGFydGludDtcIjoweDJhMGQsIFwiZnJhYzEyXCI6MHhiZCxcbiAgXCJmcmFjMTI7XCI6MHhiZCwgXCJmcmFjMTM7XCI6MHgyMTUzLFxuICBcImZyYWMxNFwiOjB4YmMsIFwiZnJhYzE0O1wiOjB4YmMsXG4gIFwiZnJhYzE1O1wiOjB4MjE1NSwgXCJmcmFjMTY7XCI6MHgyMTU5LFxuICBcImZyYWMxODtcIjoweDIxNWIsIFwiZnJhYzIzO1wiOjB4MjE1NCxcbiAgXCJmcmFjMjU7XCI6MHgyMTU2LCBcImZyYWMzNFwiOjB4YmUsXG4gIFwiZnJhYzM0O1wiOjB4YmUsIFwiZnJhYzM1O1wiOjB4MjE1NyxcbiAgXCJmcmFjMzg7XCI6MHgyMTVjLCBcImZyYWM0NTtcIjoweDIxNTgsXG4gIFwiZnJhYzU2O1wiOjB4MjE1YSwgXCJmcmFjNTg7XCI6MHgyMTVkLFxuICBcImZyYWM3ODtcIjoweDIxNWUsIFwiZnJhc2w7XCI6MHgyMDQ0LFxuICBcImZyb3duO1wiOjB4MjMyMiwgXCJmc2NyO1wiOlsweGQ4MzUsMHhkY2JiXSxcbiAgXCJnRTtcIjoweDIyNjcsIFwiZ0VsO1wiOjB4MmE4YyxcbiAgXCJnYWN1dGU7XCI6MHgxZjUsIFwiZ2FtbWE7XCI6MHgzYjMsXG4gIFwiZ2FtbWFkO1wiOjB4M2RkLCBcImdhcDtcIjoweDJhODYsXG4gIFwiZ2JyZXZlO1wiOjB4MTFmLCBcImdjaXJjO1wiOjB4MTFkLFxuICBcImdjeTtcIjoweDQzMywgXCJnZG90O1wiOjB4MTIxLFxuICBcImdlO1wiOjB4MjI2NSwgXCJnZWw7XCI6MHgyMmRiLFxuICBcImdlcTtcIjoweDIyNjUsIFwiZ2VxcTtcIjoweDIyNjcsXG4gIFwiZ2Vxc2xhbnQ7XCI6MHgyYTdlLCBcImdlcztcIjoweDJhN2UsXG4gIFwiZ2VzY2M7XCI6MHgyYWE5LCBcImdlc2RvdDtcIjoweDJhODAsXG4gIFwiZ2VzZG90bztcIjoweDJhODIsIFwiZ2VzZG90b2w7XCI6MHgyYTg0LFxuICBcImdlc2w7XCI6WzB4MjJkYiwweGZlMDBdLCBcImdlc2xlcztcIjoweDJhOTQsXG4gIFwiZ2ZyO1wiOlsweGQ4MzUsMHhkZDI0XSwgXCJnZztcIjoweDIyNmIsXG4gIFwiZ2dnO1wiOjB4MjJkOSwgXCJnaW1lbDtcIjoweDIxMzcsXG4gIFwiZ2pjeTtcIjoweDQ1MywgXCJnbDtcIjoweDIyNzcsXG4gIFwiZ2xFO1wiOjB4MmE5MiwgXCJnbGE7XCI6MHgyYWE1LFxuICBcImdsajtcIjoweDJhYTQsIFwiZ25FO1wiOjB4MjI2OSxcbiAgXCJnbmFwO1wiOjB4MmE4YSwgXCJnbmFwcHJveDtcIjoweDJhOGEsXG4gIFwiZ25lO1wiOjB4MmE4OCwgXCJnbmVxO1wiOjB4MmE4OCxcbiAgXCJnbmVxcTtcIjoweDIyNjksIFwiZ25zaW07XCI6MHgyMmU3LFxuICBcImdvcGY7XCI6WzB4ZDgzNSwweGRkNThdLCBcImdyYXZlO1wiOjB4NjAsXG4gIFwiZ3NjcjtcIjoweDIxMGEsIFwiZ3NpbTtcIjoweDIyNzMsXG4gIFwiZ3NpbWU7XCI6MHgyYThlLCBcImdzaW1sO1wiOjB4MmE5MCxcbiAgXCJndFwiOjB4M2UsIFwiZ3Q7XCI6MHgzZSxcbiAgXCJndGNjO1wiOjB4MmFhNywgXCJndGNpcjtcIjoweDJhN2EsXG4gIFwiZ3Rkb3Q7XCI6MHgyMmQ3LCBcImd0bFBhcjtcIjoweDI5OTUsXG4gIFwiZ3RxdWVzdDtcIjoweDJhN2MsIFwiZ3RyYXBwcm94O1wiOjB4MmE4NixcbiAgXCJndHJhcnI7XCI6MHgyOTc4LCBcImd0cmRvdDtcIjoweDIyZDcsXG4gIFwiZ3RyZXFsZXNzO1wiOjB4MjJkYiwgXCJndHJlcXFsZXNzO1wiOjB4MmE4YyxcbiAgXCJndHJsZXNzO1wiOjB4MjI3NywgXCJndHJzaW07XCI6MHgyMjczLFxuICBcImd2ZXJ0bmVxcTtcIjpbMHgyMjY5LDB4ZmUwMF0sIFwiZ3ZuRTtcIjpbMHgyMjY5LDB4ZmUwMF0sXG4gIFwiaEFycjtcIjoweDIxZDQsIFwiaGFpcnNwO1wiOjB4MjAwYSxcbiAgXCJoYWxmO1wiOjB4YmQsIFwiaGFtaWx0O1wiOjB4MjEwYixcbiAgXCJoYXJkY3k7XCI6MHg0NGEsIFwiaGFycjtcIjoweDIxOTQsXG4gIFwiaGFycmNpcjtcIjoweDI5NDgsIFwiaGFycnc7XCI6MHgyMWFkLFxuICBcImhiYXI7XCI6MHgyMTBmLCBcImhjaXJjO1wiOjB4MTI1LFxuICBcImhlYXJ0cztcIjoweDI2NjUsIFwiaGVhcnRzdWl0O1wiOjB4MjY2NSxcbiAgXCJoZWxsaXA7XCI6MHgyMDI2LCBcImhlcmNvbjtcIjoweDIyYjksXG4gIFwiaGZyO1wiOlsweGQ4MzUsMHhkZDI1XSwgXCJoa3NlYXJvdztcIjoweDI5MjUsXG4gIFwiaGtzd2Fyb3c7XCI6MHgyOTI2LCBcImhvYXJyO1wiOjB4MjFmZixcbiAgXCJob210aHQ7XCI6MHgyMjNiLCBcImhvb2tsZWZ0YXJyb3c7XCI6MHgyMWE5LFxuICBcImhvb2tyaWdodGFycm93O1wiOjB4MjFhYSwgXCJob3BmO1wiOlsweGQ4MzUsMHhkZDU5XSxcbiAgXCJob3JiYXI7XCI6MHgyMDE1LCBcImhzY3I7XCI6WzB4ZDgzNSwweGRjYmRdLFxuICBcImhzbGFzaDtcIjoweDIxMGYsIFwiaHN0cm9rO1wiOjB4MTI3LFxuICBcImh5YnVsbDtcIjoweDIwNDMsIFwiaHlwaGVuO1wiOjB4MjAxMCxcbiAgXCJpYWN1dGVcIjoweGVkLCBcImlhY3V0ZTtcIjoweGVkLFxuICBcImljO1wiOjB4MjA2MywgXCJpY2lyY1wiOjB4ZWUsXG4gIFwiaWNpcmM7XCI6MHhlZSwgXCJpY3k7XCI6MHg0MzgsXG4gIFwiaWVjeTtcIjoweDQzNSwgXCJpZXhjbFwiOjB4YTEsXG4gIFwiaWV4Y2w7XCI6MHhhMSwgXCJpZmY7XCI6MHgyMWQ0LFxuICBcImlmcjtcIjpbMHhkODM1LDB4ZGQyNl0sIFwiaWdyYXZlXCI6MHhlYyxcbiAgXCJpZ3JhdmU7XCI6MHhlYywgXCJpaTtcIjoweDIxNDgsXG4gIFwiaWlpaW50O1wiOjB4MmEwYywgXCJpaWludDtcIjoweDIyMmQsXG4gIFwiaWluZmluO1wiOjB4MjlkYywgXCJpaW90YTtcIjoweDIxMjksXG4gIFwiaWpsaWc7XCI6MHgxMzMsIFwiaW1hY3I7XCI6MHgxMmIsXG4gIFwiaW1hZ2U7XCI6MHgyMTExLCBcImltYWdsaW5lO1wiOjB4MjExMCxcbiAgXCJpbWFncGFydDtcIjoweDIxMTEsIFwiaW1hdGg7XCI6MHgxMzEsXG4gIFwiaW1vZjtcIjoweDIyYjcsIFwiaW1wZWQ7XCI6MHgxYjUsXG4gIFwiaW47XCI6MHgyMjA4LCBcImluY2FyZTtcIjoweDIxMDUsXG4gIFwiaW5maW47XCI6MHgyMjFlLCBcImluZmludGllO1wiOjB4MjlkZCxcbiAgXCJpbm9kb3Q7XCI6MHgxMzEsIFwiaW50O1wiOjB4MjIyYixcbiAgXCJpbnRjYWw7XCI6MHgyMmJhLCBcImludGVnZXJzO1wiOjB4MjEyNCxcbiAgXCJpbnRlcmNhbDtcIjoweDIyYmEsIFwiaW50bGFyaGs7XCI6MHgyYTE3LFxuICBcImludHByb2Q7XCI6MHgyYTNjLCBcImlvY3k7XCI6MHg0NTEsXG4gIFwiaW9nb247XCI6MHgxMmYsIFwiaW9wZjtcIjpbMHhkODM1LDB4ZGQ1YV0sXG4gIFwiaW90YTtcIjoweDNiOSwgXCJpcHJvZDtcIjoweDJhM2MsXG4gIFwiaXF1ZXN0XCI6MHhiZiwgXCJpcXVlc3Q7XCI6MHhiZixcbiAgXCJpc2NyO1wiOlsweGQ4MzUsMHhkY2JlXSwgXCJpc2luO1wiOjB4MjIwOCxcbiAgXCJpc2luRTtcIjoweDIyZjksIFwiaXNpbmRvdDtcIjoweDIyZjUsXG4gIFwiaXNpbnM7XCI6MHgyMmY0LCBcImlzaW5zdjtcIjoweDIyZjMsXG4gIFwiaXNpbnY7XCI6MHgyMjA4LCBcIml0O1wiOjB4MjA2MixcbiAgXCJpdGlsZGU7XCI6MHgxMjksIFwiaXVrY3k7XCI6MHg0NTYsXG4gIFwiaXVtbFwiOjB4ZWYsIFwiaXVtbDtcIjoweGVmLFxuICBcImpjaXJjO1wiOjB4MTM1LCBcImpjeTtcIjoweDQzOSxcbiAgXCJqZnI7XCI6WzB4ZDgzNSwweGRkMjddLCBcImptYXRoO1wiOjB4MjM3LFxuICBcImpvcGY7XCI6WzB4ZDgzNSwweGRkNWJdLCBcImpzY3I7XCI6WzB4ZDgzNSwweGRjYmZdLFxuICBcImpzZXJjeTtcIjoweDQ1OCwgXCJqdWtjeTtcIjoweDQ1NCxcbiAgXCJrYXBwYTtcIjoweDNiYSwgXCJrYXBwYXY7XCI6MHgzZjAsXG4gIFwia2NlZGlsO1wiOjB4MTM3LCBcImtjeTtcIjoweDQzYSxcbiAgXCJrZnI7XCI6WzB4ZDgzNSwweGRkMjhdLCBcImtncmVlbjtcIjoweDEzOCxcbiAgXCJraGN5O1wiOjB4NDQ1LCBcImtqY3k7XCI6MHg0NWMsXG4gIFwia29wZjtcIjpbMHhkODM1LDB4ZGQ1Y10sIFwia3NjcjtcIjpbMHhkODM1LDB4ZGNjMF0sXG4gIFwibEFhcnI7XCI6MHgyMWRhLCBcImxBcnI7XCI6MHgyMWQwLFxuICBcImxBdGFpbDtcIjoweDI5MWIsIFwibEJhcnI7XCI6MHgyOTBlLFxuICBcImxFO1wiOjB4MjI2NiwgXCJsRWc7XCI6MHgyYThiLFxuICBcImxIYXI7XCI6MHgyOTYyLCBcImxhY3V0ZTtcIjoweDEzYSxcbiAgXCJsYWVtcHR5djtcIjoweDI5YjQsIFwibGFncmFuO1wiOjB4MjExMixcbiAgXCJsYW1iZGE7XCI6MHgzYmIsIFwibGFuZztcIjoweDI3ZTgsXG4gIFwibGFuZ2Q7XCI6MHgyOTkxLCBcImxhbmdsZTtcIjoweDI3ZTgsXG4gIFwibGFwO1wiOjB4MmE4NSwgXCJsYXF1b1wiOjB4YWIsXG4gIFwibGFxdW87XCI6MHhhYiwgXCJsYXJyO1wiOjB4MjE5MCxcbiAgXCJsYXJyYjtcIjoweDIxZTQsIFwibGFycmJmcztcIjoweDI5MWYsXG4gIFwibGFycmZzO1wiOjB4MjkxZCwgXCJsYXJyaGs7XCI6MHgyMWE5LFxuICBcImxhcnJscDtcIjoweDIxYWIsIFwibGFycnBsO1wiOjB4MjkzOSxcbiAgXCJsYXJyc2ltO1wiOjB4Mjk3MywgXCJsYXJydGw7XCI6MHgyMWEyLFxuICBcImxhdDtcIjoweDJhYWIsIFwibGF0YWlsO1wiOjB4MjkxOSxcbiAgXCJsYXRlO1wiOjB4MmFhZCwgXCJsYXRlcztcIjpbMHgyYWFkLDB4ZmUwMF0sXG4gIFwibGJhcnI7XCI6MHgyOTBjLCBcImxiYnJrO1wiOjB4Mjc3MixcbiAgXCJsYnJhY2U7XCI6MHg3YiwgXCJsYnJhY2s7XCI6MHg1YixcbiAgXCJsYnJrZTtcIjoweDI5OGIsIFwibGJya3NsZDtcIjoweDI5OGYsXG4gIFwibGJya3NsdTtcIjoweDI5OGQsIFwibGNhcm9uO1wiOjB4MTNlLFxuICBcImxjZWRpbDtcIjoweDEzYywgXCJsY2VpbDtcIjoweDIzMDgsXG4gIFwibGN1YjtcIjoweDdiLCBcImxjeTtcIjoweDQzYixcbiAgXCJsZGNhO1wiOjB4MjkzNiwgXCJsZHF1bztcIjoweDIwMWMsXG4gIFwibGRxdW9yO1wiOjB4MjAxZSwgXCJsZHJkaGFyO1wiOjB4Mjk2NyxcbiAgXCJsZHJ1c2hhcjtcIjoweDI5NGIsIFwibGRzaDtcIjoweDIxYjIsXG4gIFwibGU7XCI6MHgyMjY0LCBcImxlZnRhcnJvdztcIjoweDIxOTAsXG4gIFwibGVmdGFycm93dGFpbDtcIjoweDIxYTIsIFwibGVmdGhhcnBvb25kb3duO1wiOjB4MjFiZCxcbiAgXCJsZWZ0aGFycG9vbnVwO1wiOjB4MjFiYywgXCJsZWZ0bGVmdGFycm93cztcIjoweDIxYzcsXG4gIFwibGVmdHJpZ2h0YXJyb3c7XCI6MHgyMTk0LCBcImxlZnRyaWdodGFycm93cztcIjoweDIxYzYsXG4gIFwibGVmdHJpZ2h0aGFycG9vbnM7XCI6MHgyMWNiLCBcImxlZnRyaWdodHNxdWlnYXJyb3c7XCI6MHgyMWFkLFxuICBcImxlZnR0aHJlZXRpbWVzO1wiOjB4MjJjYiwgXCJsZWc7XCI6MHgyMmRhLFxuICBcImxlcTtcIjoweDIyNjQsIFwibGVxcTtcIjoweDIyNjYsXG4gIFwibGVxc2xhbnQ7XCI6MHgyYTdkLCBcImxlcztcIjoweDJhN2QsXG4gIFwibGVzY2M7XCI6MHgyYWE4LCBcImxlc2RvdDtcIjoweDJhN2YsXG4gIFwibGVzZG90bztcIjoweDJhODEsIFwibGVzZG90b3I7XCI6MHgyYTgzLFxuICBcImxlc2c7XCI6WzB4MjJkYSwweGZlMDBdLCBcImxlc2dlcztcIjoweDJhOTMsXG4gIFwibGVzc2FwcHJveDtcIjoweDJhODUsIFwibGVzc2RvdDtcIjoweDIyZDYsXG4gIFwibGVzc2VxZ3RyO1wiOjB4MjJkYSwgXCJsZXNzZXFxZ3RyO1wiOjB4MmE4YixcbiAgXCJsZXNzZ3RyO1wiOjB4MjI3NiwgXCJsZXNzc2ltO1wiOjB4MjI3MixcbiAgXCJsZmlzaHQ7XCI6MHgyOTdjLCBcImxmbG9vcjtcIjoweDIzMGEsXG4gIFwibGZyO1wiOlsweGQ4MzUsMHhkZDI5XSwgXCJsZztcIjoweDIyNzYsXG4gIFwibGdFO1wiOjB4MmE5MSwgXCJsaGFyZDtcIjoweDIxYmQsXG4gIFwibGhhcnU7XCI6MHgyMWJjLCBcImxoYXJ1bDtcIjoweDI5NmEsXG4gIFwibGhibGs7XCI6MHgyNTg0LCBcImxqY3k7XCI6MHg0NTksXG4gIFwibGw7XCI6MHgyMjZhLCBcImxsYXJyO1wiOjB4MjFjNyxcbiAgXCJsbGNvcm5lcjtcIjoweDIzMWUsIFwibGxoYXJkO1wiOjB4Mjk2YixcbiAgXCJsbHRyaTtcIjoweDI1ZmEsIFwibG1pZG90O1wiOjB4MTQwLFxuICBcImxtb3VzdDtcIjoweDIzYjAsIFwibG1vdXN0YWNoZTtcIjoweDIzYjAsXG4gIFwibG5FO1wiOjB4MjI2OCwgXCJsbmFwO1wiOjB4MmE4OSxcbiAgXCJsbmFwcHJveDtcIjoweDJhODksIFwibG5lO1wiOjB4MmE4NyxcbiAgXCJsbmVxO1wiOjB4MmE4NywgXCJsbmVxcTtcIjoweDIyNjgsXG4gIFwibG5zaW07XCI6MHgyMmU2LCBcImxvYW5nO1wiOjB4MjdlYyxcbiAgXCJsb2FycjtcIjoweDIxZmQsIFwibG9icms7XCI6MHgyN2U2LFxuICBcImxvbmdsZWZ0YXJyb3c7XCI6MHgyN2Y1LCBcImxvbmdsZWZ0cmlnaHRhcnJvdztcIjoweDI3ZjcsXG4gIFwibG9uZ21hcHN0bztcIjoweDI3ZmMsIFwibG9uZ3JpZ2h0YXJyb3c7XCI6MHgyN2Y2LFxuICBcImxvb3BhcnJvd2xlZnQ7XCI6MHgyMWFiLCBcImxvb3BhcnJvd3JpZ2h0O1wiOjB4MjFhYyxcbiAgXCJsb3BhcjtcIjoweDI5ODUsIFwibG9wZjtcIjpbMHhkODM1LDB4ZGQ1ZF0sXG4gIFwibG9wbHVzO1wiOjB4MmEyZCwgXCJsb3RpbWVzO1wiOjB4MmEzNCxcbiAgXCJsb3dhc3Q7XCI6MHgyMjE3LCBcImxvd2JhcjtcIjoweDVmLFxuICBcImxvejtcIjoweDI1Y2EsIFwibG96ZW5nZTtcIjoweDI1Y2EsXG4gIFwibG96ZjtcIjoweDI5ZWIsIFwibHBhcjtcIjoweDI4LFxuICBcImxwYXJsdDtcIjoweDI5OTMsIFwibHJhcnI7XCI6MHgyMWM2LFxuICBcImxyY29ybmVyO1wiOjB4MjMxZiwgXCJscmhhcjtcIjoweDIxY2IsXG4gIFwibHJoYXJkO1wiOjB4Mjk2ZCwgXCJscm07XCI6MHgyMDBlLFxuICBcImxydHJpO1wiOjB4MjJiZiwgXCJsc2FxdW87XCI6MHgyMDM5LFxuICBcImxzY3I7XCI6WzB4ZDgzNSwweGRjYzFdLCBcImxzaDtcIjoweDIxYjAsXG4gIFwibHNpbTtcIjoweDIyNzIsIFwibHNpbWU7XCI6MHgyYThkLFxuICBcImxzaW1nO1wiOjB4MmE4ZiwgXCJsc3FiO1wiOjB4NWIsXG4gIFwibHNxdW87XCI6MHgyMDE4LCBcImxzcXVvcjtcIjoweDIwMWEsXG4gIFwibHN0cm9rO1wiOjB4MTQyLCBcImx0XCI6MHgzYyxcbiAgXCJsdDtcIjoweDNjLCBcImx0Y2M7XCI6MHgyYWE2LFxuICBcImx0Y2lyO1wiOjB4MmE3OSwgXCJsdGRvdDtcIjoweDIyZDYsXG4gIFwibHRocmVlO1wiOjB4MjJjYiwgXCJsdGltZXM7XCI6MHgyMmM5LFxuICBcImx0bGFycjtcIjoweDI5NzYsIFwibHRxdWVzdDtcIjoweDJhN2IsXG4gIFwibHRyUGFyO1wiOjB4Mjk5NiwgXCJsdHJpO1wiOjB4MjVjMyxcbiAgXCJsdHJpZTtcIjoweDIyYjQsIFwibHRyaWY7XCI6MHgyNWMyLFxuICBcImx1cmRzaGFyO1wiOjB4Mjk0YSwgXCJsdXJ1aGFyO1wiOjB4Mjk2NixcbiAgXCJsdmVydG5lcXE7XCI6WzB4MjI2OCwweGZlMDBdLCBcImx2bkU7XCI6WzB4MjI2OCwweGZlMDBdLFxuICBcIm1ERG90O1wiOjB4MjIzYSwgXCJtYWNyXCI6MHhhZixcbiAgXCJtYWNyO1wiOjB4YWYsIFwibWFsZTtcIjoweDI2NDIsXG4gIFwibWFsdDtcIjoweDI3MjAsIFwibWFsdGVzZTtcIjoweDI3MjAsXG4gIFwibWFwO1wiOjB4MjFhNiwgXCJtYXBzdG87XCI6MHgyMWE2LFxuICBcIm1hcHN0b2Rvd247XCI6MHgyMWE3LCBcIm1hcHN0b2xlZnQ7XCI6MHgyMWE0LFxuICBcIm1hcHN0b3VwO1wiOjB4MjFhNSwgXCJtYXJrZXI7XCI6MHgyNWFlLFxuICBcIm1jb21tYTtcIjoweDJhMjksIFwibWN5O1wiOjB4NDNjLFxuICBcIm1kYXNoO1wiOjB4MjAxNCwgXCJtZWFzdXJlZGFuZ2xlO1wiOjB4MjIyMSxcbiAgXCJtZnI7XCI6WzB4ZDgzNSwweGRkMmFdLCBcIm1obztcIjoweDIxMjcsXG4gIFwibWljcm9cIjoweGI1LCBcIm1pY3JvO1wiOjB4YjUsXG4gIFwibWlkO1wiOjB4MjIyMywgXCJtaWRhc3Q7XCI6MHgyYSxcbiAgXCJtaWRjaXI7XCI6MHgyYWYwLCBcIm1pZGRvdFwiOjB4YjcsXG4gIFwibWlkZG90O1wiOjB4YjcsIFwibWludXM7XCI6MHgyMjEyLFxuICBcIm1pbnVzYjtcIjoweDIyOWYsIFwibWludXNkO1wiOjB4MjIzOCxcbiAgXCJtaW51c2R1O1wiOjB4MmEyYSwgXCJtbGNwO1wiOjB4MmFkYixcbiAgXCJtbGRyO1wiOjB4MjAyNiwgXCJtbnBsdXM7XCI6MHgyMjEzLFxuICBcIm1vZGVscztcIjoweDIyYTcsIFwibW9wZjtcIjpbMHhkODM1LDB4ZGQ1ZV0sXG4gIFwibXA7XCI6MHgyMjEzLCBcIm1zY3I7XCI6WzB4ZDgzNSwweGRjYzJdLFxuICBcIm1zdHBvcztcIjoweDIyM2UsIFwibXU7XCI6MHgzYmMsXG4gIFwibXVsdGltYXA7XCI6MHgyMmI4LCBcIm11bWFwO1wiOjB4MjJiOCxcbiAgXCJuR2c7XCI6WzB4MjJkOSwweDMzOF0sIFwibkd0O1wiOlsweDIyNmIsMHgyMGQyXSxcbiAgXCJuR3R2O1wiOlsweDIyNmIsMHgzMzhdLCBcIm5MZWZ0YXJyb3c7XCI6MHgyMWNkLFxuICBcIm5MZWZ0cmlnaHRhcnJvdztcIjoweDIxY2UsIFwibkxsO1wiOlsweDIyZDgsMHgzMzhdLFxuICBcIm5MdDtcIjpbMHgyMjZhLDB4MjBkMl0sIFwibkx0djtcIjpbMHgyMjZhLDB4MzM4XSxcbiAgXCJuUmlnaHRhcnJvdztcIjoweDIxY2YsIFwiblZEYXNoO1wiOjB4MjJhZixcbiAgXCJuVmRhc2g7XCI6MHgyMmFlLCBcIm5hYmxhO1wiOjB4MjIwNyxcbiAgXCJuYWN1dGU7XCI6MHgxNDQsIFwibmFuZztcIjpbMHgyMjIwLDB4MjBkMl0sXG4gIFwibmFwO1wiOjB4MjI0OSwgXCJuYXBFO1wiOlsweDJhNzAsMHgzMzhdLFxuICBcIm5hcGlkO1wiOlsweDIyNGIsMHgzMzhdLCBcIm5hcG9zO1wiOjB4MTQ5LFxuICBcIm5hcHByb3g7XCI6MHgyMjQ5LCBcIm5hdHVyO1wiOjB4MjY2ZSxcbiAgXCJuYXR1cmFsO1wiOjB4MjY2ZSwgXCJuYXR1cmFscztcIjoweDIxMTUsXG4gIFwibmJzcFwiOjB4YTAsIFwibmJzcDtcIjoweGEwLFxuICBcIm5idW1wO1wiOlsweDIyNGUsMHgzMzhdLCBcIm5idW1wZTtcIjpbMHgyMjRmLDB4MzM4XSxcbiAgXCJuY2FwO1wiOjB4MmE0MywgXCJuY2Fyb247XCI6MHgxNDgsXG4gIFwibmNlZGlsO1wiOjB4MTQ2LCBcIm5jb25nO1wiOjB4MjI0NyxcbiAgXCJuY29uZ2RvdDtcIjpbMHgyYTZkLDB4MzM4XSwgXCJuY3VwO1wiOjB4MmE0MixcbiAgXCJuY3k7XCI6MHg0M2QsIFwibmRhc2g7XCI6MHgyMDEzLFxuICBcIm5lO1wiOjB4MjI2MCwgXCJuZUFycjtcIjoweDIxZDcsXG4gIFwibmVhcmhrO1wiOjB4MjkyNCwgXCJuZWFycjtcIjoweDIxOTcsXG4gIFwibmVhcnJvdztcIjoweDIxOTcsIFwibmVkb3Q7XCI6WzB4MjI1MCwweDMzOF0sXG4gIFwibmVxdWl2O1wiOjB4MjI2MiwgXCJuZXNlYXI7XCI6MHgyOTI4LFxuICBcIm5lc2ltO1wiOlsweDIyNDIsMHgzMzhdLCBcIm5leGlzdDtcIjoweDIyMDQsXG4gIFwibmV4aXN0cztcIjoweDIyMDQsIFwibmZyO1wiOlsweGQ4MzUsMHhkZDJiXSxcbiAgXCJuZ0U7XCI6WzB4MjI2NywweDMzOF0sIFwibmdlO1wiOjB4MjI3MSxcbiAgXCJuZ2VxO1wiOjB4MjI3MSwgXCJuZ2VxcTtcIjpbMHgyMjY3LDB4MzM4XSxcbiAgXCJuZ2Vxc2xhbnQ7XCI6WzB4MmE3ZSwweDMzOF0sIFwibmdlcztcIjpbMHgyYTdlLDB4MzM4XSxcbiAgXCJuZ3NpbTtcIjoweDIyNzUsIFwibmd0O1wiOjB4MjI2ZixcbiAgXCJuZ3RyO1wiOjB4MjI2ZiwgXCJuaEFycjtcIjoweDIxY2UsXG4gIFwibmhhcnI7XCI6MHgyMWFlLCBcIm5ocGFyO1wiOjB4MmFmMixcbiAgXCJuaTtcIjoweDIyMGIsIFwibmlzO1wiOjB4MjJmYyxcbiAgXCJuaXNkO1wiOjB4MjJmYSwgXCJuaXY7XCI6MHgyMjBiLFxuICBcIm5qY3k7XCI6MHg0NWEsIFwibmxBcnI7XCI6MHgyMWNkLFxuICBcIm5sRTtcIjpbMHgyMjY2LDB4MzM4XSwgXCJubGFycjtcIjoweDIxOWEsXG4gIFwibmxkcjtcIjoweDIwMjUsIFwibmxlO1wiOjB4MjI3MCxcbiAgXCJubGVmdGFycm93O1wiOjB4MjE5YSwgXCJubGVmdHJpZ2h0YXJyb3c7XCI6MHgyMWFlLFxuICBcIm5sZXE7XCI6MHgyMjcwLCBcIm5sZXFxO1wiOlsweDIyNjYsMHgzMzhdLFxuICBcIm5sZXFzbGFudDtcIjpbMHgyYTdkLDB4MzM4XSwgXCJubGVzO1wiOlsweDJhN2QsMHgzMzhdLFxuICBcIm5sZXNzO1wiOjB4MjI2ZSwgXCJubHNpbTtcIjoweDIyNzQsXG4gIFwibmx0O1wiOjB4MjI2ZSwgXCJubHRyaTtcIjoweDIyZWEsXG4gIFwibmx0cmllO1wiOjB4MjJlYywgXCJubWlkO1wiOjB4MjIyNCxcbiAgXCJub3BmO1wiOlsweGQ4MzUsMHhkZDVmXSwgXCJub3RcIjoweGFjLFxuICBcIm5vdDtcIjoweGFjLCBcIm5vdGluO1wiOjB4MjIwOSxcbiAgXCJub3RpbkU7XCI6WzB4MjJmOSwweDMzOF0sIFwibm90aW5kb3Q7XCI6WzB4MjJmNSwweDMzOF0sXG4gIFwibm90aW52YTtcIjoweDIyMDksIFwibm90aW52YjtcIjoweDIyZjcsXG4gIFwibm90aW52YztcIjoweDIyZjYsIFwibm90bmk7XCI6MHgyMjBjLFxuICBcIm5vdG5pdmE7XCI6MHgyMjBjLCBcIm5vdG5pdmI7XCI6MHgyMmZlLFxuICBcIm5vdG5pdmM7XCI6MHgyMmZkLCBcIm5wYXI7XCI6MHgyMjI2LFxuICBcIm5wYXJhbGxlbDtcIjoweDIyMjYsIFwibnBhcnNsO1wiOlsweDJhZmQsMHgyMGU1XSxcbiAgXCJucGFydDtcIjpbMHgyMjAyLDB4MzM4XSwgXCJucG9saW50O1wiOjB4MmExNCxcbiAgXCJucHI7XCI6MHgyMjgwLCBcIm5wcmN1ZTtcIjoweDIyZTAsXG4gIFwibnByZTtcIjpbMHgyYWFmLDB4MzM4XSwgXCJucHJlYztcIjoweDIyODAsXG4gIFwibnByZWNlcTtcIjpbMHgyYWFmLDB4MzM4XSwgXCJuckFycjtcIjoweDIxY2YsXG4gIFwibnJhcnI7XCI6MHgyMTliLCBcIm5yYXJyYztcIjpbMHgyOTMzLDB4MzM4XSxcbiAgXCJucmFycnc7XCI6WzB4MjE5ZCwweDMzOF0sIFwibnJpZ2h0YXJyb3c7XCI6MHgyMTliLFxuICBcIm5ydHJpO1wiOjB4MjJlYiwgXCJucnRyaWU7XCI6MHgyMmVkLFxuICBcIm5zYztcIjoweDIyODEsIFwibnNjY3VlO1wiOjB4MjJlMSxcbiAgXCJuc2NlO1wiOlsweDJhYjAsMHgzMzhdLCBcIm5zY3I7XCI6WzB4ZDgzNSwweGRjYzNdLFxuICBcIm5zaG9ydG1pZDtcIjoweDIyMjQsIFwibnNob3J0cGFyYWxsZWw7XCI6MHgyMjI2LFxuICBcIm5zaW07XCI6MHgyMjQxLCBcIm5zaW1lO1wiOjB4MjI0NCxcbiAgXCJuc2ltZXE7XCI6MHgyMjQ0LCBcIm5zbWlkO1wiOjB4MjIyNCxcbiAgXCJuc3BhcjtcIjoweDIyMjYsIFwibnNxc3ViZTtcIjoweDIyZTIsXG4gIFwibnNxc3VwZTtcIjoweDIyZTMsIFwibnN1YjtcIjoweDIyODQsXG4gIFwibnN1YkU7XCI6WzB4MmFjNSwweDMzOF0sIFwibnN1YmU7XCI6MHgyMjg4LFxuICBcIm5zdWJzZXQ7XCI6WzB4MjI4MiwweDIwZDJdLCBcIm5zdWJzZXRlcTtcIjoweDIyODgsXG4gIFwibnN1YnNldGVxcTtcIjpbMHgyYWM1LDB4MzM4XSwgXCJuc3VjYztcIjoweDIyODEsXG4gIFwibnN1Y2NlcTtcIjpbMHgyYWIwLDB4MzM4XSwgXCJuc3VwO1wiOjB4MjI4NSxcbiAgXCJuc3VwRTtcIjpbMHgyYWM2LDB4MzM4XSwgXCJuc3VwZTtcIjoweDIyODksXG4gIFwibnN1cHNldDtcIjpbMHgyMjgzLDB4MjBkMl0sIFwibnN1cHNldGVxO1wiOjB4MjI4OSxcbiAgXCJuc3Vwc2V0ZXFxO1wiOlsweDJhYzYsMHgzMzhdLCBcIm50Z2w7XCI6MHgyMjc5LFxuICBcIm50aWxkZVwiOjB4ZjEsIFwibnRpbGRlO1wiOjB4ZjEsXG4gIFwibnRsZztcIjoweDIyNzgsIFwibnRyaWFuZ2xlbGVmdDtcIjoweDIyZWEsXG4gIFwibnRyaWFuZ2xlbGVmdGVxO1wiOjB4MjJlYywgXCJudHJpYW5nbGVyaWdodDtcIjoweDIyZWIsXG4gIFwibnRyaWFuZ2xlcmlnaHRlcTtcIjoweDIyZWQsIFwibnU7XCI6MHgzYmQsXG4gIFwibnVtO1wiOjB4MjMsIFwibnVtZXJvO1wiOjB4MjExNixcbiAgXCJudW1zcDtcIjoweDIwMDcsIFwibnZEYXNoO1wiOjB4MjJhZCxcbiAgXCJudkhhcnI7XCI6MHgyOTA0LCBcIm52YXA7XCI6WzB4MjI0ZCwweDIwZDJdLFxuICBcIm52ZGFzaDtcIjoweDIyYWMsIFwibnZnZTtcIjpbMHgyMjY1LDB4MjBkMl0sXG4gIFwibnZndDtcIjpbMHgzZSwweDIwZDJdLCBcIm52aW5maW47XCI6MHgyOWRlLFxuICBcIm52bEFycjtcIjoweDI5MDIsIFwibnZsZTtcIjpbMHgyMjY0LDB4MjBkMl0sXG4gIFwibnZsdDtcIjpbMHgzYywweDIwZDJdLCBcIm52bHRyaWU7XCI6WzB4MjJiNCwweDIwZDJdLFxuICBcIm52ckFycjtcIjoweDI5MDMsIFwibnZydHJpZTtcIjpbMHgyMmI1LDB4MjBkMl0sXG4gIFwibnZzaW07XCI6WzB4MjIzYywweDIwZDJdLCBcIm53QXJyO1wiOjB4MjFkNixcbiAgXCJud2FyaGs7XCI6MHgyOTIzLCBcIm53YXJyO1wiOjB4MjE5NixcbiAgXCJud2Fycm93O1wiOjB4MjE5NiwgXCJud25lYXI7XCI6MHgyOTI3LFxuICBcIm9TO1wiOjB4MjRjOCwgXCJvYWN1dGVcIjoweGYzLFxuICBcIm9hY3V0ZTtcIjoweGYzLCBcIm9hc3Q7XCI6MHgyMjliLFxuICBcIm9jaXI7XCI6MHgyMjlhLCBcIm9jaXJjXCI6MHhmNCxcbiAgXCJvY2lyYztcIjoweGY0LCBcIm9jeTtcIjoweDQzZSxcbiAgXCJvZGFzaDtcIjoweDIyOWQsIFwib2RibGFjO1wiOjB4MTUxLFxuICBcIm9kaXY7XCI6MHgyYTM4LCBcIm9kb3Q7XCI6MHgyMjk5LFxuICBcIm9kc29sZDtcIjoweDI5YmMsIFwib2VsaWc7XCI6MHgxNTMsXG4gIFwib2ZjaXI7XCI6MHgyOWJmLCBcIm9mcjtcIjpbMHhkODM1LDB4ZGQyY10sXG4gIFwib2dvbjtcIjoweDJkYiwgXCJvZ3JhdmVcIjoweGYyLFxuICBcIm9ncmF2ZTtcIjoweGYyLCBcIm9ndDtcIjoweDI5YzEsXG4gIFwib2hiYXI7XCI6MHgyOWI1LCBcIm9obTtcIjoweDNhOSxcbiAgXCJvaW50O1wiOjB4MjIyZSwgXCJvbGFycjtcIjoweDIxYmEsXG4gIFwib2xjaXI7XCI6MHgyOWJlLCBcIm9sY3Jvc3M7XCI6MHgyOWJiLFxuICBcIm9saW5lO1wiOjB4MjAzZSwgXCJvbHQ7XCI6MHgyOWMwLFxuICBcIm9tYWNyO1wiOjB4MTRkLCBcIm9tZWdhO1wiOjB4M2M5LFxuICBcIm9taWNyb247XCI6MHgzYmYsIFwib21pZDtcIjoweDI5YjYsXG4gIFwib21pbnVzO1wiOjB4MjI5NiwgXCJvb3BmO1wiOlsweGQ4MzUsMHhkZDYwXSxcbiAgXCJvcGFyO1wiOjB4MjliNywgXCJvcGVycDtcIjoweDI5YjksXG4gIFwib3BsdXM7XCI6MHgyMjk1LCBcIm9yO1wiOjB4MjIyOCxcbiAgXCJvcmFycjtcIjoweDIxYmIsIFwib3JkO1wiOjB4MmE1ZCxcbiAgXCJvcmRlcjtcIjoweDIxMzQsIFwib3JkZXJvZjtcIjoweDIxMzQsXG4gIFwib3JkZlwiOjB4YWEsIFwib3JkZjtcIjoweGFhLFxuICBcIm9yZG1cIjoweGJhLCBcIm9yZG07XCI6MHhiYSxcbiAgXCJvcmlnb2Y7XCI6MHgyMmI2LCBcIm9yb3I7XCI6MHgyYTU2LFxuICBcIm9yc2xvcGU7XCI6MHgyYTU3LCBcIm9ydjtcIjoweDJhNWIsXG4gIFwib3NjcjtcIjoweDIxMzQsIFwib3NsYXNoXCI6MHhmOCxcbiAgXCJvc2xhc2g7XCI6MHhmOCwgXCJvc29sO1wiOjB4MjI5OCxcbiAgXCJvdGlsZGVcIjoweGY1LCBcIm90aWxkZTtcIjoweGY1LFxuICBcIm90aW1lcztcIjoweDIyOTcsIFwib3RpbWVzYXM7XCI6MHgyYTM2LFxuICBcIm91bWxcIjoweGY2LCBcIm91bWw7XCI6MHhmNixcbiAgXCJvdmJhcjtcIjoweDIzM2QsIFwicGFyO1wiOjB4MjIyNSxcbiAgXCJwYXJhXCI6MHhiNiwgXCJwYXJhO1wiOjB4YjYsXG4gIFwicGFyYWxsZWw7XCI6MHgyMjI1LCBcInBhcnNpbTtcIjoweDJhZjMsXG4gIFwicGFyc2w7XCI6MHgyYWZkLCBcInBhcnQ7XCI6MHgyMjAyLFxuICBcInBjeTtcIjoweDQzZiwgXCJwZXJjbnQ7XCI6MHgyNSxcbiAgXCJwZXJpb2Q7XCI6MHgyZSwgXCJwZXJtaWw7XCI6MHgyMDMwLFxuICBcInBlcnA7XCI6MHgyMmE1LCBcInBlcnRlbms7XCI6MHgyMDMxLFxuICBcInBmcjtcIjpbMHhkODM1LDB4ZGQyZF0sIFwicGhpO1wiOjB4M2M2LFxuICBcInBoaXY7XCI6MHgzZDUsIFwicGhtbWF0O1wiOjB4MjEzMyxcbiAgXCJwaG9uZTtcIjoweDI2MGUsIFwicGk7XCI6MHgzYzAsXG4gIFwicGl0Y2hmb3JrO1wiOjB4MjJkNCwgXCJwaXY7XCI6MHgzZDYsXG4gIFwicGxhbmNrO1wiOjB4MjEwZiwgXCJwbGFuY2toO1wiOjB4MjEwZSxcbiAgXCJwbGFua3Y7XCI6MHgyMTBmLCBcInBsdXM7XCI6MHgyYixcbiAgXCJwbHVzYWNpcjtcIjoweDJhMjMsIFwicGx1c2I7XCI6MHgyMjllLFxuICBcInBsdXNjaXI7XCI6MHgyYTIyLCBcInBsdXNkbztcIjoweDIyMTQsXG4gIFwicGx1c2R1O1wiOjB4MmEyNSwgXCJwbHVzZTtcIjoweDJhNzIsXG4gIFwicGx1c21uXCI6MHhiMSwgXCJwbHVzbW47XCI6MHhiMSxcbiAgXCJwbHVzc2ltO1wiOjB4MmEyNiwgXCJwbHVzdHdvO1wiOjB4MmEyNyxcbiAgXCJwbTtcIjoweGIxLCBcInBvaW50aW50O1wiOjB4MmExNSxcbiAgXCJwb3BmO1wiOlsweGQ4MzUsMHhkZDYxXSwgXCJwb3VuZFwiOjB4YTMsXG4gIFwicG91bmQ7XCI6MHhhMywgXCJwcjtcIjoweDIyN2EsXG4gIFwicHJFO1wiOjB4MmFiMywgXCJwcmFwO1wiOjB4MmFiNyxcbiAgXCJwcmN1ZTtcIjoweDIyN2MsIFwicHJlO1wiOjB4MmFhZixcbiAgXCJwcmVjO1wiOjB4MjI3YSwgXCJwcmVjYXBwcm94O1wiOjB4MmFiNyxcbiAgXCJwcmVjY3VybHllcTtcIjoweDIyN2MsIFwicHJlY2VxO1wiOjB4MmFhZixcbiAgXCJwcmVjbmFwcHJveDtcIjoweDJhYjksIFwicHJlY25lcXE7XCI6MHgyYWI1LFxuICBcInByZWNuc2ltO1wiOjB4MjJlOCwgXCJwcmVjc2ltO1wiOjB4MjI3ZSxcbiAgXCJwcmltZTtcIjoweDIwMzIsIFwicHJpbWVzO1wiOjB4MjExOSxcbiAgXCJwcm5FO1wiOjB4MmFiNSwgXCJwcm5hcDtcIjoweDJhYjksXG4gIFwicHJuc2ltO1wiOjB4MjJlOCwgXCJwcm9kO1wiOjB4MjIwZixcbiAgXCJwcm9mYWxhcjtcIjoweDIzMmUsIFwicHJvZmxpbmU7XCI6MHgyMzEyLFxuICBcInByb2ZzdXJmO1wiOjB4MjMxMywgXCJwcm9wO1wiOjB4MjIxZCxcbiAgXCJwcm9wdG87XCI6MHgyMjFkLCBcInByc2ltO1wiOjB4MjI3ZSxcbiAgXCJwcnVyZWw7XCI6MHgyMmIwLCBcInBzY3I7XCI6WzB4ZDgzNSwweGRjYzVdLFxuICBcInBzaTtcIjoweDNjOCwgXCJwdW5jc3A7XCI6MHgyMDA4LFxuICBcInFmcjtcIjpbMHhkODM1LDB4ZGQyZV0sIFwicWludDtcIjoweDJhMGMsXG4gIFwicW9wZjtcIjpbMHhkODM1LDB4ZGQ2Ml0sIFwicXByaW1lO1wiOjB4MjA1NyxcbiAgXCJxc2NyO1wiOlsweGQ4MzUsMHhkY2M2XSwgXCJxdWF0ZXJuaW9ucztcIjoweDIxMGQsXG4gIFwicXVhdGludDtcIjoweDJhMTYsIFwicXVlc3Q7XCI6MHgzZixcbiAgXCJxdWVzdGVxO1wiOjB4MjI1ZiwgXCJxdW90XCI6MHgyMixcbiAgXCJxdW90O1wiOjB4MjIsIFwickFhcnI7XCI6MHgyMWRiLFxuICBcInJBcnI7XCI6MHgyMWQyLCBcInJBdGFpbDtcIjoweDI5MWMsXG4gIFwickJhcnI7XCI6MHgyOTBmLCBcInJIYXI7XCI6MHgyOTY0LFxuICBcInJhY2U7XCI6WzB4MjIzZCwweDMzMV0sIFwicmFjdXRlO1wiOjB4MTU1LFxuICBcInJhZGljO1wiOjB4MjIxYSwgXCJyYWVtcHR5djtcIjoweDI5YjMsXG4gIFwicmFuZztcIjoweDI3ZTksIFwicmFuZ2Q7XCI6MHgyOTkyLFxuICBcInJhbmdlO1wiOjB4MjlhNSwgXCJyYW5nbGU7XCI6MHgyN2U5LFxuICBcInJhcXVvXCI6MHhiYiwgXCJyYXF1bztcIjoweGJiLFxuICBcInJhcnI7XCI6MHgyMTkyLCBcInJhcnJhcDtcIjoweDI5NzUsXG4gIFwicmFycmI7XCI6MHgyMWU1LCBcInJhcnJiZnM7XCI6MHgyOTIwLFxuICBcInJhcnJjO1wiOjB4MjkzMywgXCJyYXJyZnM7XCI6MHgyOTFlLFxuICBcInJhcnJoaztcIjoweDIxYWEsIFwicmFycmxwO1wiOjB4MjFhYyxcbiAgXCJyYXJycGw7XCI6MHgyOTQ1LCBcInJhcnJzaW07XCI6MHgyOTc0LFxuICBcInJhcnJ0bDtcIjoweDIxYTMsIFwicmFycnc7XCI6MHgyMTlkLFxuICBcInJhdGFpbDtcIjoweDI5MWEsIFwicmF0aW87XCI6MHgyMjM2LFxuICBcInJhdGlvbmFscztcIjoweDIxMWEsIFwicmJhcnI7XCI6MHgyOTBkLFxuICBcInJiYnJrO1wiOjB4Mjc3MywgXCJyYnJhY2U7XCI6MHg3ZCxcbiAgXCJyYnJhY2s7XCI6MHg1ZCwgXCJyYnJrZTtcIjoweDI5OGMsXG4gIFwicmJya3NsZDtcIjoweDI5OGUsIFwicmJya3NsdTtcIjoweDI5OTAsXG4gIFwicmNhcm9uO1wiOjB4MTU5LCBcInJjZWRpbDtcIjoweDE1NyxcbiAgXCJyY2VpbDtcIjoweDIzMDksIFwicmN1YjtcIjoweDdkLFxuICBcInJjeTtcIjoweDQ0MCwgXCJyZGNhO1wiOjB4MjkzNyxcbiAgXCJyZGxkaGFyO1wiOjB4Mjk2OSwgXCJyZHF1bztcIjoweDIwMWQsXG4gIFwicmRxdW9yO1wiOjB4MjAxZCwgXCJyZHNoO1wiOjB4MjFiMyxcbiAgXCJyZWFsO1wiOjB4MjExYywgXCJyZWFsaW5lO1wiOjB4MjExYixcbiAgXCJyZWFscGFydDtcIjoweDIxMWMsIFwicmVhbHM7XCI6MHgyMTFkLFxuICBcInJlY3Q7XCI6MHgyNWFkLCBcInJlZ1wiOjB4YWUsXG4gIFwicmVnO1wiOjB4YWUsIFwicmZpc2h0O1wiOjB4Mjk3ZCxcbiAgXCJyZmxvb3I7XCI6MHgyMzBiLCBcInJmcjtcIjpbMHhkODM1LDB4ZGQyZl0sXG4gIFwicmhhcmQ7XCI6MHgyMWMxLCBcInJoYXJ1O1wiOjB4MjFjMCxcbiAgXCJyaGFydWw7XCI6MHgyOTZjLCBcInJobztcIjoweDNjMSxcbiAgXCJyaG92O1wiOjB4M2YxLCBcInJpZ2h0YXJyb3c7XCI6MHgyMTkyLFxuICBcInJpZ2h0YXJyb3d0YWlsO1wiOjB4MjFhMywgXCJyaWdodGhhcnBvb25kb3duO1wiOjB4MjFjMSxcbiAgXCJyaWdodGhhcnBvb251cDtcIjoweDIxYzAsIFwicmlnaHRsZWZ0YXJyb3dzO1wiOjB4MjFjNCxcbiAgXCJyaWdodGxlZnRoYXJwb29ucztcIjoweDIxY2MsIFwicmlnaHRyaWdodGFycm93cztcIjoweDIxYzksXG4gIFwicmlnaHRzcXVpZ2Fycm93O1wiOjB4MjE5ZCwgXCJyaWdodHRocmVldGltZXM7XCI6MHgyMmNjLFxuICBcInJpbmc7XCI6MHgyZGEsIFwicmlzaW5nZG90c2VxO1wiOjB4MjI1MyxcbiAgXCJybGFycjtcIjoweDIxYzQsIFwicmxoYXI7XCI6MHgyMWNjLFxuICBcInJsbTtcIjoweDIwMGYsIFwicm1vdXN0O1wiOjB4MjNiMSxcbiAgXCJybW91c3RhY2hlO1wiOjB4MjNiMSwgXCJybm1pZDtcIjoweDJhZWUsXG4gIFwicm9hbmc7XCI6MHgyN2VkLCBcInJvYXJyO1wiOjB4MjFmZSxcbiAgXCJyb2JyaztcIjoweDI3ZTcsIFwicm9wYXI7XCI6MHgyOTg2LFxuICBcInJvcGY7XCI6WzB4ZDgzNSwweGRkNjNdLCBcInJvcGx1cztcIjoweDJhMmUsXG4gIFwicm90aW1lcztcIjoweDJhMzUsIFwicnBhcjtcIjoweDI5LFxuICBcInJwYXJndDtcIjoweDI5OTQsIFwicnBwb2xpbnQ7XCI6MHgyYTEyLFxuICBcInJyYXJyO1wiOjB4MjFjOSwgXCJyc2FxdW87XCI6MHgyMDNhLFxuICBcInJzY3I7XCI6WzB4ZDgzNSwweGRjYzddLCBcInJzaDtcIjoweDIxYjEsXG4gIFwicnNxYjtcIjoweDVkLCBcInJzcXVvO1wiOjB4MjAxOSxcbiAgXCJyc3F1b3I7XCI6MHgyMDE5LCBcInJ0aHJlZTtcIjoweDIyY2MsXG4gIFwicnRpbWVzO1wiOjB4MjJjYSwgXCJydHJpO1wiOjB4MjViOSxcbiAgXCJydHJpZTtcIjoweDIyYjUsIFwicnRyaWY7XCI6MHgyNWI4LFxuICBcInJ0cmlsdHJpO1wiOjB4MjljZSwgXCJydWx1aGFyO1wiOjB4Mjk2OCxcbiAgXCJyeDtcIjoweDIxMWUsIFwic2FjdXRlO1wiOjB4MTViLFxuICBcInNicXVvO1wiOjB4MjAxYSwgXCJzYztcIjoweDIyN2IsXG4gIFwic2NFO1wiOjB4MmFiNCwgXCJzY2FwO1wiOjB4MmFiOCxcbiAgXCJzY2Fyb247XCI6MHgxNjEsIFwic2NjdWU7XCI6MHgyMjdkLFxuICBcInNjZTtcIjoweDJhYjAsIFwic2NlZGlsO1wiOjB4MTVmLFxuICBcInNjaXJjO1wiOjB4MTVkLCBcInNjbkU7XCI6MHgyYWI2LFxuICBcInNjbmFwO1wiOjB4MmFiYSwgXCJzY25zaW07XCI6MHgyMmU5LFxuICBcInNjcG9saW50O1wiOjB4MmExMywgXCJzY3NpbTtcIjoweDIyN2YsXG4gIFwic2N5O1wiOjB4NDQxLCBcInNkb3Q7XCI6MHgyMmM1LFxuICBcInNkb3RiO1wiOjB4MjJhMSwgXCJzZG90ZTtcIjoweDJhNjYsXG4gIFwic2VBcnI7XCI6MHgyMWQ4LCBcInNlYXJoaztcIjoweDI5MjUsXG4gIFwic2VhcnI7XCI6MHgyMTk4LCBcInNlYXJyb3c7XCI6MHgyMTk4LFxuICBcInNlY3RcIjoweGE3LCBcInNlY3Q7XCI6MHhhNyxcbiAgXCJzZW1pO1wiOjB4M2IsIFwic2Vzd2FyO1wiOjB4MjkyOSxcbiAgXCJzZXRtaW51cztcIjoweDIyMTYsIFwic2V0bW47XCI6MHgyMjE2LFxuICBcInNleHQ7XCI6MHgyNzM2LCBcInNmcjtcIjpbMHhkODM1LDB4ZGQzMF0sXG4gIFwic2Zyb3duO1wiOjB4MjMyMiwgXCJzaGFycDtcIjoweDI2NmYsXG4gIFwic2hjaGN5O1wiOjB4NDQ5LCBcInNoY3k7XCI6MHg0NDgsXG4gIFwic2hvcnRtaWQ7XCI6MHgyMjIzLCBcInNob3J0cGFyYWxsZWw7XCI6MHgyMjI1LFxuICBcInNoeVwiOjB4YWQsIFwic2h5O1wiOjB4YWQsXG4gIFwic2lnbWE7XCI6MHgzYzMsIFwic2lnbWFmO1wiOjB4M2MyLFxuICBcInNpZ21hdjtcIjoweDNjMiwgXCJzaW07XCI6MHgyMjNjLFxuICBcInNpbWRvdDtcIjoweDJhNmEsIFwic2ltZTtcIjoweDIyNDMsXG4gIFwic2ltZXE7XCI6MHgyMjQzLCBcInNpbWc7XCI6MHgyYTllLFxuICBcInNpbWdFO1wiOjB4MmFhMCwgXCJzaW1sO1wiOjB4MmE5ZCxcbiAgXCJzaW1sRTtcIjoweDJhOWYsIFwic2ltbmU7XCI6MHgyMjQ2LFxuICBcInNpbXBsdXM7XCI6MHgyYTI0LCBcInNpbXJhcnI7XCI6MHgyOTcyLFxuICBcInNsYXJyO1wiOjB4MjE5MCwgXCJzbWFsbHNldG1pbnVzO1wiOjB4MjIxNixcbiAgXCJzbWFzaHA7XCI6MHgyYTMzLCBcInNtZXBhcnNsO1wiOjB4MjllNCxcbiAgXCJzbWlkO1wiOjB4MjIyMywgXCJzbWlsZTtcIjoweDIzMjMsXG4gIFwic210O1wiOjB4MmFhYSwgXCJzbXRlO1wiOjB4MmFhYyxcbiAgXCJzbXRlcztcIjpbMHgyYWFjLDB4ZmUwMF0sIFwic29mdGN5O1wiOjB4NDRjLFxuICBcInNvbDtcIjoweDJmLCBcInNvbGI7XCI6MHgyOWM0LFxuICBcInNvbGJhcjtcIjoweDIzM2YsIFwic29wZjtcIjpbMHhkODM1LDB4ZGQ2NF0sXG4gIFwic3BhZGVzO1wiOjB4MjY2MCwgXCJzcGFkZXN1aXQ7XCI6MHgyNjYwLFxuICBcInNwYXI7XCI6MHgyMjI1LCBcInNxY2FwO1wiOjB4MjI5MyxcbiAgXCJzcWNhcHM7XCI6WzB4MjI5MywweGZlMDBdLCBcInNxY3VwO1wiOjB4MjI5NCxcbiAgXCJzcWN1cHM7XCI6WzB4MjI5NCwweGZlMDBdLCBcInNxc3ViO1wiOjB4MjI4ZixcbiAgXCJzcXN1YmU7XCI6MHgyMjkxLCBcInNxc3Vic2V0O1wiOjB4MjI4ZixcbiAgXCJzcXN1YnNldGVxO1wiOjB4MjI5MSwgXCJzcXN1cDtcIjoweDIyOTAsXG4gIFwic3FzdXBlO1wiOjB4MjI5MiwgXCJzcXN1cHNldDtcIjoweDIyOTAsXG4gIFwic3FzdXBzZXRlcTtcIjoweDIyOTIsIFwic3F1O1wiOjB4MjVhMSxcbiAgXCJzcXVhcmU7XCI6MHgyNWExLCBcInNxdWFyZjtcIjoweDI1YWEsXG4gIFwic3F1ZjtcIjoweDI1YWEsIFwic3JhcnI7XCI6MHgyMTkyLFxuICBcInNzY3I7XCI6WzB4ZDgzNSwweGRjYzhdLCBcInNzZXRtbjtcIjoweDIyMTYsXG4gIFwic3NtaWxlO1wiOjB4MjMyMywgXCJzc3RhcmY7XCI6MHgyMmM2LFxuICBcInN0YXI7XCI6MHgyNjA2LCBcInN0YXJmO1wiOjB4MjYwNSxcbiAgXCJzdHJhaWdodGVwc2lsb247XCI6MHgzZjUsIFwic3RyYWlnaHRwaGk7XCI6MHgzZDUsXG4gIFwic3RybnM7XCI6MHhhZiwgXCJzdWI7XCI6MHgyMjgyLFxuICBcInN1YkU7XCI6MHgyYWM1LCBcInN1YmRvdDtcIjoweDJhYmQsXG4gIFwic3ViZTtcIjoweDIyODYsIFwic3ViZWRvdDtcIjoweDJhYzMsXG4gIFwic3VibXVsdDtcIjoweDJhYzEsIFwic3VibkU7XCI6MHgyYWNiLFxuICBcInN1Ym5lO1wiOjB4MjI4YSwgXCJzdWJwbHVzO1wiOjB4MmFiZixcbiAgXCJzdWJyYXJyO1wiOjB4Mjk3OSwgXCJzdWJzZXQ7XCI6MHgyMjgyLFxuICBcInN1YnNldGVxO1wiOjB4MjI4NiwgXCJzdWJzZXRlcXE7XCI6MHgyYWM1LFxuICBcInN1YnNldG5lcTtcIjoweDIyOGEsIFwic3Vic2V0bmVxcTtcIjoweDJhY2IsXG4gIFwic3Vic2ltO1wiOjB4MmFjNywgXCJzdWJzdWI7XCI6MHgyYWQ1LFxuICBcInN1YnN1cDtcIjoweDJhZDMsIFwic3VjYztcIjoweDIyN2IsXG4gIFwic3VjY2FwcHJveDtcIjoweDJhYjgsIFwic3VjY2N1cmx5ZXE7XCI6MHgyMjdkLFxuICBcInN1Y2NlcTtcIjoweDJhYjAsIFwic3VjY25hcHByb3g7XCI6MHgyYWJhLFxuICBcInN1Y2NuZXFxO1wiOjB4MmFiNiwgXCJzdWNjbnNpbTtcIjoweDIyZTksXG4gIFwic3VjY3NpbTtcIjoweDIyN2YsIFwic3VtO1wiOjB4MjIxMSxcbiAgXCJzdW5nO1wiOjB4MjY2YSwgXCJzdXAxXCI6MHhiOSxcbiAgXCJzdXAxO1wiOjB4YjksIFwic3VwMlwiOjB4YjIsXG4gIFwic3VwMjtcIjoweGIyLCBcInN1cDNcIjoweGIzLFxuICBcInN1cDM7XCI6MHhiMywgXCJzdXA7XCI6MHgyMjgzLFxuICBcInN1cEU7XCI6MHgyYWM2LCBcInN1cGRvdDtcIjoweDJhYmUsXG4gIFwic3VwZHN1YjtcIjoweDJhZDgsIFwic3VwZTtcIjoweDIyODcsXG4gIFwic3VwZWRvdDtcIjoweDJhYzQsIFwic3VwaHNvbDtcIjoweDI3YzksXG4gIFwic3VwaHN1YjtcIjoweDJhZDcsIFwic3VwbGFycjtcIjoweDI5N2IsXG4gIFwic3VwbXVsdDtcIjoweDJhYzIsIFwic3VwbkU7XCI6MHgyYWNjLFxuICBcInN1cG5lO1wiOjB4MjI4YiwgXCJzdXBwbHVzO1wiOjB4MmFjMCxcbiAgXCJzdXBzZXQ7XCI6MHgyMjgzLCBcInN1cHNldGVxO1wiOjB4MjI4NyxcbiAgXCJzdXBzZXRlcXE7XCI6MHgyYWM2LCBcInN1cHNldG5lcTtcIjoweDIyOGIsXG4gIFwic3Vwc2V0bmVxcTtcIjoweDJhY2MsIFwic3Vwc2ltO1wiOjB4MmFjOCxcbiAgXCJzdXBzdWI7XCI6MHgyYWQ0LCBcInN1cHN1cDtcIjoweDJhZDYsXG4gIFwic3dBcnI7XCI6MHgyMWQ5LCBcInN3YXJoaztcIjoweDI5MjYsXG4gIFwic3dhcnI7XCI6MHgyMTk5LCBcInN3YXJyb3c7XCI6MHgyMTk5LFxuICBcInN3bndhcjtcIjoweDI5MmEsIFwic3psaWdcIjoweGRmLFxuICBcInN6bGlnO1wiOjB4ZGYsIFwidGFyZ2V0O1wiOjB4MjMxNixcbiAgXCJ0YXU7XCI6MHgzYzQsIFwidGJyaztcIjoweDIzYjQsXG4gIFwidGNhcm9uO1wiOjB4MTY1LCBcInRjZWRpbDtcIjoweDE2MyxcbiAgXCJ0Y3k7XCI6MHg0NDIsIFwidGRvdDtcIjoweDIwZGIsXG4gIFwidGVscmVjO1wiOjB4MjMxNSwgXCJ0ZnI7XCI6WzB4ZDgzNSwweGRkMzFdLFxuICBcInRoZXJlNDtcIjoweDIyMzQsIFwidGhlcmVmb3JlO1wiOjB4MjIzNCxcbiAgXCJ0aGV0YTtcIjoweDNiOCwgXCJ0aGV0YXN5bTtcIjoweDNkMSxcbiAgXCJ0aGV0YXY7XCI6MHgzZDEsIFwidGhpY2thcHByb3g7XCI6MHgyMjQ4LFxuICBcInRoaWNrc2ltO1wiOjB4MjIzYywgXCJ0aGluc3A7XCI6MHgyMDA5LFxuICBcInRoa2FwO1wiOjB4MjI0OCwgXCJ0aGtzaW07XCI6MHgyMjNjLFxuICBcInRob3JuXCI6MHhmZSwgXCJ0aG9ybjtcIjoweGZlLFxuICBcInRpbGRlO1wiOjB4MmRjLCBcInRpbWVzXCI6MHhkNyxcbiAgXCJ0aW1lcztcIjoweGQ3LCBcInRpbWVzYjtcIjoweDIyYTAsXG4gIFwidGltZXNiYXI7XCI6MHgyYTMxLCBcInRpbWVzZDtcIjoweDJhMzAsXG4gIFwidGludDtcIjoweDIyMmQsIFwidG9lYTtcIjoweDI5MjgsXG4gIFwidG9wO1wiOjB4MjJhNCwgXCJ0b3Bib3Q7XCI6MHgyMzM2LFxuICBcInRvcGNpcjtcIjoweDJhZjEsIFwidG9wZjtcIjpbMHhkODM1LDB4ZGQ2NV0sXG4gIFwidG9wZm9yaztcIjoweDJhZGEsIFwidG9zYTtcIjoweDI5MjksXG4gIFwidHByaW1lO1wiOjB4MjAzNCwgXCJ0cmFkZTtcIjoweDIxMjIsXG4gIFwidHJpYW5nbGU7XCI6MHgyNWI1LCBcInRyaWFuZ2xlZG93bjtcIjoweDI1YmYsXG4gIFwidHJpYW5nbGVsZWZ0O1wiOjB4MjVjMywgXCJ0cmlhbmdsZWxlZnRlcTtcIjoweDIyYjQsXG4gIFwidHJpYW5nbGVxO1wiOjB4MjI1YywgXCJ0cmlhbmdsZXJpZ2h0O1wiOjB4MjViOSxcbiAgXCJ0cmlhbmdsZXJpZ2h0ZXE7XCI6MHgyMmI1LCBcInRyaWRvdDtcIjoweDI1ZWMsXG4gIFwidHJpZTtcIjoweDIyNWMsIFwidHJpbWludXM7XCI6MHgyYTNhLFxuICBcInRyaXBsdXM7XCI6MHgyYTM5LCBcInRyaXNiO1wiOjB4MjljZCxcbiAgXCJ0cml0aW1lO1wiOjB4MmEzYiwgXCJ0cnBleml1bTtcIjoweDIzZTIsXG4gIFwidHNjcjtcIjpbMHhkODM1LDB4ZGNjOV0sIFwidHNjeTtcIjoweDQ0NixcbiAgXCJ0c2hjeTtcIjoweDQ1YiwgXCJ0c3Ryb2s7XCI6MHgxNjcsXG4gIFwidHdpeHQ7XCI6MHgyMjZjLCBcInR3b2hlYWRsZWZ0YXJyb3c7XCI6MHgyMTllLFxuICBcInR3b2hlYWRyaWdodGFycm93O1wiOjB4MjFhMCwgXCJ1QXJyO1wiOjB4MjFkMSxcbiAgXCJ1SGFyO1wiOjB4Mjk2MywgXCJ1YWN1dGVcIjoweGZhLFxuICBcInVhY3V0ZTtcIjoweGZhLCBcInVhcnI7XCI6MHgyMTkxLFxuICBcInVicmN5O1wiOjB4NDVlLCBcInVicmV2ZTtcIjoweDE2ZCxcbiAgXCJ1Y2lyY1wiOjB4ZmIsIFwidWNpcmM7XCI6MHhmYixcbiAgXCJ1Y3k7XCI6MHg0NDMsIFwidWRhcnI7XCI6MHgyMWM1LFxuICBcInVkYmxhYztcIjoweDE3MSwgXCJ1ZGhhcjtcIjoweDI5NmUsXG4gIFwidWZpc2h0O1wiOjB4Mjk3ZSwgXCJ1ZnI7XCI6WzB4ZDgzNSwweGRkMzJdLFxuICBcInVncmF2ZVwiOjB4ZjksIFwidWdyYXZlO1wiOjB4ZjksXG4gIFwidWhhcmw7XCI6MHgyMWJmLCBcInVoYXJyO1wiOjB4MjFiZSxcbiAgXCJ1aGJsaztcIjoweDI1ODAsIFwidWxjb3JuO1wiOjB4MjMxYyxcbiAgXCJ1bGNvcm5lcjtcIjoweDIzMWMsIFwidWxjcm9wO1wiOjB4MjMwZixcbiAgXCJ1bHRyaTtcIjoweDI1ZjgsIFwidW1hY3I7XCI6MHgxNmIsXG4gIFwidW1sXCI6MHhhOCwgXCJ1bWw7XCI6MHhhOCxcbiAgXCJ1b2dvbjtcIjoweDE3MywgXCJ1b3BmO1wiOlsweGQ4MzUsMHhkZDY2XSxcbiAgXCJ1cGFycm93O1wiOjB4MjE5MSwgXCJ1cGRvd25hcnJvdztcIjoweDIxOTUsXG4gIFwidXBoYXJwb29ubGVmdDtcIjoweDIxYmYsIFwidXBoYXJwb29ucmlnaHQ7XCI6MHgyMWJlLFxuICBcInVwbHVzO1wiOjB4MjI4ZSwgXCJ1cHNpO1wiOjB4M2M1LFxuICBcInVwc2loO1wiOjB4M2QyLCBcInVwc2lsb247XCI6MHgzYzUsXG4gIFwidXB1cGFycm93cztcIjoweDIxYzgsIFwidXJjb3JuO1wiOjB4MjMxZCxcbiAgXCJ1cmNvcm5lcjtcIjoweDIzMWQsIFwidXJjcm9wO1wiOjB4MjMwZSxcbiAgXCJ1cmluZztcIjoweDE2ZiwgXCJ1cnRyaTtcIjoweDI1ZjksXG4gIFwidXNjcjtcIjpbMHhkODM1LDB4ZGNjYV0sIFwidXRkb3Q7XCI6MHgyMmYwLFxuICBcInV0aWxkZTtcIjoweDE2OSwgXCJ1dHJpO1wiOjB4MjViNSxcbiAgXCJ1dHJpZjtcIjoweDI1YjQsIFwidXVhcnI7XCI6MHgyMWM4LFxuICBcInV1bWxcIjoweGZjLCBcInV1bWw7XCI6MHhmYyxcbiAgXCJ1d2FuZ2xlO1wiOjB4MjlhNywgXCJ2QXJyO1wiOjB4MjFkNSxcbiAgXCJ2QmFyO1wiOjB4MmFlOCwgXCJ2QmFydjtcIjoweDJhZTksXG4gIFwidkRhc2g7XCI6MHgyMmE4LCBcInZhbmdydDtcIjoweDI5OWMsXG4gIFwidmFyZXBzaWxvbjtcIjoweDNmNSwgXCJ2YXJrYXBwYTtcIjoweDNmMCxcbiAgXCJ2YXJub3RoaW5nO1wiOjB4MjIwNSwgXCJ2YXJwaGk7XCI6MHgzZDUsXG4gIFwidmFycGk7XCI6MHgzZDYsIFwidmFycHJvcHRvO1wiOjB4MjIxZCxcbiAgXCJ2YXJyO1wiOjB4MjE5NSwgXCJ2YXJyaG87XCI6MHgzZjEsXG4gIFwidmFyc2lnbWE7XCI6MHgzYzIsIFwidmFyc3Vic2V0bmVxO1wiOlsweDIyOGEsMHhmZTAwXSxcbiAgXCJ2YXJzdWJzZXRuZXFxO1wiOlsweDJhY2IsMHhmZTAwXSwgXCJ2YXJzdXBzZXRuZXE7XCI6WzB4MjI4YiwweGZlMDBdLFxuICBcInZhcnN1cHNldG5lcXE7XCI6WzB4MmFjYywweGZlMDBdLCBcInZhcnRoZXRhO1wiOjB4M2QxLFxuICBcInZhcnRyaWFuZ2xlbGVmdDtcIjoweDIyYjIsIFwidmFydHJpYW5nbGVyaWdodDtcIjoweDIyYjMsXG4gIFwidmN5O1wiOjB4NDMyLCBcInZkYXNoO1wiOjB4MjJhMixcbiAgXCJ2ZWU7XCI6MHgyMjI4LCBcInZlZWJhcjtcIjoweDIyYmIsXG4gIFwidmVlZXE7XCI6MHgyMjVhLCBcInZlbGxpcDtcIjoweDIyZWUsXG4gIFwidmVyYmFyO1wiOjB4N2MsIFwidmVydDtcIjoweDdjLFxuICBcInZmcjtcIjpbMHhkODM1LDB4ZGQzM10sIFwidmx0cmk7XCI6MHgyMmIyLFxuICBcInZuc3ViO1wiOlsweDIyODIsMHgyMGQyXSwgXCJ2bnN1cDtcIjpbMHgyMjgzLDB4MjBkMl0sXG4gIFwidm9wZjtcIjpbMHhkODM1LDB4ZGQ2N10sIFwidnByb3A7XCI6MHgyMjFkLFxuICBcInZydHJpO1wiOjB4MjJiMywgXCJ2c2NyO1wiOlsweGQ4MzUsMHhkY2NiXSxcbiAgXCJ2c3VibkU7XCI6WzB4MmFjYiwweGZlMDBdLCBcInZzdWJuZTtcIjpbMHgyMjhhLDB4ZmUwMF0sXG4gIFwidnN1cG5FO1wiOlsweDJhY2MsMHhmZTAwXSwgXCJ2c3VwbmU7XCI6WzB4MjI4YiwweGZlMDBdLFxuICBcInZ6aWd6YWc7XCI6MHgyOTlhLCBcIndjaXJjO1wiOjB4MTc1LFxuICBcIndlZGJhcjtcIjoweDJhNWYsIFwid2VkZ2U7XCI6MHgyMjI3LFxuICBcIndlZGdlcTtcIjoweDIyNTksIFwid2VpZXJwO1wiOjB4MjExOCxcbiAgXCJ3ZnI7XCI6WzB4ZDgzNSwweGRkMzRdLCBcIndvcGY7XCI6WzB4ZDgzNSwweGRkNjhdLFxuICBcIndwO1wiOjB4MjExOCwgXCJ3cjtcIjoweDIyNDAsXG4gIFwid3JlYXRoO1wiOjB4MjI0MCwgXCJ3c2NyO1wiOlsweGQ4MzUsMHhkY2NjXSxcbiAgXCJ4Y2FwO1wiOjB4MjJjMiwgXCJ4Y2lyYztcIjoweDI1ZWYsXG4gIFwieGN1cDtcIjoweDIyYzMsIFwieGR0cmk7XCI6MHgyNWJkLFxuICBcInhmcjtcIjpbMHhkODM1LDB4ZGQzNV0sIFwieGhBcnI7XCI6MHgyN2ZhLFxuICBcInhoYXJyO1wiOjB4MjdmNywgXCJ4aTtcIjoweDNiZSxcbiAgXCJ4bEFycjtcIjoweDI3ZjgsIFwieGxhcnI7XCI6MHgyN2Y1LFxuICBcInhtYXA7XCI6MHgyN2ZjLCBcInhuaXM7XCI6MHgyMmZiLFxuICBcInhvZG90O1wiOjB4MmEwMCwgXCJ4b3BmO1wiOlsweGQ4MzUsMHhkZDY5XSxcbiAgXCJ4b3BsdXM7XCI6MHgyYTAxLCBcInhvdGltZTtcIjoweDJhMDIsXG4gIFwieHJBcnI7XCI6MHgyN2Y5LCBcInhyYXJyO1wiOjB4MjdmNixcbiAgXCJ4c2NyO1wiOlsweGQ4MzUsMHhkY2NkXSwgXCJ4c3FjdXA7XCI6MHgyYTA2LFxuICBcInh1cGx1cztcIjoweDJhMDQsIFwieHV0cmk7XCI6MHgyNWIzLFxuICBcInh2ZWU7XCI6MHgyMmMxLCBcInh3ZWRnZTtcIjoweDIyYzAsXG4gIFwieWFjdXRlXCI6MHhmZCwgXCJ5YWN1dGU7XCI6MHhmZCxcbiAgXCJ5YWN5O1wiOjB4NDRmLCBcInljaXJjO1wiOjB4MTc3LFxuICBcInljeTtcIjoweDQ0YiwgXCJ5ZW5cIjoweGE1LFxuICBcInllbjtcIjoweGE1LCBcInlmcjtcIjpbMHhkODM1LDB4ZGQzNl0sXG4gIFwieWljeTtcIjoweDQ1NywgXCJ5b3BmO1wiOlsweGQ4MzUsMHhkZDZhXSxcbiAgXCJ5c2NyO1wiOlsweGQ4MzUsMHhkY2NlXSwgXCJ5dWN5O1wiOjB4NDRlLFxuICBcInl1bWxcIjoweGZmLCBcInl1bWw7XCI6MHhmZixcbiAgXCJ6YWN1dGU7XCI6MHgxN2EsIFwiemNhcm9uO1wiOjB4MTdlLFxuICBcInpjeTtcIjoweDQzNywgXCJ6ZG90O1wiOjB4MTdjLFxuICBcInplZXRyZjtcIjoweDIxMjgsIFwiemV0YTtcIjoweDNiNixcbiAgXCJ6ZnI7XCI6WzB4ZDgzNSwweGRkMzddLCBcInpoY3k7XCI6MHg0MzYsXG4gIFwiemlncmFycjtcIjoweDIxZGQsIFwiem9wZjtcIjpbMHhkODM1LDB4ZGQ2Yl0sXG4gIFwienNjcjtcIjpbMHhkODM1LDB4ZGNjZl0sIFwiendqO1wiOjB4MjAwZCxcbiAgXCJ6d25qO1wiOjB4MjAwYyxcbn07XG4vKlxuICogVGhpcyByZWdleHAgaXMgZ2VuZXJhdGVkIHdpdGggdGVzdC90b29scy91cGRhdGUtZW50aXRpZXMuanNcbiAqIEl0IHdpbGwgYWx3YXlzIG1hdGNoIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgLS0gYnV0IG5vdGUgdGhhdCB0aGVyZVxuICogYXJlIG5vIGVudGl0aWVzIHdob3NlIG5hbWVzIGFyZSBhIHNpbmdsZSBjaGFyYWN0ZXIgbG9uZy5cbiAqL1xudmFyIE5BTUVEQ0hBUlJFRiA9IC8oQSg/OkVsaWc7P3xNUDs/fGFjdXRlOz98YnJldmU7fGMoPzppcmM7P3x5Oyl8ZnI7fGdyYXZlOz98bHBoYTt8bWFjcjt8bmQ7fG8oPzpnb247fHBmOyl8cHBseUZ1bmN0aW9uO3xyaW5nOz98cyg/OmNyO3xzaWduOyl8dGlsZGU7P3x1bWw7Pyl8Qig/OmEoPzpja3NsYXNoO3xyKD86djt8d2VkOykpfGN5O3xlKD86Y2F1c2U7fHJub3VsbGlzO3x0YTspfGZyO3xvcGY7fHJldmU7fHNjcjt8dW1wZXE7KXxDKD86SGN5O3xPUFk7P3xhKD86Y3V0ZTt8cCg/Ojt8aXRhbERpZmZlcmVudGlhbEQ7KXx5bGV5czspfGMoPzphcm9uO3xlZGlsOz98aXJjO3xvbmludDspfGRvdDt8ZSg/OmRpbGxhO3xudGVyRG90Oyl8ZnI7fGhpO3xpcmNsZSg/OkRvdDt8TWludXM7fFBsdXM7fFRpbWVzOyl8bG8oPzpja3dpc2VDb250b3VySW50ZWdyYWw7fHNlQ3VybHkoPzpEb3VibGVRdW90ZTt8UXVvdGU7KSl8byg/Omxvbig/Ojt8ZTspfG4oPzpncnVlbnQ7fGludDt8dG91ckludGVncmFsOyl8cCg/OmY7fHJvZHVjdDspfHVudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsOyl8cm9zczt8c2NyO3x1cCg/Ojt8Q2FwOykpfEQoPzpEKD86O3xvdHJhaGQ7KXxKY3k7fFNjeTt8WmN5O3xhKD86Z2dlcjt8cnI7fHNodjspfGMoPzphcm9uO3x5Oyl8ZWwoPzo7fHRhOyl8ZnI7fGkoPzphKD86Y3JpdGljYWwoPzpBY3V0ZTt8RG8oPzp0O3x1YmxlQWN1dGU7KXxHcmF2ZTt8VGlsZGU7KXxtb25kOyl8ZmZlcmVudGlhbEQ7KXxvKD86cGY7fHQoPzo7fERvdDt8RXF1YWw7KXx1YmxlKD86Q29udG91ckludGVncmFsO3xEbyg/OnQ7fHduQXJyb3c7KXxMKD86ZWZ0KD86QXJyb3c7fFJpZ2h0QXJyb3c7fFRlZTspfG9uZyg/OkxlZnQoPzpBcnJvdzt8UmlnaHRBcnJvdzspfFJpZ2h0QXJyb3c7KSl8UmlnaHQoPzpBcnJvdzt8VGVlOyl8VXAoPzpBcnJvdzt8RG93bkFycm93Oyl8VmVydGljYWxCYXI7KXx3big/OkFycm93KD86O3xCYXI7fFVwQXJyb3c7KXxCcmV2ZTt8TGVmdCg/OlJpZ2h0VmVjdG9yO3xUZWVWZWN0b3I7fFZlY3Rvcig/Ojt8QmFyOykpfFJpZ2h0KD86VGVlVmVjdG9yO3xWZWN0b3IoPzo7fEJhcjspKXxUZWUoPzo7fEFycm93Oyl8YXJyb3c7KSl8cyg/OmNyO3x0cm9rOykpfEUoPzpORzt8VEg7P3xhY3V0ZTs/fGMoPzphcm9uO3xpcmM7P3x5Oyl8ZG90O3xmcjt8Z3JhdmU7P3xsZW1lbnQ7fG0oPzphY3I7fHB0eSg/OlNtYWxsU3F1YXJlO3xWZXJ5U21hbGxTcXVhcmU7KSl8byg/Omdvbjt8cGY7KXxwc2lsb247fHF1KD86YWwoPzo7fFRpbGRlOyl8aWxpYnJpdW07KXxzKD86Y3I7fGltOyl8dGE7fHVtbDs/fHgoPzppc3RzO3xwb25lbnRpYWxFOykpfEYoPzpjeTt8ZnI7fGlsbGVkKD86U21hbGxTcXVhcmU7fFZlcnlTbWFsbFNxdWFyZTspfG8oPzpwZjt8ckFsbDt8dXJpZXJ0cmY7KXxzY3I7KXxHKD86SmN5O3xUOz98YW1tYSg/Ojt8ZDspfGJyZXZlO3xjKD86ZWRpbDt8aXJjO3x5Oyl8ZG90O3xmcjt8Zzt8b3BmO3xyZWF0ZXIoPzpFcXVhbCg/Ojt8TGVzczspfEZ1bGxFcXVhbDt8R3JlYXRlcjt8TGVzczt8U2xhbnRFcXVhbDt8VGlsZGU7KXxzY3I7fHQ7KXxIKD86QVJEY3k7fGEoPzpjZWs7fHQ7KXxjaXJjO3xmcjt8aWxiZXJ0U3BhY2U7fG8oPzpwZjt8cml6b250YWxMaW5lOyl8cyg/OmNyO3x0cm9rOyl8dW1wKD86RG93bkh1bXA7fEVxdWFsOykpfEkoPzpFY3k7fEpsaWc7fE9jeTt8YWN1dGU7P3xjKD86aXJjOz98eTspfGRvdDt8ZnI7fGdyYXZlOz98bSg/Ojt8YSg/OmNyO3xnaW5hcnlJOyl8cGxpZXM7KXxuKD86dCg/Ojt8ZSg/OmdyYWw7fHJzZWN0aW9uOykpfHZpc2libGUoPzpDb21tYTt8VGltZXM7KSl8byg/Omdvbjt8cGY7fHRhOyl8c2NyO3x0aWxkZTt8dSg/OmtjeTt8bWw7PykpfEooPzpjKD86aXJjO3x5Oyl8ZnI7fG9wZjt8cyg/OmNyO3xlcmN5Oyl8dWtjeTspfEsoPzpIY3k7fEpjeTt8YXBwYTt8Yyg/OmVkaWw7fHk7KXxmcjt8b3BmO3xzY3I7KXxMKD86SmN5O3xUOz98YSg/OmN1dGU7fG1iZGE7fG5nO3xwbGFjZXRyZjt8cnI7KXxjKD86YXJvbjt8ZWRpbDt8eTspfGUoPzpmdCg/OkEoPzpuZ2xlQnJhY2tldDt8cnJvdyg/Ojt8QmFyO3xSaWdodEFycm93OykpfENlaWxpbmc7fERvKD86dWJsZUJyYWNrZXQ7fHduKD86VGVlVmVjdG9yO3xWZWN0b3IoPzo7fEJhcjspKSl8Rmxvb3I7fFJpZ2h0KD86QXJyb3c7fFZlY3RvcjspfFQoPzplZSg/Ojt8QXJyb3c7fFZlY3RvcjspfHJpYW5nbGUoPzo7fEJhcjt8RXF1YWw7KSl8VXAoPzpEb3duVmVjdG9yO3xUZWVWZWN0b3I7fFZlY3Rvcig/Ojt8QmFyOykpfFZlY3Rvcig/Ojt8QmFyOyl8YXJyb3c7fHJpZ2h0YXJyb3c7KXxzcyg/OkVxdWFsR3JlYXRlcjt8RnVsbEVxdWFsO3xHcmVhdGVyO3xMZXNzO3xTbGFudEVxdWFsO3xUaWxkZTspKXxmcjt8bCg/Ojt8ZWZ0YXJyb3c7KXxtaWRvdDt8byg/Om5nKD86TGVmdCg/OkFycm93O3xSaWdodEFycm93Oyl8UmlnaHRBcnJvdzt8bGVmdCg/OmFycm93O3xyaWdodGFycm93Oyl8cmlnaHRhcnJvdzspfHBmO3x3ZXIoPzpMZWZ0QXJyb3c7fFJpZ2h0QXJyb3c7KSl8cyg/OmNyO3xoO3x0cm9rOyl8dDspfE0oPzphcDt8Y3k7fGUoPzpkaXVtU3BhY2U7fGxsaW50cmY7KXxmcjt8aW51c1BsdXM7fG9wZjt8c2NyO3x1Oyl8Tig/OkpjeTt8YWN1dGU7fGMoPzphcm9uO3xlZGlsO3x5Oyl8ZSg/OmdhdGl2ZSg/Ok1lZGl1bVNwYWNlO3xUaGkoPzpja1NwYWNlO3xuU3BhY2U7KXxWZXJ5VGhpblNwYWNlOyl8c3RlZCg/OkdyZWF0ZXJHcmVhdGVyO3xMZXNzTGVzczspfHdMaW5lOyl8ZnI7fG8oPzpCcmVhazt8bkJyZWFraW5nU3BhY2U7fHBmO3x0KD86O3xDKD86b25ncnVlbnQ7fHVwQ2FwOyl8RG91YmxlVmVydGljYWxCYXI7fEUoPzpsZW1lbnQ7fHF1YWwoPzo7fFRpbGRlOyl8eGlzdHM7KXxHcmVhdGVyKD86O3xFcXVhbDt8RnVsbEVxdWFsO3xHcmVhdGVyO3xMZXNzO3xTbGFudEVxdWFsO3xUaWxkZTspfEh1bXAoPzpEb3duSHVtcDt8RXF1YWw7KXxMZSg/OmZ0VHJpYW5nbGUoPzo7fEJhcjt8RXF1YWw7KXxzcyg/Ojt8RXF1YWw7fEdyZWF0ZXI7fExlc3M7fFNsYW50RXF1YWw7fFRpbGRlOykpfE5lc3RlZCg/OkdyZWF0ZXJHcmVhdGVyO3xMZXNzTGVzczspfFByZWNlZGVzKD86O3xFcXVhbDt8U2xhbnRFcXVhbDspfFIoPzpldmVyc2VFbGVtZW50O3xpZ2h0VHJpYW5nbGUoPzo7fEJhcjt8RXF1YWw7KSl8Uyg/OnF1YXJlU3UoPzpic2V0KD86O3xFcXVhbDspfHBlcnNldCg/Ojt8RXF1YWw7KSl8dSg/OmJzZXQoPzo7fEVxdWFsOyl8Y2NlZWRzKD86O3xFcXVhbDt8U2xhbnRFcXVhbDt8VGlsZGU7KXxwZXJzZXQoPzo7fEVxdWFsOykpKXxUaWxkZSg/Ojt8RXF1YWw7fEZ1bGxFcXVhbDt8VGlsZGU7KXxWZXJ0aWNhbEJhcjspKXxzY3I7fHRpbGRlOz98dTspfE8oPzpFbGlnO3xhY3V0ZTs/fGMoPzppcmM7P3x5Oyl8ZGJsYWM7fGZyO3xncmF2ZTs/fG0oPzphY3I7fGVnYTt8aWNyb247KXxvcGY7fHBlbkN1cmx5KD86RG91YmxlUXVvdGU7fFF1b3RlOyl8cjt8cyg/OmNyO3xsYXNoOz8pfHRpKD86bGRlOz98bWVzOyl8dW1sOz98dmVyKD86Qig/OmFyO3xyYWMoPzplO3xrZXQ7KSl8UGFyZW50aGVzaXM7KSl8UCg/OmFydGlhbEQ7fGN5O3xmcjt8aGk7fGk7fGx1c01pbnVzO3xvKD86aW5jYXJlcGxhbmU7fHBmOyl8cig/Ojt8ZWNlZGVzKD86O3xFcXVhbDt8U2xhbnRFcXVhbDt8VGlsZGU7KXxpbWU7fG8oPzpkdWN0O3xwb3J0aW9uKD86O3xhbDspKSl8cyg/OmNyO3xpOykpfFEoPzpVT1Q7P3xmcjt8b3BmO3xzY3I7KXxSKD86QmFycjt8RUc7P3xhKD86Y3V0ZTt8bmc7fHJyKD86O3x0bDspKXxjKD86YXJvbjt8ZWRpbDt8eTspfGUoPzo7fHZlcnNlKD86RSg/OmxlbWVudDt8cXVpbGlicml1bTspfFVwRXF1aWxpYnJpdW07KSl8ZnI7fGhvO3xpZ2h0KD86QSg/Om5nbGVCcmFja2V0O3xycm93KD86O3xCYXI7fExlZnRBcnJvdzspKXxDZWlsaW5nO3xEbyg/OnVibGVCcmFja2V0O3x3big/OlRlZVZlY3Rvcjt8VmVjdG9yKD86O3xCYXI7KSkpfEZsb29yO3xUKD86ZWUoPzo7fEFycm93O3xWZWN0b3I7KXxyaWFuZ2xlKD86O3xCYXI7fEVxdWFsOykpfFVwKD86RG93blZlY3Rvcjt8VGVlVmVjdG9yO3xWZWN0b3IoPzo7fEJhcjspKXxWZWN0b3IoPzo7fEJhcjspfGFycm93Oyl8byg/OnBmO3x1bmRJbXBsaWVzOyl8cmlnaHRhcnJvdzt8cyg/OmNyO3xoOyl8dWxlRGVsYXllZDspfFMoPzpIKD86Q0hjeTt8Y3k7KXxPRlRjeTt8YWN1dGU7fGMoPzo7fGFyb247fGVkaWw7fGlyYzt8eTspfGZyO3xob3J0KD86RG93bkFycm93O3xMZWZ0QXJyb3c7fFJpZ2h0QXJyb3c7fFVwQXJyb3c7KXxpZ21hO3xtYWxsQ2lyY2xlO3xvcGY7fHEoPzpydDt8dWFyZSg/Ojt8SW50ZXJzZWN0aW9uO3xTdSg/OmJzZXQoPzo7fEVxdWFsOyl8cGVyc2V0KD86O3xFcXVhbDspKXxVbmlvbjspKXxzY3I7fHRhcjt8dSg/OmIoPzo7fHNldCg/Ojt8RXF1YWw7KSl8Yyg/OmNlZWRzKD86O3xFcXVhbDt8U2xhbnRFcXVhbDt8VGlsZGU7KXxoVGhhdDspfG07fHAoPzo7fGVyc2V0KD86O3xFcXVhbDspfHNldDspKSl8VCg/OkhPUk47P3xSQURFO3xTKD86SGN5O3xjeTspfGEoPzpiO3x1Oyl8Yyg/OmFyb247fGVkaWw7fHk7KXxmcjt8aCg/OmUoPzpyZWZvcmU7fHRhOyl8aSg/OmNrU3BhY2U7fG5TcGFjZTspKXxpbGRlKD86O3xFcXVhbDt8RnVsbEVxdWFsO3xUaWxkZTspfG9wZjt8cmlwbGVEb3Q7fHMoPzpjcjt8dHJvazspKXxVKD86YSg/OmN1dGU7P3xycig/Ojt8b2NpcjspKXxicig/OmN5O3xldmU7KXxjKD86aXJjOz98eTspfGRibGFjO3xmcjt8Z3JhdmU7P3xtYWNyO3xuKD86ZGVyKD86Qig/OmFyO3xyYWMoPzplO3xrZXQ7KSl8UGFyZW50aGVzaXM7KXxpb24oPzo7fFBsdXM7KSl8byg/Omdvbjt8cGY7KXxwKD86QXJyb3coPzo7fEJhcjt8RG93bkFycm93Oyl8RG93bkFycm93O3xFcXVpbGlicml1bTt8VGVlKD86O3xBcnJvdzspfGFycm93O3xkb3duYXJyb3c7fHBlcig/OkxlZnRBcnJvdzt8UmlnaHRBcnJvdzspfHNpKD86O3xsb247KSl8cmluZzt8c2NyO3x0aWxkZTt8dW1sOz8pfFYoPzpEYXNoO3xiYXI7fGN5O3xkYXNoKD86O3xsOyl8ZSg/OmU7fHIoPzpiYXI7fHQoPzo7fGljYWwoPzpCYXI7fExpbmU7fFNlcGFyYXRvcjt8VGlsZGU7KSl8eVRoaW5TcGFjZTspKXxmcjt8b3BmO3xzY3I7fHZkYXNoOyl8Vyg/OmNpcmM7fGVkZ2U7fGZyO3xvcGY7fHNjcjspfFgoPzpmcjt8aTt8b3BmO3xzY3I7KXxZKD86QWN5O3xJY3k7fFVjeTt8YWN1dGU7P3xjKD86aXJjO3x5Oyl8ZnI7fG9wZjt8c2NyO3x1bWw7KXxaKD86SGN5O3xhY3V0ZTt8Yyg/OmFyb247fHk7KXxkb3Q7fGUoPzpyb1dpZHRoU3BhY2U7fHRhOyl8ZnI7fG9wZjt8c2NyOyl8YSg/OmFjdXRlOz98YnJldmU7fGMoPzo7fEU7fGQ7fGlyYzs/fHV0ZTs/fHk7KXxlbGlnOz98Zig/Ojt8cjspfGdyYXZlOz98bCg/OmUoPzpmc3ltO3xwaDspfHBoYTspfG0oPzphKD86Y3I7fGxnOyl8cDs/KXxuKD86ZCg/Ojt8YW5kO3xkO3xzbG9wZTt8djspfGcoPzo7fGU7fGxlO3xtc2QoPzo7fGEoPzphO3xiO3xjO3xkO3xlO3xmO3xnO3xoOykpfHJ0KD86O3x2Yig/Ojt8ZDspKXxzKD86cGg7fHQ7KXx6YXJyOykpfG8oPzpnb247fHBmOyl8cCg/Ojt8RTt8YWNpcjt8ZTt8aWQ7fG9zO3xwcm94KD86O3xlcTspKXxyaW5nOz98cyg/OmNyO3x0O3x5bXAoPzo7fGVxOykpfHRpbGRlOz98dW1sOz98dyg/OmNvbmludDt8aW50OykpfGIoPzpOb3Q7fGEoPzpjayg/OmNvbmc7fGVwc2lsb247fHByaW1lO3xzaW0oPzo7fGVxOykpfHIoPzp2ZWU7fHdlZCg/Ojt8Z2U7KSkpfGJyayg/Ojt8dGJyazspfGMoPzpvbmc7fHk7KXxkcXVvO3xlKD86Y2F1cyg/Ojt8ZTspfG1wdHl2O3xwc2k7fHJub3U7fHQoPzphO3xoO3x3ZWVuOykpfGZyO3xpZyg/OmMoPzphcDt8aXJjO3x1cDspfG8oPzpkb3Q7fHBsdXM7fHRpbWVzOyl8cyg/OnFjdXA7fHRhcjspfHRyaWFuZ2xlKD86ZG93bjt8dXA7KXx1cGx1czt8dmVlO3x3ZWRnZTspfGthcm93O3xsKD86YSg/OmNrKD86bG96ZW5nZTt8c3F1YXJlO3x0cmlhbmdsZSg/Ojt8ZG93bjt8bGVmdDt8cmlnaHQ7KSl8bms7KXxrKD86MSg/OjI7fDQ7KXwzNDspfG9jazspfG4oPzplKD86O3xxdWl2Oyl8b3Q7KXxvKD86cGY7fHQoPzo7fHRvbTspfHd0aWU7fHgoPzpEKD86TDt8Ujt8bDt8cjspfEgoPzo7fEQ7fFU7fGQ7fHU7KXxVKD86TDt8Ujt8bDt8cjspfFYoPzo7fEg7fEw7fFI7fGg7fGw7fHI7KXxib3g7fGQoPzpMO3xSO3xsO3xyOyl8aCg/Ojt8RDt8VTt8ZDt8dTspfG1pbnVzO3xwbHVzO3x0aW1lczt8dSg/Okw7fFI7fGw7fHI7KXx2KD86O3xIO3xMO3xSO3xoO3xsO3xyOykpKXxwcmltZTt8cig/OmV2ZTt8dmJhcjs/KXxzKD86Y3I7fGVtaTt8aW0oPzo7fGU7KXxvbCg/Ojt8Yjt8aHN1YjspKXx1KD86bGwoPzo7fGV0Oyl8bXAoPzo7fEU7fGUoPzo7fHE7KSkpKXxjKD86YSg/OmN1dGU7fHAoPzo7fGFuZDt8YnJjdXA7fGMoPzphcDt8dXA7KXxkb3Q7fHM7KXxyKD86ZXQ7fG9uOykpfGMoPzphKD86cHM7fHJvbjspfGVkaWw7P3xpcmM7fHVwcyg/Ojt8c207KSl8ZG90O3xlKD86ZGlsOz98bXB0eXY7fG50KD86O3xlcmRvdDt8KSl8ZnI7fGgoPzpjeTt8ZWNrKD86O3xtYXJrOyl8aTspfGlyKD86O3xFO3xjKD86O3xlcTt8bGUoPzphcnJvdyg/OmxlZnQ7fHJpZ2h0Oyl8ZCg/OlI7fFM7fGFzdDt8Y2lyYzt8ZGFzaDspKSl8ZTt8Zm5pbnQ7fG1pZDt8c2NpcjspfGx1YnMoPzo7fHVpdDspfG8oPzpsb24oPzo7fGUoPzo7fHE7KSl8bSg/Om1hKD86O3x0Oyl8cCg/Ojt8Zm47fGxlKD86bWVudDt8eGVzOykpKXxuKD86Zyg/Ojt8ZG90Oyl8aW50Oyl8cCg/OmY7fHJvZDt8eSg/Ojt8c3I7fCkpKXxyKD86YXJyO3xvc3M7KXxzKD86Y3I7fHUoPzpiKD86O3xlOyl8cCg/Ojt8ZTspKSl8dGRvdDt8dSg/OmRhcnIoPzpsO3xyOyl8ZSg/OnByO3xzYzspfGxhcnIoPzo7fHA7KXxwKD86O3xicmNhcDt8Yyg/OmFwO3x1cDspfGRvdDt8b3I7fHM7KXxyKD86YXJyKD86O3xtOyl8bHkoPzplcSg/OnByZWM7fHN1Y2M7KXx2ZWU7fHdlZGdlOyl8cmVuOz98dmVhcnJvdyg/OmxlZnQ7fHJpZ2h0OykpfHZlZTt8d2VkOyl8dyg/OmNvbmludDt8aW50Oyl8eWxjdHk7KXxkKD86QXJyO3xIYXI7fGEoPzpnZ2VyO3xsZXRoO3xycjt8c2goPzo7fHY7KSl8Yig/Omthcm93O3xsYWM7KXxjKD86YXJvbjt8eTspfGQoPzo7fGEoPzpnZ2VyO3xycjspfG90c2VxOyl8ZSg/Omc7P3xsdGE7fG1wdHl2Oyl8Zig/OmlzaHQ7fHI7KXxoYXIoPzpsO3xyOyl8aSg/OmFtKD86O3xvbmQoPzo7fHN1aXQ7KXxzOyl8ZTt8Z2FtbWE7fHNpbjt8dig/Ojt8aWRlKD86O3xvbnRpbWVzO3wpfG9ueDspKXxqY3k7fGxjKD86b3JuO3xyb3A7KXxvKD86bGxhcjt8cGY7fHQoPzo7fGVxKD86O3xkb3Q7KXxtaW51czt8cGx1czt8c3F1YXJlOyl8dWJsZWJhcndlZGdlO3x3big/OmFycm93O3xkb3duYXJyb3dzO3xoYXJwb29uKD86bGVmdDt8cmlnaHQ7KSkpfHIoPzpia2Fyb3c7fGMoPzpvcm47fHJvcDspKXxzKD86Yyg/OnI7fHk7KXxvbDt8dHJvazspfHQoPzpkb3Q7fHJpKD86O3xmOykpfHUoPzphcnI7fGhhcjspfHdhbmdsZTt8eig/OmN5O3xpZ3JhcnI7KSl8ZSg/OkQoPzpEb3Q7fG90Oyl8YSg/OmN1dGU7P3xzdGVyOyl8Yyg/OmFyb247fGlyKD86O3xjOz8pfG9sb247fHk7KXxkb3Q7fGU7fGYoPzpEb3Q7fHI7KXxnKD86O3xyYXZlOz98cyg/Ojt8ZG90OykpfGwoPzo7fGludGVyczt8bDt8cyg/Ojt8ZG90OykpfG0oPzphY3I7fHB0eSg/Ojt8c2V0O3x2Oyl8c3AoPzoxKD86Mzt8NDspfDspKXxuKD86Zzt8c3A7KXxvKD86Z29uO3xwZjspfHAoPzphcig/Ojt8c2w7KXxsdXM7fHNpKD86O3xsb247fHY7KSl8cSg/OmMoPzppcmM7fG9sb247KXxzKD86aW07fGxhbnQoPzpndHI7fGxlc3M7KSl8dSg/OmFsczt8ZXN0O3xpdig/Ojt8REQ7KSl8dnBhcnNsOyl8cig/OkRvdDt8YXJyOyl8cyg/OmNyO3xkb3Q7fGltOyl8dCg/OmE7fGg7Pyl8dSg/Om1sOz98cm87KXx4KD86Y2w7fGlzdDt8cCg/OmVjdGF0aW9uO3xvbmVudGlhbGU7KSkpfGYoPzphbGxpbmdkb3RzZXE7fGN5O3xlbWFsZTt8Zig/OmlsaWc7fGwoPzppZzt8bGlnOyl8cjspfGlsaWc7fGpsaWc7fGwoPzphdDt8bGlnO3x0bnM7KXxub2Y7fG8oPzpwZjt8cig/OmFsbDt8ayg/Ojt8djspKSl8cGFydGludDt8cig/OmEoPzpjKD86MSg/OjI7P3wzO3w0Oz98NTt8Njt8ODspfDIoPzozO3w1Oyl8Myg/OjQ7P3w1O3w4Oyl8NDU7fDUoPzo2O3w4Oyl8Nzg7KXxzbDspfG93bjspfHNjcjspfGcoPzpFKD86O3xsOyl8YSg/OmN1dGU7fG1tYSg/Ojt8ZDspfHA7KXxicmV2ZTt8Yyg/OmlyYzt8eTspfGRvdDt8ZSg/Ojt8bDt8cSg/Ojt8cTt8c2xhbnQ7KXxzKD86O3xjYzt8ZG90KD86O3xvKD86O3xsOykpfGwoPzo7fGVzOykpKXxmcjt8Zyg/Ojt8ZzspfGltZWw7fGpjeTt8bCg/Ojt8RTt8YTt8ajspfG4oPzpFO3xhcCg/Ojt8cHJveDspfGUoPzo7fHEoPzo7fHE7KSl8c2ltOyl8b3BmO3xyYXZlO3xzKD86Y3I7fGltKD86O3xlO3xsOykpfHQoPzo7fGMoPzpjO3xpcjspfGRvdDt8bFBhcjt8cXVlc3Q7fHIoPzphKD86cHByb3g7fHJyOyl8ZG90O3xlcSg/Omxlc3M7fHFsZXNzOyl8bGVzczt8c2ltOyl8KXx2KD86ZXJ0bmVxcTt8bkU7KSl8aCg/OkFycjt8YSg/Omlyc3A7fGxmO3xtaWx0O3xyKD86ZGN5O3xyKD86O3xjaXI7fHc7KSkpfGJhcjt8Y2lyYzt8ZSg/OmFydHMoPzo7fHVpdDspfGxsaXA7fHJjb247KXxmcjt8a3MoPzplYXJvdzt8d2Fyb3c7KXxvKD86YXJyO3xtdGh0O3xvayg/OmxlZnRhcnJvdzt8cmlnaHRhcnJvdzspfHBmO3xyYmFyOyl8cyg/OmNyO3xsYXNoO3x0cm9rOyl8eSg/OmJ1bGw7fHBoZW47KSl8aSg/OmFjdXRlOz98Yyg/Ojt8aXJjOz98eTspfGUoPzpjeTt8eGNsOz8pfGYoPzpmO3xyOyl8Z3JhdmU7P3xpKD86O3xpKD86aW50O3xudDspfG5maW47fG90YTspfGpsaWc7fG0oPzphKD86Y3I7fGcoPzplO3xsaW5lO3xwYXJ0Oyl8dGg7KXxvZjt8cGVkOyl8big/Ojt8Y2FyZTt8ZmluKD86O3x0aWU7KXxvZG90O3x0KD86O3xjYWw7fGUoPzpnZXJzO3xyY2FsOyl8bGFyaGs7fHByb2Q7KSl8byg/OmN5O3xnb247fHBmO3x0YTspfHByb2Q7fHF1ZXN0Oz98cyg/OmNyO3xpbig/Ojt8RTt8ZG90O3xzKD86O3x2Oyl8djspKXx0KD86O3xpbGRlOyl8dSg/OmtjeTt8bWw7PykpfGooPzpjKD86aXJjO3x5Oyl8ZnI7fG1hdGg7fG9wZjt8cyg/OmNyO3xlcmN5Oyl8dWtjeTspfGsoPzphcHBhKD86O3x2Oyl8Yyg/OmVkaWw7fHk7KXxmcjt8Z3JlZW47fGhjeTt8amN5O3xvcGY7fHNjcjspfGwoPzpBKD86YXJyO3xycjt8dGFpbDspfEJhcnI7fEUoPzo7fGc7KXxIYXI7fGEoPzpjdXRlO3xlbXB0eXY7fGdyYW47fG1iZGE7fG5nKD86O3xkO3xsZTspfHA7fHF1bzs/fHJyKD86O3xiKD86O3xmczspfGZzO3xoazt8bHA7fHBsO3xzaW07fHRsOyl8dCg/Ojt8YWlsO3xlKD86O3xzOykpKXxiKD86YXJyO3xicms7fHIoPzphYyg/OmU7fGs7KXxrKD86ZTt8c2woPzpkO3x1OykpKSl8Yyg/OmFyb247fGUoPzpkaWw7fGlsOyl8dWI7fHk7KXxkKD86Y2E7fHF1byg/Ojt8cjspfHIoPzpkaGFyO3x1c2hhcjspfHNoOyl8ZSg/Ojt8ZnQoPzphcnJvdyg/Ojt8dGFpbDspfGhhcnBvb24oPzpkb3duO3x1cDspfGxlZnRhcnJvd3M7fHJpZ2h0KD86YXJyb3coPzo7fHM7KXxoYXJwb29uczt8c3F1aWdhcnJvdzspfHRocmVldGltZXM7KXxnO3xxKD86O3xxO3xzbGFudDspfHMoPzo7fGNjO3xkb3QoPzo7fG8oPzo7fHI7KSl8Zyg/Ojt8ZXM7KXxzKD86YXBwcm94O3xkb3Q7fGVxKD86Z3RyO3xxZ3RyOyl8Z3RyO3xzaW07KSkpfGYoPzppc2h0O3xsb29yO3xyOyl8Zyg/Ojt8RTspfGgoPzphcig/OmQ7fHUoPzo7fGw7KSl8YmxrOyl8amN5O3xsKD86O3xhcnI7fGNvcm5lcjt8aGFyZDt8dHJpOyl8bSg/Omlkb3Q7fG91c3QoPzo7fGFjaGU7KSl8big/OkU7fGFwKD86O3xwcm94Oyl8ZSg/Ojt8cSg/Ojt8cTspKXxzaW07KXxvKD86YSg/Om5nO3xycjspfGJyazt8bmcoPzpsZWZ0KD86YXJyb3c7fHJpZ2h0YXJyb3c7KXxtYXBzdG87fHJpZ2h0YXJyb3c7KXxvcGFycm93KD86bGVmdDt8cmlnaHQ7KXxwKD86YXI7fGY7fGx1czspfHRpbWVzO3x3KD86YXN0O3xiYXI7KXx6KD86O3xlbmdlO3xmOykpfHBhcig/Ojt8bHQ7KXxyKD86YXJyO3xjb3JuZXI7fGhhcig/Ojt8ZDspfG07fHRyaTspfHMoPzphcXVvO3xjcjt8aDt8aW0oPzo7fGU7fGc7KXxxKD86Yjt8dW8oPzo7fHI7KSl8dHJvazspfHQoPzo7fGMoPzpjO3xpcjspfGRvdDt8aHJlZTt8aW1lczt8bGFycjt8cXVlc3Q7fHIoPzpQYXI7fGkoPzo7fGU7fGY7KSl8KXx1cig/OmRzaGFyO3x1aGFyOyl8dig/OmVydG5lcXE7fG5FOykpfG0oPzpERG90O3xhKD86Y3I7P3xsKD86ZTt8dCg/Ojt8ZXNlOykpfHAoPzo7fHN0byg/Ojt8ZG93bjt8bGVmdDt8dXA7KSl8cmtlcjspfGMoPzpvbW1hO3x5Oyl8ZGFzaDt8ZWFzdXJlZGFuZ2xlO3xmcjt8aG87fGkoPzpjcm87P3xkKD86O3xhc3Q7fGNpcjt8ZG90Oz8pfG51cyg/Ojt8Yjt8ZCg/Ojt8dTspKSl8bCg/OmNwO3xkcjspfG5wbHVzO3xvKD86ZGVsczt8cGY7KXxwO3xzKD86Y3I7fHRwb3M7KXx1KD86O3xsdGltYXA7fG1hcDspKXxuKD86Ryg/Omc7fHQoPzo7fHY7KSl8TCg/OmVmdCg/OmFycm93O3xyaWdodGFycm93Oyl8bDt8dCg/Ojt8djspKXxSaWdodGFycm93O3xWKD86RGFzaDt8ZGFzaDspfGEoPzpibGE7fGN1dGU7fG5nO3xwKD86O3xFO3xpZDt8b3M7fHByb3g7KXx0dXIoPzo7fGFsKD86O3xzOykpKXxiKD86c3A7P3x1bXAoPzo7fGU7KSl8Yyg/OmEoPzpwO3xyb247KXxlZGlsO3xvbmcoPzo7fGRvdDspfHVwO3x5Oyl8ZGFzaDt8ZSg/Ojt8QXJyO3xhcig/OmhrO3xyKD86O3xvdzspKXxkb3Q7fHF1aXY7fHMoPzplYXI7fGltOyl8eGlzdCg/Ojt8czspKXxmcjt8Zyg/OkU7fGUoPzo7fHEoPzo7fHE7fHNsYW50Oyl8czspfHNpbTt8dCg/Ojt8cjspKXxoKD86QXJyO3xhcnI7fHBhcjspfGkoPzo7fHMoPzo7fGQ7KXx2Oyl8amN5O3xsKD86QXJyO3xFO3xhcnI7fGRyO3xlKD86O3xmdCg/OmFycm93O3xyaWdodGFycm93Oyl8cSg/Ojt8cTt8c2xhbnQ7KXxzKD86O3xzOykpfHNpbTt8dCg/Ojt8cmkoPzo7fGU7KSkpfG1pZDt8byg/OnBmO3x0KD86O3xpbig/Ojt8RTt8ZG90O3x2KD86YTt8Yjt8YzspKXxuaSg/Ojt8dig/OmE7fGI7fGM7KSl8KSl8cCg/OmFyKD86O3xhbGxlbDt8c2w7fHQ7KXxvbGludDt8cig/Ojt8Y3VlO3xlKD86O3xjKD86O3xlcTspKSkpfHIoPzpBcnI7fGFycig/Ojt8Yzt8dzspfGlnaHRhcnJvdzt8dHJpKD86O3xlOykpfHMoPzpjKD86O3xjdWU7fGU7fHI7KXxob3J0KD86bWlkO3xwYXJhbGxlbDspfGltKD86O3xlKD86O3xxOykpfG1pZDt8cGFyO3xxc3UoPzpiZTt8cGU7KXx1KD86Yig/Ojt8RTt8ZTt8c2V0KD86O3xlcSg/Ojt8cTspKSl8Y2MoPzo7fGVxOyl8cCg/Ojt8RTt8ZTt8c2V0KD86O3xlcSg/Ojt8cTspKSkpKXx0KD86Z2w7fGlsZGU7P3xsZzt8cmlhbmdsZSg/OmxlZnQoPzo7fGVxOyl8cmlnaHQoPzo7fGVxOykpKXx1KD86O3xtKD86O3xlcm87fHNwOykpfHYoPzpEYXNoO3xIYXJyO3xhcDt8ZGFzaDt8Zyg/OmU7fHQ7KXxpbmZpbjt8bCg/OkFycjt8ZTt8dCg/Ojt8cmllOykpfHIoPzpBcnI7fHRyaWU7KXxzaW07KXx3KD86QXJyO3xhcig/OmhrO3xyKD86O3xvdzspKXxuZWFyOykpfG8oPzpTO3xhKD86Y3V0ZTs/fHN0Oyl8Yyg/OmlyKD86O3xjOz8pfHk7KXxkKD86YXNoO3xibGFjO3xpdjt8b3Q7fHNvbGQ7KXxlbGlnO3xmKD86Y2lyO3xyOyl8Zyg/Om9uO3xyYXZlOz98dDspfGgoPzpiYXI7fG07KXxpbnQ7fGwoPzphcnI7fGMoPzppcjt8cm9zczspfGluZTt8dDspfG0oPzphY3I7fGVnYTt8aSg/OmNyb247fGQ7fG51czspKXxvcGY7fHAoPzphcjt8ZXJwO3xsdXM7KXxyKD86O3xhcnI7fGQoPzo7fGVyKD86O3xvZjspfGY7P3xtOz8pfGlnb2Y7fG9yO3xzbG9wZTt8djspfHMoPzpjcjt8bGFzaDs/fG9sOyl8dGkoPzpsZGU7P3xtZXMoPzo7fGFzOykpfHVtbDs/fHZiYXI7KXxwKD86YXIoPzo7fGEoPzo7fGxsZWw7fCl8cyg/OmltO3xsOyl8dDspfGN5O3xlcig/OmNudDt8aW9kO3xtaWw7fHA7fHRlbms7KXxmcjt8aCg/OmkoPzo7fHY7KXxtbWF0O3xvbmU7KXxpKD86O3x0Y2hmb3JrO3x2Oyl8bCg/OmFuKD86Y2soPzo7fGg7KXxrdjspfHVzKD86O3xhY2lyO3xiO3xjaXI7fGQoPzpvO3x1Oyl8ZTt8bW47P3xzaW07fHR3bzspKXxtO3xvKD86aW50aW50O3xwZjt8dW5kOz8pfHIoPzo7fEU7fGFwO3xjdWU7fGUoPzo7fGMoPzo7fGFwcHJveDt8Y3VybHllcTt8ZXE7fG4oPzphcHByb3g7fGVxcTt8c2ltOyl8c2ltOykpfGltZSg/Ojt8czspfG4oPzpFO3xhcDt8c2ltOyl8byg/OmQ7fGYoPzphbGFyO3xsaW5lO3xzdXJmOyl8cCg/Ojt8dG87KSl8c2ltO3x1cmVsOyl8cyg/OmNyO3xpOyl8dW5jc3A7KXxxKD86ZnI7fGludDt8b3BmO3xwcmltZTt8c2NyO3x1KD86YXQoPzplcm5pb25zO3xpbnQ7KXxlc3QoPzo7fGVxOyl8b3Q7PykpfHIoPzpBKD86YXJyO3xycjt8dGFpbDspfEJhcnI7fEhhcjt8YSg/OmMoPzplO3x1dGU7KXxkaWM7fGVtcHR5djt8bmcoPzo7fGQ7fGU7fGxlOyl8cXVvOz98cnIoPzo7fGFwO3xiKD86O3xmczspfGM7fGZzO3xoazt8bHA7fHBsO3xzaW07fHRsO3x3Oyl8dCg/OmFpbDt8aW8oPzo7fG5hbHM7KSkpfGIoPzphcnI7fGJyazt8cig/OmFjKD86ZTt8azspfGsoPzplO3xzbCg/OmQ7fHU7KSkpKXxjKD86YXJvbjt8ZSg/OmRpbDt8aWw7KXx1Yjt8eTspfGQoPzpjYTt8bGRoYXI7fHF1byg/Ojt8cjspfHNoOyl8ZSg/OmFsKD86O3xpbmU7fHBhcnQ7fHM7KXxjdDt8Zzs/KXxmKD86aXNodDt8bG9vcjt8cjspfGgoPzphcig/OmQ7fHUoPzo7fGw7KSl8byg/Ojt8djspKXxpKD86Z2h0KD86YXJyb3coPzo7fHRhaWw7KXxoYXJwb29uKD86ZG93bjt8dXA7KXxsZWZ0KD86YXJyb3dzO3xoYXJwb29uczspfHJpZ2h0YXJyb3dzO3xzcXVpZ2Fycm93O3x0aHJlZXRpbWVzOyl8bmc7fHNpbmdkb3RzZXE7KXxsKD86YXJyO3xoYXI7fG07KXxtb3VzdCg/Ojt8YWNoZTspfG5taWQ7fG8oPzphKD86bmc7fHJyOyl8YnJrO3xwKD86YXI7fGY7fGx1czspfHRpbWVzOyl8cCg/OmFyKD86O3xndDspfHBvbGludDspfHJhcnI7fHMoPzphcXVvO3xjcjt8aDt8cSg/OmI7fHVvKD86O3xyOykpKXx0KD86aHJlZTt8aW1lczt8cmkoPzo7fGU7fGY7fGx0cmk7KSl8dWx1aGFyO3x4Oyl8cyg/OmFjdXRlO3xicXVvO3xjKD86O3xFO3xhKD86cDt8cm9uOyl8Y3VlO3xlKD86O3xkaWw7KXxpcmM7fG4oPzpFO3xhcDt8c2ltOyl8cG9saW50O3xzaW07fHk7KXxkb3QoPzo7fGI7fGU7KXxlKD86QXJyO3xhcig/OmhrO3xyKD86O3xvdzspKXxjdDs/fG1pO3xzd2FyO3x0bSg/OmludXM7fG47KXx4dDspfGZyKD86O3xvd247KXxoKD86YXJwO3xjKD86aGN5O3x5Oyl8b3J0KD86bWlkO3xwYXJhbGxlbDspfHk7Pyl8aSg/OmdtYSg/Ojt8Zjt8djspfG0oPzo7fGRvdDt8ZSg/Ojt8cTspfGcoPzo7fEU7KXxsKD86O3xFOyl8bmU7fHBsdXM7fHJhcnI7KSl8bGFycjt8bSg/OmEoPzpsbHNldG1pbnVzO3xzaHA7KXxlcGFyc2w7fGkoPzpkO3xsZTspfHQoPzo7fGUoPzo7fHM7KSkpfG8oPzpmdGN5O3xsKD86O3xiKD86O3xhcjspKXxwZjspfHBhKD86ZGVzKD86O3x1aXQ7KXxyOyl8cSg/OmMoPzphcCg/Ojt8czspfHVwKD86O3xzOykpfHN1KD86Yig/Ojt8ZTt8c2V0KD86O3xlcTspKXxwKD86O3xlO3xzZXQoPzo7fGVxOykpKXx1KD86O3xhcig/OmU7fGY7KXxmOykpfHJhcnI7fHMoPzpjcjt8ZXRtbjt8bWlsZTt8dGFyZjspfHQoPzphcig/Ojt8ZjspfHIoPzphaWdodCg/OmVwc2lsb247fHBoaTspfG5zOykpfHUoPzpiKD86O3xFO3xkb3Q7fGUoPzo7fGRvdDspfG11bHQ7fG4oPzpFO3xlOyl8cGx1czt8cmFycjt8cyg/OmV0KD86O3xlcSg/Ojt8cTspfG5lcSg/Ojt8cTspKXxpbTt8dSg/OmI7fHA7KSkpfGNjKD86O3xhcHByb3g7fGN1cmx5ZXE7fGVxO3xuKD86YXBwcm94O3xlcXE7fHNpbTspfHNpbTspfG07fG5nO3xwKD86MTs/fDI7P3wzOz98O3xFO3xkKD86b3Q7fHN1YjspfGUoPzo7fGRvdDspfGhzKD86b2w7fHViOyl8bGFycjt8bXVsdDt8big/OkU7fGU7KXxwbHVzO3xzKD86ZXQoPzo7fGVxKD86O3xxOyl8bmVxKD86O3xxOykpfGltO3x1KD86Yjt8cDspKSkpfHcoPzpBcnI7fGFyKD86aGs7fHIoPzo7fG93OykpfG53YXI7KXx6bGlnOz8pfHQoPzphKD86cmdldDt8dTspfGJyazt8Yyg/OmFyb247fGVkaWw7fHk7KXxkb3Q7fGVscmVjO3xmcjt8aCg/OmUoPzpyZSg/OjQ7fGZvcmU7KXx0YSg/Ojt8c3ltO3x2OykpfGkoPzpjayg/OmFwcHJveDt8c2ltOyl8bnNwOyl8ayg/OmFwO3xzaW07KXxvcm47Pyl8aSg/OmxkZTt8bWVzKD86O3xiKD86O3xhcjspfGQ7fCl8bnQ7KXxvKD86ZWE7fHAoPzo7fGJvdDt8Y2lyO3xmKD86O3xvcms7KSl8c2E7KXxwcmltZTt8cig/OmFkZTt8aSg/OmFuZ2xlKD86O3xkb3duO3xsZWZ0KD86O3xlcTspfHE7fHJpZ2h0KD86O3xlcTspKXxkb3Q7fGU7fG1pbnVzO3xwbHVzO3xzYjt8dGltZTspfHBleml1bTspfHMoPzpjKD86cjt8eTspfGhjeTt8dHJvazspfHcoPzppeHQ7fG9oZWFkKD86bGVmdGFycm93O3xyaWdodGFycm93OykpKXx1KD86QXJyO3xIYXI7fGEoPzpjdXRlOz98cnI7KXxicig/OmN5O3xldmU7KXxjKD86aXJjOz98eTspfGQoPzphcnI7fGJsYWM7fGhhcjspfGYoPzppc2h0O3xyOyl8Z3JhdmU7P3xoKD86YXIoPzpsO3xyOyl8YmxrOyl8bCg/OmMoPzpvcm4oPzo7fGVyOyl8cm9wOyl8dHJpOyl8bSg/OmFjcjt8bDs/KXxvKD86Z29uO3xwZjspfHAoPzphcnJvdzt8ZG93bmFycm93O3xoYXJwb29uKD86bGVmdDt8cmlnaHQ7KXxsdXM7fHNpKD86O3xoO3xsb247KXx1cGFycm93czspfHIoPzpjKD86b3JuKD86O3xlcjspfHJvcDspfGluZzt8dHJpOyl8c2NyO3x0KD86ZG90O3xpbGRlO3xyaSg/Ojt8ZjspKXx1KD86YXJyO3xtbDs/KXx3YW5nbGU7KXx2KD86QXJyO3xCYXIoPzo7fHY7KXxEYXNoO3xhKD86bmdydDt8cig/OmVwc2lsb247fGthcHBhO3xub3RoaW5nO3xwKD86aGk7fGk7fHJvcHRvOyl8cig/Ojt8aG87KXxzKD86aWdtYTt8dSg/OmJzZXRuZXEoPzo7fHE7KXxwc2V0bmVxKD86O3xxOykpKXx0KD86aGV0YTt8cmlhbmdsZSg/OmxlZnQ7fHJpZ2h0OykpKSl8Y3k7fGRhc2g7fGUoPzplKD86O3xiYXI7fGVxOyl8bGxpcDt8cig/OmJhcjt8dDspKXxmcjt8bHRyaTt8bnN1KD86Yjt8cDspfG9wZjt8cHJvcDt8cnRyaTt8cyg/OmNyO3x1KD86Ym4oPzpFO3xlOyl8cG4oPzpFO3xlOykpKXx6aWd6YWc7KXx3KD86Y2lyYzt8ZSg/OmQoPzpiYXI7fGdlKD86O3xxOykpfGllcnA7KXxmcjt8b3BmO3xwO3xyKD86O3xlYXRoOyl8c2NyOyl8eCg/OmMoPzphcDt8aXJjO3x1cDspfGR0cmk7fGZyO3xoKD86QXJyO3xhcnI7KXxpO3xsKD86QXJyO3xhcnI7KXxtYXA7fG5pczt8byg/OmRvdDt8cCg/OmY7fGx1czspfHRpbWU7KXxyKD86QXJyO3xhcnI7KXxzKD86Y3I7fHFjdXA7KXx1KD86cGx1czt8dHJpOyl8dmVlO3x3ZWRnZTspfHkoPzphYyg/OnV0ZTs/fHk7KXxjKD86aXJjO3x5Oyl8ZW47P3xmcjt8aWN5O3xvcGY7fHNjcjt8dSg/OmN5O3xtbDs/KSl8eig/OmFjdXRlO3xjKD86YXJvbjt8eTspfGRvdDt8ZSg/OmV0cmY7fHRhOyl8ZnI7fGhjeTt8aWdyYXJyO3xvcGY7fHNjcjt8dyg/Omo7fG5qOykpKXxbXFxzXFxTXS9nO1xuXG52YXIgTkFNRURDSEFSUkVGX01BWExFTiA9IDMyO1xuXG4vLyBSZWd1bGFyIGV4cHJlc3Npb24gY29uc3RhbnRzIHVzZWQgYnkgdGhlIHRva2VuaXplciBhbmQgcGFyc2VyXG5cbi8vIE5vdGUgdGhhdCBcXHIgaXMgaW5jbHVkZWQgaW4gYWxsIG9mIHRoZXNlIHJlZ2V4cHMgYmVjYXVzZSBpdCB3aWxsIG5lZWRcbi8vIHRvIGJlIGNvbnZlcnRlZCB0byBMRiBieSB0aGUgc2NhbkNoYXJzKCkgZnVuY3Rpb24uXG52YXIgREJMUVVPVEVBVFRSVkFMID0gL1teXFxyXCImXFx1MDAwMF0rL2c7XG52YXIgU0lOR0xFUVVPVEVBVFRSVkFMID0gL1teXFxyJyZcXHUwMDAwXSsvZztcbnZhciBVTlFVT1RFREFUVFJWQUwgPSAvW15cXHJcXHRcXG5cXGYgJj5cXHUwMDAwXSsvZztcbnZhciBUQUdOQU1FID0gL1teXFxyXFx0XFxuXFxmIFxcLz5BLVpcXHUwMDAwXSsvZztcbnZhciBBVFRSTkFNRSA9IC9bXlxcclxcdFxcblxcZiBcXC89PkEtWlxcdTAwMDBdKy9nO1xuXG52YXIgQ0RBVEFURVhUID0gL1teXFxdXFxyXFx1MDAwMFxcdWZmZmZdKi9nO1xudmFyIERBVEFURVhUID0gL1teJjxcXHJcXHUwMDAwXFx1ZmZmZl0qL2c7XG52YXIgUkFXVEVYVCA9IC9bXjxcXHJcXHUwMDAwXFx1ZmZmZl0qL2c7XG52YXIgUExBSU5URVhUID0gL1teXFxyXFx1MDAwMFxcdWZmZmZdKi9nO1xuLy8gU2luY2Ugd2UgZG9uJ3QgaGF2ZSB0aGUgJ3N0aWNreSB0YWcnLCBhZGQgJ3wuJyB0byB0aGUgZW5kIG9mIFNJTVBMRVRBR1xuLy8gYW5kIFNJTVBMRUFUVFIgc28gdGhhdCB3ZSBhcmUgZ3VhcmFudGVlZCB0byBhbHdheXMgbWF0Y2guICBUaGlzIHByZXZlbnRzXG4vLyB1cyBmcm9tIHNjYW5uaW5nIHBhc3QgdGhlIGxhc3RJbmRleCBzZXQuIChOb3RlIHRoYXQgdGhlIGRlc2lyZWQgbWF0Y2hlc1xuLy8gYXJlIGFsd2F5cyBncmVhdGVyIHRoYW4gMSBjaGFyIGxvbmcsIHNvIGxvbmdlc3QtbWF0Y2ggd2lsbCBlbnN1cmUgdGhhdCAuXG4vLyBpcyBub3QgbWF0Y2hlZCB1bmxlc3MgdGhlIGRlc2lyZWQgbWF0Y2ggZmFpbHMuKVxudmFyIFNJTVBMRVRBRyA9IC8oPzooXFwvKT8oW2Etel0rKT4pfFtcXHNcXFNdL2c7XG52YXIgU0lNUExFQVRUUiA9IC8oPzooWy1hLXpdKylbIFxcdFxcblxcZl0qPVsgXFx0XFxuXFxmXSooJ1teJyZcXHJcXHUwMDAwXSonfFwiW15cIiZcXHJcXHUwMDAwXSpcInxbXlxcdFxcblxcclxcZiBcIiYnXFx1MDAwMD5dW14mPiBcXHRcXG5cXHJcXGZcXHUwMDAwXSpbIFxcdFxcblxcZl0pKXxbXFxzXFxTXS9nO1xuXG52YXIgTk9OV1MgPSAvW15cXHgwOVxceDBBXFx4MENcXHgwRFxceDIwXS87XG52YXIgQUxMTk9OV1MgPSAvW15cXHgwOVxceDBBXFx4MENcXHgwRFxceDIwXS9nOyAvLyBsaWtlIGFib3ZlLCB3aXRoIGcgZmxhZ1xudmFyIE5PTldTTk9OTlVMID0gL1teXFx4MDBcXHgwOVxceDBBXFx4MENcXHgwRFxceDIwXS87IC8vIGRvbid0IGFsbG93IE5VTCBlaXRoZXJcbnZhciBMRUFESU5HV1MgPSAvXltcXHgwOVxceDBBXFx4MENcXHgwRFxceDIwXSsvO1xudmFyIE5VTENIQVJTID0gL1xceDAwL2c7XG5cbi8qKipcbiAqIFRoZXNlIGFyZSB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IGRvbid0IHVzZSBhbnkgb2YgdGhlIHBhcnNlcidzXG4gKiBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gYnVmMnN0cihidWYpIHtcbiAgdmFyIENIVU5LU0laRT0xNjM4NDtcbiAgaWYgKGJ1Zi5sZW5ndGggPCBDSFVOS1NJWkUpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGJ1Zik7XG4gIH1cbiAgLy8gc3BlY2lhbCBjYXNlIGZvciBsYXJnZSBzdHJpbmdzLCB0byBhdm9pZCBidXN0aW5nIHRoZSBzdGFjay5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gQ0hVTktTSVpFKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBidWYuc2xpY2UoaSwgaStDSFVOS1NJWkUpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzdHIyYnVmKHMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpPTA7IGk8cy5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IHMuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgZWxlbWVudCBpcyBhIG1lbWJlciBvZiB0aGUgc2V0LlxuLy8gVGhlIHNldCBpcyBhbiBvYmplY3QgdGhhdCBtYXBzIG5hbWVzcGFjZXMgdG8gb2JqZWN0cy4gVGhlIG9iamVjdHNcbi8vIHRoZW4gbWFwIGxvY2FsIHRhZ25hbWVzIHRvIHRoZSB2YWx1ZSB0cnVlIGlmIHRoYXQgdGFnIGlzIHBhcnQgb2YgdGhlIHNldFxuZnVuY3Rpb24gaXNBKGVsdCwgc2V0KSB7XG4gIGlmICh0eXBlb2Ygc2V0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGNvbnZlbmllbmNlIGNhc2UgZm9yIHRlc3RpbmcgYSBwYXJ0aWN1bGFyIEhUTUwgZWxlbWVudFxuICAgIHJldHVybiBlbHQubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuSFRNTCAmJlxuICAgICAgZWx0LmxvY2FsTmFtZSA9PT0gc2V0O1xuICB9XG4gIHZhciB0YWduYW1lcyA9IHNldFtlbHQubmFtZXNwYWNlVVJJXTtcbiAgcmV0dXJuIHRhZ25hbWVzICYmIHRhZ25hbWVzW2VsdC5sb2NhbE5hbWVdO1xufVxuXG5mdW5jdGlvbiBpc01hdGhtbFRleHRJbnRlZ3JhdGlvblBvaW50KG4pIHtcbiAgcmV0dXJuIGlzQShuLCBtYXRobWxUZXh0SW50ZWdyYXRpb25Qb2ludFNldCk7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEludGVncmF0aW9uUG9pbnQobikge1xuICBpZiAoaXNBKG4sIGh0bWxJbnRlZ3JhdGlvblBvaW50U2V0KSkgcmV0dXJuIHRydWU7XG4gIGlmIChuLm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLk1BVEhNTCAmJlxuICAgIG4ubG9jYWxOYW1lID09PSBcImFubm90YXRpb24teG1sXCIpIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBuLmdldEF0dHJpYnV0ZShcImVuY29kaW5nXCIpO1xuICAgIGlmIChlbmNvZGluZykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChlbmNvZGluZyA9PT0gXCJ0ZXh0L2h0bWxcIiB8fFxuICAgICAgZW5jb2RpbmcgPT09IFwiYXBwbGljYXRpb24veGh0bWwreG1sXCIpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkanVzdFNWR1RhZ05hbWUobmFtZSkge1xuICBpZiAobmFtZSBpbiBzdmdUYWdOYW1lQWRqdXN0bWVudHMpXG4gICAgcmV0dXJuIHN2Z1RhZ05hbWVBZGp1c3RtZW50c1tuYW1lXTtcbiAgZWxzZVxuICAgIHJldHVybiBuYW1lO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RTVkdBdHRyaWJ1dGVzKGF0dHJzKSB7XG4gIGZvcih2YXIgaSA9IDAsIG4gPSBhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAoYXR0cnNbaV1bMF0gaW4gc3ZnQXR0ckFkanVzdG1lbnRzKSB7XG4gICAgICBhdHRyc1tpXVswXSA9IHN2Z0F0dHJBZGp1c3RtZW50c1thdHRyc1tpXVswXV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkanVzdE1hdGhNTEF0dHJpYnV0ZXMoYXR0cnMpIHtcbiAgZm9yKHZhciBpID0gMCwgbiA9IGF0dHJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgIGlmIChhdHRyc1tpXVswXSA9PT0gXCJkZWZpbml0aW9udXJsXCIpIHtcbiAgICAgIGF0dHJzW2ldWzBdID0gXCJkZWZpbml0aW9uVVJMXCI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRqdXN0Rm9yZWlnbkF0dHJpYnV0ZXMoYXR0cnMpIHtcbiAgZm9yKHZhciBpID0gMCwgbiA9IGF0dHJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgIGlmIChhdHRyc1tpXVswXSBpbiBmb3JlaWduQXR0cmlidXRlcykge1xuICAgICAgLy8gQXR0cmlidXRlcyB3aXRoIG5hbWVzcGFjZXMgZ2V0IGEgM3JkIGVsZW1lbnQ6XG4gICAgICAvLyBbUW5hbWUsIHZhbHVlLCBuYW1lc3BhY2VdXG4gICAgICBhdHRyc1tpXS5wdXNoKGZvcmVpZ25BdHRyaWJ1dGVzW2F0dHJzW2ldWzBdXSk7XG4gICAgfVxuICB9XG59XG5cbi8vIEZvciBlYWNoIGF0dHJpYnV0ZSBpbiBhdHRycywgaWYgZWx0IGRvZXNuJ3QgaGF2ZSBhbiBhdHRyaWJ1dGVcbi8vIGJ5IHRoYXQgbmFtZSwgYWRkIHRoZSBhdHRyaWJ1dGUgdG8gZWx0XG4vLyBYWFg6IEknbSBpZ25vcmluZyBuYW1lc3BhY2VzIGZvciBub3dcbmZ1bmN0aW9uIHRyYW5zZmVyQXR0cmlidXRlcyhhdHRycywgZWx0KSB7XG4gIGZvcih2YXIgaSA9IDAsIG4gPSBhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IGF0dHJzW2ldWzBdLCB2YWx1ZSA9IGF0dHJzW2ldWzFdO1xuICAgIGlmIChlbHQuaGFzQXR0cmlidXRlKG5hbWUpKSBjb250aW51ZTtcbiAgICBlbHQuX3NldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqKlxuICogVGhlIEVsZW1lbnRTdGFjayBjbGFzc1xuICovXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjayA9IGZ1bmN0aW9uIEVsZW1lbnRTdGFjaygpIHtcbiAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICB0aGlzLnRvcCA9IG51bGw7IC8vIHN0YWNrLnRvcCBpcyB0aGUgXCJjdXJyZW50IG5vZGVcIiBpbiB0aGUgc3BlY1xufTtcblxuLypcbi8vIFRoaXMgaXMgZm9yIGRlYnVnZ2luZyBvbmx5XG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBcIlNUQUNLOiBcIiArXG4gIHRoaXMuZWxlbWVudHMubWFwKGZ1bmN0aW9uKGUpIHtyZXR1cm4gZS5sb2NhbE5hbWU7fSkuam9pbihcIi1cIik7XG59XG4qL1xuXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5lbGVtZW50cy5wdXNoKGUpO1xuICB0aGlzLnRvcCA9IGU7XG59O1xuXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLmVsZW1lbnRzLnBvcCgpO1xuICB0aGlzLnRvcCA9IHRoaXMuZWxlbWVudHNbdGhpcy5lbGVtZW50cy5sZW5ndGgtMV07XG59O1xuXG4vLyBQb3AgZWxlbWVudHMgb2ZmIHRoZSBzdGFjayB1cCB0byBhbmQgaW5jbHVkaW5nIHRoZSBmaXJzdFxuLy8gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgKEhUTUwpIHRhZ25hbWVcbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5wb3BUYWcgPSBmdW5jdGlvbih0YWcpIHtcbiAgZm9yKHZhciBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgtMTsgaSA+IDA7IGktLSkge1xuICAgIHZhciBlID0gdGhpcy5lbGVtZW50c1tpXTtcbiAgICBpZiAoaXNBKGUsIHRhZykpIGJyZWFrO1xuICB9XG4gIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gaTtcbiAgdGhpcy50b3AgPSB0aGlzLmVsZW1lbnRzW2ktMV07XG59O1xuXG4vLyBQb3AgZWxlbWVudHMgb2ZmIHRoZSBzdGFjayB1cCB0byBhbmQgaW5jbHVkaW5nIHRoZSBmaXJzdFxuLy8gZWxlbWVudCB0aGF0IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBzcGVjaWZpZWQgdHlwZVxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLnBvcEVsZW1lbnRUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICBmb3IodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aC0xOyBpID4gMDsgaS0tKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gaW5zdGFuY2VvZiB0eXBlKSBicmVhaztcbiAgfVxuICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IGk7XG4gIHRoaXMudG9wID0gdGhpcy5lbGVtZW50c1tpLTFdO1xufTtcblxuLy8gUG9wIGVsZW1lbnRzIG9mZiB0aGUgc3RhY2sgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGUgZWxlbWVudCBlLlxuLy8gTm90ZSB0aGF0IHRoaXMgaXMgdmVyeSBkaWZmZXJlbnQgZnJvbSByZW1vdmVFbGVtZW50KClcbi8vIFRoaXMgcmVxdWlyZXMgdGhhdCBlIGlzIG9uIHRoZSBzdGFjay5cbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5wb3BFbGVtZW50ID0gZnVuY3Rpb24oZSkge1xuICBmb3IodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aC0xOyBpID4gMDsgaS0tKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gPT09IGUpIGJyZWFrO1xuICB9XG4gIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gaTtcbiAgdGhpcy50b3AgPSB0aGlzLmVsZW1lbnRzW2ktMV07XG59O1xuXG4vLyBSZW1vdmUgYSBzcGVjaWZpYyBlbGVtZW50IGZyb20gdGhlIHN0YWNrLlxuLy8gRG8gbm90aGluZyBpZiB0aGUgZWxlbWVudCBpcyBub3Qgb24gdGhlIHN0YWNrXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKHRoaXMudG9wID09PSBlKSB0aGlzLnBvcCgpO1xuICBlbHNlIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5lbGVtZW50cy5sYXN0SW5kZXhPZihlKTtcbiAgICBpZiAoaWR4ICE9PSAtMSlcbiAgICAgIHRoaXMuZWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gIH1cbn07XG5cbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5jbGVhclRvQ29udGV4dCA9IGZ1bmN0aW9uKHNldCkge1xuICAvLyBOb3RlIHRoYXQgd2UgZG9uJ3QgbG9vcCB0byAwLiBOZXZlciBwb3AgdGhlIDxodG1sPiBlbHQgb2ZmLlxuICBmb3IodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aC0xOyBpID4gMDsgaS0tKSB7XG4gICAgaWYgKGlzQSh0aGlzLmVsZW1lbnRzW2ldLCBzZXQpKSBicmVhaztcbiAgfVxuICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IGkrMTtcbiAgdGhpcy50b3AgPSB0aGlzLmVsZW1lbnRzW2ldO1xufTtcblxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24odGFnKSB7XG4gIHJldHVybiB0aGlzLmluU3BlY2lmaWNTY29wZSh0YWcsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufTtcblxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmluU3BlY2lmaWNTY29wZSA9IGZ1bmN0aW9uKHRhZywgc2V0KSB7XG4gIGZvcih2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGVsdCA9IHRoaXMuZWxlbWVudHNbaV07XG4gICAgaWYgKGlzQShlbHQsIHRhZykpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0EoZWx0LCBzZXQpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gTGlrZSB0aGUgYWJvdmUsIGJ1dCBmb3IgYSBzcGVjaWZpYyBlbGVtZW50LCBub3QgYSB0YWduYW1lXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUuZWxlbWVudEluU3BlY2lmaWNTY29wZSA9IGZ1bmN0aW9uKHRhcmdldCwgc2V0KSB7XG4gIGZvcih2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGVsdCA9IHRoaXMuZWxlbWVudHNbaV07XG4gICAgaWYgKGVsdCA9PT0gdGFyZ2V0KSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBKGVsdCwgc2V0KSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIExpa2UgdGhlIGFib3ZlLCBidXQgZm9yIGFuIGVsZW1lbnQgaW50ZXJmYWNlLCBub3QgYSB0YWduYW1lXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUuZWxlbWVudFR5cGVJblNwZWNpZmljU2NvcGUgPSBmdW5jdGlvbih0YXJnZXQsIHNldCkge1xuICBmb3IodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBlbHQgPSB0aGlzLmVsZW1lbnRzW2ldO1xuICAgIGlmIChlbHQgaW5zdGFuY2VvZiB0YXJnZXQpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0EoZWx0LCBzZXQpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmluU2NvcGUgPSBmdW5jdGlvbih0YWcpIHtcbiAgcmV0dXJuIHRoaXMuaW5TcGVjaWZpY1Njb3BlKHRhZywgaW5TY29wZVNldCk7XG59O1xuXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUuZWxlbWVudEluU2NvcGUgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiB0aGlzLmVsZW1lbnRJblNwZWNpZmljU2NvcGUoZSwgaW5TY29wZVNldCk7XG59O1xuXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUuZWxlbWVudFR5cGVJblNjb3BlID0gZnVuY3Rpb24odHlwZSkge1xuICByZXR1cm4gdGhpcy5lbGVtZW50VHlwZUluU3BlY2lmaWNTY29wZSh0eXBlLCBpblNjb3BlU2V0KTtcbn07XG5cbkhUTUxQYXJzZXIuRWxlbWVudFN0YWNrLnByb3RvdHlwZS5pbkJ1dHRvblNjb3BlID0gZnVuY3Rpb24odGFnKSB7XG4gIHJldHVybiB0aGlzLmluU3BlY2lmaWNTY29wZSh0YWcsIGluQnV0dG9uU2NvcGVTZXQpO1xufTtcblxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmluTGlzdEl0ZW1TY29wZSA9IGZ1bmN0aW9uKHRhZykge1xuICByZXR1cm4gdGhpcy5pblNwZWNpZmljU2NvcGUodGFnLCBpbkxpc3RJdGVtU2NvcGVTZXQpO1xufTtcblxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmluVGFibGVTY29wZSA9IGZ1bmN0aW9uKHRhZykge1xuICByZXR1cm4gdGhpcy5pblNwZWNpZmljU2NvcGUodGFnLCBpblRhYmxlU2NvcGVTZXQpO1xufTtcblxuSFRNTFBhcnNlci5FbGVtZW50U3RhY2sucHJvdG90eXBlLmluU2VsZWN0U2NvcGUgPSBmdW5jdGlvbih0YWcpIHtcbiAgLy8gQ2FuJ3QgaW1wbGVtZW50IHRoaXMgb25lIHdpdGggaW5TcGVjaWZpY1Njb3BlLCBzaW5jZSBpdCBpbnZvbHZlc1xuICAvLyBhIHNldCBkZWZpbmVkIGJ5IGludmVydGluZyBhbm90aGVyIHNldC4gU28gaW1wbGVtZW50IG1hbnVhbGx5LlxuICBmb3IodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBlbHQgPSB0aGlzLmVsZW1lbnRzW2ldO1xuICAgIGlmIChlbHQubmFtZXNwYWNlVVJJICE9PSBOQU1FU1BBQ0UuSFRNTCkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBsb2NhbG5hbWUgPSBlbHQubG9jYWxOYW1lO1xuICAgIGlmIChsb2NhbG5hbWUgPT09IHRhZykgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxvY2FsbmFtZSAhPT0gXCJvcHRncm91cFwiICYmIGxvY2FsbmFtZSAhPT0gXCJvcHRpb25cIilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5IVE1MUGFyc2VyLkVsZW1lbnRTdGFjay5wcm90b3R5cGUuZ2VuZXJhdGVJbXBsaWVkRW5kVGFncyA9IGZ1bmN0aW9uKGJ1dG5vdCwgdGhvcm91Z2gpIHtcbiAgdmFyIGVuZFRhZ1NldCA9IHRob3JvdWdoID8gdGhvcm91Z2hJbXBsaWVkRW5kVGFnc1NldCA6IGltcGxpZWRFbmRUYWdzU2V0O1xuICBmb3IodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBlID0gdGhpcy5lbGVtZW50c1tpXTtcbiAgICBpZiAoYnV0bm90ICYmIGlzQShlLCBidXRub3QpKSBicmVhaztcbiAgICBpZiAoIWlzQSh0aGlzLmVsZW1lbnRzW2ldLCBlbmRUYWdTZXQpKSBicmVhaztcbiAgfVxuXG4gIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gaSsxO1xuICB0aGlzLnRvcCA9IHRoaXMuZWxlbWVudHNbaV07XG59O1xuXG4vKioqXG4gKiBUaGUgQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzIGNsYXNzXG4gKi9cbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzID0gZnVuY3Rpb24gQUZFKCkge1xuICB0aGlzLmxpc3QgPSBbXTsgLy8gZWxlbWVudHNcbiAgdGhpcy5hdHRycyA9IFtdOyAvLyBhdHRyaWJ1dGUgdG9rZW5zIGZvciBjbG9uaW5nXG59O1xuXG5IVE1MUGFyc2VyLkFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5wcm90b3R5cGUuTUFSS0VSID0geyBsb2NhbE5hbWU6IFwifFwiIH07XG5cbi8qXG4vLyBGb3IgZGVidWdnaW5nXG5IVE1MUGFyc2VyLkFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiQUZFOiBcIiArXG4gIHRoaXMubGlzdC5tYXAoZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5sb2NhbE5hbWU7IH0pLmpvaW4oXCItXCIpO1xufVxuKi9cblxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLmluc2VydE1hcmtlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxpc3QucHVzaCh0aGlzLk1BUktFUik7XG4gIHRoaXMuYXR0cnMucHVzaCh0aGlzLk1BUktFUik7XG59O1xuXG5IVE1MUGFyc2VyLkFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGVsdCwgYXR0cnMpIHtcbiAgLy8gU2NhbiBiYWNrd2FyZHM6IGlmIHRoZXJlIGFyZSBhbHJlYWR5IDMgY29waWVzIG9mIHRoaXMgZWxlbWVudFxuICAvLyBiZWZvcmUgd2UgZW5jb3VudGVyIGEgbWFya2VyLCB0aGVuIGRyb3AgdGhlIGxhc3Qgb25lXG4gIHZhciBjb3VudCA9IDA7XG4gIGZvcih2YXIgaSA9IHRoaXMubGlzdC5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAodGhpcy5saXN0W2ldID09PSB0aGlzLk1BUktFUikgYnJlYWs7XG4gICAgLy8gZXF1YWwoKSBpcyBkZWZpbmVkIGJlbG93XG4gICAgaWYgKGVxdWFsKGVsdCwgdGhpcy5saXN0W2ldLCB0aGlzLmF0dHJzW2ldKSkge1xuICAgICAgY291bnQrKztcbiAgICAgIGlmIChjb3VudCA9PT0gMykge1xuICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLmF0dHJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvLyBOb3cgcHVzaCB0aGUgZWxlbWVudCBvbnRvIHRoZSBsaXN0XG4gIHRoaXMubGlzdC5wdXNoKGVsdCk7XG5cbiAgLy8gQ29weSB0aGUgYXR0cmlidXRlcyBhbmQgcHVzaCB0aG9zZSBvbiwgdG9vXG4gIHZhciBhdHRyY29weSA9IFtdO1xuICBmb3IodmFyIGlpID0gMDsgaWkgPCBhdHRycy5sZW5ndGg7IGlpKyspIHtcbiAgICBhdHRyY29weVtpaV0gPSBhdHRyc1tpaV07XG4gIH1cblxuICB0aGlzLmF0dHJzLnB1c2goYXR0cmNvcHkpO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gZGVmaW5lcyBlcXVhbGl0eSBvZiB0d28gZWxlbWVudHMgZm9yIHRoZSBwdXJwb3Nlc1xuICAvLyBvZiB0aGUgQUZFIGxpc3QuICBOb3RlIHRoYXQgaXQgY29tcGFyZXMgdGhlIG5ldyBlbGVtZW50c1xuICAvLyBhdHRyaWJ1dGVzIHRvIHRoZSBzYXZlZCBhcnJheSBvZiBhdHRyaWJ1dGVzIGFzc29jaWF0ZWQgd2l0aFxuICAvLyB0aGUgb2xkIGVsZW1lbnQgYmVjYXVzZSBhIHNjcmlwdCBjb3VsZCBoYXZlIGNoYW5nZWQgdGhlXG4gIC8vIG9sZCBlbGVtZW50J3Mgc2V0IG9mIGF0dHJpYnV0ZXNcbiAgZnVuY3Rpb24gZXF1YWwobmV3ZWx0LCBvbGRlbHQsIG9sZGF0dHJzKSB7XG4gICAgaWYgKG5ld2VsdC5sb2NhbE5hbWUgIT09IG9sZGVsdC5sb2NhbE5hbWUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAobmV3ZWx0Ll9udW1hdHRycyAhPT0gb2xkYXR0cnMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yKHZhciBpID0gMCwgbiA9IG9sZGF0dHJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgdmFyIG9sZG5hbWUgPSBvbGRhdHRyc1tpXVswXTtcbiAgICAgIHZhciBvbGR2YWwgPSBvbGRhdHRyc1tpXVsxXTtcbiAgICAgIGlmICghbmV3ZWx0Lmhhc0F0dHJpYnV0ZShvbGRuYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKG5ld2VsdC5nZXRBdHRyaWJ1dGUob2xkbmFtZSkgIT09IG9sZHZhbCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLmNsZWFyVG9NYXJrZXIgPSBmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpID0gdGhpcy5saXN0Lmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgIGlmICh0aGlzLmxpc3RbaV0gPT09IHRoaXMuTUFSS0VSKSBicmVhaztcbiAgfVxuICBpZiAoaSA8IDApIGkgPSAwO1xuICB0aGlzLmxpc3QubGVuZ3RoID0gaTtcbiAgdGhpcy5hdHRycy5sZW5ndGggPSBpO1xufTtcblxuLy8gRmluZCBhbmQgcmV0dXJuIHRoZSBsYXN0IGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHRhZyBiZXR3ZWVuIHRoZVxuLy8gZW5kIG9mIHRoZSBsaXN0IGFuZCB0aGUgbGFzdCBtYXJrZXIgb24gdGhlIGxpc3QuXG4vLyBVc2VkIHdoZW4gcGFyc2luZyA8YT4gaW5fYm9keV9tb2RlKClcbkhUTUxQYXJzZXIuQWN0aXZlRm9ybWF0dGluZ0VsZW1lbnRzLnByb3RvdHlwZS5maW5kRWxlbWVudEJ5VGFnID0gZnVuY3Rpb24odGFnKSB7XG4gIGZvcih2YXIgaSA9IHRoaXMubGlzdC5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgZWx0ID0gdGhpcy5saXN0W2ldO1xuICAgIGlmIChlbHQgPT09IHRoaXMuTUFSS0VSKSBicmVhaztcbiAgICBpZiAoZWx0LmxvY2FsTmFtZSA9PT0gdGFnKSByZXR1cm4gZWx0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiB0aGlzLmxpc3QubGFzdEluZGV4T2YoZSk7XG59O1xuXG4vLyBGaW5kIHRoZSBlbGVtZW50IGUgaW4gdGhlIGxpc3QgYW5kIHJlbW92ZSBpdFxuLy8gVXNlZCB3aGVuIHBhcnNpbmcgPGE+IGluX2JvZHkoKVxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGlkeCA9IHRoaXMubGlzdC5sYXN0SW5kZXhPZihlKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICB0aGlzLmxpc3Quc3BsaWNlKGlkeCwgMSk7XG4gICAgdGhpcy5hdHRycy5zcGxpY2UoaWR4LCAxKTtcbiAgfVxufTtcblxuLy8gRmluZCBlbGVtZW50IGEgaW4gdGhlIGxpc3QgYW5kIHJlcGxhY2UgaXQgd2l0aCBlbGVtZW50IGJcbi8vIFhYWDogRG8gSSBuZWVkIHRvIGhhbmRsZSBhdHRyaWJ1dGVzIGhlcmU/XG5IVE1MUGFyc2VyLkFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cy5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKGEsIGIsIGF0dHJzKSB7XG4gIHZhciBpZHggPSB0aGlzLmxpc3QubGFzdEluZGV4T2YoYSk7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgdGhpcy5saXN0W2lkeF0gPSBiO1xuICAgIHRoaXMuYXR0cnNbaWR4XSA9IGF0dHJzO1xuICB9XG59O1xuXG4vLyBGaW5kIGEgaW4gdGhlIGxpc3QgYW5kIGluc2VydCBiIGFmdGVyIGl0XG4vLyBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgaW5zZXJ0IGEgYm9va21hcmsgb2JqZWN0LCBzbyB0aGVcbi8vIGF0dHJzIGFycmF5IGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuSFRNTFBhcnNlci5BY3RpdmVGb3JtYXR0aW5nRWxlbWVudHMucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24oYSxiKSB7XG4gIHZhciBpZHggPSB0aGlzLmxpc3QubGFzdEluZGV4T2YoYSk7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgdGhpcy5saXN0LnNwbGljZShpZHgsIDAsIGIpO1xuICAgIHRoaXMuYXR0cnMuc3BsaWNlKGlkeCwgMCwgYik7XG4gIH1cbn07XG5cblxuXG5cbi8qKipcbiAqIFRoaXMgaXMgdGhlIHBhcnNlciBmYWN0b3J5IGZ1bmN0aW9uLiBJdCBpcyB0aGUgcmV0dXJuIHZhbHVlIG9mXG4gKiB0aGUgb3V0ZXIgY2xvc3VyZSB0aGF0IGl0IGlzIGRlZmluZWQgd2l0aGluLiAgTW9zdCBvZiB0aGUgcGFyc2VyXG4gKiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGFyZSBpbnNpZGUgdGhpcyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gSFRNTFBhcnNlcihhZGRyZXNzLCBmcmFnbWVudENvbnRleHQsIG9wdGlvbnMpIHtcbiAgLyoqKlxuICAgKiBUaGVzZSBhcmUgdGhlIHBhcnNlcidzIHN0YXRlIHZhcmlhYmxlc1xuICAgKi9cbiAgLy8gU2Nhbm5lciBzdGF0ZVxuICB2YXIgY2hhcnMgPSBudWxsO1xuICB2YXIgbnVtY2hhcnMgPSAwOyAvLyBMZW5ndGggb2YgY2hhcnNcbiAgdmFyIG5leHRjaGFyID0gMDsgLy8gSW5kZXggb2YgbmV4dCBjaGFyXG4gIHZhciBpbnB1dF9jb21wbGV0ZSA9IGZhbHNlOyAvLyBCZWNvbWVzIHRydWUgd2hlbiBlbmQoKSBjYWxsZWQuXG4gIHZhciBzY2FubmVyX3NraXBfbmV3bGluZSA9IGZhbHNlOyAvLyBJZiBwcmV2aW91cyBjaGFyIHdhcyBDUlxuICB2YXIgcmVlbnRyYW50X2ludm9jYXRpb25zID0gMDtcbiAgdmFyIHNhdmVkX3NjYW5uZXJfc3RhdGUgPSBbXTtcbiAgdmFyIGxlZnRvdmVycyA9IFwiXCI7XG4gIHZhciBmaXJzdF9iYXRjaCA9IHRydWU7XG4gIHZhciBwYXVzZWQgPSAwOyAvLyBCZWNvbWVzIG5vbi16ZXJvIHdoaWxlIGxvYWRpbmcgc2NyaXB0c1xuXG5cbiAgLy8gVG9rZW5pemVyIHN0YXRlXG4gIHZhciB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlOyAvLyBDdXJyZW50IHRva2VuaXplciBzdGF0ZVxuICB2YXIgcmV0dXJuX3N0YXRlO1xuICB2YXIgY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlO1xuICB2YXIgdGFnbmFtZWJ1ZiA9IFwiXCI7XG4gIHZhciBsYXN0dGFnbmFtZSA9IFwiXCI7IC8vIGhvbGRzIHRoZSB0YXJnZXQgZW5kIHRhZyBmb3IgdGV4dCBzdGF0ZXNcbiAgdmFyIHRlbXBidWYgPSBbXTtcbiAgdmFyIGF0dHJuYW1lYnVmID0gXCJcIjtcbiAgdmFyIGF0dHJ2YWx1ZWJ1ZiA9IFwiXCI7XG4gIHZhciBjb21tZW50YnVmID0gW107XG4gIHZhciBkb2N0eXBlbmFtZWJ1ZiA9IFtdO1xuICB2YXIgZG9jdHlwZXB1YmxpY2J1ZiA9IFtdO1xuICB2YXIgZG9jdHlwZXN5c3RlbWJ1ZiA9IFtdO1xuICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuICB2YXIgaXNfZW5kX3RhZyA9IGZhbHNlO1xuXG4gIC8vIFRyZWUgYnVpbGRlciBzdGF0ZVxuICB2YXIgcGFyc2VyID0gaW5pdGlhbF9tb2RlOyAvLyBDdXJyZW50IGluc2VydGlvbiBtb2RlXG4gIHZhciBvcmlnaW5hbEluc2VydGlvbk1vZGUgPSBudWxsOyAvLyBBIHNhdmVkIGluc2VydGlvbiBtb2RlXG4gIHZhciB0ZW1wbGF0ZUluc2VydGlvbk1vZGVzID0gW107IC8vIFN0YWNrIG9mIHRlbXBsYXRlIGluc2VydGlvbiBtb2Rlcy5cbiAgdmFyIHN0YWNrID0gbmV3IEhUTUxQYXJzZXIuRWxlbWVudFN0YWNrKCk7IC8vIFN0YWNrIG9mIG9wZW4gZWxlbWVudHNcbiAgdmFyIGFmZSA9IG5ldyBIVE1MUGFyc2VyLkFjdGl2ZUZvcm1hdHRpbmdFbGVtZW50cygpOyAvLyBtaXMtbmVzdGVkIHRhZ3NcbiAgdmFyIGZyYWdtZW50ID0gKGZyYWdtZW50Q29udGV4dCE9PXVuZGVmaW5lZCk7IC8vIEZvciBpbm5lckhUTUwsIGV0Yy5cbiAgdmFyIGhlYWRfZWxlbWVudF9wb2ludGVyID0gbnVsbDtcbiAgdmFyIGZvcm1fZWxlbWVudF9wb2ludGVyID0gbnVsbDtcbiAgdmFyIHNjcmlwdGluZ19lbmFibGVkID0gdHJ1ZTtcbiAgaWYgKGZyYWdtZW50Q29udGV4dCkge1xuXHRzY3JpcHRpbmdfZW5hYmxlZCA9IGZyYWdtZW50Q29udGV4dC5vd25lckRvY3VtZW50Ll9zY3JpcHRpbmdfZW5hYmxlZDtcbiAgfVxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNjcmlwdGluZ19lbmFibGVkID09PSBmYWxzZSlcbiAgICBzY3JpcHRpbmdfZW5hYmxlZCA9IGZhbHNlO1xuICB2YXIgZnJhbWVzZXRfb2sgPSB0cnVlO1xuICB2YXIgZm9yY2VfcXVpcmtzID0gZmFsc2U7XG4gIHZhciBwZW5kaW5nX3RhYmxlX3RleHQ7XG4gIHZhciB0ZXh0X2ludGVncmF0aW9uX21vZGU7IC8vIFhYWCBhIHNwZWMgYnVnIHdvcmthcm91bmQ/XG5cbiAgLy8gQSBzaW5nbGUgcnVuIG9mIGNoYXJhY3RlcnMsIGJ1ZmZlcmVkIHVwIHRvIGJlIHNlbnQgdG9cbiAgLy8gdGhlIHBhcnNlciBhcyBhIHNpbmdsZSBzdHJpbmcuXG4gIHZhciB0ZXh0cnVuID0gW107XG4gIHZhciB0ZXh0SW5jbHVkZXNOVUwgPSBmYWxzZTtcbiAgdmFyIGlnbm9yZV9saW5lZmVlZCA9IGZhbHNlO1xuXG4gIC8qKipcbiAgICogVGhpcyBpcyB0aGUgcGFyc2VyIG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzXG4gICAqIGZhY3RvcnkgZnVuY3Rpb24sIHdoaWNoIGlzIHNvbWUgNTAwMCBsaW5lcyBiZWxvdy5cbiAgICogTm90ZSB0aGF0IHRoZSB2YXJpYWJsZSBcInBhcnNlclwiIGlzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxuICAgKiBwYXJzZXIncyBzdGF0ZSBtYWNoaW5lLiAgVGhpcyB2YXJpYWJsZSBcImh0bWxwYXJzZXJcIiBpcyB0aGVcbiAgICogcmV0dXJuIHZhbHVlIGFuZCBkZWZpbmVzIHRoZSBwdWJsaWMgQVBJIG9mIHRoZSBwYXJzZXJcbiAgICovXG4gIHZhciBodG1scGFyc2VyID0ge1xuICAgIGRvY3VtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb2M7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgZnJvbSBIVE1MU2NyaXB0RWxlbWVudCB0byBwYXVzZSB0aGVcbiAgICAvLyBwYXJzZXIgd2hpbGUgYSBzY3JpcHQgaXMgYmVpbmcgbG9hZGVkIGZyb20gdGhlIG5ldHdvcmtcbiAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBwcmludChcInBhdXNpbmcgcGFyc2VyXCIpO1xuICAgICAgcGF1c2VkKys7XG4gICAgfSxcblxuICAgIC8vIENhbGxlZCB3aGVuIGEgc2NyaXB0IGZpbmlzaGVzIGxvYWRpbmdcbiAgICByZXN1bWU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gcHJpbnQoXCJyZXN1bWluZyBwYXJzZXJcIik7XG4gICAgICBwYXVzZWQtLTtcbiAgICAgIC8vIFhYWDogYWRkZWQgdGhpcyB0byBmb3JjZSBhIHJlc3VtcHRpb24uXG4gICAgICAvLyBJcyB0aGlzIHRoZSByaWdodCB0aGluZyB0byBkbz9cbiAgICAgIHRoaXMucGFyc2UoXCJcIik7XG4gICAgfSxcblxuICAgIC8vIFBhcnNlIHRoZSBIVE1MIHRleHQgcy5cbiAgICAvLyBUaGUgc2Vjb25kIGFyZ3VtZW50IHNob3VsZCBiZSB0cnVlIGlmIHRoZXJlIGlzIG5vIG1vcmVcbiAgICAvLyB0ZXh0IHRvIGJlIHBhcnNlZCwgYW5kIHNob3VsZCBiZSBmYWxzZSBvciBvbWl0dGVkIG90aGVyd2lzZS5cbiAgICAvLyBUaGUgc2Vjb25kIGFyZ3VtZW50IG11c3Qgbm90IGJlIHNldCBmb3IgcmVjdXJzaXZlIGludm9jYXRpb25zXG4gICAgLy8gZnJvbSBkb2N1bWVudC53cml0ZSgpXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHMsIGVuZCkge1xuXG4gICAgICAvLyBJZiB3ZSdyZSBwYXVzZWQsIHJlbWVtYmVyIHRoZSB0ZXh0IHRvIHBhcnNlLCBidXRcbiAgICAgIC8vIGRvbid0IHBhcnNlIGl0IG5vdy5cbiAgICAgIGlmIChwYXVzZWQgPiAwKSB7XG4gICAgICAgIGxlZnRvdmVycyArPSBzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cblxuICAgICAgaWYgKHJlZW50cmFudF9pbnZvY2F0aW9ucyA9PT0gMCkge1xuICAgICAgICAvLyBBIG5vcm1hbCwgdG9wLWxldmVsIGludm9jYXRpb25cbiAgICAgICAgaWYgKGxlZnRvdmVycykge1xuICAgICAgICAgIHMgPSBsZWZ0b3ZlcnMgKyBzO1xuICAgICAgICAgIGxlZnRvdmVycyA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYSBzcGVjaWFsIG1hcmtlciBjaGFyYWN0ZXIgdG8gdGhlIGVuZCBvZlxuICAgICAgICAvLyB0aGUgYnVmZmVyLiAgSWYgdGhlIHNjYW5uZXIgaXMgYXQgdGhlIGVuZCBvZlxuICAgICAgICAvLyB0aGUgYnVmZmVyIGFuZCBpbnB1dF9jb21wbGV0ZSBpcyBzZXQsIHRoZW4gdGhpc1xuICAgICAgICAvLyBjaGFyYWN0ZXIgd2lsbCB0cmFuc2Zvcm0gaW50byBhbiBFT0YgdG9rZW4uXG4gICAgICAgIC8vIEhhdmluZyBhbiBhY3R1YWwgY2hhcmFjdGVyIHRoYXQgcmVwcmVzZW50cyBFT0ZcbiAgICAgICAgLy8gaW4gdGhlIGNoYXJhY3RlciBidWZmZXIgbWFrZXMgbG9va2FoZWFkIHJlZ2V4cFxuICAgICAgICAvLyBtYXRjaGluZyB3b3JrIG1vcmUgZWFzaWx5LCBhbmQgdGhpcyBpc1xuICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIGNoYXJhY3RlciByZWZlcmVuY2VzLlxuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgcyArPSBcIlxcdUZGRkZcIjtcbiAgICAgICAgICBpbnB1dF9jb21wbGV0ZSA9IHRydWU7IC8vIE1ha2VzIHNjYW5DaGFycygpIHNlbmQgRU9GXG4gICAgICAgIH1cblxuICAgICAgICBjaGFycyA9IHM7XG4gICAgICAgIG51bWNoYXJzID0gcy5sZW5ndGg7XG4gICAgICAgIG5leHRjaGFyID0gMDtcblxuICAgICAgICBpZiAoZmlyc3RfYmF0Y2gpIHtcbiAgICAgICAgICAvLyBXZSBza2lwIGEgbGVhZGluZyBCeXRlIE9yZGVyIE1hcmsgKFxcdUZFRkYpXG4gICAgICAgICAgLy8gb24gZmlyc3QgYmF0Y2ggb2YgdGV4dCB3ZSdyZSBnaXZlblxuICAgICAgICAgIGZpcnN0X2JhdGNoID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGNoYXJzLmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikgbmV4dGNoYXIgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVlbnRyYW50X2ludm9jYXRpb25zKys7XG4gICAgICAgIHNjYW5DaGFycygpO1xuICAgICAgICBsZWZ0b3ZlcnMgPSBjaGFycy5zdWJzdHJpbmcobmV4dGNoYXIsIG51bWNoYXJzKTtcbiAgICAgICAgcmVlbnRyYW50X2ludm9jYXRpb25zLS07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgcmUtZW50cmFudCBjYXNlLCB3aGljaCB3ZSBoYXZlIHRvXG4gICAgICAgIC8vIGhhbmRsZSBhIGxpdHRsZSBkaWZmZXJlbnRseS5cbiAgICAgICAgcmVlbnRyYW50X2ludm9jYXRpb25zKys7XG5cbiAgICAgICAgLy8gU2F2ZSBjdXJyZW50IHNjYW5uZXIgc3RhdGVcbiAgICAgICAgc2F2ZWRfc2Nhbm5lcl9zdGF0ZS5wdXNoKGNoYXJzLCBudW1jaGFycywgbmV4dGNoYXIpO1xuXG4gICAgICAgIC8vIFNldCBuZXcgc2Nhbm5lciBzdGF0ZVxuICAgICAgICBjaGFycyA9IHM7XG4gICAgICAgIG51bWNoYXJzID0gcy5sZW5ndGg7XG4gICAgICAgIG5leHRjaGFyID0gMDtcblxuICAgICAgICAvLyBOb3cgc2NhbiBhcyBtYW55IG9mIHRoZXNlIG5ldyBjaGFycyBhcyB3ZSBjYW5cbiAgICAgICAgc2NhbkNoYXJzKCk7XG5cbiAgICAgICAgbGVmdG92ZXJzID0gY2hhcnMuc3Vic3RyaW5nKG5leHRjaGFyLCBudW1jaGFycyk7XG5cbiAgICAgICAgLy8gcmVzdG9yZSBvbGQgc2Nhbm5lciBzdGF0ZVxuICAgICAgICBuZXh0Y2hhciA9IHNhdmVkX3NjYW5uZXJfc3RhdGUucG9wKCk7XG4gICAgICAgIG51bWNoYXJzID0gc2F2ZWRfc2Nhbm5lcl9zdGF0ZS5wb3AoKTtcbiAgICAgICAgY2hhcnMgPSBzYXZlZF9zY2FubmVyX3N0YXRlLnBvcCgpO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIHdlcmUgbGVmdG92ZXIgY2hhcnMgZnJvbSB0aGlzIGludm9jYXRpb25cbiAgICAgICAgLy8gaW5zZXJ0IHRoZW0gaW50byB0aGUgcGVuZGluZyBpbnZvY2F0aW9uJ3MgYnVmZmVyXG4gICAgICAgIC8vIGFuZCB0cmltIGFscmVhZHkgcHJvY2Vzc2VkIGNoYXJzIGF0IHRoZSBzYW1lIHRpbWVcbiAgICAgICAgaWYgKGxlZnRvdmVycykge1xuICAgICAgICAgIGNoYXJzID0gbGVmdG92ZXJzICsgY2hhcnMuc3Vic3RyaW5nKG5leHRjaGFyKTtcbiAgICAgICAgICBudW1jaGFycyA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgICBuZXh0Y2hhciA9IDA7XG4gICAgICAgICAgbGVmdG92ZXJzID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY3JlbWVudCB0aGUgY291bnRlclxuICAgICAgICByZWVudHJhbnRfaW52b2NhdGlvbnMtLTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICAvLyBUaGlzIGlzIHRoZSBkb2N1bWVudCB3ZSdsbCBiZSBidWlsZGluZyB1cFxuICB2YXIgZG9jID0gbmV3IERvY3VtZW50KHRydWUsIGFkZHJlc3MpO1xuXG4gIC8vIFRoZSBkb2N1bWVudCBuZWVkcyB0byBrbm93IGFib3V0IHRoZSBwYXJzZXIsIGZvciBkb2N1bWVudC53cml0ZSgpLlxuICAvLyBUaGlzIF9wYXJzZXIgcHJvcGVydHkgd2lsbCBiZSBkZWxldGVkIHdoZW4gd2UncmUgZG9uZSBwYXJzaW5nLlxuICBkb2MuX3BhcnNlciA9IGh0bWxwYXJzZXI7XG5cbiAgLy8gWFhYIEkgdGhpbmsgdGhhdCBhbnkgZG9jdW1lbnQgd2UgdXNlIHRoaXMgcGFyc2VyIG9uIHNob3VsZCBzdXBwb3J0XG4gIC8vIHNjcmlwdHMuIEJ1dCBJIG1heSBuZWVkIHRvIGNvbmZpZ3VyZSB0aGF0IHRocm91Z2ggYSBwYXJzZXIgcGFyYW1ldGVyXG4gIC8vIE9ubHkgZG9jdW1lbnRzIHdpdGggd2luZG93cyAoXCJicm93c2luZyBjb250ZXh0c1wiIHRvIGJlIHByZWNpc2UpXG4gIC8vIGFsbG93IHNjcmlwdGluZy5cbiAgZG9jLl9zY3JpcHRpbmdfZW5hYmxlZCA9IHNjcmlwdGluZ19lbmFibGVkO1xuXG5cbiAgLyoqKlxuICAgKiBUaGUgYWN0dWFsIGNvZGUgb2YgdGhlIEhUTUxQYXJzZXIoKSBmYWN0b3J5IGZ1bmN0aW9uIGJlZ2lucyBoZXJlLlxuICAgKi9cblxuICBpZiAoZnJhZ21lbnRDb250ZXh0KSB7IC8vIGZvciBpbm5lckhUTUwgcGFyc2luZ1xuICAgIGlmIChmcmFnbWVudENvbnRleHQub3duZXJEb2N1bWVudC5fcXVpcmtzKVxuICAgICAgZG9jLl9xdWlya3MgPSB0cnVlO1xuICAgIGlmIChmcmFnbWVudENvbnRleHQub3duZXJEb2N1bWVudC5fbGltaXRlZFF1aXJrcylcbiAgICAgIGRvYy5fbGltaXRlZFF1aXJrcyA9IHRydWU7XG5cbiAgICAvLyBTZXQgdGhlIGluaXRpYWwgdG9rZW5pemVyIHN0YXRlXG4gICAgaWYgKGZyYWdtZW50Q29udGV4dC5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5IVE1MKSB7XG4gICAgICBzd2l0Y2goZnJhZ21lbnRDb250ZXh0LmxvY2FsTmFtZSkge1xuICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgdG9rZW5pemVyID0gcmNkYXRhX3N0YXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgY2FzZSBcInhtcFwiOlxuICAgICAgY2FzZSBcImlmcmFtZVwiOlxuICAgICAgY2FzZSBcIm5vZW1iZWRcIjpcbiAgICAgIGNhc2UgXCJub2ZyYW1lc1wiOlxuICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgY2FzZSBcInBsYWludGV4dFwiOlxuICAgICAgICB0b2tlbml6ZXIgPSBwbGFpbnRleHRfc3RhdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm5vc2NyaXB0XCI6XG4gICAgICAgIGlmIChzY3JpcHRpbmdfZW5hYmxlZClcbiAgICAgICAgICB0b2tlbml6ZXIgPSBwbGFpbnRleHRfc3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBkb2MuY3JlYXRlRWxlbWVudChcImh0bWxcIik7XG4gICAgZG9jLl9hcHBlbmRDaGlsZChyb290KTtcbiAgICBzdGFjay5wdXNoKHJvb3QpO1xuICAgIGlmIChmcmFnbWVudENvbnRleHQgaW5zdGFuY2VvZiBpbXBsLkhUTUxUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgIHRlbXBsYXRlSW5zZXJ0aW9uTW9kZXMucHVzaChpbl90ZW1wbGF0ZV9tb2RlKTtcbiAgICB9XG4gICAgcmVzZXRJbnNlcnRpb25Nb2RlKCk7XG5cbiAgICBmb3IodmFyIGUgPSBmcmFnbWVudENvbnRleHQ7IGUgIT09IG51bGw7IGUgPSBlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgaW1wbC5IVE1MRm9ybUVsZW1lbnQpIHtcbiAgICAgICAgZm9ybV9lbGVtZW50X3BvaW50ZXIgPSBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKioqXG4gICAqIFNjYW5uZXIgZnVuY3Rpb25zXG4gICAqL1xuICAvLyBMb29wIHRocm91Z2ggdGhlIGNoYXJhY3RlcnMgaW4gY2hhcnMsIGFuZCBwYXNzIHRoZW0gb25lIGF0IGEgdGltZVxuICAvLyB0byB0aGUgdG9rZW5pemVyIEZTTS4gUmV0dXJuIHdoZW4gbm8gbW9yZSBjaGFyYWN0ZXJzIGNhbiBiZSBwcm9jZXNzZWRcbiAgLy8gKFRoaXMgbWF5IGxlYXZlIDEgb3IgbW9yZSBjaGFyYWN0ZXJzIGluIHRoZSBidWZmZXI6IGxpa2UgYSBDUlxuICAvLyB3YWl0aW5nIHRvIHNlZSBpZiB0aGUgbmV4dCBjaGFyIGlzIExGLCBvciBmb3Igc3RhdGVzIHRoYXQgcmVxdWlyZVxuICAvLyBsb29rYWhlYWQuLi4pXG4gIGZ1bmN0aW9uIHNjYW5DaGFycygpIHtcbiAgICB2YXIgY29kZXBvaW50LCBzLCBwYXR0ZXJuLCBlb2Y7XG5cbiAgICB3aGlsZShuZXh0Y2hhciA8IG51bWNoYXJzKSB7XG5cbiAgICAgIC8vIElmIHdlIGp1c3QgdG9rZW5pemVkIGEgPC9zY3JpcHQ+IHRhZywgdGhlbiB0aGUgcGF1c2VkIGZsYWdcbiAgICAgIC8vIG1heSBoYXZlIGJlZW4gc2V0IHRvIHRlbGwgdXMgdG8gc3RvcCB0b2tlbml6aW5nIHdoaWxlXG4gICAgICAvLyB0aGUgc2NyaXB0IGlzIGxvYWRpbmdcbiAgICAgIGlmIChwYXVzZWQgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuXG4gICAgICBzd2l0Y2godHlwZW9mIHRva2VuaXplci5sb29rYWhlYWQpIHtcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIGNvZGVwb2ludCA9IGNoYXJzLmNoYXJDb2RlQXQobmV4dGNoYXIrKyk7XG4gICAgICAgIGlmIChzY2FubmVyX3NraXBfbmV3bGluZSkge1xuICAgICAgICAgIHNjYW5uZXJfc2tpcF9uZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGNvZGVwb2ludCA9PT0gMHgwMDBBKSB7XG4gICAgICAgICAgICBuZXh0Y2hhcisrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChjb2RlcG9pbnQpIHtcbiAgICAgICAgY2FzZSAweDAwMEQ6XG4gICAgICAgICAgLy8gQ1IgYWx3YXlzIHR1cm5zIGludG8gTEYsIGJ1dCBpZiB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAvLyBpcyBMRiwgdGhlbiB0aGF0IHNlY29uZCBMRiBpcyBza2lwcGVkLlxuICAgICAgICAgIGlmIChuZXh0Y2hhciA8IG51bWNoYXJzKSB7XG4gICAgICAgICAgICBpZiAoY2hhcnMuY2hhckNvZGVBdChuZXh0Y2hhcikgPT09IDB4MDAwQSlcbiAgICAgICAgICAgICAgbmV4dGNoYXIrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBrbm93IHRoZSBuZXh0IGNoYXIgcmlnaHQgbm93LCBzbyB3ZVxuICAgICAgICAgICAgLy8gY2FuJ3QgY2hlY2sgaWYgaXQgaXMgYSBMRi4gIFNvIHNldCBhIGZsYWdcbiAgICAgICAgICAgIHNjYW5uZXJfc2tpcF9uZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJbiBlaXRoZXIgY2FzZSwgZW1pdCBhIExGXG4gICAgICAgICAgdG9rZW5pemVyKDB4MDAwQSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweEZGRkY6XG4gICAgICAgICAgaWYgKGlucHV0X2NvbXBsZXRlICYmIG5leHRjaGFyID09PSBudW1jaGFycykge1xuICAgICAgICAgICAgdG9rZW5pemVyKEVPRik7IC8vIGNvZGVwb2ludCB3aWxsIGJlIDB4RkZGRiBoZXJlXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRva2VuaXplcihjb2RlcG9pbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjb2RlcG9pbnQgPSBjaGFycy5jaGFyQ29kZUF0KG5leHRjaGFyKTtcblxuICAgICAgICAvLyBUaGUgb25seSB0b2tlbml6ZXIgc3RhdGVzIHRoYXQgcmVxdWlyZSBmaXhlZCBsb29rYWhlYWRcbiAgICAgICAgLy8gb25seSBjb25zdW1lIGFscGhhbnVtIGNoYXJhY3RlcnMsIHNvIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gdG8gd29ycnkgYWJvdXQgQ1IgYW5kIExGIGluIHRoaXMgY2FzZVxuXG4gICAgICAgIC8vIHRva2VuaXplciB3YW50cyBuIGNoYXJzIG9mIGxvb2thaGVhZFxuICAgICAgICB2YXIgbiA9IHRva2VuaXplci5sb29rYWhlYWQ7XG4gICAgICAgIHZhciBuZWVkc1N0cmluZyA9IHRydWU7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgIG5lZWRzU3RyaW5nID0gZmFsc2U7XG4gICAgICAgICAgbiA9IC1uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gPCBudW1jaGFycyAtIG5leHRjaGFyKSB7XG4gICAgICAgICAgLy8gSWYgd2UgY2FuIGxvb2sgYWhlYWQgdGhhdCBmYXJcbiAgICAgICAgICBzID0gbmVlZHNTdHJpbmcgPyBjaGFycy5zdWJzdHJpbmcobmV4dGNoYXIsIG5leHRjaGFyK24pIDogbnVsbDtcbiAgICAgICAgICBlb2YgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gaWYgd2UgZG9uJ3QgaGF2ZSB0aGF0IG1hbnkgY2hhcmFjdGVyc1xuICAgICAgICAgIGlmIChpbnB1dF9jb21wbGV0ZSkgeyAvLyBJZiBubyBtb3JlIGFyZSBjb21pbmdcbiAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHdoYXQgd2UgaGF2ZVxuICAgICAgICAgICAgcyA9IG5lZWRzU3RyaW5nID8gY2hhcnMuc3Vic3RyaW5nKG5leHRjaGFyLCBudW1jaGFycykgOiBudWxsO1xuICAgICAgICAgICAgZW9mID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjb2RlcG9pbnQgPT09IDB4RkZGRiAmJiBuZXh0Y2hhciA9PT0gbnVtY2hhcnMtMSlcbiAgICAgICAgICAgICAgY29kZXBvaW50ID0gRU9GO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBub3cgYW5kIHdhaXQgZm9yIG1vcmUgY2hhcnMgbGF0ZXJcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5pemVyKGNvZGVwb2ludCwgcywgZW9mKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjb2RlcG9pbnQgPSBjaGFycy5jaGFyQ29kZUF0KG5leHRjaGFyKTtcblxuICAgICAgICAvLyB0b2tlbml6ZXIgd2FudHMgY2hhcmFjdGVycyB1cCB0byBhIG1hdGNoaW5nIHN0cmluZ1xuICAgICAgICBwYXR0ZXJuID0gdG9rZW5pemVyLmxvb2thaGVhZDtcbiAgICAgICAgdmFyIHBvcyA9IGNoYXJzLmluZGV4T2YocGF0dGVybiwgbmV4dGNoYXIpO1xuICAgICAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICAgIHMgPSBjaGFycy5zdWJzdHJpbmcobmV4dGNoYXIsIHBvcyArIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgICBlb2YgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgIC8vIE5vIG1hdGNoXG4gICAgICAgICAgLy8gSWYgbW9yZSBjaGFyYWN0ZXJzIGNvbWluZywgd2FpdCBmb3IgdGhlbVxuICAgICAgICAgIGlmICghaW5wdXRfY29tcGxldGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UndmUgZ290IHRvIHJldHVybiB3aGF0IHdlJ3ZlIGdvdFxuICAgICAgICAgIHMgPSBjaGFycy5zdWJzdHJpbmcobmV4dGNoYXIsIG51bWNoYXJzKTtcbiAgICAgICAgICBpZiAoY29kZXBvaW50ID09PSAweEZGRkYgJiYgbmV4dGNoYXIgPT09IG51bWNoYXJzLTEpXG4gICAgICAgICAgICBjb2RlcG9pbnQgPSBFT0Y7XG4gICAgICAgICAgZW9mID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSB0b2tlbml6ZXIgc3RhdGVzIHRoYXQgcmVxdWlyZSB0aGlzIGtpbmQgb2ZcbiAgICAgICAgLy8gbG9va2FoZWFkIGhhdmUgdG8gYmUgY2FyZWZ1bCB0byBoYW5kbGUgQ1IgY2hhcmFjdGVyc1xuICAgICAgICAvLyBjb3JyZWN0bHlcbiAgICAgICAgdG9rZW5pemVyKGNvZGVwb2ludCwgcywgZW9mKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvKioqXG4gICAqIFRva2VuaXplciB1dGlsaXR5IGZ1bmN0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gYWRkQXR0cmlidXRlKG5hbWUsdmFsdWUpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXNuJ3QgYWxyZWFkeSBhbiBhdHRyaWJ1dGUgd2l0aCB0aGlzIG5hbWVcbiAgICAvLyBJZiB0aGVyZSBpcywgaWdub3JlIHRoaXMgb25lLlxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXR0cmlidXRlc1tpXVswXSA9PT0gbmFtZSkgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKFtuYW1lXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2hvcnRjdXQgZm9yIHNpbXBsZSBhdHRyaWJ1dGVzXG4gIGZ1bmN0aW9uIGhhbmRsZVNpbXBsZUF0dHJpYnV0ZSgpIHtcbiAgICBTSU1QTEVBVFRSLmxhc3RJbmRleCA9IG5leHRjaGFyLTE7XG4gICAgdmFyIG1hdGNoZWQgPSBTSU1QTEVBVFRSLmV4ZWMoY2hhcnMpO1xuICAgIGlmICghbWF0Y2hlZCkgdGhyb3cgbmV3IEVycm9yKFwic2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcbiAgICB2YXIgbmFtZSA9IG1hdGNoZWRbMV07XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHZhbHVlID0gbWF0Y2hlZFsyXTtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgIHN3aXRjaCh2YWx1ZVswXSkge1xuICAgIGNhc2UgJ1wiJzpcbiAgICBjYXNlIFwiJ1wiOlxuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgbGVuLTEpO1xuICAgICAgbmV4dGNoYXIgKz0gKG1hdGNoZWRbMF0ubGVuZ3RoLTEpO1xuICAgICAgdG9rZW5pemVyID0gYWZ0ZXJfYXR0cmlidXRlX3ZhbHVlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGU7XG4gICAgICBuZXh0Y2hhciArPSAobWF0Y2hlZFswXS5sZW5ndGgtMSk7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBsZW4tMSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXNuJ3QgYWxyZWFkeSBhbiBhdHRyaWJ1dGUgd2l0aCB0aGlzIG5hbWVcbiAgICAvLyBJZiB0aGVyZSBpcywgaWdub3JlIHRoaXMgb25lLlxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXR0cmlidXRlc1tpXVswXSA9PT0gbmFtZSkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5UYWdOYW1lKCkge1xuICAgIGlzX2VuZF90YWcgPSBmYWxzZTtcbiAgICB0YWduYW1lYnVmID0gXCJcIjtcbiAgICBhdHRyaWJ1dGVzLmxlbmd0aCA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gYmVnaW5FbmRUYWdOYW1lKCkge1xuICAgIGlzX2VuZF90YWcgPSB0cnVlO1xuICAgIHRhZ25hbWVidWYgPSBcIlwiO1xuICAgIGF0dHJpYnV0ZXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luVGVtcEJ1ZigpIHsgdGVtcGJ1Zi5sZW5ndGggPSAwOyB9XG4gIGZ1bmN0aW9uIGJlZ2luQXR0ck5hbWUoKSB7IGF0dHJuYW1lYnVmID0gXCJcIjsgfVxuICBmdW5jdGlvbiBiZWdpbkF0dHJWYWx1ZSgpIHsgYXR0cnZhbHVlYnVmID0gXCJcIjsgfVxuICBmdW5jdGlvbiBiZWdpbkNvbW1lbnQoKSB7IGNvbW1lbnRidWYubGVuZ3RoID0gMDsgfVxuICBmdW5jdGlvbiBiZWdpbkRvY3R5cGUoKSB7XG4gICAgZG9jdHlwZW5hbWVidWYubGVuZ3RoID0gMDtcbiAgICBkb2N0eXBlcHVibGljYnVmID0gbnVsbDtcbiAgICBkb2N0eXBlc3lzdGVtYnVmID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBiZWdpbkRvY3R5cGVQdWJsaWNJZCgpIHsgZG9jdHlwZXB1YmxpY2J1ZiA9IFtdOyB9XG4gIGZ1bmN0aW9uIGJlZ2luRG9jdHlwZVN5c3RlbUlkKCkgeyBkb2N0eXBlc3lzdGVtYnVmID0gW107IH1cbiAgZnVuY3Rpb24gZm9yY2VxdWlya3MoKSB7IGZvcmNlX3F1aXJrcyA9IHRydWU7IH1cbiAgZnVuY3Rpb24gY2RhdGFBbGxvd2VkKCkge1xuICAgIHJldHVybiBzdGFjay50b3AgJiZcbiAgICAgIHN0YWNrLnRvcC5uYW1lc3BhY2VVUkkgIT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIGNvZGVwb2ludHMgaW4gdGhlIHNwZWNpZmllZCBidWZmZXIgbWF0Y2ggdGhlXG4gIC8vIGNoYXJhY3RlcnMgb2YgbGFzdHRhZ25hbWVcbiAgZnVuY3Rpb24gYXBwcm9wcmlhdGVFbmRUYWcoYnVmKSB7XG4gICAgcmV0dXJuIGxhc3R0YWduYW1lID09PSBidWY7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaFRleHQoKSB7XG4gICAgaWYgKHRleHRydW4ubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHMgPSBidWYyc3RyKHRleHRydW4pO1xuICAgICAgdGV4dHJ1bi5sZW5ndGggPSAwO1xuXG4gICAgICBpZiAoaWdub3JlX2xpbmVmZWVkKSB7XG4gICAgICAgIGlnbm9yZV9saW5lZmVlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoc1swXSA9PT0gXCJcXG5cIikgcyA9IHMuc3Vic3RyaW5nKDEpO1xuICAgICAgICBpZiAocy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW5zZXJ0VG9rZW4oVEVYVCwgcyk7XG4gICAgICB0ZXh0SW5jbHVkZXNOVUwgPSBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlX2xpbmVmZWVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBDb25zdW1lIGNoYXJzIG1hdGNoZWQgYnkgdGhlIHBhdHRlcm4gYW5kIHJldHVybiB0aGVtIGFzIGEgc3RyaW5nLiBTdGFydHNcbiAgLy8gbWF0Y2hpbmcgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIHNvIHVzZXJzIHNob3VsZCBkcm9wIHRoZSBjdXJyZW50IGNoYXJcbiAgLy8gb3RoZXJ3aXNlLlxuICBmdW5jdGlvbiBnZXRNYXRjaGluZ0NoYXJzKHBhdHRlcm4pIHtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IG5leHRjaGFyIC0gMTtcbiAgICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoY2hhcnMpO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA9PT0gbmV4dGNoYXIgLSAxKSB7XG4gICAgICBtYXRjaCA9IG1hdGNoWzBdO1xuICAgICAgbmV4dGNoYXIgKz0gbWF0Y2gubGVuZ3RoIC0gMTtcbiAgICAgIC8qIENhcmVmdWwhICBNYWtlIHN1cmUgd2UgaGF2ZW4ndCBtYXRjaGVkIHRoZSBFT0YgY2hhcmFjdGVyISAqL1xuICAgICAgaWYgKGlucHV0X2NvbXBsZXRlICYmIG5leHRjaGFyID09PSBudW1jaGFycykge1xuICAgICAgICAvLyBPb3BzLCBiYWNrdXAgb25lLlxuICAgICAgICBtYXRjaCA9IG1hdGNoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgbmV4dGNoYXItLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcbiAgICB9XG4gIH1cblxuICAvLyBlbWl0IGEgc3RyaW5nIG9mIGNoYXJzIHRoYXQgbWF0Y2ggYSByZWdleHBcbiAgLy8gUmV0dXJucyBmYWxzZSBpZiBubyBjaGFycyBtYXRjaGVkLlxuICBmdW5jdGlvbiBlbWl0Q2hhcnNXaGlsZShwYXR0ZXJuKSB7XG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSBuZXh0Y2hhci0xO1xuICAgIHZhciBtYXRjaCA9IHBhdHRlcm4uZXhlYyhjaGFycylbMF07XG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhbHNlO1xuICAgIGVtaXRDaGFyU3RyaW5nKG1hdGNoKTtcbiAgICBuZXh0Y2hhciArPSBtYXRjaC5sZW5ndGggLSAxO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVGhpcyBpcyB1c2VkIGJ5IENEQVRBIHNlY3Rpb25zXG4gIGZ1bmN0aW9uIGVtaXRDaGFyU3RyaW5nKHMpIHtcbiAgICBpZiAodGV4dHJ1bi5sZW5ndGggPiAwKSBmbHVzaFRleHQoKTtcblxuICAgIGlmIChpZ25vcmVfbGluZWZlZWQpIHtcbiAgICAgIGlnbm9yZV9saW5lZmVlZCA9IGZhbHNlO1xuICAgICAgaWYgKHNbMF0gPT09IFwiXFxuXCIpIHMgPSBzLnN1YnN0cmluZygxKTtcbiAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc2VydFRva2VuKFRFWFQsIHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFRhZygpIHtcbiAgICBpZiAoaXNfZW5kX3RhZykgaW5zZXJ0VG9rZW4oRU5EVEFHLCB0YWduYW1lYnVmKTtcbiAgICBlbHNlIHtcbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBsYXN0IG9wZW4gdGFnIHdlIGVtaXR0ZWRcbiAgICAgIHZhciB0YWduYW1lID0gdGFnbmFtZWJ1ZjtcbiAgICAgIHRhZ25hbWVidWYgPSBcIlwiO1xuICAgICAgbGFzdHRhZ25hbWUgPSB0YWduYW1lO1xuICAgICAgaW5zZXJ0VG9rZW4oVEFHLCB0YWduYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIEEgc2hvcnRjdXQ6IGxvb2sgYWhlYWQgYW5kIGlmIHRoaXMgaXMgYSBvcGVuIG9yIGNsb3NlIHRhZ1xuICAvLyBpbiBsb3dlcmNhc2Ugd2l0aCBubyBzcGFjZXMgYW5kIG5vIGF0dHJpYnV0ZXMsIGp1c3QgZW1pdCBpdCBub3cuXG4gIGZ1bmN0aW9uIGVtaXRTaW1wbGVUYWcoKSB7XG4gICAgU0lNUExFVEFHLmxhc3RJbmRleCA9IG5leHRjaGFyO1xuICAgIHZhciBtYXRjaGVkID0gU0lNUExFVEFHLmV4ZWMoY2hhcnMpO1xuICAgIGlmICghbWF0Y2hlZCkgdGhyb3cgbmV3IEVycm9yKFwic2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcbiAgICB2YXIgdGFnbmFtZSA9IG1hdGNoZWRbMl07XG4gICAgaWYgKCF0YWduYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGVuZHRhZyA9IG1hdGNoZWRbMV07XG4gICAgaWYgKGVuZHRhZykge1xuICAgICAgbmV4dGNoYXIgKz0gKHRhZ25hbWUubGVuZ3RoKzIpO1xuICAgICAgaW5zZXJ0VG9rZW4oRU5EVEFHLCB0YWduYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBuZXh0Y2hhciArPSAodGFnbmFtZS5sZW5ndGgrMSk7XG4gICAgICBsYXN0dGFnbmFtZSA9IHRhZ25hbWU7XG4gICAgICBpbnNlcnRUb2tlbihUQUcsIHRhZ25hbWUsIE5PQVRUUlMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRTZWxmQ2xvc2luZ1RhZygpIHtcbiAgICBpZiAoaXNfZW5kX3RhZykgaW5zZXJ0VG9rZW4oRU5EVEFHLCB0YWduYW1lYnVmLCBudWxsLCB0cnVlKTtcbiAgICBlbHNlIHtcbiAgICAgIGluc2VydFRva2VuKFRBRywgdGFnbmFtZWJ1ZiwgYXR0cmlidXRlcywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdERvY3R5cGUoKSB7XG4gICAgaW5zZXJ0VG9rZW4oRE9DVFlQRSxcbiAgICAgICAgICBidWYyc3RyKGRvY3R5cGVuYW1lYnVmKSxcbiAgICAgICAgICBkb2N0eXBlcHVibGljYnVmID8gYnVmMnN0cihkb2N0eXBlcHVibGljYnVmKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb2N0eXBlc3lzdGVtYnVmID8gYnVmMnN0cihkb2N0eXBlc3lzdGVtYnVmKSA6IHVuZGVmaW5lZCk7XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0RU9GKCkge1xuICAgIGZsdXNoVGV4dCgpO1xuICAgIHBhcnNlcihFT0YpOyAvLyBFT0YgbmV2ZXIgZ29lcyB0byBpbnNlcnRGb3JlaWduQ29udGVudCgpXG4gICAgZG9jLm1vZGNsb2NrID0gMTsgLy8gU3RhcnQgdHJhY2tpbmcgbW9kaWZpY2F0aW9uc1xuICB9XG5cbiAgLy8gSW5zZXJ0IGEgdG9rZW4sIGVpdGhlciB1c2luZyB0aGUgY3VycmVudCBwYXJzZXIgaW5zZXJ0aW9uIG1vZGVcbiAgLy8gKGZvciBIVE1MIHN0dWZmKSBvciB1c2luZyB0aGUgaW5zZXJ0Rm9yZWlnblRva2VuKCkgbWV0aG9kLlxuICB2YXIgaW5zZXJ0VG9rZW4gPSBodG1scGFyc2VyLmluc2VydFRva2VuID0gZnVuY3Rpb24gaW5zZXJ0VG9rZW4odCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBmbHVzaFRleHQoKTtcbiAgICB2YXIgY3VycmVudCA9IHN0YWNrLnRvcDtcblxuICAgIGlmICghY3VycmVudCB8fCBjdXJyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLkhUTUwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGNvbW1vbiBjYXNlXG4gICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSB3ZSBtYXkgbmVlZCB0byBpbnNlcnQgdGhpcyB0b2tlbiBhcyBmb3JlaWduIGNvbnRlbnRcbiAgICAgIGlmICh0ICE9PSBUQUcgJiYgdCAhPT0gVEVYVCkge1xuICAgICAgICBpbnNlcnRGb3JlaWduVG9rZW4odCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIEJ1dCBpbiBzb21lIGNhc2VzIHdlIHRyZWF0IGl0IGFzIHJlZ3VsYXIgY29udGVudFxuICAgICAgICBpZiAoKGlzTWF0aG1sVGV4dEludGVncmF0aW9uUG9pbnQoY3VycmVudCkgJiZcbiAgICAgICAgICAgKHQgPT09IFRFWFQgfHxcbiAgICAgICAgICAgICh0ID09PSBUQUcgJiZcbiAgICAgICAgICAgICB2YWx1ZSAhPT0gXCJtZ2x5cGhcIiAmJiB2YWx1ZSAhPT0gXCJtYWxpZ25tYXJrXCIpKSkgfHxcbiAgICAgICAgICAodCA9PT0gVEFHICYmXG4gICAgICAgICAgIHZhbHVlID09PSBcInN2Z1wiICYmXG4gICAgICAgICAgIGN1cnJlbnQubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuTUFUSE1MICYmXG4gICAgICAgICAgIGN1cnJlbnQubG9jYWxOYW1lID09PSBcImFubm90YXRpb24teG1sXCIpIHx8XG4gICAgICAgICAgaXNIVE1MSW50ZWdyYXRpb25Qb2ludChjdXJyZW50KSkge1xuXG4gICAgICAgICAgLy8gWFhYOiB0aGUgdGV4dF9pbnRlZ3JhdGlvbl9tb2RlIHN0dWZmIGlzIGFuXG4gICAgICAgICAgLy8gYXR0ZW1wdGVkIGJ1ZyB3b3JrYXJvdW5kIG9mIG1pbmVcbiAgICAgICAgICB0ZXh0X2ludGVncmF0aW9uX21vZGUgPSB0cnVlO1xuICAgICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgICAgdGV4dF9pbnRlZ3JhdGlvbl9tb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IGlzIGZvcmVpZ24gY29udGVudFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRGb3JlaWduVG9rZW4odCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqKlxuICAgKiBUcmVlIGJ1aWxkaW5nIHV0aWxpdHkgZnVuY3Rpb25zXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnRDb21tZW50KGRhdGEpIHtcbiAgICB2YXIgcGFyZW50ID0gc3RhY2sudG9wO1xuICAgIGlmIChmb3N0ZXJfcGFyZW50X21vZGUgJiYgaXNBKHBhcmVudCwgdGFibGVzZWN0aW9ucm93U2V0KSkge1xuICAgICAgZm9zdGVyUGFyZW50KGZ1bmN0aW9uKGRvYykgeyByZXR1cm4gZG9jLmNyZWF0ZUNvbW1lbnQoZGF0YSk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBcIklmIHRoZSBhZGp1c3RlZCBpbnNlcnRpb24gbG9jYXRpb24gaXMgaW5zaWRlIGEgdGVtcGxhdGUgZWxlbWVudCxcbiAgICAgIC8vIGxldCBpdCBpbnN0ZWFkIGJlIGluc2lkZSB0aGUgdGVtcGxhdGUgZWxlbWVudCdzIHRlbXBsYXRlIGNvbnRlbnRzXCJcbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBpbXBsLkhUTUxUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQuX2FwcGVuZENoaWxkKHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoZGF0YSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydFRleHQocykge1xuICAgIHZhciBwYXJlbnQgPSBzdGFjay50b3A7XG4gICAgaWYgKGZvc3Rlcl9wYXJlbnRfbW9kZSAmJiBpc0EocGFyZW50LCB0YWJsZXNlY3Rpb25yb3dTZXQpKSB7XG4gICAgICBmb3N0ZXJQYXJlbnQoZnVuY3Rpb24oZG9jKSB7IHJldHVybiBkb2MuY3JlYXRlVGV4dE5vZGUocyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBcIklmIHRoZSBhZGp1c3RlZCBpbnNlcnRpb24gbG9jYXRpb24gaXMgaW5zaWRlIGEgdGVtcGxhdGUgZWxlbWVudCxcbiAgICAgIC8vIGxldCBpdCBpbnN0ZWFkIGJlIGluc2lkZSB0aGUgdGVtcGxhdGUgZWxlbWVudCdzIHRlbXBsYXRlIGNvbnRlbnRzXCJcbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBpbXBsLkhUTUxUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICB9XG4gICAgICAvLyBcIklmIHRoZXJlIGlzIGEgVGV4dCBub2RlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgYWRqdXN0ZWQgaW5zZXJ0aW9uXG4gICAgICAvLyBsb2NhdGlvbiwgdGhlbiBhcHBlbmQgZGF0YSB0byB0aGF0IFRleHQgbm9kZSdzIGRhdGEuXCJcbiAgICAgIHZhciBsYXN0Q2hpbGQgPSBwYXJlbnQubGFzdENoaWxkO1xuICAgICAgaWYgKGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGxhc3RDaGlsZC5hcHBlbmREYXRhKHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50Ll9hcHBlbmRDaGlsZChwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSFRNTEVsdChkb2MsIG5hbWUsIGF0dHJzKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBlbGVtZW50IHRoaXMgd2F5LCByYXRoZXIgdGhhbiB3aXRoXG4gICAgLy8gZG9jLmNyZWF0ZUVsZW1lbnQgYmVjYXVzZSBjcmVhdGVFbGVtZW50KCkgZG9lcyBlcnJvclxuICAgIC8vIGNoZWNraW5nIG9uIHRoZSBlbGVtZW50IG5hbWUgdGhhdCB3ZSBuZWVkIHRvIGF2b2lkIGhlcmUuXG4gICAgdmFyIGVsdCA9IGh0bWwuY3JlYXRlRWxlbWVudChkb2MsIG5hbWUsIG51bGwpO1xuXG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICBmb3IodmFyIGkgPSAwLCBuID0gYXR0cnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgXyB2ZXJzaW9uIHRvIGF2b2lkIHRlc3RpbmcgdGhlIHZhbGlkaXR5XG4gICAgICAgIC8vIG9mIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICBlbHQuX3NldEF0dHJpYnV0ZShhdHRyc1tpXVswXSwgYXR0cnNbaV1bMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBYWFhcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBhIHJlc2V0dGFibGUgZm9ybSBlbGVtZW50LFxuICAgIC8vIHJ1biBpdHMgcmVzZXQgYWxnb3JpdGhtIG5vd1xuICAgIC8vIFhYWFxuICAgIC8vIGhhbmRsZSBjYXNlIHdoZXJlIGZvcm0tZWxlbWVudC1wb2ludGVyIGlzIG5vdCBudWxsXG4gICAgcmV0dXJuIGVsdDtcbiAgfVxuXG4gIC8vIFRoZSBpbl90YWJsZSBpbnNlcnRpb24gbW9kZSB0dXJucyBvbiB0aGlzIGZsYWcsIGFuZCB0aGF0IG1ha2VzXG4gIC8vIGluc2VydEhUTUxFbGVtZW50IHVzZSB0aGUgZm9zdGVyIHBhcmVudGluZyBhbGdvcml0aG0gZm9yIGVsZW1lbnRzXG4gIC8vIHRhZ3MgaW5zaWRlIGEgdGFibGVcbiAgdmFyIGZvc3Rlcl9wYXJlbnRfbW9kZSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGluc2VydEhUTUxFbGVtZW50KG5hbWUsIGF0dHJzKSB7XG4gICAgdmFyIGVsdCA9IGluc2VydEVsZW1lbnQoZnVuY3Rpb24oZG9jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSFRNTEVsdChkb2MsIG5hbWUsIGF0dHJzKTtcbiAgICB9KTtcblxuICAgIC8vIFhYWFxuICAgIC8vIElmIHRoaXMgaXMgYSBmb3JtIGVsZW1lbnQsIHNldCBpdHMgZm9ybSBhdHRyaWJ1dGUgcHJvcGVydHkgaGVyZVxuICAgIGlmIChpc0EoZWx0LCBmb3JtYXNzb2NpYXRlZFNldCkpIHtcbiAgICAgIGVsdC5fZm9ybSA9IGZvcm1fZWxlbWVudF9wb2ludGVyO1xuICAgIH1cblxuICAgIHJldHVybiBlbHQ7XG4gIH1cblxuICAvLyBJbnNlcnQgdGhlIGVsZW1lbnQgaW50byB0aGUgb3BlbiBlbGVtZW50IG9yIGZvc3RlciBwYXJlbnQgaXRcbiAgZnVuY3Rpb24gaW5zZXJ0RWxlbWVudChlbHRGdW5jKSB7XG4gICAgdmFyIGVsdDtcbiAgICBpZiAoZm9zdGVyX3BhcmVudF9tb2RlICYmIGlzQShzdGFjay50b3AsIHRhYmxlc2VjdGlvbnJvd1NldCkpIHtcbiAgICAgIGVsdCA9IGZvc3RlclBhcmVudChlbHRGdW5jKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAvLyBcIklmIHRoZSBhZGp1c3RlZCBpbnNlcnRpb24gbG9jYXRpb24gaXMgaW5zaWRlIGEgdGVtcGxhdGUgZWxlbWVudCxcbiAgICAgIC8vIGxldCBpdCBpbnN0ZWFkIGJlIGluc2lkZSB0aGUgdGVtcGxhdGUgZWxlbWVudCdzIHRlbXBsYXRlIGNvbnRlbnRzXCJcbiAgICAgIGVsdCA9IGVsdEZ1bmMoc3RhY2sudG9wLmNvbnRlbnQub3duZXJEb2N1bWVudCk7XG4gICAgICBzdGFjay50b3AuY29udGVudC5fYXBwZW5kQ2hpbGQoZWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWx0ID0gZWx0RnVuYyhzdGFjay50b3Aub3duZXJEb2N1bWVudCk7XG4gICAgICBzdGFjay50b3AuX2FwcGVuZENoaWxkKGVsdCk7XG4gICAgfVxuXG4gICAgc3RhY2sucHVzaChlbHQpO1xuICAgIHJldHVybiBlbHQ7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRGb3JlaWduRWxlbWVudChuYW1lLCBhdHRycywgbnMpIHtcbiAgICByZXR1cm4gaW5zZXJ0RWxlbWVudChmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBlbHQgPSBkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCBuYW1lKTtcbiAgICAgIGlmIChhdHRycykge1xuICAgICAgICBmb3IodmFyIGkgPSAwLCBuID0gYXR0cnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgICAgICBpZiAoYXR0ci5sZW5ndGggPT09IDIpXG4gICAgICAgICAgICBlbHQuX3NldEF0dHJpYnV0ZShhdHRyWzBdLCBhdHRyWzFdKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsdC5fc2V0QXR0cmlidXRlTlMoYXR0clsyXSwgYXR0clswXSwgYXR0clsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZWx0O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbGFzdEVsZW1lbnRPZlR5cGUodHlwZSkge1xuICAgIGZvcih2YXIgaSA9IHN0YWNrLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHN0YWNrLmVsZW1lbnRzW2ldIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9zdGVyUGFyZW50KGVsdEZ1bmMpIHtcbiAgICB2YXIgcGFyZW50LCBiZWZvcmUsIGxhc3RUYWJsZSA9IC0xLCBsYXN0VGVtcGxhdGUgPSAtMSwgZWx0O1xuXG4gICAgbGFzdFRhYmxlID0gbGFzdEVsZW1lbnRPZlR5cGUoaW1wbC5IVE1MVGFibGVFbGVtZW50KTtcbiAgICBsYXN0VGVtcGxhdGUgPSBsYXN0RWxlbWVudE9mVHlwZShpbXBsLkhUTUxUZW1wbGF0ZUVsZW1lbnQpO1xuXG4gICAgaWYgKGxhc3RUZW1wbGF0ZSA+PSAwICYmIChsYXN0VGFibGUgPCAwIHx8IGxhc3RUZW1wbGF0ZSA+IGxhc3RUYWJsZSkpIHtcbiAgICAgIHBhcmVudCA9IHN0YWNrLmVsZW1lbnRzW2xhc3RUZW1wbGF0ZV07XG4gICAgfSBlbHNlIGlmIChsYXN0VGFibGUgPj0gMCkge1xuICAgICAgcGFyZW50ID0gc3RhY2suZWxlbWVudHNbbGFzdFRhYmxlXS5wYXJlbnROb2RlO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBiZWZvcmUgPSBzdGFjay5lbGVtZW50c1tsYXN0VGFibGVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gc3RhY2suZWxlbWVudHNbbGFzdFRhYmxlIC0gMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFyZW50KSBwYXJlbnQgPSBzdGFjay5lbGVtZW50c1swXTsgLy8gdGhlIGBodG1sYCBlbGVtZW50LlxuXG4gICAgLy8gXCJJZiB0aGUgYWRqdXN0ZWQgaW5zZXJ0aW9uIGxvY2F0aW9uIGlzIGluc2lkZSBhIHRlbXBsYXRlIGVsZW1lbnQsXG4gICAgLy8gbGV0IGl0IGluc3RlYWQgYmUgaW5zaWRlIHRoZSB0ZW1wbGF0ZSBlbGVtZW50J3MgdGVtcGxhdGUgY29udGVudHNcIlxuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBpbXBsLkhUTUxUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5jb250ZW50O1xuICAgIH1cbiAgICAvLyBDcmVhdGUgZWxlbWVudCBpbiB0aGUgYXBwcm9wcmlhdGUgZG9jdW1lbnQuXG4gICAgZWx0ID0gZWx0RnVuYyhwYXJlbnQub3duZXJEb2N1bWVudCk7XG5cbiAgICBpZiAoZWx0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgdmFyIHByZXY7XG4gICAgICBpZiAoYmVmb3JlKSBwcmV2ID0gYmVmb3JlLnByZXZpb3VzU2libGluZztcbiAgICAgIGVsc2UgcHJldiA9IHBhcmVudC5sYXN0Q2hpbGQ7XG4gICAgICBpZiAocHJldiAmJiBwcmV2Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBwcmV2LmFwcGVuZERhdGEoZWx0LmRhdGEpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVmb3JlKVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShlbHQsIGJlZm9yZSk7XG4gICAgZWxzZVxuICAgICAgcGFyZW50Ll9hcHBlbmRDaGlsZChlbHQpO1xuICAgIHJldHVybiBlbHQ7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHJlc2V0SW5zZXJ0aW9uTW9kZSgpIHtcbiAgICB2YXIgbGFzdCA9IGZhbHNlO1xuICAgIGZvcih2YXIgaSA9IHN0YWNrLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIG5vZGUgPSBzdGFjay5lbGVtZW50c1tpXTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGxhc3QgPSB0cnVlO1xuICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICBub2RlID0gZnJhZ21lbnRDb250ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5IVE1MKSB7XG4gICAgICAgIHZhciB0YWcgPSBub2RlLmxvY2FsTmFtZTtcbiAgICAgICAgc3dpdGNoKHRhZykge1xuICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgZm9yKHZhciBqID0gaTsgaiA+IDA7ICkge1xuICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gc3RhY2suZWxlbWVudHNbLS1qXTtcbiAgICAgICAgICAgIGlmIChhbmNlc3RvciBpbnN0YW5jZW9mIGltcGwuSFRNTFRlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5jZXN0b3IgaW5zdGFuY2VvZiBpbXBsLkhUTUxUYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgcGFyc2VyID0gaW5fc2VsZWN0X2luX3RhYmxlX21vZGU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyc2VyID0gaW5fc2VsZWN0X21vZGU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgICBwYXJzZXIgPSBpbl9yb3dfbW9kZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICAgICAgcGFyc2VyID0gaW5fdGFibGVfYm9keV9tb2RlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcImNhcHRpb25cIjpcbiAgICAgICAgICBwYXJzZXIgPSBpbl9jYXB0aW9uX21vZGU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgICAgICBwYXJzZXIgPSBpbl9jb2x1bW5fZ3JvdXBfbW9kZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgICAgIHBhcnNlciA9IGluX3RhYmxlX21vZGU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgICBwYXJzZXIgPSB0ZW1wbGF0ZUluc2VydGlvbk1vZGVzW3RlbXBsYXRlSW5zZXJ0aW9uTW9kZXMubGVuZ3RoLTFdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICBwYXJzZXIgPSBpbl9ib2R5X21vZGU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiZnJhbWVzZXRcIjpcbiAgICAgICAgICBwYXJzZXIgPSBpbl9mcmFtZXNldF9tb2RlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICBpZiAoaGVhZF9lbGVtZW50X3BvaW50ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcnNlciA9IGJlZm9yZV9oZWFkX21vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlciA9IGFmdGVyX2hlYWRfbW9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gXCJoZWFkXCIpIHtcbiAgICAgICAgICAgICAgcGFyc2VyID0gaW5faGVhZF9tb2RlO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFnID09PSBcInRkXCIgfHwgdGFnID09PSBcInRoXCIpIHtcbiAgICAgICAgICAgICAgcGFyc2VyID0gaW5fY2VsbF9tb2RlO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdCkge1xuICAgICAgICBwYXJzZXIgPSBpbl9ib2R5X21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHBhcnNlUmF3VGV4dChuYW1lLCBhdHRycykge1xuICAgIGluc2VydEhUTUxFbGVtZW50KG5hbWUsIGF0dHJzKTtcbiAgICB0b2tlbml6ZXIgPSByYXd0ZXh0X3N0YXRlO1xuICAgIG9yaWdpbmFsSW5zZXJ0aW9uTW9kZSA9IHBhcnNlcjtcbiAgICBwYXJzZXIgPSB0ZXh0X21vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVJDREFUQShuYW1lLCBhdHRycykge1xuICAgIGluc2VydEhUTUxFbGVtZW50KG5hbWUsIGF0dHJzKTtcbiAgICB0b2tlbml6ZXIgPSByY2RhdGFfc3RhdGU7XG4gICAgb3JpZ2luYWxJbnNlcnRpb25Nb2RlID0gcGFyc2VyO1xuICAgIHBhcnNlciA9IHRleHRfbW9kZTtcbiAgfVxuXG4gIC8vIE1ha2UgYSBjb3B5IG9mIGVsZW1lbnQgaSBvbiB0aGUgbGlzdCBvZiBhY3RpdmUgZm9ybWF0dGluZ1xuICAvLyBlbGVtZW50cywgdXNpbmcgaXRzIG9yaWdpbmFsIGF0dHJpYnV0ZXMsIG5vdCBjdXJyZW50XG4gIC8vIGF0dHJpYnV0ZXMgKHdoaWNoIG1heSBoYXZlIGJlZW4gbW9kaWZpZWQgYnkgYSBzY3JpcHQpXG4gIGZ1bmN0aW9uIGFmZWNsb25lKGRvYywgaSkge1xuICAgIHJldHVybiB7XG4gICAgICBlbHQ6IGNyZWF0ZUhUTUxFbHQoZG9jLCBhZmUubGlzdFtpXS5sb2NhbE5hbWUsIGFmZS5hdHRyc1tpXSksXG4gICAgICBhdHRyczogYWZlLmF0dHJzW2ldLFxuICAgIH07XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGFmZXJlY29uc3RydWN0KCkge1xuICAgIGlmIChhZmUubGlzdC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgZW50cnkgPSBhZmUubGlzdFthZmUubGlzdC5sZW5ndGgtMV07XG4gICAgLy8gSWYgdGhlIGxhc3QgaXMgYSBtYXJrZXIgLCBkbyBub3RoaW5nXG4gICAgaWYgKGVudHJ5ID09PSBhZmUuTUFSS0VSKSByZXR1cm47XG4gICAgLy8gT3IgaWYgaXQgaXMgYW4gb3BlbiBlbGVtZW50LCBkbyBub3RoaW5nXG4gICAgaWYgKHN0YWNrLmVsZW1lbnRzLmxhc3RJbmRleE9mKGVudHJ5KSAhPT0gLTEpIHJldHVybjtcblxuICAgIC8vIExvb3AgYmFja3dhcmQgdGhyb3VnaCB0aGUgbGlzdCB1bnRpbCB3ZSBmaW5kIGEgbWFya2VyIG9yIGFuXG4gICAgLy8gb3BlbiBlbGVtZW50LCBhbmQgdGhlbiBtb3ZlIGZvcndhcmQgb25lIGZyb20gdGhlcmUuXG4gICAgZm9yKHZhciBpID0gYWZlLmxpc3QubGVuZ3RoLTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBlbnRyeSA9IGFmZS5saXN0W2ldO1xuICAgICAgaWYgKGVudHJ5ID09PSBhZmUuTUFSS0VSKSBicmVhaztcbiAgICAgIGlmIChzdGFjay5lbGVtZW50cy5sYXN0SW5kZXhPZihlbnRyeSkgIT09IC0xKSBicmVhaztcbiAgICB9XG5cbiAgICAvLyBOb3cgbG9vcCBmb3J3YXJkLCBzdGFydGluZyBmcm9tIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBjdXJyZW50XG4gICAgLy8gb25lLCByZWNyZWF0aW5nIGZvcm1hdHRpbmcgZWxlbWVudHMgYW5kIHB1c2hpbmcgdGhlbSBiYWNrIG9udG9cbiAgICAvLyB0aGUgbGlzdCBvZiBvcGVuIGVsZW1lbnRzXG4gICAgZm9yKGkgPSBpKzE7IGkgPCBhZmUubGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5ld2VsdCA9IGluc2VydEVsZW1lbnQoZnVuY3Rpb24oZG9jKSB7IHJldHVybiBhZmVjbG9uZShkb2MsIGkpLmVsdDsgfSk7XG4gICAgICBhZmUubGlzdFtpXSA9IG5ld2VsdDtcbiAgICB9XG4gIH1cblxuICAvLyBVc2VkIGJ5IHRoZSBhZG9wdGlvbkFnZW5jeSgpIGZ1bmN0aW9uXG4gIHZhciBCT09LTUFSSyA9IHtsb2NhbE5hbWU6XCJCTVwifTtcblxuICBmdW5jdGlvbiBhZG9wdGlvbkFnZW5jeSh0YWcpIHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIGlzIGFuIEhUTUwgZWxlbWVudCB3aG9zZSB0YWcgbmFtZSBpcyBzdWJqZWN0LFxuICAgIC8vIGFuZCB0aGUgY3VycmVudCBub2RlIGlzIG5vdCBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgZm9ybWF0dGluZ1xuICAgIC8vIGVsZW1lbnRzLCB0aGVuIHBvcCB0aGUgY3VycmVudCBub2RlIG9mZiB0aGUgc3RhY2sgb2Ygb3BlblxuICAgIC8vIGVsZW1lbnRzIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICBpZiAoaXNBKHN0YWNrLnRvcCwgdGFnKSAmJiBhZmUuaW5kZXhPZihzdGFjay50b3ApID09PSAtMSkge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gbm8gbW9yZSBoYW5kbGluZyByZXF1aXJlZFxuICAgIH1cblxuICAgIC8vIExldCBvdXRlciBsb29wIGNvdW50ZXIgYmUgemVyby5cbiAgICB2YXIgb3V0ZXIgPSAwO1xuXG4gICAgLy8gT3V0ZXIgbG9vcDogSWYgb3V0ZXIgbG9vcCBjb3VudGVyIGlzIGdyZWF0ZXIgdGhhbiBvclxuICAgIC8vIGVxdWFsIHRvIGVpZ2h0LCB0aGVuIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgIHdoaWxlKG91dGVyIDwgOCkge1xuICAgICAgLy8gSW5jcmVtZW50IG91dGVyIGxvb3AgY291bnRlciBieSBvbmUuXG4gICAgICBvdXRlcisrO1xuXG4gICAgICAvLyBMZXQgdGhlIGZvcm1hdHRpbmcgZWxlbWVudCBiZSB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBsaXN0XG4gICAgICAvLyBvZiBhY3RpdmUgZm9ybWF0dGluZyBlbGVtZW50cyB0aGF0OiBpcyBiZXR3ZWVuIHRoZSBlbmQgb2ZcbiAgICAgIC8vIHRoZSBsaXN0IGFuZCB0aGUgbGFzdCBzY29wZSBtYXJrZXIgaW4gdGhlIGxpc3QsIGlmIGFueSwgb3JcbiAgICAgIC8vIHRoZSBzdGFydCBvZiB0aGUgbGlzdCBvdGhlcndpc2UsIGFuZCBoYXMgdGhlIHNhbWUgdGFnIG5hbWVcbiAgICAgIC8vIGFzIHRoZSB0b2tlbi5cbiAgICAgIHZhciBmbXRlbHQgPSBhZmUuZmluZEVsZW1lbnRCeVRhZyh0YWcpO1xuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdWNoIG5vZGUsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMgYW5kIGluc3RlYWRcbiAgICAgIC8vIGFjdCBhcyBkZXNjcmliZWQgaW4gdGhlIFwiYW55IG90aGVyIGVuZCB0YWdcIiBlbnRyeSBiZWxvdy5cbiAgICAgIGlmICghZm10ZWx0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gZmFsc2UgbWVhbnMgaGFuZGxlIGJ5IHRoZSBkZWZhdWx0IGNhc2VcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBzdWNoIGEgbm9kZSwgYnV0IHRoYXQgbm9kZSBpcyBub3QgaW5cbiAgICAgIC8vIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzLCB0aGVuIHRoaXMgaXMgYSBwYXJzZSBlcnJvcjtcbiAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBsaXN0LCBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICB2YXIgaW5kZXggPSBzdGFjay5lbGVtZW50cy5sYXN0SW5kZXhPZihmbXRlbHQpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBhZmUucmVtb3ZlKGZtdGVsdCk7XG4gICAgICAgIHJldHVybiB0cnVlOyAgIC8vIHRydWUgbWVhbnMgbm8gbW9yZSBoYW5kbGluZyByZXF1aXJlZFxuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZXJlIGlzIHN1Y2ggYSBub2RlLCBhbmQgdGhhdCBub2RlIGlzIGFsc28gaW5cbiAgICAgIC8vIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzLCBidXQgdGhlIGVsZW1lbnQgaXMgbm90IGluIHNjb3BlLFxuICAgICAgLy8gdGhlbiB0aGlzIGlzIGEgcGFyc2UgZXJyb3I7IGlnbm9yZSB0aGUgdG9rZW4sIGFuZCBhYm9ydFxuICAgICAgLy8gdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoIXN0YWNrLmVsZW1lbnRJblNjb3BlKGZtdGVsdCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIExldCB0aGUgZnVydGhlc3QgYmxvY2sgYmUgdGhlIHRvcG1vc3Qgbm9kZSBpbiB0aGUgc3RhY2sgb2ZcbiAgICAgIC8vIG9wZW4gZWxlbWVudHMgdGhhdCBpcyBsb3dlciBpbiB0aGUgc3RhY2sgdGhhbiB0aGUgZm9ybWF0dGluZ1xuICAgICAgLy8gZWxlbWVudCwgYW5kIGlzIGFuIGVsZW1lbnQgaW4gdGhlIHNwZWNpYWwgY2F0ZWdvcnkuIFRoZXJlXG4gICAgICAvLyBtaWdodCBub3QgYmUgb25lLlxuICAgICAgdmFyIGZ1cnRoZXN0YmxvY2sgPSBudWxsLCBmdXJ0aGVzdGJsb2NraW5kZXg7XG4gICAgICBmb3IodmFyIGkgPSBpbmRleCsxOyBpIDwgc3RhY2suZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzQShzdGFjay5lbGVtZW50c1tpXSwgc3BlY2lhbFNldCkpIHtcbiAgICAgICAgICBmdXJ0aGVzdGJsb2NrID0gc3RhY2suZWxlbWVudHNbaV07XG4gICAgICAgICAgZnVydGhlc3RibG9ja2luZGV4ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBmdXJ0aGVzdCBibG9jaywgdGhlbiB0aGUgVUEgbXVzdCBza2lwIHRoZVxuICAgICAgLy8gc3Vic2VxdWVudCBzdGVwcyBhbmQgaW5zdGVhZCBqdXN0IHBvcCBhbGwgdGhlIG5vZGVzIGZyb20gdGhlXG4gICAgICAvLyBib3R0b20gb2YgdGhlIHN0YWNrIG9mIG9wZW4gZWxlbWVudHMsIGZyb20gdGhlIGN1cnJlbnQgbm9kZVxuICAgICAgLy8gdXAgdG8gYW5kIGluY2x1ZGluZyB0aGUgZm9ybWF0dGluZyBlbGVtZW50LCBhbmQgcmVtb3ZlIHRoZVxuICAgICAgLy8gZm9ybWF0dGluZyBlbGVtZW50IGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmdcbiAgICAgIC8vIGVsZW1lbnRzLlxuICAgICAgaWYgKCFmdXJ0aGVzdGJsb2NrKSB7XG4gICAgICAgIHN0YWNrLnBvcEVsZW1lbnQoZm10ZWx0KTtcbiAgICAgICAgYWZlLnJlbW92ZShmbXRlbHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBMZXQgdGhlIGNvbW1vbiBhbmNlc3RvciBiZSB0aGUgZWxlbWVudCBpbW1lZGlhdGVseSBhYm92ZVxuICAgICAgICAvLyB0aGUgZm9ybWF0dGluZyBlbGVtZW50IGluIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzLlxuICAgICAgICB2YXIgYW5jZXN0b3IgPSBzdGFjay5lbGVtZW50c1tpbmRleC0xXTtcblxuICAgICAgICAvLyBMZXQgYSBib29rbWFyayBub3RlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZm9ybWF0dGluZ1xuICAgICAgICAvLyBlbGVtZW50IGluIHRoZSBsaXN0IG9mIGFjdGl2ZSBmb3JtYXR0aW5nIGVsZW1lbnRzXG4gICAgICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50cyBvbiBlaXRoZXIgc2lkZSBvZiBpdCBpbiB0aGVcbiAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgYWZlLmluc2VydEFmdGVyKGZtdGVsdCwgQk9PS01BUkspO1xuXG4gICAgICAgIC8vIExldCBub2RlIGFuZCBsYXN0IG5vZGUgYmUgdGhlIGZ1cnRoZXN0IGJsb2NrLlxuICAgICAgICB2YXIgbm9kZSA9IGZ1cnRoZXN0YmxvY2s7XG4gICAgICAgIHZhciBsYXN0bm9kZSA9IGZ1cnRoZXN0YmxvY2s7XG4gICAgICAgIHZhciBub2RlaW5kZXggPSBmdXJ0aGVzdGJsb2NraW5kZXg7XG4gICAgICAgIHZhciBub2RlYWZlaW5kZXg7XG5cbiAgICAgICAgLy8gTGV0IGlubmVyIGxvb3AgY291bnRlciBiZSB6ZXJvLlxuICAgICAgICB2YXIgaW5uZXIgPSAwO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgICAvLyBJbmNyZW1lbnQgaW5uZXIgbG9vcCBjb3VudGVyIGJ5IG9uZS5cbiAgICAgICAgICBpbm5lcisrO1xuXG4gICAgICAgICAgLy8gTGV0IG5vZGUgYmUgdGhlIGVsZW1lbnQgaW1tZWRpYXRlbHkgYWJvdmUgbm9kZSBpblxuICAgICAgICAgIC8vIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzLCBvciBpZiBub2RlIGlzIG5vIGxvbmdlclxuICAgICAgICAgIC8vIGluIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzIChlLmcuIGJlY2F1c2UgaXQgZ290XG4gICAgICAgICAgLy8gcmVtb3ZlZCBieSB0aGlzIGFsZ29yaXRobSksIHRoZSBlbGVtZW50IHRoYXQgd2FzXG4gICAgICAgICAgLy8gaW1tZWRpYXRlbHkgYWJvdmUgbm9kZSBpbiB0aGUgc3RhY2sgb2Ygb3BlbiBlbGVtZW50c1xuICAgICAgICAgIC8vIGJlZm9yZSBub2RlIHdhcyByZW1vdmVkLlxuICAgICAgICAgIG5vZGUgPSBzdGFjay5lbGVtZW50c1stLW5vZGVpbmRleF07XG5cbiAgICAgICAgICAvLyBJZiBub2RlIGlzIHRoZSBmb3JtYXR0aW5nIGVsZW1lbnQsIHRoZW4gZ29cbiAgICAgICAgICAvLyB0byB0aGUgbmV4dCBzdGVwIGluIHRoZSBvdmVyYWxsIGFsZ29yaXRobS5cbiAgICAgICAgICBpZiAobm9kZSA9PT0gZm10ZWx0KSBicmVhaztcblxuICAgICAgICAgIC8vIElmIHRoZSBpbm5lciBsb29wIGNvdW50ZXIgaXMgZ3JlYXRlciB0aGFuIHRocmVlIGFuZCBub2RlXG4gICAgICAgICAgLy8gaXMgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmcgZWxlbWVudHMsIHRoZW4gcmVtb3ZlXG4gICAgICAgICAgLy8gbm9kZSBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBmb3JtYXR0aW5nIGVsZW1lbnRzLlxuICAgICAgICAgIG5vZGVhZmVpbmRleCA9IGFmZS5pbmRleE9mKG5vZGUpO1xuICAgICAgICAgIGlmIChpbm5lciA+IDMgJiYgbm9kZWFmZWluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgYWZlLnJlbW92ZShub2RlKTtcbiAgICAgICAgICAgIG5vZGVhZmVpbmRleCA9IC0xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIG5vZGUgaXMgbm90IGluIHRoZSBsaXN0IG9mIGFjdGl2ZSBmb3JtYXR0aW5nXG4gICAgICAgICAgLy8gZWxlbWVudHMsIHRoZW4gcmVtb3ZlIG5vZGUgZnJvbSB0aGUgc3RhY2sgb2Ygb3BlblxuICAgICAgICAgIC8vIGVsZW1lbnRzIGFuZCB0aGVuIGdvIGJhY2sgdG8gdGhlIHN0ZXAgbGFiZWxlZCBpbm5lclxuICAgICAgICAgIC8vIGxvb3AuXG4gICAgICAgICAgaWYgKG5vZGVhZmVpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHN0YWNrLnJlbW92ZUVsZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgYW4gZWxlbWVudCBmb3IgdGhlIHRva2VuIGZvciB3aGljaCB0aGVcbiAgICAgICAgICAvLyBlbGVtZW50IG5vZGUgd2FzIGNyZWF0ZWQgd2l0aCBjb21tb24gYW5jZXN0b3IgYXNcbiAgICAgICAgICAvLyB0aGUgaW50ZW5kZWQgcGFyZW50LCByZXBsYWNlIHRoZSBlbnRyeSBmb3Igbm9kZVxuICAgICAgICAgIC8vIGluIHRoZSBsaXN0IG9mIGFjdGl2ZSBmb3JtYXR0aW5nIGVsZW1lbnRzIHdpdGggYW5cbiAgICAgICAgICAvLyBlbnRyeSBmb3IgdGhlIG5ldyBlbGVtZW50LCByZXBsYWNlIHRoZSBlbnRyeSBmb3JcbiAgICAgICAgICAvLyBub2RlIGluIHRoZSBzdGFjayBvZiBvcGVuIGVsZW1lbnRzIHdpdGggYW4gZW50cnkgZm9yXG4gICAgICAgICAgLy8gdGhlIG5ldyBlbGVtZW50LCBhbmQgbGV0IG5vZGUgYmUgdGhlIG5ldyBlbGVtZW50LlxuICAgICAgICAgIHZhciBuZXdlbHQgPSBhZmVjbG9uZShhbmNlc3Rvci5vd25lckRvY3VtZW50LCBub2RlYWZlaW5kZXgpO1xuICAgICAgICAgIGFmZS5yZXBsYWNlKG5vZGUsIG5ld2VsdC5lbHQsIG5ld2VsdC5hdHRycyk7XG4gICAgICAgICAgc3RhY2suZWxlbWVudHNbbm9kZWluZGV4XSA9IG5ld2VsdC5lbHQ7XG4gICAgICAgICAgbm9kZSA9IG5ld2VsdC5lbHQ7XG5cbiAgICAgICAgICAvLyBJZiBsYXN0IG5vZGUgaXMgdGhlIGZ1cnRoZXN0IGJsb2NrLCB0aGVuIG1vdmUgdGhlXG4gICAgICAgICAgLy8gYWZvcmVtZW50aW9uZWQgYm9va21hcmsgdG8gYmUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlXG4gICAgICAgICAgLy8gbmV3IG5vZGUgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIGZvcm1hdHRpbmcgZWxlbWVudHMuXG4gICAgICAgICAgaWYgKGxhc3Rub2RlID09PSBmdXJ0aGVzdGJsb2NrKSB7XG4gICAgICAgICAgICBhZmUucmVtb3ZlKEJPT0tNQVJLKTtcbiAgICAgICAgICAgIGFmZS5pbnNlcnRBZnRlcihuZXdlbHQuZWx0LCBCT09LTUFSSyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSW5zZXJ0IGxhc3Qgbm9kZSBpbnRvIG5vZGUsIGZpcnN0IHJlbW92aW5nIGl0IGZyb21cbiAgICAgICAgICAvLyBpdHMgcHJldmlvdXMgcGFyZW50IG5vZGUgaWYgYW55LlxuICAgICAgICAgIG5vZGUuX2FwcGVuZENoaWxkKGxhc3Rub2RlKTtcblxuICAgICAgICAgIC8vIExldCBsYXN0IG5vZGUgYmUgbm9kZS5cbiAgICAgICAgICBsYXN0bm9kZSA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgY29tbW9uIGFuY2VzdG9yIG5vZGUgaXMgYSB0YWJsZSwgdGJvZHksIHRmb290LFxuICAgICAgICAvLyB0aGVhZCwgb3IgdHIgZWxlbWVudCwgdGhlbiwgZm9zdGVyIHBhcmVudCB3aGF0ZXZlciBsYXN0XG4gICAgICAgIC8vIG5vZGUgZW5kZWQgdXAgYmVpbmcgaW4gdGhlIHByZXZpb3VzIHN0ZXAsIGZpcnN0IHJlbW92aW5nXG4gICAgICAgIC8vIGl0IGZyb20gaXRzIHByZXZpb3VzIHBhcmVudCBub2RlIGlmIGFueS5cbiAgICAgICAgaWYgKGZvc3Rlcl9wYXJlbnRfbW9kZSAmJiBpc0EoYW5jZXN0b3IsIHRhYmxlc2VjdGlvbnJvd1NldCkpIHtcbiAgICAgICAgICBmb3N0ZXJQYXJlbnQoZnVuY3Rpb24oKSB7IHJldHVybiBsYXN0bm9kZTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhcHBlbmQgd2hhdGV2ZXIgbGFzdCBub2RlIGVuZGVkIHVwIGJlaW5nIGluXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyBzdGVwIHRvIHRoZSBjb21tb24gYW5jZXN0b3Igbm9kZSwgZmlyc3RcbiAgICAgICAgLy8gcmVtb3ZpbmcgaXQgZnJvbSBpdHMgcHJldmlvdXMgcGFyZW50IG5vZGUgaWYgYW55LlxuICAgICAgICBlbHNlIGlmIChhbmNlc3RvciBpbnN0YW5jZW9mIGltcGwuSFRNTFRlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgIGFuY2VzdG9yLmNvbnRlbnQuX2FwcGVuZENoaWxkKGxhc3Rub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmNlc3Rvci5fYXBwZW5kQ2hpbGQobGFzdG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIGVsZW1lbnQgZm9yIHRoZSB0b2tlbiBmb3Igd2hpY2ggdGhlXG4gICAgICAgIC8vIGZvcm1hdHRpbmcgZWxlbWVudCB3YXMgY3JlYXRlZCwgd2l0aCBmdXJ0aGVzdCBibG9ja1xuICAgICAgICAvLyBhcyB0aGUgaW50ZW5kZWQgcGFyZW50LlxuICAgICAgICB2YXIgbmV3ZWx0MiA9IGFmZWNsb25lKGZ1cnRoZXN0YmxvY2sub3duZXJEb2N1bWVudCwgYWZlLmluZGV4T2YoZm10ZWx0KSk7XG5cbiAgICAgICAgLy8gVGFrZSBhbGwgb2YgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBmdXJ0aGVzdCBibG9jayBhbmRcbiAgICAgICAgLy8gYXBwZW5kIHRoZW0gdG8gdGhlIGVsZW1lbnQgY3JlYXRlZCBpbiB0aGUgbGFzdCBzdGVwLlxuICAgICAgICB3aGlsZShmdXJ0aGVzdGJsb2NrLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIG5ld2VsdDIuZWx0Ll9hcHBlbmRDaGlsZChmdXJ0aGVzdGJsb2NrLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIHRoYXQgbmV3IGVsZW1lbnQgdG8gdGhlIGZ1cnRoZXN0IGJsb2NrLlxuICAgICAgICBmdXJ0aGVzdGJsb2NrLl9hcHBlbmRDaGlsZChuZXdlbHQyLmVsdCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBmb3JtYXR0aW5nIGVsZW1lbnQgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmVcbiAgICAgICAgLy8gZm9ybWF0dGluZyBlbGVtZW50cywgYW5kIGluc2VydCB0aGUgbmV3IGVsZW1lbnQgaW50byB0aGVcbiAgICAgICAgLy8gbGlzdCBvZiBhY3RpdmUgZm9ybWF0dGluZyBlbGVtZW50cyBhdCB0aGUgcG9zaXRpb24gb2ZcbiAgICAgICAgLy8gdGhlIGFmb3JlbWVudGlvbmVkIGJvb2ttYXJrLlxuICAgICAgICBhZmUucmVtb3ZlKGZtdGVsdCk7XG4gICAgICAgIGFmZS5yZXBsYWNlKEJPT0tNQVJLLCBuZXdlbHQyLmVsdCwgbmV3ZWx0Mi5hdHRycyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBmb3JtYXR0aW5nIGVsZW1lbnQgZnJvbSB0aGUgc3RhY2sgb2Ygb3BlblxuICAgICAgICAvLyBlbGVtZW50cywgYW5kIGluc2VydCB0aGUgbmV3IGVsZW1lbnQgaW50byB0aGUgc3RhY2sgb2ZcbiAgICAgICAgLy8gb3BlbiBlbGVtZW50cyBpbW1lZGlhdGVseSBiZWxvdyB0aGUgcG9zaXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGZ1cnRoZXN0IGJsb2NrIGluIHRoYXQgc3RhY2suXG4gICAgICAgIHN0YWNrLnJlbW92ZUVsZW1lbnQoZm10ZWx0KTtcbiAgICAgICAgdmFyIHBvcyA9IHN0YWNrLmVsZW1lbnRzLmxhc3RJbmRleE9mKGZ1cnRoZXN0YmxvY2spO1xuICAgICAgICBzdGFjay5lbGVtZW50cy5zcGxpY2UocG9zKzEsIDAsIG5ld2VsdDIuZWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFdlIGRvIHRoaXMgd2hlbiB3ZSBnZXQgL3NjcmlwdCBpbiBpbl90ZXh0X21vZGVcbiAgZnVuY3Rpb24gaGFuZGxlU2NyaXB0RW5kKCkge1xuICAgIC8vIFhYWDpcbiAgICAvLyBUaGlzIGlzIGp1c3QgYSBzdHViIGltcGxlbWVudGF0aW9uIHJpZ2h0IG5vdyBhbmQgZG9lc24ndCBydW4gc2NyaXB0cy5cbiAgICAvLyBHZXR0aW5nIHRoaXMgbWV0aG9kIHJpZ2h0IGludm9sdmVzIHRoZSBldmVudCBsb29wLCBVUkwgcmVzb2x1dGlvblxuICAgIC8vIHNjcmlwdCBmZXRjaGluZyBldGMuIEZvciBub3cgSSBqdXN0IHdhbnQgdG8gYmUgYWJsZSB0byBwYXJzZVxuICAgIC8vIGRvY3VtZW50cyBhbmQgdGVzdCB0aGUgcGFyc2VyLlxuXG4gICAgLy92YXIgc2NyaXB0ID0gc3RhY2sudG9wO1xuICAgIHN0YWNrLnBvcCgpO1xuICAgIHBhcnNlciA9IG9yaWdpbmFsSW5zZXJ0aW9uTW9kZTtcbiAgICAvL3NjcmlwdC5fcHJlcGFyZSgpO1xuICAgIHJldHVybjtcblxuICAgIC8vIFhYWDogaGVyZSBpcyB3aGF0IHRoaXMgbWV0aG9kIGlzIHN1cHBvc2VkIHRvIGRvXG5cbiAgICAvLyBQcm92aWRlIGEgc3RhYmxlIHN0YXRlLlxuXG4gICAgLy8gTGV0IHNjcmlwdCBiZSB0aGUgY3VycmVudCBub2RlICh3aGljaCB3aWxsIGJlIGEgc2NyaXB0XG4gICAgLy8gZWxlbWVudCkuXG5cbiAgICAvLyBQb3AgdGhlIGN1cnJlbnQgbm9kZSBvZmYgdGhlIHN0YWNrIG9mIG9wZW4gZWxlbWVudHMuXG5cbiAgICAvLyBTd2l0Y2ggdGhlIGluc2VydGlvbiBtb2RlIHRvIHRoZSBvcmlnaW5hbCBpbnNlcnRpb24gbW9kZS5cblxuICAgIC8vIExldCB0aGUgb2xkIGluc2VydGlvbiBwb2ludCBoYXZlIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBjdXJyZW50XG4gICAgLy8gaW5zZXJ0aW9uIHBvaW50LiBMZXQgdGhlIGluc2VydGlvbiBwb2ludCBiZSBqdXN0IGJlZm9yZSB0aGVcbiAgICAvLyBuZXh0IGlucHV0IGNoYXJhY3Rlci5cblxuICAgIC8vIEluY3JlbWVudCB0aGUgcGFyc2VyJ3Mgc2NyaXB0IG5lc3RpbmcgbGV2ZWwgYnkgb25lLlxuXG4gICAgLy8gUHJlcGFyZSB0aGUgc2NyaXB0LiBUaGlzIG1pZ2h0IGNhdXNlIHNvbWUgc2NyaXB0IHRvIGV4ZWN1dGUsXG4gICAgLy8gd2hpY2ggbWlnaHQgY2F1c2UgbmV3IGNoYXJhY3RlcnMgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAvLyB0b2tlbml6ZXIsIGFuZCBtaWdodCBjYXVzZSB0aGUgdG9rZW5pemVyIHRvIG91dHB1dCBtb3JlIHRva2VucyxcbiAgICAvLyByZXN1bHRpbmcgaW4gYSByZWVudHJhbnQgaW52b2NhdGlvbiBvZiB0aGUgcGFyc2VyLlxuXG4gICAgLy8gRGVjcmVtZW50IHRoZSBwYXJzZXIncyBzY3JpcHQgbmVzdGluZyBsZXZlbCBieSBvbmUuIElmIHRoZVxuICAgIC8vIHBhcnNlcidzIHNjcmlwdCBuZXN0aW5nIGxldmVsIGlzIHplcm8sIHRoZW4gc2V0IHRoZSBwYXJzZXJcbiAgICAvLyBwYXVzZSBmbGFnIHRvIGZhbHNlLlxuXG4gICAgLy8gTGV0IHRoZSBpbnNlcnRpb24gcG9pbnQgaGF2ZSB0aGUgdmFsdWUgb2YgdGhlIG9sZCBpbnNlcnRpb25cbiAgICAvLyBwb2ludC4gKEluIG90aGVyIHdvcmRzLCByZXN0b3JlIHRoZSBpbnNlcnRpb24gcG9pbnQgdG8gaXRzXG4gICAgLy8gcHJldmlvdXMgdmFsdWUuIFRoaXMgdmFsdWUgbWlnaHQgYmUgdGhlIFwidW5kZWZpbmVkXCIgdmFsdWUuKVxuXG4gICAgLy8gQXQgdGhpcyBzdGFnZSwgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHBhcnNpbmctYmxvY2tpbmcgc2NyaXB0LFxuICAgIC8vIHRoZW46XG5cbiAgICAvLyBJZiB0aGUgc2NyaXB0IG5lc3RpbmcgbGV2ZWwgaXMgbm90IHplcm86XG5cbiAgICAvLyAgIFNldCB0aGUgcGFyc2VyIHBhdXNlIGZsYWcgdG8gdHJ1ZSwgYW5kIGFib3J0IHRoZSBwcm9jZXNzaW5nXG4gICAgLy8gICBvZiBhbnkgbmVzdGVkIGludm9jYXRpb25zIG9mIHRoZSB0b2tlbml6ZXIsIHlpZWxkaW5nXG4gICAgLy8gICBjb250cm9sIGJhY2sgdG8gdGhlIGNhbGxlci4gKFRva2VuaXphdGlvbiB3aWxsIHJlc3VtZSB3aGVuXG4gICAgLy8gICB0aGUgY2FsbGVyIHJldHVybnMgdG8gdGhlIFwib3V0ZXJcIiB0cmVlIGNvbnN0cnVjdGlvbiBzdGFnZS4pXG5cbiAgICAvLyAgIFRoZSB0cmVlIGNvbnN0cnVjdGlvbiBzdGFnZSBvZiB0aGlzIHBhcnRpY3VsYXIgcGFyc2VyIGlzXG4gICAgLy8gICBiZWluZyBjYWxsZWQgcmVlbnRyYW50bHksIHNheSBmcm9tIGEgY2FsbCB0b1xuICAgIC8vICAgZG9jdW1lbnQud3JpdGUoKS5cblxuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vICAgICBSdW4gdGhlc2Ugc3RlcHM6XG5cbiAgICAvLyAgICAgICBMZXQgdGhlIHNjcmlwdCBiZSB0aGUgcGVuZGluZyBwYXJzaW5nLWJsb2NraW5nXG4gICAgLy8gICAgICAgc2NyaXB0LiBUaGVyZSBpcyBubyBsb25nZXIgYSBwZW5kaW5nXG4gICAgLy8gICAgICAgcGFyc2luZy1ibG9ja2luZyBzY3JpcHQuXG5cbiAgICAvLyAgICAgICBCbG9jayB0aGUgdG9rZW5pemVyIGZvciB0aGlzIGluc3RhbmNlIG9mIHRoZSBIVE1MXG4gICAgLy8gICAgICAgcGFyc2VyLCBzdWNoIHRoYXQgdGhlIGV2ZW50IGxvb3Agd2lsbCBub3QgcnVuIHRhc2tzXG4gICAgLy8gICAgICAgdGhhdCBpbnZva2UgdGhlIHRva2VuaXplci5cblxuICAgIC8vICAgICAgIElmIHRoZSBwYXJzZXIncyBEb2N1bWVudCBoYXMgYSBzdHlsZSBzaGVldCB0aGF0IGlzXG4gICAgLy8gICAgICAgYmxvY2tpbmcgc2NyaXB0cyBvciB0aGUgc2NyaXB0J3MgXCJyZWFkeSB0byBiZVxuICAgIC8vICAgICAgIHBhcnNlci1leGVjdXRlZFwiIGZsYWcgaXMgbm90IHNldDogc3BpbiB0aGUgZXZlbnRcbiAgICAvLyAgICAgICBsb29wIHVudGlsIHRoZSBwYXJzZXIncyBEb2N1bWVudCBoYXMgbm8gc3R5bGUgc2hlZXRcbiAgICAvLyAgICAgICB0aGF0IGlzIGJsb2NraW5nIHNjcmlwdHMgYW5kIHRoZSBzY3JpcHQncyBcInJlYWR5IHRvXG4gICAgLy8gICAgICAgYmUgcGFyc2VyLWV4ZWN1dGVkXCIgZmxhZyBpcyBzZXQuXG5cbiAgICAvLyAgICAgICBVbmJsb2NrIHRoZSB0b2tlbml6ZXIgZm9yIHRoaXMgaW5zdGFuY2Ugb2YgdGhlIEhUTUxcbiAgICAvLyAgICAgICBwYXJzZXIsIHN1Y2ggdGhhdCB0YXNrcyB0aGF0IGludm9rZSB0aGUgdG9rZW5pemVyXG4gICAgLy8gICAgICAgY2FuIGFnYWluIGJlIHJ1bi5cblxuICAgIC8vICAgICAgIExldCB0aGUgaW5zZXJ0aW9uIHBvaW50IGJlIGp1c3QgYmVmb3JlIHRoZSBuZXh0XG4gICAgLy8gICAgICAgaW5wdXQgY2hhcmFjdGVyLlxuXG4gICAgLy8gICAgICAgSW5jcmVtZW50IHRoZSBwYXJzZXIncyBzY3JpcHQgbmVzdGluZyBsZXZlbCBieSBvbmVcbiAgICAvLyAgICAgICAoaXQgc2hvdWxkIGJlIHplcm8gYmVmb3JlIHRoaXMgc3RlcCwgc28gdGhpcyBzZXRzXG4gICAgLy8gICAgICAgaXQgdG8gb25lKS5cblxuICAgIC8vICAgICAgIEV4ZWN1dGUgdGhlIHNjcmlwdC5cblxuICAgIC8vICAgICAgIERlY3JlbWVudCB0aGUgcGFyc2VyJ3Mgc2NyaXB0IG5lc3RpbmcgbGV2ZWwgYnlcbiAgICAvLyAgICAgICBvbmUuIElmIHRoZSBwYXJzZXIncyBzY3JpcHQgbmVzdGluZyBsZXZlbCBpcyB6ZXJvXG4gICAgLy8gICAgICAgKHdoaWNoIGl0IGFsd2F5cyBzaG91bGQgYmUgYXQgdGhpcyBwb2ludCksIHRoZW4gc2V0XG4gICAgLy8gICAgICAgdGhlIHBhcnNlciBwYXVzZSBmbGFnIHRvIGZhbHNlLlxuXG4gICAgLy8gICAgICAgTGV0IHRoZSBpbnNlcnRpb24gcG9pbnQgYmUgdW5kZWZpbmVkIGFnYWluLlxuXG4gICAgLy8gICAgICAgSWYgdGhlcmUgaXMgb25jZSBhZ2FpbiBhIHBlbmRpbmcgcGFyc2luZy1ibG9ja2luZ1xuICAgIC8vICAgICAgIHNjcmlwdCwgdGhlbiByZXBlYXQgdGhlc2Ugc3RlcHMgZnJvbSBzdGVwIDEuXG5cblxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcFBhcnNpbmcoKSB7XG4gICAgLy8gWFhYIFRoaXMgaXMganVzdCBhIHRlbXBvcmFyeSBpbXBsZW1lbnRhdGlvbiB0byBnZXQgdGhlIHBhcnNlciB3b3JraW5nLlxuICAgIC8vIEEgZnVsbCBpbXBsZW1lbnRhdGlvbiBpbnZvbHZlcyBzY3JpcHRzIGFuZCBldmVudHMgYW5kIHRoZSBldmVudCBsb29wLlxuXG4gICAgLy8gUmVtb3ZlIHRoZSBsaW5rIGZyb20gZG9jdW1lbnQgdG8gcGFyc2VyLlxuICAgIC8vIFRoaXMgaXMgaW5zdGVhZCBvZiBcInNldCB0aGUgaW5zZXJ0aW9uIHBvaW50IHRvIHVuZGVmaW5lZFwiLlxuICAgIC8vIEl0IG1lYW5zIHRoYXQgZG9jdW1lbnQud3JpdGUoKSBjYW4ndCB3cml0ZSBpbnRvIHRoZSBkb2MgYW55bW9yZS5cbiAgICBkZWxldGUgZG9jLl9wYXJzZXI7XG5cbiAgICBzdGFjay5lbGVtZW50cy5sZW5ndGggPSAwOyAvLyBwb3AgZXZlcnl0aGluZyBvZmZcblxuICAgIC8vIElmIHRoZXJlIGlzIGEgd2luZG93IG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGRvY3VtZW50XG4gICAgLy8gdGhlbiB0cmlnZ2VyIGFuIGxvYWQgZXZlbnQgb24gaXRcbiAgICBpZiAoZG9jLmRlZmF1bHRWaWV3KSB7XG4gICAgICBkb2MuZGVmYXVsdFZpZXcuZGlzcGF0Y2hFdmVudChuZXcgaW1wbC5FdmVudChcImxvYWRcIix7fSkpO1xuICAgIH1cblxuICB9XG5cbiAgLyoqKipcbiAgICogVG9rZW5pemVyIHN0YXRlc1xuICAgKi9cblxuICAvKipcbiAgICogVGhpcyBmaWxlIHdhcyBwYXJ0aWFsbHkgbWVjaGFuaWNhbGx5IGdlbmVyYXRlZCBmcm9tXG4gICAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3Rva2VuaXphdGlvbi5odG1sXG4gICAqXG4gICAqIEFmdGVyIG1lY2hhbmljYWwgY29udmVyc2lvbiwgaXQgd2FzIGZ1cnRoZXIgY29udmVydGVkIGZyb21cbiAgICogcHJvc2UgdG8gSlMgYnkgaGFuZCwgYnV0IHRoZSBpbnRlbnQgaXMgdGhhdCBpdCBpcyBhIHZlcnlcbiAgICogZmFpdGhmdWwgcmVuZGVyaW5nIG9mIHRoZSBIVE1MIHRva2VuaXphdGlvbiBzcGVjIGluXG4gICAqIEphdmFTY3JpcHQuXG4gICAqXG4gICAqIEl0IGlzIG5vdCBhIGdvYWwgb2YgdGhpcyB0b2tlbml6ZXIgdG8gZGV0ZWN0IG9yIHJlcG9ydFxuICAgKiBwYXJzZSBlcnJvcnMuXG4gICAqXG4gICAqIFhYWCBUaGUgdG9rZW5pemVyIGlzIHN1cHBvc2VkIHRvIHdvcmsgd2l0aCBzdHJhaWdodCBVVEYzMlxuICAgKiBjb2RlcG9pbnRzLiBCdXQgSSBkb24ndCB0aGluayBpdCBoYXMgYW55IGRlcGVuZGVuY2llcyBvblxuICAgKiBhbnkgY2hhcmFjdGVyIG91dHNpZGUgb2YgdGhlIEJNUCBzbyBJIHRoaW5rIGl0IGlzIHNhZmUgdG9cbiAgICogcGFzcyBpdCBVVEYxNiBjaGFyYWN0ZXJzLiBJIGRvbid0IHRoaW5rIGl0IHdpbGwgZXZlciBjaGFuZ2VcbiAgICogc3RhdGUgaW4gdGhlIG1pZGRsZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgKi9cblxuICAvKlxuICAgKiBFYWNoIHN0YXRlIGlzIHJlcHJlc2VudGVkIGJ5IGEgZnVuY3Rpb24uICBGb3IgbW9zdCBzdGF0ZXMsIHRoZVxuICAgKiBzY2FubmVyIHNpbXBseSBwYXNzZXMgdGhlIG5leHQgY2hhcmFjdGVyIChhcyBhbiBpbnRlZ2VyXG4gICAqIGNvZGVwb2ludCkgdG8gdGhlIGN1cnJlbnQgc3RhdGUgZnVuY3Rpb24gYW5kIGF1dG9tYXRpY2FsbHlcbiAgICogY29uc3VtZXMgdGhlIGNoYXJhY3Rlci4gIElmIHRoZSBzdGF0ZSBmdW5jdGlvbiBjYW4ndCBwcm9jZXNzXG4gICAqIHRoZSBjaGFyYWN0ZXIgaXQgY2FuIGNhbGwgcHVzaGJhY2soKSB0byBwdXNoIGl0IGJhY2sgdG8gdGhlXG4gICAqIHNjYW5uZXIuXG4gICAqXG4gICAqIFNvbWUgc3RhdGVzIHJlcXVpcmUgbG9va2FoZWFkLCB0aG91Z2guICBJZiBhIHN0YXRlIGZ1bmN0aW9uIGhhc1xuICAgKiBhIGxvb2thaGVhZCBwcm9wZXJ0eSwgdGhlbiBpdCBpcyBpbnZva2VkIGRpZmZlcmVudGx5LiAgSW4gdGhpc1xuICAgKiBjYXNlLCB0aGUgc2Nhbm5lciBpbnZva2VzIHRoZSBmdW5jdGlvbiB3aXRoIDMgYXJndW1lbnRzOiAxKSB0aGVcbiAgICogbmV4dCBjb2RlcG9pbnQgMikgYSBzdHJpbmcgb2YgbG9va2FoZWFkIHRleHQgMykgYSBib29sZWFuIHRoYXRcbiAgICogaXMgdHJ1ZSBpZiB0aGUgbG9va2FoZWFkIGdvZXMgYWxsIHRoZSB3YXkgdG8gdGhlIEVPRi4gKFhYWFxuICAgKiBhY3R1YWxseSBtYXliZSB0aGlzIHRoaXJkIGlzIG5vdCBuZWNlc3NhcnkuLi4gdGhlIGxvb2thaGVhZFxuICAgKiBjb3VsZCBqdXN0IGluY2x1ZGUgXFx1RkZGRj8pXG4gICAqXG4gICAqIElmIHRoZSBsb29rYWhlYWQgcHJvcGVydHkgb2YgYSBzdGF0ZSBmdW5jdGlvbiBpcyBhbiBpbnRlZ2VyLCBpdFxuICAgKiBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHJlcXVpcmVkLiBJZiBpdCBpcyBhIHN0cmluZyxcbiAgICogdGhlbiB0aGUgc2Nhbm5lciB3aWxsIHNjYW4gZm9yIHRoYXQgc3RyaW5nIGFuZCByZXR1cm4gYWxsXG4gICAqIGNoYXJhY3RlcnMgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGF0IHNlcXVlbmNlLCBvciB1cCB0byBFT0YuICBJZlxuICAgKiB0aGUgbG9va2FoZWFkIHByb3BlcnR5IGlzIGEgcmVnZXhwLCB0aGVuIHRoZSBzY2FubmVyIHdpbGwgbWF0Y2hcbiAgICogdGhlIHJlZ2V4cCBhdCB0aGUgY3VycmVudCBwb2ludCBhbmQgcmV0dXJuIHRoZSBtYXRjaGluZyBzdHJpbmcuXG4gICAqXG4gICAqIFN0YXRlcyB0aGF0IHJlcXVpcmUgbG9va2FoZWFkIGFyZSByZXNwb25zaWJsZSBmb3IgZXhwbGljaXRseVxuICAgKiBjb25zdW1pbmcgdGhlIGNoYXJhY3RlcnMgdGhleSBwcm9jZXNzLiBUaGV5IGRvIHRoaXMgYnlcbiAgICogaW5jcmVtZW50aW5nIG5leHRjaGFyIGJ5IHRoZSBudW1iZXIgb2YgcHJvY2Vzc2VkIGNoYXJhY3RlcnMuXG4gICAqL1xuICBmdW5jdGlvbiByZWNvbnN1bWUoYywgbmV3X3N0YXRlKSB7XG4gICAgdG9rZW5pemVyID0gbmV3X3N0YXRlO1xuICAgIG5leHRjaGFyLS07IC8vIHB1c2hiYWNrXG4gIH1cblxuICBmdW5jdGlvbiBkYXRhX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDI2OiAvLyBBTVBFUlNBTkRcbiAgICAgIHJldHVybl9zdGF0ZSA9IGRhdGFfc3RhdGU7XG4gICAgICB0b2tlbml6ZXIgPSBjaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICBpZiAoZW1pdFNpbXBsZVRhZygpKSAvLyBTaG9ydGN1dCBmb3IgPHA+LCA8ZGw+LCA8L2Rpdj4gZXRjLlxuICAgICAgICBicmVhaztcbiAgICAgIHRva2VuaXplciA9IHRhZ19vcGVuX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIC8vIFVzdWFsbHkgbnVsbCBjaGFyYWN0ZXJzIGVtaXR0ZWQgYnkgdGhlIHRva2VuaXplciB3aWxsIGJlXG4gICAgICAvLyBpZ25vcmVkIGJ5IHRoZSB0cmVlIGJ1aWxkZXIsIGJ1dCBzb21ldGltZXMgdGhleSdsbCBiZVxuICAgICAgLy8gY29udmVydGVkIHRvIFxcdUZGRkQuICBJIGRvbid0IHdhbnQgdG8gaGF2ZSB0aGUgc2VhcmNoIGV2ZXJ5XG4gICAgICAvLyBzdHJpbmcgZW1pdHRlZCB0byByZXBsYWNlIE5VTHMsIHNvIEknbGwgc2V0IGEgZmxhZ1xuICAgICAgLy8gaWYgSSd2ZSBlbWl0dGVkIGEgTlVMLlxuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgdGV4dEluY2x1ZGVzTlVMID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEluc3RlYWQgb2YganVzdCBwdXNoaW5nIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgdGhlblxuICAgICAgLy8gY29taW5nIGJhY2sgdG8gdGhlIHZlcnkgc2FtZSBwbGFjZSwgbG9va2FoZWFkIGFuZFxuICAgICAgLy8gZW1pdCBldmVyeXRoaW5nIHdlIGNhbiBhdCBvbmNlLlxuICAgICAgLypqc2hpbnQgLVcwMzAgKi9cbiAgICAgIGVtaXRDaGFyc1doaWxlKERBVEFURVhUKSB8fCB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByY2RhdGFfc3RhdGUoYykge1xuICAgIC8vIFNhdmUgdGhlIG9wZW4gdGFnIHNvIHdlIGNhbiBmaW5kIGEgbWF0Y2hpbmcgY2xvc2UgdGFnXG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyNjogLy8gQU1QRVJTQU5EXG4gICAgICByZXR1cm5fc3RhdGUgPSByY2RhdGFfc3RhdGU7XG4gICAgICB0b2tlbml6ZXIgPSBjaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSByY2RhdGFfbGVzc190aGFuX3NpZ25fc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgdGV4dHJ1bi5wdXNoKDB4RkZGRCk7IC8vIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuICAgICAgdGV4dEluY2x1ZGVzTlVMID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRleHRydW4ucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJhd3RleHRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSByYXd0ZXh0X2xlc3NfdGhhbl9zaWduX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8qanNoaW50IC1XMDMwICovXG4gICAgICBlbWl0Q2hhcnNXaGlsZShSQVdURVhUKSB8fCB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2xlc3NfdGhhbl9zaWduX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8qanNoaW50IC1XMDMwICovXG4gICAgICBlbWl0Q2hhcnNXaGlsZShSQVdURVhUKSB8fCB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFpbnRleHRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8qanNoaW50IC1XMDMwICovXG4gICAgICBlbWl0Q2hhcnNXaGlsZShQTEFJTlRFWFQpIHx8IHRleHRydW4ucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRhZ19vcGVuX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDIxOiAvLyBFWENMQU1BVElPTiBNQVJLXG4gICAgICB0b2tlbml6ZXIgPSBtYXJrdXBfZGVjbGFyYXRpb25fb3Blbl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXG4gICAgICB0b2tlbml6ZXIgPSBlbmRfdGFnX29wZW5fc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxuICAgIGNhc2UgMHgwMDYyOmNhc2UgMHgwMDYzOmNhc2UgMHgwMDY0OmNhc2UgMHgwMDY1OmNhc2UgMHgwMDY2OlxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxuICAgIGNhc2UgMHgwMDcxOmNhc2UgMHgwMDcyOmNhc2UgMHgwMDczOmNhc2UgMHgwMDc0OmNhc2UgMHgwMDc1OlxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxuICAgICAgYmVnaW5UYWdOYW1lKCk7XG4gICAgICByZWNvbnN1bWUoYywgdGFnX25hbWVfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0Y6IC8vIFFVRVNUSU9OIE1BUktcbiAgICAgIHJlY29uc3VtZShjLCBib2d1c19jb21tZW50X3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHJlY29uc3VtZShjLCBkYXRhX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZF90YWdfb3Blbl9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxuICAgIGNhc2UgMHgwMDYyOmNhc2UgMHgwMDYzOmNhc2UgMHgwMDY0OmNhc2UgMHgwMDY1OmNhc2UgMHgwMDY2OlxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxuICAgIGNhc2UgMHgwMDcxOmNhc2UgMHgwMDcyOmNhc2UgMHgwMDczOmNhc2UgMHgwMDc0OmNhc2UgMHgwMDc1OlxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxuICAgICAgYmVnaW5FbmRUYWdOYW1lKCk7XG4gICAgICByZWNvbnN1bWUoYywgdGFnX25hbWVfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkYpOyAvLyBTT0xJRFVTXG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVjb25zdW1lKGMsIGJvZ3VzX2NvbW1lbnRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGFnX25hbWVfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xuICAgICAgdG9rZW5pemVyID0gc2VsZl9jbG9zaW5nX3N0YXJ0X3RhZ19zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXRUYWcoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjICsgMHgwMDIwKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICB0YWduYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEIC8qIFJFUExBQ0VNRU5UIENIQVJBQ1RFUiAqLyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0YWduYW1lYnVmICs9IGdldE1hdGNoaW5nQ2hhcnMoVEFHTkFNRSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByY2RhdGFfbGVzc190aGFuX3NpZ25fc3RhdGUoYykge1xuICAgIC8qIGlkZW50aWNhbCB0byB0aGUgUkFXVEVYVCBsZXNzLXRoYW4gc2lnbiBzdGF0ZSwgZXhjZXB0IHMvUkFXVEVYVC9SQ0RBVEEvZyAqL1xuICAgIGlmIChjID09PSAweDAwMkYpIHsgIC8vIFNPTElEVVNcbiAgICAgIGJlZ2luVGVtcEJ1ZigpO1xuICAgICAgdG9rZW5pemVyID0gcmNkYXRhX2VuZF90YWdfb3Blbl9zdGF0ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHJlY29uc3VtZShjLCByY2RhdGFfc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJjZGF0YV9lbmRfdGFnX29wZW5fc3RhdGUoYykge1xuICAgIC8qIGlkZW50aWNhbCB0byB0aGUgUkFXVEVYVCAoYW5kIFNjcmlwdCBkYXRhKSBlbmQgdGFnIG9wZW4gc3RhdGUsIGV4Y2VwdCBzL1JBV1RFWFQvUkNEQVRBL2cgKi9cbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XG4gICAgY2FzZSAweDAwNjc6Y2FzZSAweDAwNjg6Y2FzZSAweDAwNjk6Y2FzZSAweDAwNkE6Y2FzZSAweDAwNkI6XG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XG4gICAgY2FzZSAweDAwNzY6Y2FzZSAweDAwNzc6Y2FzZSAweDAwNzg6Y2FzZSAweDAwNzk6Y2FzZSAweDAwN0E6XG4gICAgICBiZWdpbkVuZFRhZ05hbWUoKTtcbiAgICAgIHJlY29uc3VtZShjLCByY2RhdGFfZW5kX3RhZ19uYW1lX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkYpOyAvLyBTT0xJRFVTXG4gICAgICByZWNvbnN1bWUoYywgcmNkYXRhX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJjZGF0YV9lbmRfdGFnX25hbWVfc3RhdGUoYykge1xuICAgIC8qIGlkZW50aWNhbCB0byB0aGUgUkFXVEVYVCAoYW5kIFNjcmlwdCBkYXRhKSBlbmQgdGFnIG5hbWUgc3RhdGUsIGV4Y2VwdCBzL1JBV1RFWFQvUkNEQVRBL2cgKi9cbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgaWYgKGFwcHJvcHJpYXRlRW5kVGFnKHRhZ25hbWVidWYpKSB7XG4gICAgICAgIHRva2VuaXplciA9IGJlZm9yZV9hdHRyaWJ1dGVfbmFtZV9zdGF0ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xuICAgICAgICB0b2tlbml6ZXIgPSBzZWxmX2Nsb3Npbmdfc3RhcnRfdGFnX3N0YXRlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xuICAgICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgICBlbWl0VGFnKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcblxuICAgICAgdGFnbmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgKyAweDAwMjApO1xuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcblxuICAgICAgdGFnbmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBkb24ndCByZXR1cm4gaW4gb25lIG9mIHRoZSBjYXNlcyBhYm92ZSwgdGhlbiB0aGlzIHdhcyBub3RcbiAgICAvLyBhbiBhcHByb3ByaWF0ZWx5IG1hdGNoaW5nIGNsb3NlIHRhZywgc28gYmFjayBvdXQgYnkgZW1pdHRpbmcgYWxsXG4gICAgLy8gdGhlIGNoYXJhY3RlcnMgYXMgdGV4dFxuICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgIHRleHRydW4ucHVzaCgweDAwMkYpOyAvLyBTT0xJRFVTXG4gICAgcHVzaEFsbCh0ZXh0cnVuLCB0ZW1wYnVmKTtcbiAgICByZWNvbnN1bWUoYywgcmNkYXRhX3N0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhd3RleHRfbGVzc190aGFuX3NpZ25fc3RhdGUoYykge1xuICAgIC8qIGlkZW50aWNhbCB0byB0aGUgUkNEQVRBIGxlc3MtdGhhbiBzaWduIHN0YXRlLCBleGNlcHQgcy9SQ0RBVEEvUkFXVEVYVC9nXG4gICAgICovXG4gICAgaWYgKGMgPT09IDB4MDAyRikgeyAvLyBTT0xJRFVTXG4gICAgICBiZWdpblRlbXBCdWYoKTtcbiAgICAgIHRva2VuaXplciA9IHJhd3RleHRfZW5kX3RhZ19vcGVuX3N0YXRlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgcmVjb25zdW1lKGMsIHJhd3RleHRfc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJhd3RleHRfZW5kX3RhZ19vcGVuX3N0YXRlKGMpIHtcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJDREFUQSAoYW5kIFNjcmlwdCBkYXRhKSBlbmQgdGFnIG9wZW4gc3RhdGUsIGV4Y2VwdCBzL1JDREFUQS9SQVdURVhUL2cgKi9cbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XG4gICAgY2FzZSAweDAwNjc6Y2FzZSAweDAwNjg6Y2FzZSAweDAwNjk6Y2FzZSAweDAwNkE6Y2FzZSAweDAwNkI6XG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XG4gICAgY2FzZSAweDAwNzY6Y2FzZSAweDAwNzc6Y2FzZSAweDAwNzg6Y2FzZSAweDAwNzk6Y2FzZSAweDAwN0E6XG4gICAgICBiZWdpbkVuZFRhZ05hbWUoKTtcbiAgICAgIHJlY29uc3VtZShjLCByYXd0ZXh0X2VuZF90YWdfbmFtZV9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJGKTsgLy8gU09MSURVU1xuICAgICAgcmVjb25zdW1lKGMsIHJhd3RleHRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmF3dGV4dF9lbmRfdGFnX25hbWVfc3RhdGUoYykge1xuICAgIC8qIGlkZW50aWNhbCB0byB0aGUgUkNEQVRBIChhbmQgU2NyaXB0IGRhdGEpIGVuZCB0YWcgbmFtZSBzdGF0ZSwgZXhjZXB0IHMvUkNEQVRBL1JBV1RFWFQvZyAqL1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICBpZiAoYXBwcm9wcmlhdGVFbmRUYWcodGFnbmFtZWJ1ZikpIHtcbiAgICAgICAgdG9rZW5pemVyID0gYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xuICAgICAgaWYgKGFwcHJvcHJpYXRlRW5kVGFnKHRhZ25hbWVidWYpKSB7XG4gICAgICAgIHRva2VuaXplciA9IHNlbGZfY2xvc2luZ19zdGFydF90YWdfc3RhdGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgaWYgKGFwcHJvcHJpYXRlRW5kVGFnKHRhZ25hbWVidWYpKSB7XG4gICAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICAgIGVtaXRUYWcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxuICAgICAgdGFnbmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgKyAweDAwMjApO1xuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgIHRlbXBidWYucHVzaChjKTtcbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgcmV0dXJuIGluIG9uZSBvZiB0aGUgY2FzZXMgYWJvdmUsIHRoZW4gdGhpcyB3YXMgbm90XG4gICAgLy8gYW4gYXBwcm9wcmlhdGVseSBtYXRjaGluZyBjbG9zZSB0YWcsIHNvIGJhY2sgb3V0IGJ5IGVtaXR0aW5nIGFsbFxuICAgIC8vIHRoZSBjaGFyYWN0ZXJzIGFzIHRleHRcbiAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICB0ZXh0cnVuLnB1c2goMHgwMDJGKTsgLy8gU09MSURVU1xuICAgIHB1c2hBbGwodGV4dHJ1bix0ZW1wYnVmKTtcbiAgICByZWNvbnN1bWUoYywgcmF3dGV4dF9zdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9sZXNzX3RoYW5fc2lnbl9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xuICAgICAgYmVnaW5UZW1wQnVmKCk7XG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9lbmRfdGFnX29wZW5fc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyMTogLy8gRVhDTEFNQVRJT04gTUFSS1xuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlX3N0YXJ0X3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDIxKTsgLy8gRVhDTEFNQVRJT04gTUFSS1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2VuZF90YWdfb3Blbl9zdGF0ZShjKSB7XG4gICAgLyogaWRlbnRpY2FsIHRvIHRoZSBSQ0RBVEEgKGFuZCBSQVdURVhUKSBlbmQgdGFnIG9wZW4gc3RhdGUsIGV4Y2VwdCBzL1JDREFUQS9TY3JpcHQgZGF0YS9nICovXG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxuICAgIGNhc2UgMHgwMDYyOmNhc2UgMHgwMDYzOmNhc2UgMHgwMDY0OmNhc2UgMHgwMDY1OmNhc2UgMHgwMDY2OlxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxuICAgIGNhc2UgMHgwMDcxOmNhc2UgMHgwMDcyOmNhc2UgMHgwMDczOmNhc2UgMHgwMDc0OmNhc2UgMHgwMDc1OlxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxuICAgICAgYmVnaW5FbmRUYWdOYW1lKCk7XG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfZW5kX3RhZ19uYW1lX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDNDKTsgLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkYpOyAvLyBTT0xJRFVTXG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZW5kX3RhZ19uYW1lX3N0YXRlKGMpIHtcbiAgICAvKiBpZGVudGljYWwgdG8gdGhlIFJDREFUQSAoYW5kIFJBV1RFWFQpIGVuZCB0YWcgbmFtZSBzdGF0ZSwgZXhjZXB0IHMvUkNEQVRBL1NjcmlwdCBkYXRhL2cgKi9cbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgaWYgKGFwcHJvcHJpYXRlRW5kVGFnKHRhZ25hbWVidWYpKSB7XG4gICAgICAgIHRva2VuaXplciA9IGJlZm9yZV9hdHRyaWJ1dGVfbmFtZV9zdGF0ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xuICAgICAgICB0b2tlbml6ZXIgPSBzZWxmX2Nsb3Npbmdfc3RhcnRfdGFnX3N0YXRlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xuICAgICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgICBlbWl0VGFnKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcblxuICAgICAgdGFnbmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgKyAweDAwMjApO1xuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcblxuICAgICAgdGFnbmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBkb24ndCByZXR1cm4gaW4gb25lIG9mIHRoZSBjYXNlcyBhYm92ZSwgdGhlbiB0aGlzIHdhcyBub3RcbiAgICAvLyBhbiBhcHByb3ByaWF0ZWx5IG1hdGNoaW5nIGNsb3NlIHRhZywgc28gYmFjayBvdXQgYnkgZW1pdHRpbmcgYWxsXG4gICAgLy8gdGhlIGNoYXJhY3RlcnMgYXMgdGV4dFxuICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgIHRleHRydW4ucHVzaCgweDAwMkYpOyAvLyBTT0xJRFVTXG4gICAgcHVzaEFsbCh0ZXh0cnVuLHRlbXBidWYpO1xuICAgIHJlY29uc3VtZShjLCBzY3JpcHRfZGF0YV9zdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9lc2NhcGVfc3RhcnRfc3RhdGUoYykge1xuICAgIGlmIChjID09PSAweDAwMkQpIHsgLy8gSFlQSEVOLU1JTlVTXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9lc2NhcGVfc3RhcnRfZGFzaF9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkQpOyAvLyBIWVBIRU4tTUlOVVNcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2VzY2FwZV9zdGFydF9kYXNoX3N0YXRlKGMpIHtcbiAgICBpZiAoYyA9PT0gMHgwMDJEKSB7IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9kYXNoX2Rhc2hfc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJEKTsgLy8gSFlQSEVOLU1JTlVTXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX3N0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9lc2NhcGVkX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDJEOiAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfZGFzaF9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwMkQpOyAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9sZXNzX3RoYW5fc2lnbl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICB0ZXh0cnVuLnB1c2goMHhGRkZEKTsgLy8gUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9lc2NhcGVkX2Rhc2hfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9kYXNoX2Rhc2hfc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJEKTsgLy8gSFlQSEVOLU1JTlVTXG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfbGVzc190aGFuX3NpZ25fc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9lc2NhcGVkX2Rhc2hfZGFzaF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDJEKTsgLy8gSFlQSEVOLU1JTlVTXG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfbGVzc190aGFuX3NpZ25fc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzRSk7IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9lc2NhcGVkX2xlc3NfdGhhbl9zaWduX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXG4gICAgICBiZWdpblRlbXBCdWYoKTtcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2VzY2FwZWRfZW5kX3RhZ19vcGVuX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcbiAgICAgIGJlZ2luVGVtcEJ1ZigpO1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZV9zdGFydF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9lc2NhcGVkX2VuZF90YWdfb3Blbl9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDA0MTogIC8vIFtBLVpdXG4gICAgY2FzZSAweDAwNDI6Y2FzZSAweDAwNDM6Y2FzZSAweDAwNDQ6Y2FzZSAweDAwNDU6Y2FzZSAweDAwNDY6XG4gICAgY2FzZSAweDAwNDc6Y2FzZSAweDAwNDg6Y2FzZSAweDAwNDk6Y2FzZSAweDAwNEE6Y2FzZSAweDAwNEI6XG4gICAgY2FzZSAweDAwNEM6Y2FzZSAweDAwNEQ6Y2FzZSAweDAwNEU6Y2FzZSAweDAwNEY6Y2FzZSAweDAwNTA6XG4gICAgY2FzZSAweDAwNTE6Y2FzZSAweDAwNTI6Y2FzZSAweDAwNTM6Y2FzZSAweDAwNTQ6Y2FzZSAweDAwNTU6XG4gICAgY2FzZSAweDAwNTY6Y2FzZSAweDAwNTc6Y2FzZSAweDAwNTg6Y2FzZSAweDAwNTk6Y2FzZSAweDAwNUE6XG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxuICAgIGNhc2UgMHgwMDYyOmNhc2UgMHgwMDYzOmNhc2UgMHgwMDY0OmNhc2UgMHgwMDY1OmNhc2UgMHgwMDY2OlxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxuICAgIGNhc2UgMHgwMDcxOmNhc2UgMHgwMDcyOmNhc2UgMHgwMDczOmNhc2UgMHgwMDc0OmNhc2UgMHgwMDc1OlxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxuICAgICAgYmVnaW5FbmRUYWdOYW1lKCk7XG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfZXNjYXBlZF9lbmRfdGFnX25hbWVfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRik7IC8vIFNPTElEVVNcbiAgICAgIHJlY29uc3VtZShjLCBzY3JpcHRfZGF0YV9lc2NhcGVkX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2VzY2FwZWRfZW5kX3RhZ19uYW1lX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgaWYgKGFwcHJvcHJpYXRlRW5kVGFnKHRhZ25hbWVidWYpKSB7XG4gICAgICAgIHRva2VuaXplciA9IGJlZm9yZV9hdHRyaWJ1dGVfbmFtZV9zdGF0ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMkY6IC8vIFNPTElEVVNcbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xuICAgICAgICB0b2tlbml6ZXIgPSBzZWxmX2Nsb3Npbmdfc3RhcnRfdGFnX3N0YXRlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGlmIChhcHByb3ByaWF0ZUVuZFRhZyh0YWduYW1lYnVmKSkge1xuICAgICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgICBlbWl0VGFnKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcbiAgICAgIHRhZ25hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjICsgMHgwMDIwKTtcbiAgICAgIHRlbXBidWYucHVzaChjKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDB4MDA2MTogIC8vIFthLXpdXG4gICAgY2FzZSAweDAwNjI6Y2FzZSAweDAwNjM6Y2FzZSAweDAwNjQ6Y2FzZSAweDAwNjU6Y2FzZSAweDAwNjY6XG4gICAgY2FzZSAweDAwNjc6Y2FzZSAweDAwNjg6Y2FzZSAweDAwNjk6Y2FzZSAweDAwNkE6Y2FzZSAweDAwNkI6XG4gICAgY2FzZSAweDAwNkM6Y2FzZSAweDAwNkQ6Y2FzZSAweDAwNkU6Y2FzZSAweDAwNkY6Y2FzZSAweDAwNzA6XG4gICAgY2FzZSAweDAwNzE6Y2FzZSAweDAwNzI6Y2FzZSAweDAwNzM6Y2FzZSAweDAwNzQ6Y2FzZSAweDAwNzU6XG4gICAgY2FzZSAweDAwNzY6Y2FzZSAweDAwNzc6Y2FzZSAweDAwNzg6Y2FzZSAweDAwNzk6Y2FzZSAweDAwN0E6XG4gICAgICB0YWduYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICB0ZW1wYnVmLnB1c2goYyk7XG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFdlIGdldCBoZXJlIGluIHRoZSBkZWZhdWx0IGNhc2UsIGFuZCBpZiB0aGUgY2xvc2luZyB0YWduYW1lXG4gICAgLy8gaXMgbm90IGFuIGFwcHJvcHJpYXRlIHRhZ25hbWUuXG4gICAgdGV4dHJ1bi5wdXNoKDB4MDAzQyk7IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgdGV4dHJ1bi5wdXNoKDB4MDAyRik7IC8vIFNPTElEVVNcbiAgICBwdXNoQWxsKHRleHRydW4sdGVtcGJ1Zik7XG4gICAgcmVjb25zdW1lKGMsIHNjcmlwdF9kYXRhX2VzY2FwZWRfc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZV9zdGFydF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgaWYgKGJ1ZjJzdHIodGVtcGJ1ZikgPT09IFwic2NyaXB0XCIpIHtcbiAgICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfc3RhdGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZTtcbiAgICAgIH1cbiAgICAgIHRleHRydW4ucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcbiAgICAgIHRlbXBidWYucHVzaChjICsgMHgwMDIwKTtcbiAgICAgIHRleHRydW4ucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDYxOiAgLy8gW2Etel1cbiAgICBjYXNlIDB4MDA2MjpjYXNlIDB4MDA2MzpjYXNlIDB4MDA2NDpjYXNlIDB4MDA2NTpjYXNlIDB4MDA2NjpcbiAgICBjYXNlIDB4MDA2NzpjYXNlIDB4MDA2ODpjYXNlIDB4MDA2OTpjYXNlIDB4MDA2QTpjYXNlIDB4MDA2QjpcbiAgICBjYXNlIDB4MDA2QzpjYXNlIDB4MDA2RDpjYXNlIDB4MDA2RTpjYXNlIDB4MDA2RjpjYXNlIDB4MDA3MDpcbiAgICBjYXNlIDB4MDA3MTpjYXNlIDB4MDA3MjpjYXNlIDB4MDA3MzpjYXNlIDB4MDA3NDpjYXNlIDB4MDA3NTpcbiAgICBjYXNlIDB4MDA3NjpjYXNlIDB4MDA3NzpjYXNlIDB4MDA3ODpjYXNlIDB4MDA3OTpjYXNlIDB4MDA3QTpcbiAgICAgIHRlbXBidWYucHVzaChjKTtcbiAgICAgIHRleHRydW4ucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfZXNjYXBlZF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9kYXNoX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRCk7IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9sZXNzX3RoYW5fc2lnbl9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIHRleHRydW4ucHVzaCgweEZGRkQpOyAvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRleHRydW4ucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX2Rhc2hfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfZGFzaF9kYXNoX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRCk7IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9sZXNzX3RoYW5fc2lnbl9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4RkZGRCk7IC8vIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9kYXNoX2Rhc2hfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRCk7IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9sZXNzX3RoYW5fc2lnbl9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0MpOyAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9zdGF0ZTtcbiAgICAgIHRleHRydW4ucHVzaCgweDAwM0UpOyAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4RkZGRCk7IC8vIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdG9rZW5pemVyID0gc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfc3RhdGU7XG4gICAgICB0ZXh0cnVuLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9sZXNzX3RoYW5fc2lnbl9zdGF0ZShjKSB7XG4gICAgaWYgKGMgPT09IDB4MDAyRikgeyAvLyBTT0xJRFVTXG4gICAgICBiZWdpblRlbXBCdWYoKTtcbiAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVfZW5kX3N0YXRlO1xuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDAyRik7IC8vIFNPTElEVVNcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZWNvbnN1bWUoYywgc2NyaXB0X2RhdGFfZG91YmxlX2VzY2FwZWRfc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVfZW5kX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBpZiAoYnVmMnN0cih0ZW1wYnVmKSA9PT0gXCJzY3JpcHRcIikge1xuICAgICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9lc2NhcGVkX3N0YXRlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRva2VuaXplciA9IHNjcmlwdF9kYXRhX2RvdWJsZV9lc2NhcGVkX3N0YXRlO1xuICAgICAgfVxuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxuICAgICAgdGVtcGJ1Zi5wdXNoKGMgKyAweDAwMjApO1xuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwNjE6ICAvLyBbYS16XVxuICAgIGNhc2UgMHgwMDYyOmNhc2UgMHgwMDYzOmNhc2UgMHgwMDY0OmNhc2UgMHgwMDY1OmNhc2UgMHgwMDY2OlxuICAgIGNhc2UgMHgwMDY3OmNhc2UgMHgwMDY4OmNhc2UgMHgwMDY5OmNhc2UgMHgwMDZBOmNhc2UgMHgwMDZCOlxuICAgIGNhc2UgMHgwMDZDOmNhc2UgMHgwMDZEOmNhc2UgMHgwMDZFOmNhc2UgMHgwMDZGOmNhc2UgMHgwMDcwOlxuICAgIGNhc2UgMHgwMDcxOmNhc2UgMHgwMDcyOmNhc2UgMHgwMDczOmNhc2UgMHgwMDc0OmNhc2UgMHgwMDc1OlxuICAgIGNhc2UgMHgwMDc2OmNhc2UgMHgwMDc3OmNhc2UgMHgwMDc4OmNhc2UgMHgwMDc5OmNhc2UgMHgwMDdBOlxuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xuICAgICAgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBzY3JpcHRfZGF0YV9kb3VibGVfZXNjYXBlZF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICAvKiBJZ25vcmUgdGhlIGNoYXJhY3Rlci4gKi9cbiAgICAgIGJyZWFrO1xuICAgIC8vIEZvciBTT0xJRFVTLCBHUkVBVEVSLVRIQU4gU0lHTiwgYW5kIEVPRiwgc3BlYyBzYXlzIFwicmVjb25zdW1lIGluXG4gICAgLy8gdGhlIGFmdGVyIGF0dHJpYnV0ZSBuYW1lIHN0YXRlXCIsIGJ1dCBpbiBvdXIgaW1wbGVtZW50YXRpb24gdGhhdFxuICAgIC8vIHN0YXRlIGFsd2F5cyBoYXMgYW4gYWN0aXZlIGF0dHJpYnV0ZSBpbiBhdHRybmFtZWJ1Zi4gIEp1c3QgY2xvbmVcbiAgICAvLyB0aGUgcnVsZXMgaGVyZSwgd2l0aG91dCB0aGUgYWRkQXR0cmlidXRlIGJ1c2luZXNzLlxuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXG4gICAgICB0b2tlbml6ZXIgPSBzZWxmX2Nsb3Npbmdfc3RhcnRfdGFnX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdFRhZygpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRDogLy8gRVFVQUxTIFNJR05cbiAgICAgIGJlZ2luQXR0ck5hbWUoKTtcbiAgICAgIGF0dHJuYW1lYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICB0b2tlbml6ZXIgPSBhdHRyaWJ1dGVfbmFtZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoaGFuZGxlU2ltcGxlQXR0cmlidXRlKCkpIGJyZWFrO1xuICAgICAgYmVnaW5BdHRyTmFtZSgpO1xuICAgICAgcmVjb25zdW1lKGMsIGF0dHJpYnV0ZV9uYW1lX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJlZ2luQXR0ck5hbWUoKSBtdXN0IGhhdmUgYmVlbiBjYWxsZWQgYmVmb3JlIHRoaXMgcG9pbnRcbiAgLy8gVGhlcmUgaXMgYW4gYWN0aXZlIGF0dHJpYnV0ZSBpbiBhdHRybmFtZWJ1ZiAoYnV0IG5vdCBhdHRydmFsdWVidWYpXG4gIGZ1bmN0aW9uIGF0dHJpYnV0ZV9uYW1lX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICByZWNvbnN1bWUoYywgYWZ0ZXJfYXR0cmlidXRlX25hbWVfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0Q6IC8vIEVRVUFMUyBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX3ZhbHVlX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwNDE6ICAvLyBbQS1aXVxuICAgIGNhc2UgMHgwMDQyOmNhc2UgMHgwMDQzOmNhc2UgMHgwMDQ0OmNhc2UgMHgwMDQ1OmNhc2UgMHgwMDQ2OlxuICAgIGNhc2UgMHgwMDQ3OmNhc2UgMHgwMDQ4OmNhc2UgMHgwMDQ5OmNhc2UgMHgwMDRBOmNhc2UgMHgwMDRCOlxuICAgIGNhc2UgMHgwMDRDOmNhc2UgMHgwMDREOmNhc2UgMHgwMDRFOmNhc2UgMHgwMDRGOmNhc2UgMHgwMDUwOlxuICAgIGNhc2UgMHgwMDUxOmNhc2UgMHgwMDUyOmNhc2UgMHgwMDUzOmNhc2UgMHgwMDU0OmNhc2UgMHgwMDU1OlxuICAgIGNhc2UgMHgwMDU2OmNhc2UgMHgwMDU3OmNhc2UgMHgwMDU4OmNhc2UgMHgwMDU5OmNhc2UgMHgwMDVBOlxuICAgICAgYXR0cm5hbWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjICsgMHgwMDIwKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICBhdHRybmFtZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCAvKiBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi8pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjI6IC8vIFFVT1RBVElPTiBNQVJLXG4gICAgY2FzZSAweDAwMjc6IC8vIEFQT1NUUk9QSEVcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBkZWZhdWx0OlxuICAgICAgYXR0cm5hbWVidWYgKz0gZ2V0TWF0Y2hpbmdDaGFycyhBVFRSTkFNRSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBUaGVyZSBpcyBhbiBhY3RpdmUgYXR0cmlidXRlIGluIGF0dHJuYW1lYnVmLCBidXQgbm90IHlldCBpbiBhdHRydmFsdWVidWYuXG4gIGZ1bmN0aW9uIGFmdGVyX2F0dHJpYnV0ZV9uYW1lX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgLyogSWdub3JlIHRoZSBjaGFyYWN0ZXIuICovXG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyRjogLy8gU09MSURVU1xuICAgICAgLy8gS2VlcCBpbiBzeW5jIHdpdGggYmVmb3JlX2F0dHJpYnV0ZV9uYW1lX3N0YXRlLlxuICAgICAgYWRkQXR0cmlidXRlKGF0dHJuYW1lYnVmKTtcbiAgICAgIHRva2VuaXplciA9IHNlbGZfY2xvc2luZ19zdGFydF90YWdfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRDogLy8gRVFVQUxTIFNJR05cbiAgICAgIHRva2VuaXplciA9IGJlZm9yZV9hdHRyaWJ1dGVfdmFsdWVfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIC8vIEtlZXAgaW4gc3luYyB3aXRoIGJlZm9yZV9hdHRyaWJ1dGVfbmFtZV9zdGF0ZS5cbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBhZGRBdHRyaWJ1dGUoYXR0cm5hbWVidWYpO1xuICAgICAgZW1pdFRhZygpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICAvLyBLZWVwIGluIHN5bmMgd2l0aCBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGUuXG4gICAgICBhZGRBdHRyaWJ1dGUoYXR0cm5hbWVidWYpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGFkZEF0dHJpYnV0ZShhdHRybmFtZWJ1Zik7XG4gICAgICBiZWdpbkF0dHJOYW1lKCk7XG4gICAgICByZWNvbnN1bWUoYywgYXR0cmlidXRlX25hbWVfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVmb3JlX2F0dHJpYnV0ZV92YWx1ZV9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICAgIC8qIElnbm9yZSB0aGUgY2hhcmFjdGVyLiAqL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjI6IC8vIFFVT1RBVElPTiBNQVJLXG4gICAgICBiZWdpbkF0dHJWYWx1ZSgpO1xuICAgICAgdG9rZW5pemVyID0gYXR0cmlidXRlX3ZhbHVlX2RvdWJsZV9xdW90ZWRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyNzogLy8gQVBPU1RST1BIRVxuICAgICAgYmVnaW5BdHRyVmFsdWUoKTtcbiAgICAgIHRva2VuaXplciA9IGF0dHJpYnV0ZV92YWx1ZV9zaW5nbGVfcXVvdGVkX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIGJlZ2luQXR0clZhbHVlKCk7XG4gICAgICByZWNvbnN1bWUoYywgYXR0cmlidXRlX3ZhbHVlX3VucXVvdGVkX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJpYnV0ZV92YWx1ZV9kb3VibGVfcXVvdGVkX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xuICAgICAgYWRkQXR0cmlidXRlKGF0dHJuYW1lYnVmLCBhdHRydmFsdWVidWYpO1xuICAgICAgdG9rZW5pemVyID0gYWZ0ZXJfYXR0cmlidXRlX3ZhbHVlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDI2OiAvLyBBTVBFUlNBTkRcbiAgICAgIHJldHVybl9zdGF0ZSA9IGF0dHJpYnV0ZV92YWx1ZV9kb3VibGVfcXVvdGVkX3N0YXRlO1xuICAgICAgdG9rZW5pemVyID0gY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICBhdHRydmFsdWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMEE6IC8vIExGXG4gICAgICAvLyB0aGlzIGNvdWxkIGJlIGEgY29udmVydGVkIFxcciwgc28gZG9uJ3QgdXNlIGdldE1hdGNoaW5nQ2hhcnNcbiAgICAgIGF0dHJ2YWx1ZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGF0dHJ2YWx1ZWJ1ZiArPSBnZXRNYXRjaGluZ0NoYXJzKERCTFFVT1RFQVRUUlZBTCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyaWJ1dGVfdmFsdWVfc2luZ2xlX3F1b3RlZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyNzogLy8gQVBPU1RST1BIRVxuICAgICAgYWRkQXR0cmlidXRlKGF0dHJuYW1lYnVmLCBhdHRydmFsdWVidWYpO1xuICAgICAgdG9rZW5pemVyID0gYWZ0ZXJfYXR0cmlidXRlX3ZhbHVlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDI2OiAvLyBBTVBFUlNBTkRcbiAgICAgIHJldHVybl9zdGF0ZSA9IGF0dHJpYnV0ZV92YWx1ZV9zaW5nbGVfcXVvdGVkX3N0YXRlO1xuICAgICAgdG9rZW5pemVyID0gY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICBhdHRydmFsdWVidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMEE6IC8vIExGXG4gICAgICAvLyB0aGlzIGNvdWxkIGJlIGEgY29udmVydGVkIFxcciwgc28gZG9uJ3QgdXNlIGdldE1hdGNoaW5nQ2hhcnNcbiAgICAgIGF0dHJ2YWx1ZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGF0dHJ2YWx1ZWJ1ZiArPSBnZXRNYXRjaGluZ0NoYXJzKFNJTkdMRVFVT1RFQVRUUlZBTCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyaWJ1dGVfdmFsdWVfdW5xdW90ZWRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICBhZGRBdHRyaWJ1dGUoYXR0cm5hbWVidWYsIGF0dHJ2YWx1ZWJ1Zik7XG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyNjogLy8gQU1QRVJTQU5EXG4gICAgICByZXR1cm5fc3RhdGUgPSBhdHRyaWJ1dGVfdmFsdWVfdW5xdW90ZWRfc3RhdGU7XG4gICAgICB0b2tlbml6ZXIgPSBjaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBhZGRBdHRyaWJ1dGUoYXR0cm5hbWVidWYsIGF0dHJ2YWx1ZWJ1Zik7XG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdFRhZygpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIGF0dHJ2YWx1ZWJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCAvKiBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi8pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBuZXh0Y2hhci0tOyAvLyBwdXNoYmFja1xuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgY2FzZSAweDAwM0Q6IC8vIEVRVUFMUyBTSUdOXG4gICAgY2FzZSAweDAwNjA6IC8vIEdSQVZFIEFDQ0VOVFxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICBhdHRydmFsdWVidWYgKz0gZ2V0TWF0Y2hpbmdDaGFycyhVTlFVT1RFREFUVFJWQUwpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJfYXR0cmlidXRlX3ZhbHVlX3F1b3RlZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICAgIHRva2VuaXplciA9IGJlZm9yZV9hdHRyaWJ1dGVfbmFtZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDJGOiAvLyBTT0xJRFVTXG4gICAgICB0b2tlbml6ZXIgPSBzZWxmX2Nsb3Npbmdfc3RhcnRfdGFnX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdFRhZygpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVjb25zdW1lKGMsIGJlZm9yZV9hdHRyaWJ1dGVfbmFtZV9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWxmX2Nsb3Npbmdfc3RhcnRfdGFnX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgLy8gU2V0IHRoZSA8aT5zZWxmLWNsb3NpbmcgZmxhZzwvaT4gb2YgdGhlIGN1cnJlbnQgdGFnIHRva2VuLlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXRTZWxmQ2xvc2luZ1RhZyh0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBiZWZvcmVfYXR0cmlidXRlX25hbWVfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYm9ndXNfY29tbWVudF9zdGF0ZShjLCBsb29rYWhlYWQsIGVvZikge1xuICAgIHZhciBsZW4gPSBsb29rYWhlYWQubGVuZ3RoO1xuXG4gICAgaWYgKGVvZikge1xuICAgICAgbmV4dGNoYXIgKz0gbGVuLTE7IC8vIGRvbid0IGNvbnN1bWUgdGhlIGVvZlxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5leHRjaGFyICs9IGxlbjtcbiAgICB9XG5cbiAgICB2YXIgY29tbWVudCA9IGxvb2thaGVhZC5zdWJzdHJpbmcoMCwgbGVuLTEpO1xuXG4gICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZSgvXFx1MDAwMC9nLFwiXFx1RkZGRFwiKTtcbiAgICBjb21tZW50ID0gY29tbWVudC5yZXBsYWNlKC9cXHUwMDBEXFx1MDAwQS9nLFwiXFx1MDAwQVwiKTtcbiAgICBjb21tZW50ID0gY29tbWVudC5yZXBsYWNlKC9cXHUwMDBEL2csXCJcXHUwMDBBXCIpO1xuXG4gICAgaW5zZXJ0VG9rZW4oQ09NTUVOVCwgY29tbWVudCk7XG4gICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgfVxuICBib2d1c19jb21tZW50X3N0YXRlLmxvb2thaGVhZCA9IFwiPlwiO1xuXG4gIGZ1bmN0aW9uIG1hcmt1cF9kZWNsYXJhdGlvbl9vcGVuX3N0YXRlKGMsIGxvb2thaGVhZCwgZW9mKSB7XG4gICAgaWYgKGxvb2thaGVhZFswXSA9PT0gXCItXCIgJiYgbG9va2FoZWFkWzFdID09PSBcIi1cIikge1xuICAgICAgbmV4dGNoYXIgKz0gMjtcbiAgICAgIGJlZ2luQ29tbWVudCgpO1xuICAgICAgdG9rZW5pemVyID0gY29tbWVudF9zdGFydF9zdGF0ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobG9va2FoZWFkLnRvVXBwZXJDYXNlKCkgPT09IFwiRE9DVFlQRVwiKSB7XG4gICAgICBuZXh0Y2hhciArPSA3O1xuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9zdGF0ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobG9va2FoZWFkID09PSBcIltDREFUQVtcIiAmJiBjZGF0YUFsbG93ZWQoKSkge1xuICAgICAgbmV4dGNoYXIgKz0gNztcbiAgICAgIHRva2VuaXplciA9IGNkYXRhX3NlY3Rpb25fc3RhdGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdG9rZW5pemVyID0gYm9ndXNfY29tbWVudF9zdGF0ZTtcbiAgICB9XG4gIH1cbiAgbWFya3VwX2RlY2xhcmF0aW9uX29wZW5fc3RhdGUubG9va2FoZWFkID0gNztcblxuICBmdW5jdGlvbiBjb21tZW50X3N0YXJ0X3N0YXRlKGMpIHtcbiAgICBiZWdpbkNvbW1lbnQoKTtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDJEOiAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIHRva2VuaXplciA9IGNvbW1lbnRfc3RhcnRfZGFzaF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGluc2VydFRva2VuKENPTU1FTlQsIGJ1ZjJzdHIoY29tbWVudGJ1ZikpO1xuICAgICAgYnJlYWs7IC8qIHNlZSBjb21tZW50IGluIGNvbW1lbnQgZW5kIHN0YXRlICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1lbnRfc3RhcnRfZGFzaF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X2VuZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGluc2VydFRva2VuKENPTU1FTlQsIGJ1ZjJzdHIoY29tbWVudGJ1ZikpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBpbnNlcnRUb2tlbihDT01NRU5ULCBidWYyc3RyKGNvbW1lbnRidWYpKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrOyAvKiBzZWUgY29tbWVudCBpbiBjb21tZW50IGVuZCBzdGF0ZSAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDJEIC8qIEhZUEhFTi1NSU5VUyAqLyk7XG4gICAgICByZWNvbnN1bWUoYywgY29tbWVudF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21tZW50X3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDNDOiAvLyBMRVNTLVRIQU4gU0lHTlxuICAgICAgY29tbWVudGJ1Zi5wdXNoKGMpO1xuICAgICAgdG9rZW5pemVyID0gY29tbWVudF9sZXNzX3RoYW5fc2lnbl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDJEOiAvLyBIWVBIRU4tTUlOVVNcbiAgICAgIHRva2VuaXplciA9IGNvbW1lbnRfZW5kX2Rhc2hfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgY29tbWVudGJ1Zi5wdXNoKDB4RkZGRCAvKiBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi8pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBpbnNlcnRUb2tlbihDT01NRU5ULCBidWYyc3RyKGNvbW1lbnRidWYpKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrOyAvKiBzZWUgY29tbWVudCBpbiBjb21tZW50IGVuZCBzdGF0ZSAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb21tZW50YnVmLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21tZW50X2xlc3NfdGhhbl9zaWduX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDIxOiAvLyBFWENMQU1BVElPTiBNQVJLXG4gICAgICBjb21tZW50YnVmLnB1c2goYyk7XG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X2xlc3NfdGhhbl9zaWduX2Jhbmdfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzQzogLy8gTEVTUy1USEFOIFNJR05cbiAgICAgIGNvbW1lbnRidWYucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgY29tbWVudF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21tZW50X2xlc3NfdGhhbl9zaWduX2Jhbmdfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgdG9rZW5pemVyID0gY29tbWVudF9sZXNzX3RoYW5fc2lnbl9iYW5nX2Rhc2hfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVjb25zdW1lKGMsIGNvbW1lbnRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWVudF9sZXNzX3RoYW5fc2lnbl9iYW5nX2Rhc2hfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgdG9rZW5pemVyID0gY29tbWVudF9sZXNzX3RoYW5fc2lnbl9iYW5nX2Rhc2hfZGFzaF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgY29tbWVudF9lbmRfZGFzaF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21tZW50X2xlc3NfdGhhbl9zaWduX2JhbmdfZGFzaF9kYXNoX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgcmVjb25zdW1lKGMsIGNvbW1lbnRfZW5kX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBwYXJzZSBlcnJvclxuICAgICAgcmVjb25zdW1lKGMsIGNvbW1lbnRfZW5kX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1lbnRfZW5kX2Rhc2hfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMkQ6IC8vIEhZUEhFTi1NSU5VU1xuICAgICAgdG9rZW5pemVyID0gY29tbWVudF9lbmRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGluc2VydFRva2VuKENPTU1FTlQsIGJ1ZjJzdHIoY29tbWVudGJ1ZikpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7IC8qIHNlZSBjb21tZW50IGluIGNvbW1lbnQgZW5kIHN0YXRlICovXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweDAwMkQgLyogSFlQSEVOLU1JTlVTICovKTtcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1lbnRfZW5kX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGluc2VydFRva2VuKENPTU1FTlQsIGJ1ZjJzdHIoY29tbWVudGJ1ZikpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjE6IC8vIEVYQ0xBTUFUSU9OIE1BUktcbiAgICAgIHRva2VuaXplciA9IGNvbW1lbnRfZW5kX2Jhbmdfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDJEKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgaW5zZXJ0VG9rZW4oQ09NTUVOVCwgYnVmMnN0cihjb21tZW50YnVmKSk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhazsgLyogRm9yIHNlY3VyaXR5IHJlYXNvbnM6IG90aGVyd2lzZSwgaG9zdGlsZSB1c2VyIGNvdWxkIHB1dCBhIHNjcmlwdCBpbiBhIGNvbW1lbnQgZS5nLiBpbiBhIGJsb2cgY29tbWVudCBhbmQgdGhlbiBET1MgdGhlIHNlcnZlciBzbyB0aGF0IHRoZSBlbmQgdGFnIGlzbid0IHJlYWQsIGFuZCB0aGVuIHRoZSBjb21tZW50ZWQgc2NyaXB0IHRhZyB3b3VsZCBiZSB0cmVhdGVkIGFzIGxpdmUgY29kZSAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDJEKTtcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweDAwMkQpO1xuICAgICAgcmVjb25zdW1lKGMsIGNvbW1lbnRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWVudF9lbmRfYmFuZ19zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyRDogLy8gSFlQSEVOLU1JTlVTXG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDJEKTtcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweDAwMkQpO1xuICAgICAgY29tbWVudGJ1Zi5wdXNoKDB4MDAyMSk7XG4gICAgICB0b2tlbml6ZXIgPSBjb21tZW50X2VuZF9kYXNoX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgaW5zZXJ0VG9rZW4oQ09NTUVOVCwgYnVmMnN0cihjb21tZW50YnVmKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGluc2VydFRva2VuKENPTU1FTlQsIGJ1ZjJzdHIoY29tbWVudGJ1ZikpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7IC8qIHNlZSBjb21tZW50IGluIGNvbW1lbnQgZW5kIHN0YXRlICovXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbW1lbnRidWYucHVzaCgweDAwMkQpO1xuICAgICAgY29tbWVudGJ1Zi5wdXNoKDB4MDAyRCk7XG4gICAgICBjb21tZW50YnVmLnB1c2goMHgwMDIxKTtcbiAgICAgIHJlY29uc3VtZShjLCBjb21tZW50X3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvY3R5cGVfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfZG9jdHlwZV9uYW1lX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBiZWdpbkRvY3R5cGUoKTtcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBiZWZvcmVfZG9jdHlwZV9uYW1lX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZm9yZV9kb2N0eXBlX25hbWVfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICAvKiBJZ25vcmUgdGhlIGNoYXJhY3Rlci4gKi9cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcbiAgICAgIGJlZ2luRG9jdHlwZSgpO1xuICAgICAgZG9jdHlwZW5hbWVidWYucHVzaChjICsgMHgwMDIwKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfbmFtZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICBiZWdpbkRvY3R5cGUoKTtcbiAgICAgIGRvY3R5cGVuYW1lYnVmLnB1c2goMHhGRkZEKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfbmFtZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgYmVnaW5Eb2N0eXBlKCk7XG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGJlZ2luRG9jdHlwZSgpO1xuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYmVnaW5Eb2N0eXBlKCk7XG4gICAgICBkb2N0eXBlbmFtZWJ1Zi5wdXNoKGMpO1xuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9uYW1lX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZG9jdHlwZV9uYW1lX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgdG9rZW5pemVyID0gYWZ0ZXJfZG9jdHlwZV9uYW1lX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDQxOiAgLy8gW0EtWl1cbiAgICBjYXNlIDB4MDA0MjpjYXNlIDB4MDA0MzpjYXNlIDB4MDA0NDpjYXNlIDB4MDA0NTpjYXNlIDB4MDA0NjpcbiAgICBjYXNlIDB4MDA0NzpjYXNlIDB4MDA0ODpjYXNlIDB4MDA0OTpjYXNlIDB4MDA0QTpjYXNlIDB4MDA0QjpcbiAgICBjYXNlIDB4MDA0QzpjYXNlIDB4MDA0RDpjYXNlIDB4MDA0RTpjYXNlIDB4MDA0RjpjYXNlIDB4MDA1MDpcbiAgICBjYXNlIDB4MDA1MTpjYXNlIDB4MDA1MjpjYXNlIDB4MDA1MzpjYXNlIDB4MDA1NDpjYXNlIDB4MDA1NTpcbiAgICBjYXNlIDB4MDA1NjpjYXNlIDB4MDA1NzpjYXNlIDB4MDA1ODpjYXNlIDB4MDA1OTpjYXNlIDB4MDA1QTpcbiAgICAgIGRvY3R5cGVuYW1lYnVmLnB1c2goYyArIDB4MDAyMCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgZG9jdHlwZW5hbWVidWYucHVzaCgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZG9jdHlwZW5hbWVidWYucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyX2RvY3R5cGVfbmFtZV9zdGF0ZShjLCBsb29rYWhlYWQsIGVvZikge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICAvKiBJZ25vcmUgdGhlIGNoYXJhY3Rlci4gKi9cbiAgICAgIG5leHRjaGFyICs9IDE7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBuZXh0Y2hhciArPSAxO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbG9va2FoZWFkID0gbG9va2FoZWFkLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAobG9va2FoZWFkID09PSBcIlBVQkxJQ1wiKSB7XG4gICAgICAgIG5leHRjaGFyICs9IDY7XG4gICAgICAgIHRva2VuaXplciA9IGFmdGVyX2RvY3R5cGVfcHVibGljX2tleXdvcmRfc3RhdGU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsb29rYWhlYWQgPT09IFwiU1lTVEVNXCIpIHtcbiAgICAgICAgbmV4dGNoYXIgKz0gNjtcbiAgICAgICAgdG9rZW5pemVyID0gYWZ0ZXJfZG9jdHlwZV9zeXN0ZW1fa2V5d29yZF9zdGF0ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgICB0b2tlbml6ZXIgPSBib2d1c19kb2N0eXBlX3N0YXRlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGFmdGVyX2RvY3R5cGVfbmFtZV9zdGF0ZS5sb29rYWhlYWQgPSA2O1xuXG4gIGZ1bmN0aW9uIGFmdGVyX2RvY3R5cGVfcHVibGljX2tleXdvcmRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICB0b2tlbml6ZXIgPSBiZWZvcmVfZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xuICAgICAgYmVnaW5Eb2N0eXBlUHVibGljSWQoKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfZG91YmxlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXG4gICAgICBiZWdpbkRvY3R5cGVQdWJsaWNJZCgpO1xuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9zaW5nbGVfcXVvdGVkX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICB0b2tlbml6ZXIgPSBib2d1c19kb2N0eXBlX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVmb3JlX2RvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIENIQVJBQ1RFUiBUQUJVTEFUSU9OICh0YWIpXG4gICAgY2FzZSAweDAwMEE6IC8vIExJTkUgRkVFRCAoTEYpXG4gICAgY2FzZSAweDAwMEM6IC8vIEZPUk0gRkVFRCAoRkYpXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgICAvKiBJZ25vcmUgdGhlIGNoYXJhY3Rlci4gKi9cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xuICAgICAgYmVnaW5Eb2N0eXBlUHVibGljSWQoKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfcHVibGljX2lkZW50aWZpZXJfZG91YmxlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXG4gICAgICBiZWdpbkRvY3R5cGVQdWJsaWNJZCgpO1xuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9zaW5nbGVfcXVvdGVkX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICB0b2tlbml6ZXIgPSBib2d1c19kb2N0eXBlX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9kb3VibGVfcXVvdGVkX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xuICAgICAgdG9rZW5pemVyID0gYWZ0ZXJfZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICBkb2N0eXBlcHVibGljYnVmLnB1c2goMHhGRkZEIC8qIFJFUExBQ0VNRU5UIENIQVJBQ1RFUiAqLyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZG9jdHlwZXB1YmxpY2J1Zi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZG9jdHlwZV9wdWJsaWNfaWRlbnRpZmllcl9zaW5nbGVfcXVvdGVkX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXG4gICAgICB0b2tlbml6ZXIgPSBhZnRlcl9kb2N0eXBlX3B1YmxpY19pZGVudGlmaWVyX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMDA6IC8vIE5VTExcbiAgICAgIGRvY3R5cGVwdWJsaWNidWYucHVzaCgweEZGRkQgLyogUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBkb2N0eXBlcHVibGljYnVmLnB1c2goYyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZnRlcl9kb2N0eXBlX3B1YmxpY19pZGVudGlmaWVyX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDA5OiAvLyBDSEFSQUNURVIgVEFCVUxBVElPTiAodGFiKVxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRUQgKExGKVxuICAgIGNhc2UgMHgwMDBDOiAvLyBGT1JNIEZFRUQgKEZGKVxuICAgIGNhc2UgMHgwMDIwOiAvLyBTUEFDRVxuICAgICAgdG9rZW5pemVyID0gYmV0d2Vlbl9kb2N0eXBlX3B1YmxpY19hbmRfc3lzdGVtX2lkZW50aWZpZXJzX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDIyOiAvLyBRVU9UQVRJT04gTUFSS1xuICAgICAgYmVnaW5Eb2N0eXBlU3lzdGVtSWQoKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfZG91YmxlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDI3OiAvLyBBUE9TVFJPUEhFXG4gICAgICBiZWdpbkRvY3R5cGVTeXN0ZW1JZCgpO1xuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9zaW5nbGVfcXVvdGVkX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gYm9ndXNfZG9jdHlwZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJldHdlZW5fZG9jdHlwZV9wdWJsaWNfYW5kX3N5c3RlbV9pZGVudGlmaWVyc19zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0UgSWdub3JlIHRoZSBjaGFyYWN0ZXIuXG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjI6IC8vIFFVT1RBVElPTiBNQVJLXG4gICAgICBiZWdpbkRvY3R5cGVTeXN0ZW1JZCgpO1xuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9kb3VibGVfcXVvdGVkX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjc6IC8vIEFQT1NUUk9QSEVcbiAgICAgIGJlZ2luRG9jdHlwZVN5c3RlbUlkKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX3NpbmdsZV9xdW90ZWRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICB0b2tlbml6ZXIgPSBib2d1c19kb2N0eXBlX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJfZG9jdHlwZV9zeXN0ZW1fa2V5d29yZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICAgIHRva2VuaXplciA9IGJlZm9yZV9kb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjI6IC8vIFFVT1RBVElPTiBNQVJLXG4gICAgICBiZWdpbkRvY3R5cGVTeXN0ZW1JZCgpO1xuICAgICAgdG9rZW5pemVyID0gZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9kb3VibGVfcXVvdGVkX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMjc6IC8vIEFQT1NUUk9QSEVcbiAgICAgIGJlZ2luRG9jdHlwZVN5c3RlbUlkKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX3NpbmdsZV9xdW90ZWRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIHRva2VuaXplciA9IGJvZ3VzX2RvY3R5cGVfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZWZvcmVfZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0UgSWdub3JlIHRoZSBjaGFyYWN0ZXIuXG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcbiAgICAgIGJlZ2luRG9jdHlwZVN5c3RlbUlkKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkb2N0eXBlX3N5c3RlbV9pZGVudGlmaWVyX2RvdWJsZV9xdW90ZWRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAyNzogLy8gQVBPU1RST1BIRVxuICAgICAgYmVnaW5Eb2N0eXBlU3lzdGVtSWQoKTtcbiAgICAgIHRva2VuaXplciA9IGRvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfc2luZ2xlX3F1b3RlZF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNFOiAvLyBHUkVBVEVSLVRIQU4gU0lHTlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gYm9ndXNfZG9jdHlwZV9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfZG91YmxlX3F1b3RlZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyMjogLy8gUVVPVEFUSU9OIE1BUktcbiAgICAgIHRva2VuaXplciA9IGFmdGVyX2RvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAwMDogLy8gTlVMTFxuICAgICAgZG9jdHlwZXN5c3RlbWJ1Zi5wdXNoKDB4RkZGRCAvKiBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi8pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBmb3JjZXF1aXJrcygpO1xuICAgICAgdG9rZW5pemVyID0gZGF0YV9zdGF0ZTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICBlbWl0RG9jdHlwZSgpO1xuICAgICAgZW1pdEVPRigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGRvY3R5cGVzeXN0ZW1idWYucHVzaChjKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvY3R5cGVfc3lzdGVtX2lkZW50aWZpZXJfc2luZ2xlX3F1b3RlZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAyNzogLy8gQVBPU1RST1BIRVxuICAgICAgdG9rZW5pemVyID0gYWZ0ZXJfZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICBkb2N0eXBlc3lzdGVtYnVmLnB1c2goMHhGRkZEIC8qIFJFUExBQ0VNRU5UIENIQVJBQ1RFUiAqLyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzRTogLy8gR1JFQVRFUi1USEFOIFNJR05cbiAgICAgIGZvcmNlcXVpcmtzKCk7XG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZG9jdHlwZXN5c3RlbWJ1Zi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJfZG9jdHlwZV9zeXN0ZW1faWRlbnRpZmllcl9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAwOTogLy8gQ0hBUkFDVEVSIFRBQlVMQVRJT04gKHRhYilcbiAgICBjYXNlIDB4MDAwQTogLy8gTElORSBGRUVEIChMRilcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEIChGRilcbiAgICBjYXNlIDB4MDAyMDogLy8gU1BBQ0VcbiAgICAgIC8qIElnbm9yZSB0aGUgY2hhcmFjdGVyLiAqL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZm9yY2VxdWlya3MoKTtcbiAgICAgIGVtaXREb2N0eXBlKCk7XG4gICAgICBlbWl0RU9GKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdG9rZW5pemVyID0gYm9ndXNfZG9jdHlwZV9zdGF0ZTtcbiAgICAgIC8qIFRoaXMgZG9lcyAqbm90KiBzZXQgdGhlIERPQ1RZUEUgdG9rZW4ncyBmb3JjZS1xdWlya3MgZmxhZy4gKi9cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJvZ3VzX2RvY3R5cGVfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgZW1pdERvY3R5cGUoKTtcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvKiBJZ25vcmUgdGhlIGNoYXJhY3Rlci4gKi9cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNkYXRhX3NlY3Rpb25fc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwNUQ6IC8vIFJJR0hUIFNRVUFSRSBCUkFDS0VUXG4gICAgICB0b2tlbml6ZXIgPSBjZGF0YV9zZWN0aW9uX2JyYWNrZXRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIGVtaXRFT0YoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDAwOiAvLyBOVUxMXG4gICAgICB0ZXh0SW5jbHVkZXNOVUwgPSB0cnVlO1xuICAgICAgLyogZmFsbCB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEluc3RlYWQgb2YganVzdCBwdXNoaW5nIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgdGhlblxuICAgICAgLy8gY29taW5nIGJhY2sgdG8gdGhlIHZlcnkgc2FtZSBwbGFjZSwgbG9va2FoZWFkIGFuZFxuICAgICAgLy8gZW1pdCBldmVyeXRoaW5nIHdlIGNhbiBhdCBvbmNlLlxuICAgICAgLypqc2hpbnQgLVcwMzAgKi9cbiAgICAgIGVtaXRDaGFyc1doaWxlKENEQVRBVEVYVCkgfHwgdGV4dHJ1bi5wdXNoKGMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2RhdGFfc2VjdGlvbl9icmFja2V0X3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDVEOiAvLyBSSUdIVCBTUVVBUkUgQlJBQ0tFVFxuICAgICAgdG9rZW5pemVyID0gY2RhdGFfc2VjdGlvbl9lbmRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDA1RCk7XG4gICAgICByZWNvbnN1bWUoYywgY2RhdGFfc2VjdGlvbl9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjZGF0YV9zZWN0aW9uX2VuZF9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDA1RDogLy8gUklHSFQgU1FVQVJFIEJSQUNLRVRcbiAgICAgIHRleHRydW4ucHVzaCgweDAwNUQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwM0U6IC8vIEdSRUFURVItVEhBTiBTSUdOXG4gICAgICBmbHVzaFRleHQoKTtcbiAgICAgIHRva2VuaXplciA9IGRhdGFfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGV4dHJ1bi5wdXNoKDB4MDA1RCk7XG4gICAgICB0ZXh0cnVuLnB1c2goMHgwMDVEKTtcbiAgICAgIHJlY29uc3VtZShjLCBjZGF0YV9zZWN0aW9uX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhdGUoYykge1xuICAgIGJlZ2luVGVtcEJ1ZigpO1xuICAgIHRlbXBidWYucHVzaCgweDAwMjYpO1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMDk6IC8vIFRBQlxuICAgIGNhc2UgMHgwMDBBOiAvLyBMSU5FIEZFRURcbiAgICBjYXNlIDB4MDAwQzogLy8gRk9STSBGRUVEXG4gICAgY2FzZSAweDAwMjA6IC8vIFNQQUNFXG4gICAgY2FzZSAweDAwM0M6IC8vIExFU1MtVEhBTiBTSUdOXG4gICAgY2FzZSAweDAwMjY6IC8vIEFNUEVSU0FORFxuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgcmVjb25zdW1lKGMsIGNoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDIzOiAvLyBOVU1CRVIgU0lHTlxuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xuICAgICAgdG9rZW5pemVyID0gbnVtZXJpY19jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBuYW1lZF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5hbWVkX2NoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhdGUoYykge1xuICAgIE5BTUVEQ0hBUlJFRi5sYXN0SW5kZXggPSBuZXh0Y2hhcjsgLy8gdy8gbG9va2FoZWFkIG5vIGNoYXIgaGFzIGJlZW4gY29uc3VtZWRcbiAgICB2YXIgbWF0Y2hlZCA9IE5BTUVEQ0hBUlJFRi5leGVjKGNoYXJzKTtcbiAgICBpZiAoIW1hdGNoZWQpIHRocm93IG5ldyBFcnJvcihcInNob3VsZCBuZXZlciBoYXBwZW5cIik7XG4gICAgdmFyIG5hbWUgPSBtYXRjaGVkWzFdO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgLy8gSWYgbm8gbWF0Y2ggY2FuIGJlIG1hZGUsIHN3aXRjaCB0byB0aGUgY2hhcmFjdGVyIHJlZmVyZW5jZSBlbmQgc3RhdGVcbiAgICAgIHRva2VuaXplciA9IGNoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWUgdGhlIG1hdGNoZWQgY2hhcmFjdGVycyBhbmQgYXBwZW5kIHRoZW0gdG8gdGVtcG9yYXJ5IGJ1ZmZlclxuICAgIG5leHRjaGFyICs9IG5hbWUubGVuZ3RoO1xuICAgIHB1c2hBbGwodGVtcGJ1Ziwgc3RyMmJ1ZihuYW1lKSk7XG5cbiAgICBzd2l0Y2gocmV0dXJuX3N0YXRlKSB7XG4gICAgY2FzZSBhdHRyaWJ1dGVfdmFsdWVfZG91YmxlX3F1b3RlZF9zdGF0ZTpcbiAgICBjYXNlIGF0dHJpYnV0ZV92YWx1ZV9zaW5nbGVfcXVvdGVkX3N0YXRlOlxuICAgIGNhc2UgYXR0cmlidXRlX3ZhbHVlX3VucXVvdGVkX3N0YXRlOlxuICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciByZWZlcmVuY2Ugd2FzIGNvbnN1bWVkIGFzIHBhcnQgb2YgYW4gYXR0cmlidXRlLi4uXG4gICAgICBpZiAobmFtZVtuYW1lLmxlbmd0aC0xXSAhPT0gJzsnKSB7IC8vIC4uLmFuZCB0aGUgbGFzdCBjaGFyIGlzIG5vdCA7XG4gICAgICAgIGlmICgvWz1BLVphLXowLTldLy50ZXN0KGNoYXJzW25leHRjaGFyXSkpIHtcbiAgICAgICAgICB0b2tlbml6ZXIgPSBjaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBiZWdpblRlbXBCdWYoKTtcbiAgICB2YXIgcnYgPSBuYW1lZENoYXJSZWZzW25hbWVdO1xuICAgIGlmICh0eXBlb2YgcnYgPT09ICdudW1iZXInKSB7XG4gICAgICB0ZW1wYnVmLnB1c2gocnYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoQWxsKHRlbXBidWYsIHJ2KTtcbiAgICB9XG4gICAgdG9rZW5pemVyID0gY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGU7XG4gIH1cbiAgLy8gV2UgbWlnaHQgbmVlZCB0byBwYXVzZSB0b2tlbml6YXRpb24gdW50aWwgd2UgaGF2ZSBlbm91Z2ggY2hhcmFjdGVyc1xuICAvLyBpbiB0aGUgYnVmZmVyIGZvciBsb25nZXN0IHBvc3NpYmxlIGNoYXJhY3RlciByZWZlcmVuY2UuXG4gIG5hbWVkX2NoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhdGUubG9va2FoZWFkID0gLU5BTUVEQ0hBUlJFRl9NQVhMRU47XG5cbiAgZnVuY3Rpb24gbnVtZXJpY19jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlKGMpIHtcbiAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgPSAwO1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwNzg6IC8vIHhcbiAgICBjYXNlIDB4MDA1ODogLy8gWFxuICAgICAgdGVtcGJ1Zi5wdXNoKGMpO1xuICAgICAgdG9rZW5pemVyID0gaGV4YWRlY2ltYWxfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGFydF9zdGF0ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZWNvbnN1bWUoYywgZGVjaW1hbF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXJ0X3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhleGFkZWNpbWFsX2NoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhcnRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMzA6IGNhc2UgMHgwMDMxOiBjYXNlIDB4MDAzMjogY2FzZSAweDAwMzM6IGNhc2UgMHgwMDM0OlxuICAgIGNhc2UgMHgwMDM1OiBjYXNlIDB4MDAzNjogY2FzZSAweDAwMzc6IGNhc2UgMHgwMDM4OiBjYXNlIDB4MDAzOTogLy8gWzAtOV1cbiAgICBjYXNlIDB4MDA0MTogY2FzZSAweDAwNDI6IGNhc2UgMHgwMDQzOiBjYXNlIDB4MDA0NDogY2FzZSAweDAwNDU6XG4gICAgY2FzZSAweDAwNDY6IC8vIFtBLUZdXG4gICAgY2FzZSAweDAwNjE6IGNhc2UgMHgwMDYyOiBjYXNlIDB4MDA2MzogY2FzZSAweDAwNjQ6IGNhc2UgMHgwMDY1OlxuICAgIGNhc2UgMHgwMDY2OiAvLyBbYS1mXVxuICAgICAgcmVjb25zdW1lKGMsIGhleGFkZWNpbWFsX2NoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBjaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWNpbWFsX2NoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhcnRfc3RhdGUoYykge1xuICAgIHN3aXRjaChjKSB7XG4gICAgY2FzZSAweDAwMzA6IGNhc2UgMHgwMDMxOiBjYXNlIDB4MDAzMjogY2FzZSAweDAwMzM6IGNhc2UgMHgwMDM0OlxuICAgIGNhc2UgMHgwMDM1OiBjYXNlIDB4MDAzNjogY2FzZSAweDAwMzc6IGNhc2UgMHgwMDM4OiBjYXNlIDB4MDAzOTogLy8gWzAtOV1cbiAgICAgIHJlY29uc3VtZShjLCBkZWNpbWFsX2NoYXJhY3Rlcl9yZWZlcmVuY2Vfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBjaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoZXhhZGVjaW1hbF9jaGFyYWN0ZXJfcmVmZXJlbmNlX3N0YXRlKGMpIHtcbiAgICBzd2l0Y2goYykge1xuICAgIGNhc2UgMHgwMDQxOiBjYXNlIDB4MDA0MjogY2FzZSAweDAwNDM6IGNhc2UgMHgwMDQ0OiBjYXNlIDB4MDA0NTpcbiAgICBjYXNlIDB4MDA0NjogLy8gW0EtRl1cbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSAqPSAxNjtcbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSArPSAoYyAtIDB4MDAzNyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDA2MTogY2FzZSAweDAwNjI6IGNhc2UgMHgwMDYzOiBjYXNlIDB4MDA2NDogY2FzZSAweDAwNjU6XG4gICAgY2FzZSAweDAwNjY6IC8vIFthLWZdXG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgKj0gMTY7XG4gICAgICBjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgKz0gKGMgLSAweDAwNTcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDAwMzA6IGNhc2UgMHgwMDMxOiBjYXNlIDB4MDAzMjogY2FzZSAweDAwMzM6IGNhc2UgMHgwMDM0OlxuICAgIGNhc2UgMHgwMDM1OiBjYXNlIDB4MDAzNjogY2FzZSAweDAwMzc6IGNhc2UgMHgwMDM4OiBjYXNlIDB4MDAzOTogLy8gWzAtOV1cbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSAqPSAxNjtcbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSArPSAoYyAtIDB4MDAzMCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDAzQjogLy8gU0VNSUNPTE9OXG4gICAgICB0b2tlbml6ZXIgPSBudW1lcmljX2NoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY29uc3VtZShjLCBudW1lcmljX2NoYXJhY3Rlcl9yZWZlcmVuY2VfZW5kX3N0YXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY2ltYWxfY2hhcmFjdGVyX3JlZmVyZW5jZV9zdGF0ZShjKSB7XG4gICAgc3dpdGNoKGMpIHtcbiAgICBjYXNlIDB4MDAzMDogY2FzZSAweDAwMzE6IGNhc2UgMHgwMDMyOiBjYXNlIDB4MDAzMzogY2FzZSAweDAwMzQ6XG4gICAgY2FzZSAweDAwMzU6IGNhc2UgMHgwMDM2OiBjYXNlIDB4MDAzNzogY2FzZSAweDAwMzg6IGNhc2UgMHgwMDM5OiAvLyBbMC05XVxuICAgICAgY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlICo9IDEwO1xuICAgICAgY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlICs9IChjIC0gMHgwMDMwKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMHgwMDNCOiAvLyBTRU1JQ09MT05cbiAgICAgIHRva2VuaXplciA9IG51bWVyaWNfY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVjb25zdW1lKGMsIG51bWVyaWNfY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbnVtZXJpY19jaGFyYWN0ZXJfcmVmZXJlbmNlX2VuZF9zdGF0ZShjKSB7XG4gICAgaWYgKGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSBpbiBudW1lcmljQ2hhclJlZlJlcGxhY2VtZW50cykge1xuICAgICAgY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlID0gbnVtZXJpY0NoYXJSZWZSZXBsYWNlbWVudHNbY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlXTtcbiAgICB9IGVsc2UgaWYgKGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA+IDB4MTBGRkZGIHx8IChjaGFyYWN0ZXJfcmVmZXJlbmNlX2NvZGUgPj0gMHhEODAwICYmIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA8IDB4RTAwMCkpIHtcbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA9IDB4RkZGRDtcbiAgICB9XG5cbiAgICBiZWdpblRlbXBCdWYoKTtcbiAgICBpZiAoY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlIDw9IDB4RkZGRikge1xuICAgICAgdGVtcGJ1Zi5wdXNoKGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSA9IGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSAtIDB4MTAwMDA7XG4gICAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgICAgIHRlbXBidWYucHVzaCgweEQ4MDAgKyAoY2hhcmFjdGVyX3JlZmVyZW5jZV9jb2RlID4+IDEwKSk7XG4gICAgICB0ZW1wYnVmLnB1c2goMHhEQzAwICsgKGNoYXJhY3Rlcl9yZWZlcmVuY2VfY29kZSAmIDB4MDNGRikpO1xuICAgIH1cbiAgICByZWNvbnN1bWUoYywgY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhcmFjdGVyX3JlZmVyZW5jZV9lbmRfc3RhdGUoYykge1xuICAgIHN3aXRjaChyZXR1cm5fc3RhdGUpIHtcbiAgICBjYXNlIGF0dHJpYnV0ZV92YWx1ZV9kb3VibGVfcXVvdGVkX3N0YXRlOlxuICAgIGNhc2UgYXR0cmlidXRlX3ZhbHVlX3NpbmdsZV9xdW90ZWRfc3RhdGU6XG4gICAgY2FzZSBhdHRyaWJ1dGVfdmFsdWVfdW5xdW90ZWRfc3RhdGU6XG4gICAgICAvLyBhcHBlbmQgZWFjaCBjaGFyYWN0ZXIgdG8gdGhlIGN1cnJlbnQgYXR0cmlidXRlJ3MgdmFsdWVcbiAgICAgIGF0dHJ2YWx1ZWJ1ZiArPSBidWYyc3RyKHRlbXBidWYpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHB1c2hBbGwodGV4dHJ1biwgdGVtcGJ1Zik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmVjb25zdW1lKGMsIHJldHVybl9zdGF0ZSk7XG4gIH1cblxuICAvKioqXG4gICAqIFRoZSB0cmVlIGJ1aWxkZXIgaW5zZXJ0aW9uIG1vZGVzXG4gICAqL1xuXG4gIC8vIDExLjIuNS40LjEgVGhlIFwiaW5pdGlhbFwiIGluc2VydGlvbiBtb2RlXG4gIGZ1bmN0aW9uIGluaXRpYWxfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoTEVBRElOR1dTLCBcIlwiKTsgLy8gSWdub3JlIHNwYWNlc1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyBBcmUgd2UgZG9uZT9cbiAgICAgIGJyZWFrOyAvLyBIYW5kbGUgYW55dGhpbmcgbm9uLXNwYWNlIHRleHQgYmVsb3dcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIGRvYy5fYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUNvbW1lbnQodmFsdWUpKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIHZhciBuYW1lID0gdmFsdWU7XG4gICAgICB2YXIgcHVibGljaWQgPSBhcmczO1xuICAgICAgdmFyIHN5c3RlbWlkID0gYXJnNDtcbiAgICAgIC8vIFVzZSB0aGUgY29uc3RydWN0b3IgZGlyZWN0bHkgaW5zdGVhZCBvZlxuICAgICAgLy8gaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnRUeXBlIGJlY2F1c2UgdGhlIGNyZWF0ZVxuICAgICAgLy8gZnVuY3Rpb24gdGhyb3dzIGVycm9ycyBvbiBpbnZhbGlkIGNoYXJhY3RlcnMsIGFuZFxuICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgcGFyc2VyIHRvIHRocm93IHRoZW0uXG4gICAgICBkb2MuYXBwZW5kQ2hpbGQobmV3IERvY3VtZW50VHlwZShuYW1lLHB1YmxpY2lkLCBzeXN0ZW1pZCkpO1xuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gcHVibGljIEFQSSBmb3Igc2V0dGluZyBxdWlya3MgbW9kZSBXZSBjYW5cbiAgICAgIC8vIGRvIHRoaXMgaGVyZSBiZWNhdXNlIHdlIGhhdmUgYWNjZXNzIHRvIGltcGxlbWVudGF0aW9uIGRldGFpbHNcbiAgICAgIGlmIChmb3JjZV9xdWlya3MgfHxcbiAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImh0bWxcIiB8fFxuICAgICAgICBxdWlya3lQdWJsaWNJZHMudGVzdChwdWJsaWNpZCkgfHxcbiAgICAgICAgKHN5c3RlbWlkICYmIHN5c3RlbWlkLnRvTG93ZXJDYXNlKCkgPT09IHF1aXJreVN5c3RlbUlkKSB8fFxuICAgICAgICAoc3lzdGVtaWQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgY29uZGl0aW9uYWxseVF1aXJreVB1YmxpY0lkcy50ZXN0KHB1YmxpY2lkKSkpXG4gICAgICAgIGRvYy5fcXVpcmtzID0gdHJ1ZTtcbiAgICAgIGVsc2UgaWYgKGxpbWl0ZWRRdWlya3lQdWJsaWNJZHMudGVzdChwdWJsaWNpZCkgfHxcbiAgICAgICAgICAgKHN5c3RlbWlkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGNvbmRpdGlvbmFsbHlRdWlya3lQdWJsaWNJZHMudGVzdChwdWJsaWNpZCkpKVxuICAgICAgICBkb2MuX2xpbWl0ZWRRdWlya3MgPSB0cnVlO1xuICAgICAgcGFyc2VyID0gYmVmb3JlX2h0bWxfbW9kZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0YWdzIG9yIG5vbi13aGl0ZXNwYWNlIHRleHRcbiAgICBkb2MuX3F1aXJrcyA9IHRydWU7XG4gICAgcGFyc2VyID0gYmVmb3JlX2h0bWxfbW9kZTtcbiAgICBwYXJzZXIodCx2YWx1ZSxhcmczLGFyZzQpO1xuICB9XG5cbiAgLy8gMTEuMi41LjQuMiBUaGUgXCJiZWZvcmUgaHRtbFwiIGluc2VydGlvbiBtb2RlXG4gIGZ1bmN0aW9uIGJlZm9yZV9odG1sX21vZGUodCx2YWx1ZSxhcmczLGFyZzQpIHtcbiAgICB2YXIgZWx0O1xuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoTEVBRElOR1dTLCBcIlwiKTsgLy8gSWdub3JlIHNwYWNlc1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyBBcmUgd2UgZG9uZT9cbiAgICAgIGJyZWFrOyAvLyBIYW5kbGUgYW55dGhpbmcgbm9uLXNwYWNlIHRleHQgYmVsb3dcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIC8qIGlnbm9yZSB0aGUgdG9rZW4gKi9cbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIGRvYy5fYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUNvbW1lbnQodmFsdWUpKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgaWYgKHZhbHVlID09PSBcImh0bWxcIikge1xuICAgICAgICBlbHQgPSBjcmVhdGVIVE1MRWx0KGRvYywgdmFsdWUsIGFyZzMpO1xuICAgICAgICBzdGFjay5wdXNoKGVsdCk7XG4gICAgICAgIGRvYy5hcHBlbmRDaGlsZChlbHQpO1xuICAgICAgICAvLyBYWFg6IGhhbmRsZSBhcHBsaWNhdGlvbiBjYWNoZSBoZXJlXG4gICAgICAgIHBhcnNlciA9IGJlZm9yZV9oZWFkX21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy8gRU5EVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICBicmVhazsgIC8vIGZhbGwgdGhyb3VnaCBvbiB0aGVzZVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuOyAvLyBpZ25vcmUgbW9zdCBlbmQgdGFnc1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFueXRoaW5nIHRoYXQgZGlkbid0IGdldCBoYW5kbGVkIGFib3ZlIGlzIGhhbmRsZWQgbGlrZSB0aGlzOlxuICAgIGVsdCA9IGNyZWF0ZUhUTUxFbHQoZG9jLCBcImh0bWxcIiwgbnVsbCk7XG4gICAgc3RhY2sucHVzaChlbHQpO1xuICAgIGRvYy5hcHBlbmRDaGlsZChlbHQpO1xuICAgIC8vIFhYWDogaGFuZGxlIGFwcGxpY2F0aW9uIGNhY2hlIGhlcmVcbiAgICBwYXJzZXIgPSBiZWZvcmVfaGVhZF9tb2RlO1xuICAgIHBhcnNlcih0LHZhbHVlLGFyZzMsYXJnNCk7XG4gIH1cblxuICAvLyAxMS4yLjUuNC4zIFRoZSBcImJlZm9yZSBoZWFkXCIgaW5zZXJ0aW9uIG1vZGVcbiAgZnVuY3Rpb24gYmVmb3JlX2hlYWRfbW9kZSh0LHZhbHVlLGFyZzMsYXJnNCkge1xuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoTEVBRElOR1dTLCBcIlwiKTsgIC8vIElnbm9yZSBzcGFjZXNcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHJldHVybjsgLy8gQXJlIHdlIGRvbmU/XG4gICAgICBicmVhazsgIC8vIEhhbmRsZSBhbnl0aGluZyBub24tc3BhY2UgdGV4dCBiZWxvd1xuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxuICAgICAgLyogaWdub3JlIHRoZSB0b2tlbiAqL1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsdmFsdWUsYXJnMyxhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgICAgdmFyIGVsdCA9IGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgaGVhZF9lbGVtZW50X3BvaW50ZXIgPSBlbHQ7XG4gICAgICAgIHBhcnNlciA9IGluX2hlYWRfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgY2FzZSBcImJyXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuOyAvLyBpZ25vcmUgbW9zdCBlbmQgdGFnc1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdCBoYW5kbGVkIGV4cGxpY2l0bHkgYWJvdmVcbiAgICBiZWZvcmVfaGVhZF9tb2RlKFRBRywgXCJoZWFkXCIsIG51bGwpOyAvLyBjcmVhdGUgYSBoZWFkIHRhZ1xuICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7IC8vIHRoZW4gdHJ5IGFnYWluIHdpdGggdGhpcyB0b2tlblxuICB9XG5cbiAgZnVuY3Rpb24gaW5faGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDE6IC8vIFRFWFRcbiAgICAgIHZhciB3cyA9IHZhbHVlLm1hdGNoKExFQURJTkdXUyk7XG4gICAgICBpZiAod3MpIHtcbiAgICAgICAgaW5zZXJ0VGV4dCh3c1swXSk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHdzWzBdLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICBicmVhazsgLy8gSGFuZGxlIG5vbi13aGl0ZXNwYWNlIGJlbG93XG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgICBpbnNlcnRDb21tZW50KHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAvLyBYWFg6XG4gICAgICAgIC8vIE1heSBuZWVkIHRvIGNoYW5nZSB0aGUgZW5jb2RpbmcgYmFzZWQgb24gdGhpcyB0YWdcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgIGNhc2UgXCJiYXNlZm9udFwiOlxuICAgICAgY2FzZSBcImJnc291bmRcIjpcbiAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICBwYXJzZVJDREFUQSh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJub3NjcmlwdFwiOlxuICAgICAgICBpZiAoIXNjcmlwdGluZ19lbmFibGVkKSB7XG4gICAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICAgIHBhcnNlciA9IGluX2hlYWRfbm9zY3JpcHRfbW9kZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBzY3JpcHRpbmcgaXMgZW5hYmxlZC4uLlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFwibm9mcmFtZXNcIjpcbiAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBwYXJzZVJhd1RleHQodmFsdWUsYXJnMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgaW5zZXJ0RWxlbWVudChmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICB2YXIgZWx0ID0gY3JlYXRlSFRNTEVsdChkb2MsIHZhbHVlLCBhcmczKTtcbiAgICAgICAgICBlbHQuX3BhcnNlcl9pbnNlcnRlZCA9IHRydWU7XG4gICAgICAgICAgZWx0Ll9mb3JjZV9hc3luYyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChmcmFnbWVudCkgZWx0Ll9hbHJlYWR5X3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIGZsdXNoVGV4dCgpO1xuICAgICAgICAgIHJldHVybiBlbHQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0b2tlbml6ZXIgPSBzY3JpcHRfZGF0YV9zdGF0ZTtcbiAgICAgICAgb3JpZ2luYWxJbnNlcnRpb25Nb2RlID0gcGFyc2VyO1xuICAgICAgICBwYXJzZXIgPSB0ZXh0X21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIGFmZS5pbnNlcnRNYXJrZXIoKTtcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgcGFyc2VyID0gaW5fdGVtcGxhdGVfbW9kZTtcbiAgICAgICAgdGVtcGxhdGVJbnNlcnRpb25Nb2Rlcy5wdXNoKHBhcnNlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICAgIHJldHVybjsgLy8gaWdub3JlIGl0XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgcGFyc2VyID0gYWZ0ZXJfaGVhZF9tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICBicmVhazsgLy8gaGFuZGxlIHRoZXNlIGF0IHRoZSBib3R0b20gb2YgdGhlIGZ1bmN0aW9uXG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgaWYgKCFzdGFjay5jb250YWlucyhcInRlbXBsYXRlXCIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MobnVsbCwgXCJ0aG9yb3VnaFwiKTtcbiAgICAgICAgc3RhY2sucG9wVGFnKFwidGVtcGxhdGVcIik7XG4gICAgICAgIGFmZS5jbGVhclRvTWFya2VyKCk7XG4gICAgICAgIHRlbXBsYXRlSW5zZXJ0aW9uTW9kZXMucG9wKCk7XG4gICAgICAgIHJlc2V0SW5zZXJ0aW9uTW9kZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBpZ25vcmUgYW55IG90aGVyIGVuZCB0YWdcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgbm90IGhhbmRsZWQgYWJvdmVcbiAgICBpbl9oZWFkX21vZGUoRU5EVEFHLCBcImhlYWRcIiwgbnVsbCk7ICAgLy8gc3ludGhldGljIDwvaGVhZD5cbiAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpOyAgIC8vIFRoZW4gcmVkbyB0aGlzIG9uZVxuICB9XG5cbiAgLy8gMTMuMi41LjQuNSBUaGUgXCJpbiBoZWFkIG5vc2NyaXB0XCIgaW5zZXJ0aW9uIG1vZGVcbiAgZnVuY3Rpb24gaW5faGVhZF9ub3NjcmlwdF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICB2YXIgd3MgPSB2YWx1ZS5tYXRjaChMRUFESU5HV1MpO1xuICAgICAgaWYgKHdzKSB7XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB3c1swXSk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHdzWzBdLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIG5vIG1vcmUgdGV4dFxuICAgICAgYnJlYWs7IC8vIEhhbmRsZSBub24td2hpdGVzcGFjZSBiZWxvd1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJiYXNlZm9udFwiOlxuICAgICAgY2FzZSBcImJnc291bmRcIjpcbiAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgaW5faGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgIGNhc2UgXCJub3NjcmlwdFwiOlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwibm9zY3JpcHRcIjpcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHBhcnNlciA9IGluX2hlYWRfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImJyXCI6XG4gICAgICAgIGJyZWFrOyAgLy8gZ29lcyB0byB0aGUgb3V0ZXIgZGVmYXVsdFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuOyAvLyBpZ25vcmUgb3RoZXIgZW5kIHRhZ3NcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIElmIG5vdCBoYW5kbGVkIGFib3ZlXG4gICAgaW5faGVhZF9ub3NjcmlwdF9tb2RlKEVORFRBRywgXCJub3NjcmlwdFwiLCBudWxsKTtcbiAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJfaGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDE6IC8vIFRFWFRcbiAgICAgIHZhciB3cyA9IHZhbHVlLm1hdGNoKExFQURJTkdXUyk7XG4gICAgICBpZiAod3MpIHtcbiAgICAgICAgaW5zZXJ0VGV4dCh3c1swXSk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHdzWzBdLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICBicmVhazsgLy8gSGFuZGxlIG5vbi13aGl0ZXNwYWNlIGJlbG93XG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgICBpbnNlcnRDb21tZW50KHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICAgIHBhcnNlciA9IGluX2JvZHlfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImZyYW1lc2V0XCI6XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgcGFyc2VyID0gaW5fZnJhbWVzZXRfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgIGNhc2UgXCJiYXNlZm9udFwiOlxuICAgICAgY2FzZSBcImJnc291bmRcIjpcbiAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XG4gICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxuICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgIHN0YWNrLnB1c2goaGVhZF9lbGVtZW50X3BvaW50ZXIpO1xuICAgICAgICBpbl9oZWFkX21vZGUoVEFHLCB2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHN0YWNrLnJlbW92ZUVsZW1lbnQoaGVhZF9lbGVtZW50X3BvaW50ZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiaGVhZFwiOlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgcmV0dXJuIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjsgIC8vIGlnbm9yZSBhbnkgb3RoZXIgZW5kIHRhZ1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYWZ0ZXJfaGVhZF9tb2RlKFRBRywgXCJib2R5XCIsIG51bGwpO1xuICAgIGZyYW1lc2V0X29rID0gdHJ1ZTtcbiAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICB9XG5cbiAgLy8gMTMuMi41LjQuNyBUaGUgXCJpbiBib2R5XCIgaW5zZXJ0aW9uIG1vZGVcbiAgZnVuY3Rpb24gaW5fYm9keV9tb2RlKHQsdmFsdWUsYXJnMyxhcmc0KSB7XG4gICAgdmFyIGJvZHksIGksIG5vZGUsIGVsdDtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgaWYgKHRleHRJbmNsdWRlc05VTCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoTlVMQ0hBUlMsIFwiXCIpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBJZiBhbnkgbm9uLXNwYWNlIGNoYXJhY3RlcnNcbiAgICAgIGlmIChmcmFtZXNldF9vayAmJiBOT05XUy50ZXN0KHZhbHVlKSlcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgIGFmZXJlY29uc3RydWN0KCk7XG4gICAgICBpbnNlcnRUZXh0KHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIGluc2VydENvbW1lbnQodmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgaWYgKHRlbXBsYXRlSW5zZXJ0aW9uTW9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBpbl90ZW1wbGF0ZV9tb2RlKHQpO1xuICAgICAgfVxuICAgICAgc3RvcFBhcnNpbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICBpZiAoc3RhY2suY29udGFpbnMoXCJ0ZW1wbGF0ZVwiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2ZlckF0dHJpYnV0ZXMoYXJnMywgc3RhY2suZWxlbWVudHNbMF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgY2FzZSBcImJhc2Vmb250XCI6XG4gICAgICBjYXNlIFwiYmdzb3VuZFwiOlxuICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICBjYXNlIFwibm9mcmFtZXNcIjpcbiAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XG4gICAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgICAgaW5faGVhZF9tb2RlKFRBRywgdmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICBib2R5ID0gc3RhY2suZWxlbWVudHNbMV07XG4gICAgICAgIGlmICghYm9keSB8fCAhKGJvZHkgaW5zdGFuY2VvZiBpbXBsLkhUTUxCb2R5RWxlbWVudCkgfHxcbiAgICAgICAgICAgIHN0YWNrLmNvbnRhaW5zKFwidGVtcGxhdGVcIikpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xuICAgICAgICB0cmFuc2ZlckF0dHJpYnV0ZXMoYXJnMywgYm9keSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJmcmFtZXNldFwiOlxuICAgICAgICBpZiAoIWZyYW1lc2V0X29rKSByZXR1cm47XG4gICAgICAgIGJvZHkgPSBzdGFjay5lbGVtZW50c1sxXTtcbiAgICAgICAgaWYgKCFib2R5IHx8ICEoYm9keSBpbnN0YW5jZW9mIGltcGwuSFRNTEJvZHlFbGVtZW50KSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChib2R5LnBhcmVudE5vZGUpIGJvZHkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib2R5KTtcbiAgICAgICAgd2hpbGUoIShzdGFjay50b3AgaW5zdGFuY2VvZiBpbXBsLkhUTUxIdG1sRWxlbWVudCkpXG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgcGFyc2VyID0gaW5fZnJhbWVzZXRfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgY2FzZSBcImFydGljbGVcIjpcbiAgICAgIGNhc2UgXCJhc2lkZVwiOlxuICAgICAgY2FzZSBcImJsb2NrcXVvdGVcIjpcbiAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgIGNhc2UgXCJkZXRhaWxzXCI6XG4gICAgICBjYXNlIFwiZGlhbG9nXCI6XG4gICAgICBjYXNlIFwiZGlyXCI6XG4gICAgICBjYXNlIFwiZGl2XCI6XG4gICAgICBjYXNlIFwiZGxcIjpcbiAgICAgIGNhc2UgXCJmaWVsZHNldFwiOlxuICAgICAgY2FzZSBcImZpZ2NhcHRpb25cIjpcbiAgICAgIGNhc2UgXCJmaWd1cmVcIjpcbiAgICAgIGNhc2UgXCJmb290ZXJcIjpcbiAgICAgIGNhc2UgXCJoZWFkZXJcIjpcbiAgICAgIGNhc2UgXCJoZ3JvdXBcIjpcbiAgICAgIGNhc2UgXCJtYWluXCI6XG4gICAgICBjYXNlIFwibmF2XCI6XG4gICAgICBjYXNlIFwib2xcIjpcbiAgICAgIGNhc2UgXCJwXCI6XG4gICAgICBjYXNlIFwic2VjdGlvblwiOlxuICAgICAgY2FzZSBcInN1bW1hcnlcIjpcbiAgICAgIGNhc2UgXCJ1bFwiOlxuICAgICAgICBpZiAoc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJtZW51XCI6XG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xuICAgICAgICBpZiAoaXNBKHN0YWNrLnRvcCwgJ21lbnVpdGVtJykpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImgxXCI6XG4gICAgICBjYXNlIFwiaDJcIjpcbiAgICAgIGNhc2UgXCJoM1wiOlxuICAgICAgY2FzZSBcImg0XCI6XG4gICAgICBjYXNlIFwiaDVcIjpcbiAgICAgIGNhc2UgXCJoNlwiOlxuICAgICAgICBpZiAoc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcbiAgICAgICAgaWYgKHN0YWNrLnRvcCBpbnN0YW5jZW9mIGltcGwuSFRNTEhlYWRpbmdFbGVtZW50KVxuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInByZVwiOlxuICAgICAgY2FzZSBcImxpc3RpbmdcIjpcbiAgICAgICAgaWYgKHN0YWNrLmluQnV0dG9uU2NvcGUoXCJwXCIpKSBpbl9ib2R5X21vZGUoRU5EVEFHLCBcInBcIik7XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgaWdub3JlX2xpbmVmZWVkID0gdHJ1ZTtcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgICBpZiAoZm9ybV9lbGVtZW50X3BvaW50ZXIgJiYgIXN0YWNrLmNvbnRhaW5zKFwidGVtcGxhdGVcIikpIHJldHVybjtcbiAgICAgICAgaWYgKHN0YWNrLmluQnV0dG9uU2NvcGUoXCJwXCIpKSBpbl9ib2R5X21vZGUoRU5EVEFHLCBcInBcIik7XG4gICAgICAgIGVsdCA9IGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgaWYgKCFzdGFjay5jb250YWlucyhcInRlbXBsYXRlXCIpKVxuICAgICAgICAgIGZvcm1fZWxlbWVudF9wb2ludGVyID0gZWx0O1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJsaVwiOlxuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xuICAgICAgICBmb3IoaSA9IHN0YWNrLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIG5vZGUgPSBzdGFjay5lbGVtZW50c1tpXTtcbiAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGltcGwuSFRNTExJRWxlbWVudCkge1xuICAgICAgICAgICAgaW5fYm9keV9tb2RlKEVORFRBRywgXCJsaVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBKG5vZGUsIHNwZWNpYWxTZXQpICYmICFpc0Eobm9kZSwgYWRkcmVzc2RpdnBTZXQpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLmluQnV0dG9uU2NvcGUoXCJwXCIpKSBpbl9ib2R5X21vZGUoRU5EVEFHLCBcInBcIik7XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiZGRcIjpcbiAgICAgIGNhc2UgXCJkdFwiOlxuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xuICAgICAgICBmb3IoaSA9IHN0YWNrLmVsZW1lbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIG5vZGUgPSBzdGFjay5lbGVtZW50c1tpXTtcbiAgICAgICAgICBpZiAoaXNBKG5vZGUsIGRkZHRTZXQpKSB7XG4gICAgICAgICAgICBpbl9ib2R5X21vZGUoRU5EVEFHLCBub2RlLmxvY2FsTmFtZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQShub2RlLCBzcGVjaWFsU2V0KSAmJiAhaXNBKG5vZGUsIGFkZHJlc3NkaXZwU2V0KSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInBsYWludGV4dFwiOlxuICAgICAgICBpZiAoc3RhY2suaW5CdXR0b25TY29wZShcInBcIikpIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICB0b2tlbml6ZXIgPSBwbGFpbnRleHRfc3RhdGU7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgICBpZiAoc3RhY2suaW5TY29wZShcImJ1dHRvblwiKSkge1xuICAgICAgICAgIGluX2JvZHlfbW9kZShFTkRUQUcsIFwiYnV0dG9uXCIpO1xuICAgICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcbiAgICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gYWZlLmZpbmRFbGVtZW50QnlUYWcoXCJhXCIpO1xuICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgIGluX2JvZHlfbW9kZShFTkRUQUcsIHZhbHVlKTtcbiAgICAgICAgICBhZmUucmVtb3ZlKGFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgIHN0YWNrLnJlbW92ZUVsZW1lbnQoYWN0aXZlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBcImJcIjpcbiAgICAgIGNhc2UgXCJiaWdcIjpcbiAgICAgIGNhc2UgXCJjb2RlXCI6XG4gICAgICBjYXNlIFwiZW1cIjpcbiAgICAgIGNhc2UgXCJmb250XCI6XG4gICAgICBjYXNlIFwiaVwiOlxuICAgICAgY2FzZSBcInNcIjpcbiAgICAgIGNhc2UgXCJzbWFsbFwiOlxuICAgICAgY2FzZSBcInN0cmlrZVwiOlxuICAgICAgY2FzZSBcInN0cm9uZ1wiOlxuICAgICAgY2FzZSBcInR0XCI6XG4gICAgICBjYXNlIFwidVwiOlxuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xuICAgICAgICBhZmUucHVzaChpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcIm5vYnJcIjpcbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcblxuICAgICAgICBpZiAoc3RhY2suaW5TY29wZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpbl9ib2R5X21vZGUoRU5EVEFHLCB2YWx1ZSk7XG4gICAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcbiAgICAgICAgfVxuICAgICAgICBhZmUucHVzaChpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImFwcGxldFwiOlxuICAgICAgY2FzZSBcIm1hcnF1ZWVcIjpcbiAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIGFmZS5pbnNlcnRNYXJrZXIoKTtcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgaWYgKCFkb2MuX3F1aXJrcyAmJiBzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkge1xuICAgICAgICAgIGluX2JvZHlfbW9kZShFTkRUQUcsIFwicFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgcGFyc2VyID0gaW5fdGFibGVfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiYXJlYVwiOlxuICAgICAgY2FzZSBcImJyXCI6XG4gICAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgIGNhc2UgXCJrZXlnZW5cIjpcbiAgICAgIGNhc2UgXCJ3YnJcIjpcbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xuICAgICAgICBlbHQgPSBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciB0eXBlID0gZWx0LmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG4gICAgICAgIGlmICghdHlwZSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IFwiaGlkZGVuXCIpXG4gICAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwicGFyYW1cIjpcbiAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgIGNhc2UgXCJ0cmFja1wiOlxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xuICAgICAgICBpZiAoaXNBKHN0YWNrLnRvcCwgJ21lbnVpdGVtJykpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGZyYW1lc2V0X29rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgIGluX2JvZHlfbW9kZShUQUcsIFwiaW1nXCIsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgICAgaWdub3JlX2xpbmVmZWVkID0gdHJ1ZTtcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgdG9rZW5pemVyID0gcmNkYXRhX3N0YXRlO1xuICAgICAgICBvcmlnaW5hbEluc2VydGlvbk1vZGUgPSBwYXJzZXI7XG4gICAgICAgIHBhcnNlciA9IHRleHRfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwieG1wXCI6XG4gICAgICAgIGlmIChzdGFjay5pbkJ1dHRvblNjb3BlKFwicFwiKSkgaW5fYm9keV9tb2RlKEVORFRBRywgXCJwXCIpO1xuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xuICAgICAgICBmcmFtZXNldF9vayA9IGZhbHNlO1xuICAgICAgICBwYXJzZVJhd1RleHQodmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJpZnJhbWVcIjpcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgcGFyc2VSYXdUZXh0KHZhbHVlLCBhcmczKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwibm9lbWJlZFwiOlxuICAgICAgICBwYXJzZVJhd1RleHQodmFsdWUsYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcIm5vc2NyaXB0XCI6XG4gICAgICAgIGlmIChzY3JpcHRpbmdfZW5hYmxlZCkge1xuICAgICAgICAgIHBhcnNlUmF3VGV4dCh2YWx1ZSxhcmczKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAvLyBYWFggT3RoZXJ3aXNlIHRyZWF0IGl0IGFzIGFueSBvdGhlciBvcGVuIHRhZz9cblxuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKHBhcnNlciA9PT0gaW5fdGFibGVfbW9kZSB8fFxuICAgICAgICAgIHBhcnNlciA9PT0gaW5fY2FwdGlvbl9tb2RlIHx8XG4gICAgICAgICAgcGFyc2VyID09PSBpbl90YWJsZV9ib2R5X21vZGUgfHxcbiAgICAgICAgICBwYXJzZXIgPT09IGluX3Jvd19tb2RlIHx8XG4gICAgICAgICAgcGFyc2VyID09PSBpbl9jZWxsX21vZGUpXG4gICAgICAgICAgcGFyc2VyID0gaW5fc2VsZWN0X2luX3RhYmxlX21vZGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwYXJzZXIgPSBpbl9zZWxlY3RfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwib3B0Z3JvdXBcIjpcbiAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgaWYgKHN0YWNrLnRvcCBpbnN0YW5jZW9mIGltcGwuSFRNTE9wdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgICBpbl9ib2R5X21vZGUoRU5EVEFHLCBcIm9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwibWVudWl0ZW1cIjpcbiAgICAgICAgaWYgKGlzQShzdGFjay50b3AsICdtZW51aXRlbScpKSB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWZlcmVjb25zdHJ1Y3QoKTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsIGFyZzMpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJyYlwiOlxuICAgICAgY2FzZSBcInJ0Y1wiOlxuICAgICAgICBpZiAoc3RhY2suaW5TY29wZShcInJ1YnlcIikpIHtcbiAgICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInJwXCI6XG4gICAgICBjYXNlIFwicnRcIjpcbiAgICAgICAgaWYgKHN0YWNrLmluU2NvcGUoXCJydWJ5XCIpKSB7XG4gICAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncyhcInJ0Y1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgICBhZmVyZWNvbnN0cnVjdCgpO1xuICAgICAgICBhZGp1c3RNYXRoTUxBdHRyaWJ1dGVzKGFyZzMpO1xuICAgICAgICBhZGp1c3RGb3JlaWduQXR0cmlidXRlcyhhcmczKTtcbiAgICAgICAgaW5zZXJ0Rm9yZWlnbkVsZW1lbnQodmFsdWUsIGFyZzMsIE5BTUVTUEFDRS5NQVRITUwpO1xuICAgICAgICBpZiAoYXJnNCkgLy8gc2VsZi1jbG9zaW5nIGZsYWdcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgIGFmZXJlY29uc3RydWN0KCk7XG4gICAgICAgIGFkanVzdFNWR0F0dHJpYnV0ZXMoYXJnMyk7XG4gICAgICAgIGFkanVzdEZvcmVpZ25BdHRyaWJ1dGVzKGFyZzMpO1xuICAgICAgICBpbnNlcnRGb3JlaWduRWxlbWVudCh2YWx1ZSwgYXJnMywgTkFNRVNQQUNFLlNWRyk7XG4gICAgICAgIGlmIChhcmc0KSAvLyBzZWxmLWNsb3NpbmcgZmxhZ1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICBjYXNlIFwiY29sXCI6XG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgIGNhc2UgXCJmcmFtZVwiOlxuICAgICAgY2FzZSBcImhlYWRcIjpcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgY2FzZSBcInRkXCI6XG4gICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgLy8gSWdub3JlIHRhYmxlIHRhZ3MgaWYgd2UncmUgbm90IGluX3RhYmxlIG1vZGVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgYW55IG90aGVyIHN0YXJ0IHRhZyBoZXJlXG4gICAgICAvLyAoYW5kIGFsc28gbm9zY3JpcHQgdGFncyB3aGVuIHNjcmlwdGluZyBpcyBkaXNhYmxlZClcbiAgICAgIGFmZXJlY29uc3RydWN0KCk7XG4gICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgMzogLy8gRU5EVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxuICAgICAgICBpbl9oZWFkX21vZGUoRU5EVEFHLCB2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgIGlmICghc3RhY2suaW5TY29wZShcImJvZHlcIikpIHJldHVybjtcbiAgICAgICAgcGFyc2VyID0gYWZ0ZXJfYm9keV9tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICBpZiAoIXN0YWNrLmluU2NvcGUoXCJib2R5XCIpKSByZXR1cm47XG4gICAgICAgIHBhcnNlciA9IGFmdGVyX2JvZHlfbW9kZTtcbiAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgY2FzZSBcImFydGljbGVcIjpcbiAgICAgIGNhc2UgXCJhc2lkZVwiOlxuICAgICAgY2FzZSBcImJsb2NrcXVvdGVcIjpcbiAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgIGNhc2UgXCJkZXRhaWxzXCI6XG4gICAgICBjYXNlIFwiZGlhbG9nXCI6XG4gICAgICBjYXNlIFwiZGlyXCI6XG4gICAgICBjYXNlIFwiZGl2XCI6XG4gICAgICBjYXNlIFwiZGxcIjpcbiAgICAgIGNhc2UgXCJmaWVsZHNldFwiOlxuICAgICAgY2FzZSBcImZpZ2NhcHRpb25cIjpcbiAgICAgIGNhc2UgXCJmaWd1cmVcIjpcbiAgICAgIGNhc2UgXCJmb290ZXJcIjpcbiAgICAgIGNhc2UgXCJoZWFkZXJcIjpcbiAgICAgIGNhc2UgXCJoZ3JvdXBcIjpcbiAgICAgIGNhc2UgXCJsaXN0aW5nXCI6XG4gICAgICBjYXNlIFwibWFpblwiOlxuICAgICAgY2FzZSBcIm1lbnVcIjpcbiAgICAgIGNhc2UgXCJuYXZcIjpcbiAgICAgIGNhc2UgXCJvbFwiOlxuICAgICAgY2FzZSBcInByZVwiOlxuICAgICAgY2FzZSBcInNlY3Rpb25cIjpcbiAgICAgIGNhc2UgXCJzdW1tYXJ5XCI6XG4gICAgICBjYXNlIFwidWxcIjpcbiAgICAgICAgLy8gSWdub3JlIGlmIHRoZXJlIGlzIG5vdCBhIG1hdGNoaW5nIG9wZW4gdGFnXG4gICAgICAgIGlmICghc3RhY2suaW5TY29wZSh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xuICAgICAgICBzdGFjay5wb3BUYWcodmFsdWUpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJmb3JtXCI6XG4gICAgICAgIGlmICghc3RhY2suY29udGFpbnMoXCJ0ZW1wbGF0ZVwiKSkge1xuICAgICAgICAgIHZhciBvcGVuZm9ybSA9IGZvcm1fZWxlbWVudF9wb2ludGVyO1xuICAgICAgICAgIGZvcm1fZWxlbWVudF9wb2ludGVyID0gbnVsbDtcbiAgICAgICAgICBpZiAoIW9wZW5mb3JtIHx8ICFzdGFjay5lbGVtZW50SW5TY29wZShvcGVuZm9ybSkpIHJldHVybjtcbiAgICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XG4gICAgICAgICAgc3RhY2sucmVtb3ZlRWxlbWVudChvcGVuZm9ybSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFzdGFjay5pblNjb3BlKFwiZm9ybVwiKSkgcmV0dXJuO1xuICAgICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3MoKTtcbiAgICAgICAgICBzdGFjay5wb3BUYWcoXCJmb3JtXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInBcIjpcbiAgICAgICAgaWYgKCFzdGFjay5pbkJ1dHRvblNjb3BlKHZhbHVlKSkge1xuICAgICAgICAgIGluX2JvZHlfbW9kZShUQUcsIHZhbHVlLCBudWxsKTtcbiAgICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3ModmFsdWUpO1xuICAgICAgICAgIHN0YWNrLnBvcFRhZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwibGlcIjpcbiAgICAgICAgaWYgKCFzdGFjay5pbkxpc3RJdGVtU2NvcGUodmFsdWUpKSByZXR1cm47XG4gICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3ModmFsdWUpO1xuICAgICAgICBzdGFjay5wb3BUYWcodmFsdWUpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgY2FzZSBcImR0XCI6XG4gICAgICAgIGlmICghc3RhY2suaW5TY29wZSh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncyh2YWx1ZSk7XG4gICAgICAgIHN0YWNrLnBvcFRhZyh2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImgxXCI6XG4gICAgICBjYXNlIFwiaDJcIjpcbiAgICAgIGNhc2UgXCJoM1wiOlxuICAgICAgY2FzZSBcImg0XCI6XG4gICAgICBjYXNlIFwiaDVcIjpcbiAgICAgIGNhc2UgXCJoNlwiOlxuICAgICAgICBpZiAoIXN0YWNrLmVsZW1lbnRUeXBlSW5TY29wZShpbXBsLkhUTUxIZWFkaW5nRWxlbWVudCkpIHJldHVybjtcbiAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xuICAgICAgICBzdGFjay5wb3BFbGVtZW50VHlwZShpbXBsLkhUTUxIZWFkaW5nRWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInNhcmNhc21cIjpcbiAgICAgICAgLy8gVGFrZSBhIGRlZXAgYnJlYXRoLCBhbmQgdGhlbjpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICBjYXNlIFwiYlwiOlxuICAgICAgY2FzZSBcImJpZ1wiOlxuICAgICAgY2FzZSBcImNvZGVcIjpcbiAgICAgIGNhc2UgXCJlbVwiOlxuICAgICAgY2FzZSBcImZvbnRcIjpcbiAgICAgIGNhc2UgXCJpXCI6XG4gICAgICBjYXNlIFwibm9iclwiOlxuICAgICAgY2FzZSBcInNcIjpcbiAgICAgIGNhc2UgXCJzbWFsbFwiOlxuICAgICAgY2FzZSBcInN0cmlrZVwiOlxuICAgICAgY2FzZSBcInN0cm9uZ1wiOlxuICAgICAgY2FzZSBcInR0XCI6XG4gICAgICBjYXNlIFwidVwiOlxuICAgICAgICB2YXIgcmVzdWx0ID0gYWRvcHRpb25BZ2VuY3kodmFsdWUpO1xuICAgICAgICBpZiAocmVzdWx0KSByZXR1cm47ICAvLyBJZiB3ZSBkaWQgc29tZXRoaW5nIHdlJ3JlIGRvbmVcbiAgICAgICAgYnJlYWs7ICAgICAgICAgLy8gR28gdG8gdGhlIFwiYW55IG90aGVyIGVuZCB0YWdcIiBjYXNlXG5cbiAgICAgIGNhc2UgXCJhcHBsZXRcIjpcbiAgICAgIGNhc2UgXCJtYXJxdWVlXCI6XG4gICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgIGlmICghc3RhY2suaW5TY29wZSh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgc3RhY2suZ2VuZXJhdGVJbXBsaWVkRW5kVGFncygpO1xuICAgICAgICBzdGFjay5wb3BUYWcodmFsdWUpO1xuICAgICAgICBhZmUuY2xlYXJUb01hcmtlcigpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICBpbl9ib2R5X21vZGUoVEFHLCB2YWx1ZSwgbnVsbCk7ICAvLyBUdXJuIDwvYnI+IGludG8gPGJyPlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFueSBvdGhlciBlbmQgdGFnIGdvZXMgaGVyZVxuICAgICAgZm9yKGkgPSBzdGFjay5lbGVtZW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbm9kZSA9IHN0YWNrLmVsZW1lbnRzW2ldO1xuICAgICAgICBpZiAoaXNBKG5vZGUsIHZhbHVlKSkge1xuICAgICAgICAgIHN0YWNrLmdlbmVyYXRlSW1wbGllZEVuZFRhZ3ModmFsdWUpO1xuICAgICAgICAgIHN0YWNrLnBvcEVsZW1lbnQobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBKG5vZGUsIHNwZWNpYWxTZXQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgaW5zZXJ0VGV4dCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MU2NyaXB0RWxlbWVudClcbiAgICAgICAgc3RhY2sudG9wLl9hbHJlYWR5X3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBwYXJzZXIgPSBvcmlnaW5hbEluc2VydGlvbk1vZGU7XG4gICAgICBwYXJzZXIodCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJzY3JpcHRcIikge1xuICAgICAgICBoYW5kbGVTY3JpcHRFbmQoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgcGFyc2VyID0gb3JpZ2luYWxJbnNlcnRpb25Nb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZ2V0IGFueSBvdGhlciB0b2tlbiB0eXBlc1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluX3RhYmxlX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBmdW5jdGlvbiBnZXRUeXBlQXR0cihhdHRycykge1xuICAgICAgZm9yKHZhciBpID0gMCwgbiA9IGF0dHJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoYXR0cnNbaV1bMF0gPT09IFwidHlwZVwiKVxuICAgICAgICAgIHJldHVybiBhdHRyc1tpXVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDE6IC8vIFRFWFRcbiAgICAgIC8vIFhYWCB0aGUgdGV4dF9pbnRlZ3JhdGlvbl9tb2RlIHN0dWZmIGlzXG4gICAgICAvLyBqdXN0IGEgaGFjayBJIG1hZGUgdXBcbiAgICAgIGlmICh0ZXh0X2ludGVncmF0aW9uX21vZGUpIHtcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBKHN0YWNrLnRvcCwgdGFibGVzZWN0aW9ucm93U2V0KSkge1xuICAgICAgICBwZW5kaW5nX3RhYmxlX3RleHQgPSBbXTtcbiAgICAgICAgb3JpZ2luYWxJbnNlcnRpb25Nb2RlID0gcGFyc2VyO1xuICAgICAgICBwYXJzZXIgPSBpbl90YWJsZV90ZXh0X21vZGU7XG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImNhcHRpb25cIjpcbiAgICAgICAgc3RhY2suY2xlYXJUb0NvbnRleHQodGFibGVDb250ZXh0U2V0KTtcbiAgICAgICAgYWZlLmluc2VydE1hcmtlcigpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgICAgcGFyc2VyID0gaW5fY2FwdGlvbl9tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgICAgc3RhY2suY2xlYXJUb0NvbnRleHQodGFibGVDb250ZXh0U2V0KTtcbiAgICAgICAgaW5zZXJ0SFRNTEVsZW1lbnQodmFsdWUsYXJnMyk7XG4gICAgICAgIHBhcnNlciA9IGluX2NvbHVtbl9ncm91cF9tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiY29sXCI6XG4gICAgICAgIGluX3RhYmxlX21vZGUoVEFHLCBcImNvbGdyb3VwXCIsIG51bGwpO1xuICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxuICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICAgIHN0YWNrLmNsZWFyVG9Db250ZXh0KHRhYmxlQ29udGV4dFNldCk7XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLGFyZzMpO1xuICAgICAgICBwYXJzZXIgPSBpbl90YWJsZV9ib2R5X21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgY2FzZSBcInRoXCI6XG4gICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgaW5fdGFibGVfbW9kZShUQUcsIFwidGJvZHlcIiwgbnVsbCk7XG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybjsgLy8gSWdub3JlIHRoZSB0b2tlblxuICAgICAgICB9XG4gICAgICAgIGluX3RhYmxlX21vZGUoRU5EVEFHLCB2YWx1ZSk7XG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgaW5faGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlQXR0cihhcmczKTtcbiAgICAgICAgaWYgKHR5cGUgIT09IFwiaGlkZGVuXCIpIGJyZWFrOyAgLy8gdG8gdGhlIGFueXRoaW5nIGVsc2UgY2FzZVxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSxhcmczKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImZvcm1cIjpcbiAgICAgICAgaWYgKGZvcm1fZWxlbWVudF9wb2ludGVyIHx8IHN0YWNrLmNvbnRhaW5zKFwidGVtcGxhdGVcIikpIHJldHVybjtcbiAgICAgICAgZm9ybV9lbGVtZW50X3BvaW50ZXIgPSBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHN0YWNrLnBvcEVsZW1lbnQoZm9ybV9lbGVtZW50X3BvaW50ZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgaWYgKCFzdGFjay5pblRhYmxlU2NvcGUodmFsdWUpKSByZXR1cm47XG4gICAgICAgIHN0YWNrLnBvcFRhZyh2YWx1ZSk7XG4gICAgICAgIHJlc2V0SW5zZXJ0aW9uTW9kZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgY2FzZSBcImNhcHRpb25cIjpcbiAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgY2FzZSBcInRkXCI6XG4gICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdGhlIGFueXRoaW5nIGVsc2UgY2FzZVxuICAgIGZvc3Rlcl9wYXJlbnRfbW9kZSA9IHRydWU7XG4gICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICBmb3N0ZXJfcGFyZW50X21vZGUgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX3RhYmxlX3RleHRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIGlmICh0ID09PSBURVhUKSB7XG4gICAgICBpZiAodGV4dEluY2x1ZGVzTlVMKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShOVUxDSEFSUywgXCJcIik7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBlbmRpbmdfdGFibGVfdGV4dC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcyA9IHBlbmRpbmdfdGFibGVfdGV4dC5qb2luKFwiXCIpO1xuICAgICAgcGVuZGluZ190YWJsZV90ZXh0Lmxlbmd0aCA9IDA7XG4gICAgICBpZiAoTk9OV1MudGVzdChzKSkgeyAvLyBJZiBhbnkgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICAgICAgICAvLyBUaGlzIG11c3QgYmUgdGhlIHNhbWUgY29kZSBhcyB0aGUgXCJhbnl0aGluZyBlbHNlXCJcbiAgICAgICAgLy8gY2FzZSBvZiB0aGUgaW5fdGFibGUgbW9kZSBhYm92ZS5cbiAgICAgICAgZm9zdGVyX3BhcmVudF9tb2RlID0gdHJ1ZTtcbiAgICAgICAgaW5fYm9keV9tb2RlKFRFWFQsIHMpO1xuICAgICAgICBmb3N0ZXJfcGFyZW50X21vZGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpbnNlcnRUZXh0KHMpO1xuICAgICAgfVxuICAgICAgcGFyc2VyID0gb3JpZ2luYWxJbnNlcnRpb25Nb2RlO1xuICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGluX2NhcHRpb25fbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIGZ1bmN0aW9uIGVuZF9jYXB0aW9uKCkge1xuICAgICAgaWYgKCFzdGFjay5pblRhYmxlU2NvcGUoXCJjYXB0aW9uXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XG4gICAgICBzdGFjay5wb3BUYWcoXCJjYXB0aW9uXCIpO1xuICAgICAgYWZlLmNsZWFyVG9NYXJrZXIoKTtcbiAgICAgIHBhcnNlciA9IGluX3RhYmxlX21vZGU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICBjYXNlIFwiY29sXCI6XG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgY2FzZSBcInRkXCI6XG4gICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgaWYgKGVuZF9jYXB0aW9uKCkpIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy8gRU5EVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICAgIGVuZF9jYXB0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgICBpZiAoZW5kX2NhcHRpb24oKSkgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgY2FzZSBcInRkXCI6XG4gICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVGhlIEFueXRoaW5nIEVsc2UgY2FzZVxuICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9jb2x1bW5fZ3JvdXBfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICB2YXIgd3MgPSB2YWx1ZS5tYXRjaChMRUFESU5HV1MpO1xuICAgICAgaWYgKHdzKSB7XG4gICAgICAgIGluc2VydFRleHQod3NbMF0pO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyh3c1swXS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgYnJlYWs7IC8vIEhhbmRsZSBub24td2hpdGVzcGFjZSBiZWxvd1xuXG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgICBpbnNlcnRDb21tZW50KHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiY29sXCI6XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxuICAgICAgICBpbl9oZWFkX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgICAgaWYgKCFpc0Eoc3RhY2sudG9wLCAnY29sZ3JvdXAnKSkge1xuICAgICAgICAgIHJldHVybjsgLy8gSWdub3JlIHRoZSB0b2tlbi5cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgcGFyc2VyID0gaW5fdGFibGVfbW9kZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgaW5faGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFueXRoaW5nIGVsc2VcbiAgICBpZiAoIWlzQShzdGFjay50b3AsICdjb2xncm91cCcpKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSB0aGUgdG9rZW4uXG4gICAgfVxuICAgIGluX2NvbHVtbl9ncm91cF9tb2RlKEVORFRBRywgXCJjb2xncm91cFwiKTtcbiAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fdGFibGVfYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgZnVuY3Rpb24gZW5kc2VjdCgpIHtcbiAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKFwidGJvZHlcIikgJiZcbiAgICAgICAgIXN0YWNrLmluVGFibGVTY29wZShcInRoZWFkXCIpICYmXG4gICAgICAgICFzdGFjay5pblRhYmxlU2NvcGUoXCJ0Zm9vdFwiKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgc3RhY2suY2xlYXJUb0NvbnRleHQodGFibGVCb2R5Q29udGV4dFNldCk7XG4gICAgICBpbl90YWJsZV9ib2R5X21vZGUoRU5EVEFHLCBzdGFjay50b3AubG9jYWxOYW1lLCBudWxsKTtcbiAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgfVxuXG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgc3RhY2suY2xlYXJUb0NvbnRleHQodGFibGVCb2R5Q29udGV4dFNldCk7XG4gICAgICAgIGluc2VydEhUTUxFbGVtZW50KHZhbHVlLCBhcmczKTtcbiAgICAgICAgcGFyc2VyID0gaW5fcm93X21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgY2FzZSBcInRkXCI6XG4gICAgICAgIGluX3RhYmxlX2JvZHlfbW9kZShUQUcsIFwidHJcIiwgbnVsbCk7XG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICBjYXNlIFwiY29sXCI6XG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICBjYXNlIFwidGhlYWRcIjpcbiAgICAgICAgZW5kc2VjdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgZW5kc2VjdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxuICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICAgIGlmIChzdGFjay5pblRhYmxlU2NvcGUodmFsdWUpKSB7XG4gICAgICAgICAgc3RhY2suY2xlYXJUb0NvbnRleHQodGFibGVCb2R5Q29udGV4dFNldCk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgcGFyc2VyID0gaW5fdGFibGVfbW9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgY2FzZSBcImNhcHRpb25cIjpcbiAgICAgIGNhc2UgXCJjb2xcIjpcbiAgICAgIGNhc2UgXCJjb2xncm91cFwiOlxuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgY2FzZSBcInRoXCI6XG4gICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZTpcbiAgICBpbl90YWJsZV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX3Jvd19tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgZnVuY3Rpb24gZW5kcm93KCkge1xuICAgICAgaWYgKCFzdGFjay5pblRhYmxlU2NvcGUoXCJ0clwiKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgc3RhY2suY2xlYXJUb0NvbnRleHQodGFibGVSb3dDb250ZXh0U2V0KTtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgcGFyc2VyID0gaW5fdGFibGVfYm9keV9tb2RlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwidGhcIjpcbiAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgICBzdGFjay5jbGVhclRvQ29udGV4dCh0YWJsZVJvd0NvbnRleHRTZXQpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHBhcnNlciA9IGluX2NlbGxfbW9kZTtcbiAgICAgICAgYWZlLmluc2VydE1hcmtlcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICBjYXNlIFwidGJvZHlcIjpcbiAgICAgIGNhc2UgXCJ0Zm9vdFwiOlxuICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgaWYgKGVuZHJvdygpKSBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgZW5kcm93KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgICBpZiAoZW5kcm93KCkpIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICBjYXNlIFwidGhlYWRcIjpcbiAgICAgICAgaWYgKHN0YWNrLmluVGFibGVTY29wZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZW5kcm93KCkpIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICBjYXNlIFwiY29sXCI6XG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICBjYXNlIFwidGRcIjpcbiAgICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBhbnl0aGluZyBlbHNlXG4gICAgaW5fdGFibGVfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9jZWxsX21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICBjYXNlIFwiY29sXCI6XG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgY2FzZSBcInRkXCI6XG4gICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgIGNhc2UgXCJ0aFwiOlxuICAgICAgY2FzZSBcInRoZWFkXCI6XG4gICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgaWYgKHN0YWNrLmluVGFibGVTY29wZShcInRkXCIpKSB7XG4gICAgICAgICAgaW5fY2VsbF9tb2RlKEVORFRBRywgXCJ0ZFwiKTtcbiAgICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YWNrLmluVGFibGVTY29wZShcInRoXCIpKSB7XG4gICAgICAgICAgaW5fY2VsbF9tb2RlKEVORFRBRywgXCJ0aFwiKTtcbiAgICAgICAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy8gRU5EVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJ0ZFwiOlxuICAgICAgY2FzZSBcInRoXCI6XG4gICAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICBzdGFjay5nZW5lcmF0ZUltcGxpZWRFbmRUYWdzKCk7XG4gICAgICAgIHN0YWNrLnBvcFRhZyh2YWx1ZSk7XG4gICAgICAgIGFmZS5jbGVhclRvTWFya2VyKCk7XG4gICAgICAgIHBhcnNlciA9IGluX3Jvd19tb2RlO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICBjYXNlIFwiY2FwdGlvblwiOlxuICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgY2FzZSBcImNvbGdyb3VwXCI6XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgY2FzZSBcInRib2R5XCI6XG4gICAgICBjYXNlIFwidGZvb3RcIjpcbiAgICAgIGNhc2UgXCJ0aGVhZFwiOlxuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIGlmICghc3RhY2suaW5UYWJsZVNjb3BlKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICBpbl9jZWxsX21vZGUoRU5EVEFHLCBzdGFjay5pblRhYmxlU2NvcGUoXCJ0ZFwiKSA/IFwidGRcIiA6IFwidGhcIik7XG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGFueXRoaW5nIGVsc2VcbiAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fc2VsZWN0X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgaWYgKHRleHRJbmNsdWRlc05VTCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoTlVMQ0hBUlMsIFwiXCIpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB9XG4gICAgICBpbnNlcnRUZXh0KHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIGluc2VydENvbW1lbnQodmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDI6IC8vIFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgIGlmIChzdGFjay50b3AgaW5zdGFuY2VvZiBpbXBsLkhUTUxPcHRpb25FbGVtZW50KVxuICAgICAgICAgIGluX3NlbGVjdF9tb2RlKEVORFRBRywgdmFsdWUpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJvcHRncm91cFwiOlxuICAgICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MT3B0aW9uRWxlbWVudClcbiAgICAgICAgICBpbl9zZWxlY3RfbW9kZShFTkRUQUcsIFwib3B0aW9uXCIpO1xuICAgICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MT3B0R3JvdXBFbGVtZW50KVxuICAgICAgICAgIGluX3NlbGVjdF9tb2RlKEVORFRBRywgdmFsdWUpO1xuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgaW5fc2VsZWN0X21vZGUoRU5EVEFHLCB2YWx1ZSk7IC8vIHRyZWF0IGl0IGFzIGEgY2xvc2UgdGFnXG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICBjYXNlIFwia2V5Z2VuXCI6XG4gICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgaWYgKCFzdGFjay5pblNlbGVjdFNjb3BlKFwic2VsZWN0XCIpKSByZXR1cm47XG4gICAgICAgIGluX3NlbGVjdF9tb2RlKEVORFRBRywgXCJzZWxlY3RcIik7XG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy8gRU5EVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJvcHRncm91cFwiOlxuICAgICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MT3B0aW9uRWxlbWVudCAmJlxuICAgICAgICAgIHN0YWNrLmVsZW1lbnRzW3N0YWNrLmVsZW1lbnRzLmxlbmd0aC0yXSBpbnN0YW5jZW9mXG4gICAgICAgICAgaW1wbC5IVE1MT3B0R3JvdXBFbGVtZW50KSB7XG4gICAgICAgICAgaW5fc2VsZWN0X21vZGUoRU5EVEFHLCBcIm9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MT3B0R3JvdXBFbGVtZW50KVxuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICBpZiAoc3RhY2sudG9wIGluc3RhbmNlb2YgaW1wbC5IVE1MT3B0aW9uRWxlbWVudClcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIGlmICghc3RhY2suaW5TZWxlY3RTY29wZSh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgc3RhY2sucG9wVGFnKHZhbHVlKTtcbiAgICAgICAgcmVzZXRJbnNlcnRpb25Nb2RlKCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gYW55dGhpbmcgZWxzZToganVzdCBpZ25vcmUgdGhlIHRva2VuXG4gIH1cblxuICBmdW5jdGlvbiBpbl9zZWxlY3RfaW5fdGFibGVfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgY2FzZSBcInRhYmxlXCI6XG4gICAgY2FzZSBcInRib2R5XCI6XG4gICAgY2FzZSBcInRmb290XCI6XG4gICAgY2FzZSBcInRoZWFkXCI6XG4gICAgY2FzZSBcInRyXCI6XG4gICAgY2FzZSBcInRkXCI6XG4gICAgY2FzZSBcInRoXCI6XG4gICAgICBzd2l0Y2godCkge1xuICAgICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgICAgaW5fc2VsZWN0X2luX3RhYmxlX21vZGUoRU5EVEFHLCBcInNlbGVjdFwiKTtcbiAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgICAgaWYgKHN0YWNrLmluVGFibGVTY29wZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpbl9zZWxlY3RfaW5fdGFibGVfbW9kZShFTkRUQUcsIFwic2VsZWN0XCIpO1xuICAgICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFueXRoaW5nIGVsc2VcbiAgICBpbl9zZWxlY3RfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbl90ZW1wbGF0ZV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgZnVuY3Rpb24gc3dpdGNoTW9kZUFuZFJlcHJvY2Vzcyhtb2RlKSB7XG4gICAgICBwYXJzZXIgPSBtb2RlO1xuICAgICAgdGVtcGxhdGVJbnNlcnRpb25Nb2Rlc1t0ZW1wbGF0ZUluc2VydGlvbk1vZGVzLmxlbmd0aC0xXSA9IHBhcnNlcjtcbiAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgfVxuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgLTE6IC8vIEVPRlxuICAgICAgaWYgKCFzdGFjay5jb250YWlucyhcInRlbXBsYXRlXCIpKSB7XG4gICAgICAgIHN0b3BQYXJzaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFjay5wb3BUYWcoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgICAgYWZlLmNsZWFyVG9NYXJrZXIoKTtcbiAgICAgICAgdGVtcGxhdGVJbnNlcnRpb25Nb2Rlcy5wb3AoKTtcbiAgICAgICAgcmVzZXRJbnNlcnRpb25Nb2RlKCk7XG4gICAgICAgIHBhcnNlcih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgIGNhc2UgXCJiYXNlZm9udFwiOlxuICAgICAgY2FzZSBcImJnc291bmRcIjpcbiAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XG4gICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgIGNhc2UgXCJ0ZW1wbGF0ZVwiOlxuICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJjYXB0aW9uXCI6XG4gICAgICBjYXNlIFwiY29sZ3JvdXBcIjpcbiAgICAgIGNhc2UgXCJ0Ym9keVwiOlxuICAgICAgY2FzZSBcInRmb290XCI6XG4gICAgICBjYXNlIFwidGhlYWRcIjpcbiAgICAgICAgc3dpdGNoTW9kZUFuZFJlcHJvY2Vzcyhpbl90YWJsZV9tb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImNvbFwiOlxuICAgICAgICBzd2l0Y2hNb2RlQW5kUmVwcm9jZXNzKGluX2NvbHVtbl9ncm91cF9tb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcInRyXCI6XG4gICAgICAgIHN3aXRjaE1vZGVBbmRSZXByb2Nlc3MoaW5fdGFibGVfYm9keV9tb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcInRkXCI6XG4gICAgICBjYXNlIFwidGhcIjpcbiAgICAgICAgc3dpdGNoTW9kZUFuZFJlcHJvY2Vzcyhpbl9yb3dfbW9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaE1vZGVBbmRSZXByb2Nlc3MoaW5fYm9keV9tb2RlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgaW5faGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICAvLyBJZiBhbnkgbm9uLXNwYWNlIGNoYXJzLCBoYW5kbGUgYmVsb3dcbiAgICAgIGlmIChOT05XUy50ZXN0KHZhbHVlKSkgYnJlYWs7XG4gICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxuICAgICAgLy8gQXBwZW5kIGl0IHRvIHRoZSA8aHRtbD4gZWxlbWVudFxuICAgICAgc3RhY2suZWxlbWVudHNbMF0uX2FwcGVuZENoaWxkKGRvYy5jcmVhdGVDb21tZW50KHZhbHVlKSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICByZXR1cm47XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBzdG9wUGFyc2luZygpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBpZiAodmFsdWUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrOyAvLyBmb3IgYW55IG90aGVyIHRhZ3NcbiAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgaWYgKHZhbHVlID09PSBcImh0bWxcIikge1xuICAgICAgICBpZiAoZnJhZ21lbnQpIHJldHVybjtcbiAgICAgICAgcGFyc2VyID0gYWZ0ZXJfYWZ0ZXJfYm9keV9tb2RlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBicmVhazsgLy8gZm9yIGFueSBvdGhlciB0YWdzXG4gICAgfVxuXG4gICAgLy8gYW55dGhpbmcgZWxzZVxuICAgIHBhcnNlciA9IGluX2JvZHlfbW9kZTtcbiAgICBwYXJzZXIodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fZnJhbWVzZXRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCkge1xuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICAvLyBJZ25vcmUgYW55IG5vbi1zcGFjZSBjaGFyYWN0ZXJzXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoQUxMTk9OV1MsIFwiXCIpO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIGluc2VydFRleHQodmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxuICAgICAgaW5zZXJ0Q29tbWVudCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICByZXR1cm47XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBzdG9wUGFyc2luZygpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJmcmFtZXNldFwiOlxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJmcmFtZVwiOlxuICAgICAgICBpbnNlcnRIVE1MRWxlbWVudCh2YWx1ZSwgYXJnMyk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwibm9mcmFtZXNcIjpcbiAgICAgICAgaW5faGVhZF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJmcmFtZXNldFwiKSB7XG4gICAgICAgIGlmIChmcmFnbWVudCAmJiBzdGFjay50b3AgaW5zdGFuY2VvZiBpbXBsLkhUTUxIdG1sRWxlbWVudClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIWZyYWdtZW50ICYmXG4gICAgICAgICAgIShzdGFjay50b3AgaW5zdGFuY2VvZiBpbXBsLkhUTUxGcmFtZVNldEVsZW1lbnQpKVxuICAgICAgICAgIHBhcnNlciA9IGFmdGVyX2ZyYW1lc2V0X21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBhbnl0aGluZyBlbHNlXG4gIH1cblxuICBmdW5jdGlvbiBhZnRlcl9mcmFtZXNldF9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgc3dpdGNoKHQpIHtcbiAgICBjYXNlIDE6IC8vIFRFWFRcbiAgICAgIC8vIElnbm9yZSBhbnkgbm9uLXNwYWNlIGNoYXJhY3RlcnNcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShBTExOT05XUywgXCJcIik7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkgaW5zZXJ0VGV4dCh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSA0OiAvLyBDT01NRU5UXG4gICAgICBpbnNlcnRDb21tZW50KHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIHN0b3BQYXJzaW5nKCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy8gRU5EVEFHXG4gICAgICBpZiAodmFsdWUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgIHBhcnNlciA9IGFmdGVyX2FmdGVyX2ZyYW1lc2V0X21vZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBhbnl0aGluZyBlbHNlXG4gIH1cblxuICBmdW5jdGlvbiBhZnRlcl9hZnRlcl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgLy8gSWYgYW55IG5vbi1zcGFjZSBjaGFycywgaGFuZGxlIGJlbG93XG4gICAgICBpZiAoTk9OV1MudGVzdCh2YWx1ZSkpIGJyZWFrO1xuICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIGRvYy5fYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUNvbW1lbnQodmFsdWUpKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDU6IC8vIERPQ1RZUEVcbiAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAtMTogLy8gRU9GXG4gICAgICBzdG9wUGFyc2luZygpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICBpZiAodmFsdWUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgIGluX2JvZHlfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGFueXRoaW5nIGVsc2VcbiAgICBwYXJzZXIgPSBpbl9ib2R5X21vZGU7XG4gICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyX2FmdGVyX2ZyYW1lc2V0X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICBzd2l0Y2godCkge1xuICAgIGNhc2UgMTogLy8gVEVYVFxuICAgICAgLy8gSWdub3JlIGFueSBub24tc3BhY2UgY2hhcmFjdGVyc1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKEFMTE5PTldTLCBcIlwiKTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKVxuICAgICAgICBpbl9ib2R5X21vZGUodCwgdmFsdWUsIGFyZzMsIGFyZzQpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgNDogLy8gQ09NTUVOVFxuICAgICAgZG9jLl9hcHBlbmRDaGlsZChkb2MuY3JlYXRlQ29tbWVudCh2YWx1ZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxuICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgIHN0b3BQYXJzaW5nKCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgaW5fYm9keV9tb2RlKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIm5vZnJhbWVzXCI6XG4gICAgICAgIGluX2hlYWRfbW9kZSh0LCB2YWx1ZSwgYXJnMywgYXJnNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBhbnl0aGluZyBlbHNlXG4gIH1cblxuXG4gIC8vIDEzLjIuNS41IFRoZSBydWxlcyBmb3IgcGFyc2luZyB0b2tlbnMgaW4gZm9yZWlnbiBjb250ZW50XG4gIC8vXG4gIC8vIFRoaXMgaXMgbGlrZSBvbmUgb2YgdGhlIGluc2VydGlvbiBtb2RlcyBhYm92ZSwgYnV0IGlzXG4gIC8vIGludm9rZWQgc29tZXdoYXQgZGlmZmVyZW50bHkgd2hlbiB0aGUgY3VycmVudCB0b2tlbiBpcyBub3QgSFRNTC5cbiAgLy8gU2VlIHRoZSBpbnNlcnRUb2tlbigpIGZ1bmN0aW9uLlxuICBmdW5jdGlvbiBpbnNlcnRGb3JlaWduVG9rZW4odCwgdmFsdWUsIGFyZzMsIGFyZzQpIHtcbiAgICAvLyBBIDxmb250PiB0YWcgaXMgYW4gSFRNTCBmb250IHRhZyBpZiBpdCBoYXMgYSBjb2xvciwgZm9udCwgb3Igc2l6ZVxuICAgIC8vIGF0dHJpYnV0ZS4gIE90aGVyd2lzZSB3ZSBhc3N1bWUgaXQgaXMgZm9yZWlnbiBjb250ZW50XG4gICAgZnVuY3Rpb24gaXNIVE1MRm9udChhdHRycykge1xuICAgICAgZm9yKHZhciBpID0gMCwgbiA9IGF0dHJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBzd2l0Y2goYXR0cnNbaV1bMF0pIHtcbiAgICAgICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICAgIGNhc2UgXCJmYWNlXCI6XG4gICAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudDtcblxuICAgIHN3aXRjaCh0KSB7XG4gICAgY2FzZSAxOiAvLyBURVhUXG4gICAgICAvLyBJZiBhbnkgbm9uLXNwYWNlLCBub24tbnVsIGNoYXJhY3RlcnNcbiAgICAgIGlmIChmcmFtZXNldF9vayAmJiBOT05XU05PTk5VTC50ZXN0KHZhbHVlKSlcbiAgICAgICAgZnJhbWVzZXRfb2sgPSBmYWxzZTtcbiAgICAgIGlmICh0ZXh0SW5jbHVkZXNOVUwpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKE5VTENIQVJTLCBcIlxcdUZGRkRcIik7XG4gICAgICB9XG4gICAgICBpbnNlcnRUZXh0KHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIDQ6IC8vIENPTU1FTlRcbiAgICAgIGluc2VydENvbW1lbnQodmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgNTogLy8gRE9DVFlQRVxuICAgICAgLy8gaWdub3JlIGl0XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAyOiAvLyBUQUdcbiAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgY2FzZSBcImZvbnRcIjpcbiAgICAgICAgaWYgKCFpc0hUTUxGb250KGFyZzMpKSBicmVhaztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBcImJcIjpcbiAgICAgIGNhc2UgXCJiaWdcIjpcbiAgICAgIGNhc2UgXCJibG9ja3F1b3RlXCI6XG4gICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgY2FzZSBcImJyXCI6XG4gICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICBjYXNlIFwiY29kZVwiOlxuICAgICAgY2FzZSBcImRkXCI6XG4gICAgICBjYXNlIFwiZGl2XCI6XG4gICAgICBjYXNlIFwiZGxcIjpcbiAgICAgIGNhc2UgXCJkdFwiOlxuICAgICAgY2FzZSBcImVtXCI6XG4gICAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgIGNhc2UgXCJoMVwiOlxuICAgICAgY2FzZSBcImgyXCI6XG4gICAgICBjYXNlIFwiaDNcIjpcbiAgICAgIGNhc2UgXCJoNFwiOlxuICAgICAgY2FzZSBcImg1XCI6XG4gICAgICBjYXNlIFwiaDZcIjpcbiAgICAgIGNhc2UgXCJoZWFkXCI6XG4gICAgICBjYXNlIFwiaHJcIjpcbiAgICAgIGNhc2UgXCJpXCI6XG4gICAgICBjYXNlIFwiaW1nXCI6XG4gICAgICBjYXNlIFwibGlcIjpcbiAgICAgIGNhc2UgXCJsaXN0aW5nXCI6XG4gICAgICBjYXNlIFwibWVudVwiOlxuICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgIGNhc2UgXCJub2JyXCI6XG4gICAgICBjYXNlIFwib2xcIjpcbiAgICAgIGNhc2UgXCJwXCI6XG4gICAgICBjYXNlIFwicHJlXCI6XG4gICAgICBjYXNlIFwicnVieVwiOlxuICAgICAgY2FzZSBcInNcIjpcbiAgICAgIGNhc2UgXCJzbWFsbFwiOlxuICAgICAgY2FzZSBcInNwYW5cIjpcbiAgICAgIGNhc2UgXCJzdHJvbmdcIjpcbiAgICAgIGNhc2UgXCJzdHJpa2VcIjpcbiAgICAgIGNhc2UgXCJzdWJcIjpcbiAgICAgIGNhc2UgXCJzdXBcIjpcbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgY2FzZSBcInR0XCI6XG4gICAgICBjYXNlIFwidVwiOlxuICAgICAgY2FzZSBcInVsXCI6XG4gICAgICBjYXNlIFwidmFyXCI6XG4gICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBjdXJyZW50ID0gc3RhY2sudG9wO1xuICAgICAgICB9IHdoaWxlKGN1cnJlbnQubmFtZXNwYWNlVVJJICE9PSBOQU1FU1BBQ0UuSFRNTCAmJlxuICAgICAgICAgICAgIWlzTWF0aG1sVGV4dEludGVncmF0aW9uUG9pbnQoY3VycmVudCkgJiZcbiAgICAgICAgICAgICFpc0hUTUxJbnRlZ3JhdGlvblBvaW50KGN1cnJlbnQpKTtcblxuICAgICAgICBpbnNlcnRUb2tlbih0LCB2YWx1ZSwgYXJnMywgYXJnNCk7ICAvLyByZXByb2Nlc3NcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBbnkgb3RoZXIgc3RhcnQgdGFnIGNhc2UgZ29lcyBoZXJlXG4gICAgICBjdXJyZW50ID0gKHN0YWNrLmVsZW1lbnRzLmxlbmd0aD09PTEgJiYgZnJhZ21lbnQpID8gZnJhZ21lbnRDb250ZXh0IDpcbiAgICAgICAgc3RhY2sudG9wO1xuICAgICAgaWYgKGN1cnJlbnQubmFtZXNwYWNlVVJJID09PSBOQU1FU1BBQ0UuTUFUSE1MKSB7XG4gICAgICAgIGFkanVzdE1hdGhNTEF0dHJpYnV0ZXMoYXJnMyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjdXJyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLlNWRykge1xuICAgICAgICB2YWx1ZSA9IGFkanVzdFNWR1RhZ05hbWUodmFsdWUpO1xuICAgICAgICBhZGp1c3RTVkdBdHRyaWJ1dGVzKGFyZzMpO1xuICAgICAgfVxuICAgICAgYWRqdXN0Rm9yZWlnbkF0dHJpYnV0ZXMoYXJnMyk7XG5cbiAgICAgIGluc2VydEZvcmVpZ25FbGVtZW50KHZhbHVlLCBhcmczLCBjdXJyZW50Lm5hbWVzcGFjZVVSSSk7XG4gICAgICBpZiAoYXJnNCkgeyAvLyB0aGUgc2VsZi1jbG9zaW5nIGZsYWdcbiAgICAgICAgaWYgKHZhbHVlID09PSAnc2NyaXB0JyAmJiBjdXJyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFLlNWRykge1xuICAgICAgICAgIC8vIFhYWCBkZWFsIHdpdGggU1ZHIHNjcmlwdHMgaGVyZVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAzOiAvLyBFTkRUQUdcbiAgICAgIGN1cnJlbnQgPSBzdGFjay50b3A7XG4gICAgICBpZiAodmFsdWUgPT09IFwic2NyaXB0XCIgJiZcbiAgICAgICAgY3VycmVudC5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRS5TVkcgJiZcbiAgICAgICAgY3VycmVudC5sb2NhbE5hbWUgPT09IFwic2NyaXB0XCIpIHtcblxuICAgICAgICBzdGFjay5wb3AoKTtcblxuICAgICAgICAvLyBYWFhcbiAgICAgICAgLy8gRGVhbCB3aXRoIFNWRyBzY3JpcHRzIGhlcmVcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGUgYW55IG90aGVyIGVuZCB0YWcgY2FzZVxuICAgICAgICB2YXIgaSA9IHN0YWNrLmVsZW1lbnRzLmxlbmd0aC0xO1xuICAgICAgICB2YXIgbm9kZSA9IHN0YWNrLmVsZW1lbnRzW2ldO1xuICAgICAgICBmb3IoOzspIHtcbiAgICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHN0YWNrLnBvcEVsZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IHN0YWNrLmVsZW1lbnRzWy0taV07XG4gICAgICAgICAgLy8gSWYgbm9uLWh0bWwsIGtlZXAgbG9vcGluZ1xuICAgICAgICAgIGlmIChub2RlLm5hbWVzcGFjZVVSSSAhPT0gTkFNRVNQQUNFLkhUTUwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgcHJvY2VzcyB0aGUgZW5kIHRhZyBhcyBodG1sXG4gICAgICAgICAgcGFyc2VyKHQsIHZhbHVlLCBhcmczLCBhcmc0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8qKipcbiAgICogRmluYWxseSwgdGhpcyBpcyB0aGUgZW5kIG9mIHRoZSBIVE1MUGFyc2VyKCkgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICogSXQgcmV0dXJucyB0aGUgaHRtbHBhcnNlciBvYmplY3Qgd2l0aCB0aGUgYXBwZW5kKCkgYW5kIGVuZCgpIG1ldGhvZHMuXG4gICAqL1xuXG4gIC8vIFNuZWFrIGFub3RoZXIgbWV0aG9kIGludG8gdGhlIGh0bWxwYXJzZXIgb2JqZWN0IHRvIGFsbG93IHVzIHRvIHJ1blxuICAvLyB0b2tlbml6ZXIgdGVzdHMuICBUaGlzIGNhbiBiZSBjb21tZW50ZWQgb3V0IGluIHByb2R1Y3Rpb24gY29kZS5cbiAgLy8gVGhpcyBpcyBhIGhvb2sgZm9yIHRlc3RpbmcgdGhlIHRva2VuaXplci4gSXQgaGFzIHRvIGJlIGhlcmVcbiAgLy8gYmVjYXVzZSB0aGUgdG9rZW5pemVyIGRldGFpbHMgYXJlIGFsbCBoaWRkZW4gYXdheSB3aXRoaW4gdGhlIGNsb3N1cmUuXG4gIC8vIEl0IHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgdG9rZW5zIGdlbmVyYXRlZCB3aGlsZSBwYXJzaW5nIHRoZVxuICAvLyBpbnB1dCBzdHJpbmcuXG4gIGh0bWxwYXJzZXIudGVzdFRva2VuaXplciA9IGZ1bmN0aW9uKGlucHV0LCBpbml0aWFsU3RhdGUsIGxhc3RTdGFydFRhZywgY2hhcmJ5Y2hhcikge1xuICAgIHZhciB0b2tlbnMgPSBbXTtcblxuICAgIHN3aXRjaChpbml0aWFsU3RhdGUpIHtcbiAgICBjYXNlIFwiUENEQVRBIHN0YXRlXCI6XG4gICAgICB0b2tlbml6ZXIgPSBkYXRhX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlJDREFUQSBzdGF0ZVwiOlxuICAgICAgdG9rZW5pemVyID0gcmNkYXRhX3N0YXRlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlJBV1RFWFQgc3RhdGVcIjpcbiAgICAgIHRva2VuaXplciA9IHJhd3RleHRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUExBSU5URVhUIHN0YXRlXCI6XG4gICAgICB0b2tlbml6ZXIgPSBwbGFpbnRleHRfc3RhdGU7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAobGFzdFN0YXJ0VGFnKSB7XG4gICAgICBsYXN0dGFnbmFtZSA9IGxhc3RTdGFydFRhZztcbiAgICB9XG5cbiAgICBpbnNlcnRUb2tlbiA9IGZ1bmN0aW9uKHQsIHZhbHVlLCBhcmczLCBhcmc0KSB7XG4gICAgICBmbHVzaFRleHQoKTtcbiAgICAgIHN3aXRjaCh0KSB7XG4gICAgICBjYXNlIDE6IC8vIFRFWFRcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGgtMV1bMF0gPT09IFwiQ2hhcmFjdGVyXCIpIHtcbiAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aC0xXVsxXSArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHRva2Vucy5wdXNoKFtcIkNoYXJhY3RlclwiLCB2YWx1ZV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDogLy8gQ09NTUVOVFxuICAgICAgICB0b2tlbnMucHVzaChbXCJDb21tZW50XCIsIHZhbHVlXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OiAvLyBET0NUWVBFXG4gICAgICAgIHRva2Vucy5wdXNoKFtcIkRPQ1RZUEVcIiwgdmFsdWUsXG4gICAgICAgICAgICAgICBhcmczID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJnMyxcbiAgICAgICAgICAgICAgIGFyZzQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmc0LFxuICAgICAgICAgICAgICAgIWZvcmNlX3F1aXJrc10pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogLy8gVEFHXG4gICAgICAgIHZhciBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmczLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gWFhYOiBkb2VzIGF0dHJpYnV0ZSBvcmRlciBtYXR0ZXI/XG4gICAgICAgICAgdmFyIGEgPSBhcmczW2ldO1xuICAgICAgICAgIGlmIChhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgYXR0cnNbYVswXV0gPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJzW2FbMF1dID0gYVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRva2VuID0gW1wiU3RhcnRUYWdcIiwgdmFsdWUsIGF0dHJzXTtcbiAgICAgICAgaWYgKGFyZzQpIHRva2VuLnB1c2godHJ1ZSk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6IC8vIEVORFRBR1xuICAgICAgICB0b2tlbnMucHVzaChbXCJFbmRUYWdcIiwgdmFsdWVdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIC0xOiAvLyBFT0ZcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghY2hhcmJ5Y2hhcikge1xuICAgICAgdGhpcy5wYXJzZShpbnB1dCwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucGFyc2UoaW5wdXRbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJzZShcIlwiLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VucztcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHBhcnNlciBvYmplY3QgZnJvbSB0aGUgSFRNTFBhcnNlcigpIGZhY3RvcnkgZnVuY3Rpb25cbiAgcmV0dXJuIGh0bWxwYXJzZXI7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0hUTUxQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMSkpKDEwNSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZmlyc3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjUuMi4zXG4gKiAoYykgMjAxMC0yMDE4IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInKSwgcmVxdWlyZSgnQGFuZ3VsYXIvYW5pbWF0aW9ucy9icm93c2VyJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbW1vbicpLCByZXF1aXJlKCdAYW5ndWxhci9jb21tb24vaHR0cCcpLCByZXF1aXJlKCdAYW5ndWxhci9odHRwJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYycpLCByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2FuaW1hdGlvbnMnKSwgcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyksIHJlcXVpcmUoJ3J4anMvU3ViamVjdCcpLCByZXF1aXJlKCd1cmwnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvY29tcGlsZXInKSwgcmVxdWlyZSgncnhqcy9vcGVyYXRvci9maWx0ZXInKSwgcmVxdWlyZSgncnhqcy9vcGVyYXRvci9maXJzdCcpLCByZXF1aXJlKCdyeGpzL29wZXJhdG9yL3RvUHJvbWlzZScpKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnQGFuZ3VsYXIvcGxhdGZvcm0tc2VydmVyJywgWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicsICdAYW5ndWxhci9hbmltYXRpb25zL2Jyb3dzZXInLCAnQGFuZ3VsYXIvY29tbW9uJywgJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJywgJ0Bhbmd1bGFyL2h0dHAnLCAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJywgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucycsICdyeGpzL09ic2VydmFibGUnLCAncnhqcy9TdWJqZWN0JywgJ3VybCcsICdAYW5ndWxhci9jb21waWxlcicsICdyeGpzL29wZXJhdG9yL2ZpbHRlcicsICdyeGpzL29wZXJhdG9yL2ZpcnN0JywgJ3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLnBsYXRmb3JtU2VydmVyID0ge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXIsZ2xvYmFsLm5nLmFuaW1hdGlvbnMuYnJvd3NlcixnbG9iYWwubmcuY29tbW9uLGdsb2JhbC5uZy5jb21tb24uaHR0cCxnbG9iYWwubmcuaHR0cCxnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyRHluYW1pYyxnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyLmFuaW1hdGlvbnMsZ2xvYmFsLlJ4LGdsb2JhbC5SeCxnbG9iYWwudXJsLGdsb2JhbC5uZy5jb21waWxlcixnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsX2FuZ3VsYXJfY29yZSxfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIsX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLF9hbmd1bGFyX2NvbW1vbixfYW5ndWxhcl9jb21tb25faHR0cCxfYW5ndWxhcl9odHRwLF9hbmd1bGFyX3BsYXRmb3JtQnJvd3NlckR5bmFtaWMsX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyX2FuaW1hdGlvbnMscnhqc19PYnNlcnZhYmxlLHJ4anNfU3ViamVjdCx1cmwsX2FuZ3VsYXJfY29tcGlsZXIscnhqc19vcGVyYXRvcl9maWx0ZXIscnhqc19vcGVyYXRvcl9maXJzdCxyeGpzX29wZXJhdG9yX3RvUHJvbWlzZSkgeyAndXNlIHN0cmljdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NS4yLjNcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgZG9taW5vID0gcmVxdWlyZSgnZG9taW5vJyk7XG4vKipcbiAqIEBwYXJhbSB7P30gbWV0aG9kTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX25vdEltcGxlbWVudGVkKG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gRG9taW5vQWRhcHRlcjogJyArIG1ldGhvZE5hbWUpO1xufVxuLyoqXG4gKiBQYXJzZXMgYSBkb2N1bWVudCBzdHJpbmcgdG8gYSBEb2N1bWVudCBvYmplY3QuXG4gKiBAcGFyYW0gez99IGh0bWxcbiAqIEBwYXJhbSB7Pz19IHVybFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChodG1sLCB1cmwkJDEpIHtcbiAgICBpZiAodXJsJCQxID09PSB2b2lkIDApIHsgdXJsJCQxID0gJy8nOyB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2luZG93ID0gZG9taW5vLmNyZWF0ZVdpbmRvdyhodG1sLCB1cmwkJDEpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRvYyA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICByZXR1cm4gZG9jO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEgZG9jdW1lbnQgdG8gc3RyaW5nLlxuICogQHBhcmFtIHs/fSBkb2NcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZURvY3VtZW50KGRvYykge1xuICAgIHJldHVybiAoLyoqIEB0eXBlIHs/fSAqLyAoZG9jKSkuc2VyaWFsaXplKCk7XG59XG4vKipcbiAqIERPTSBBZGFwdGVyIGZvciB0aGUgc2VydmVyIHBsYXRmb3JtIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZ25hc3MvZG9taW5vLlxuICovXG52YXIgRG9taW5vQWRhcHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9taW5vQWRhcHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb21pbm9BZGFwdGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5tYWtlQ3VycmVudCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVzZXRSb290RG9tQWRhcHRlcihuZXcgRG9taW5vQWRhcHRlcigpKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5sb2dFcnJvciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlcnJvcikgeyBjb25zb2xlLmVycm9yKGVycm9yKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5sb2cgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUubG9nR3JvdXAgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZXJyb3IpIHsgY29uc29sZS5lcnJvcihlcnJvcik7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5sb2dHcm91cEVuZCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNET01FdmVudHMgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNOYXRpdmVTaGFkb3dET00gPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZUFcbiAgICAgKiBAcGFyYW0gez99IG5vZGVCXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5jb250YWlucyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZUFcbiAgICAgKiBAcGFyYW0gez99IG5vZGVCXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobm9kZUEsIG5vZGVCKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyID0gbm9kZUI7XG4gICAgICAgIHdoaWxlIChpbm5lcikge1xuICAgICAgICAgICAgaWYgKGlubmVyID09PSBub2RlQSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlubmVyID0gaW5uZXIucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlSHRtbERvY3VtZW50ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZURvY3VtZW50KCc8aHRtbD48aGVhZD48dGl0bGU+ZmFrZVRpdGxlPC90aXRsZT48L2hlYWQ+PGJvZHk+PC9ib2R5PjwvaHRtbD4nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0RGVmYXVsdERvY3VtZW50ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghRG9taW5vQWRhcHRlci5kZWZhdWx0RG9jKSB7XG4gICAgICAgICAgICBEb21pbm9BZGFwdGVyLmRlZmF1bHREb2MgPSBkb21pbm8uY3JlYXRlRG9jdW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRG9taW5vQWRhcHRlci5kZWZhdWx0RG9jO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7Pz19IGRvY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlU2hhZG93Um9vdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez89fSBkb2NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbCwgZG9jKSB7XG4gICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxuICAgICAgICBlbC5zaGFkb3dSb290ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgZWwuc2hhZG93Um9vdC5wYXJlbnQgPSBlbDtcbiAgICAgICAgcmV0dXJuIGVsLnNoYWRvd1Jvb3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5nZXRTaGFkb3dSb290ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5zaGFkb3dSb290OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuaXNUZXh0Tm9kZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IERvbWlub0FkYXB0ZXIuZGVmYXVsdERvYy5URVhUX05PREU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5pc0NvbW1lbnROb2RlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gRG9taW5vQWRhcHRlci5kZWZhdWx0RG9jLkNPTU1FTlRfTk9ERTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuaXNFbGVtZW50Tm9kZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5vZGVUeXBlID09PSBEb21pbm9BZGFwdGVyLmRlZmF1bHREb2MuRUxFTUVOVF9OT0RFIDogZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmhhc1NoYWRvd1Jvb3QgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnNoYWRvd1Jvb3QgIT0gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmlzU2hhZG93Um9vdCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRoaXMuZ2V0U2hhZG93Um9vdChub2RlKSA9PSBub2RlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmdldFByb3BlcnR5ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnaHJlZicpIHtcbiAgICAgICAgICAgIC8vIERvbWlubyB0cmllcyB0cCByZXNvbHZlIGhyZWYtcyB3aGljaCB3ZSBkbyBub3Qgd2FudC4gSnVzdCByZXR1cm4gdGhlXG4gICAgICAgICAgICAvLyBhdHJpYnV0ZSB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShlbCwgJ2hyZWYnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnaW5uZXJUZXh0Jykge1xuICAgICAgICAgICAgLy8gRG9taW5vIGRvZXMgbm90IHN1cHBvcnQgaW5uZXJUZXh0LiBKdXN0IG1hcCBpdCB0byB0ZXh0Q29udGVudC5cbiAgICAgICAgICAgIHJldHVybiBlbC50ZXh0Q29udGVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7P30gKi8gKGVsKSlbbmFtZV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgICAvLyBFdmVudGhvdWdoIHRoZSBzZXJ2ZXIgcmVuZGVyZXIgcmVmbGVjdHMgYW55IHByb3BlcnRpZXMgdG8gYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gbWFwICdocmVmJyB0byBhdHJpYnV0ZSBqdXN0IHRvIGhhbmRsZSB3aGVuIHNldFByb3BlcnR5IGlzIGRpcmVjdGx5IGNhbGxlZC5cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGVsLCAnaHJlZicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnaW5uZXJUZXh0Jykge1xuICAgICAgICAgICAgLy8gRG9taW5vIGRvZXMgbm90IHN1cHBvcnQgaW5uZXJUZXh0LiBKdXN0IG1hcCBpdCB0byB0ZXh0Q29udGVudC5cbiAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKGVsKSlbbmFtZV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZG9jXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmdldEdsb2JhbEV2ZW50VGFyZ2V0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBkb2NcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGRvYywgdGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0QmFzZUhyZWYgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGRvYykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlID0gdGhpcy5xdWVyeVNlbGVjdG9yKGRvYy5kb2N1bWVudEVsZW1lbnQsICdiYXNlJyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhyZWYgPSAnJztcbiAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgIGhyZWYgPSB0aGlzLmdldEhyZWYoYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBOZWVkIHJlbGF0aXZlIHBhdGggbG9naWMgZnJvbSBCcm93c2VyRG9tQWRhcHRlciBoZXJlP1xuICAgICAgICByZXR1cm4gaHJlZjtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuX3JlYWRTdHlsZUF0dHJpYnV0ZSA9IC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZU1hcCA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICBpZiAoc3R5bGVBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlTGlzdCA9IHN0eWxlQXR0cmlidXRlLnNwbGl0KC87Ky9nKTtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzdHlsZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVMaXN0W2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGUgPSAvKiogQHR5cGUgez99ICovIChzdHlsZUxpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xvbiA9IHN0eWxlLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBDU1Mgc3R5bGU6IFwiICsgc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICgvKiogQHR5cGUgez99ICovIChzdHlsZU1hcCkpW3N0eWxlLnN1YnN0cigwLCBjb2xvbikudHJpbSgpXSA9IHN0eWxlLnN1YnN0cihjb2xvbiArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlTWFwO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU1hcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuX3dyaXRlU3R5bGVBdHRyaWJ1dGUgPSAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVNYXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU1hcCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZUF0dHJWYWx1ZSA9ICcnO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGtleSBpbiBzdHlsZU1hcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3VmFsdWUgPSBzdHlsZU1hcFtrZXldO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVBdHRyVmFsdWUgKz0ga2V5ICsgJzonICsgc3R5bGVNYXBba2V5XSArICc7JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZUF0dHJWYWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlTmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHN0eWxlVmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLnNldFN0eWxlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBzdHlsZVZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlTWFwID0gdGhpcy5fcmVhZFN0eWxlQXR0cmlidXRlKGVsZW1lbnQpO1xuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGVNYXApKVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgICAgdGhpcy5fd3JpdGVTdHlsZUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZU1hcCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlU3R5bGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlTmFtZSkgeyB0aGlzLnNldFN0eWxlKGVsZW1lbnQsIHN0eWxlTmFtZSwgbnVsbCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmdldFN0eWxlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVNYXAgPSB0aGlzLl9yZWFkU3R5bGVBdHRyaWJ1dGUoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBzdHlsZU1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpID8gKC8qKiBAdHlwZSB7P30gKi8gKHN0eWxlTWFwKSlbc3R5bGVOYW1lXSA6ICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzdHlsZU5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBzdHlsZVZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5oYXNTdHlsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVOYW1lXG4gICAgICogQHBhcmFtIHs/PX0gc3R5bGVWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRoaXMuZ2V0U3R5bGUoZWxlbWVudCwgc3R5bGVOYW1lKSB8fCAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlVmFsdWUgPyB2YWx1ZSA9PSBzdHlsZVZhbHVlIDogdmFsdWUubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IGV2dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IGV2dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBldnQpIHtcbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIHdpbmRvdyBhbHNvLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkb2MgPSBlbC5vd25lckRvY3VtZW50IHx8IGVsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3aW4gPSAoLyoqIEB0eXBlIHs/fSAqLyAoZG9jKSkuZGVmYXVsdFZpZXc7XG4gICAgICAgIGlmICh3aW4pIHtcbiAgICAgICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuZ2V0SGlzdG9yeSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB0aHJvdyBfbm90SW1wbGVtZW50ZWQoJ2dldEhpc3RvcnknKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmdldExvY2F0aW9uID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHRocm93IF9ub3RJbXBsZW1lbnRlZCgnZ2V0TG9jYXRpb24nKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmdldFVzZXJBZ2VudCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Zha2UgdXNlciBhZ2VudCc7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c1dlYkFuaW1hdGlvbiA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5wZXJmb3JtYW5jZU5vdyA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gRGF0ZS5ub3coKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmdldEFuaW1hdGlvblByZWZpeCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uRW5kID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAndHJhbnNpdGlvbmVuZCc7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c0FuaW1hdGlvbiA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5nZXREaXN0cmlidXRlZE5vZGVzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsKSB7IHRocm93IF9ub3RJbXBsZW1lbnRlZCgnZ2V0RGlzdHJpYnV0ZWROb2RlcycpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9taW5vQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNDb29raWVzID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbWlub0FkYXB0ZXIucHJvdG90eXBlLmdldENvb2tpZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUpIHsgdGhyb3cgX25vdEltcGxlbWVudGVkKCdnZXRDb29raWUnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21pbm9BZGFwdGVyLnByb3RvdHlwZS5zZXRDb29raWUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHsgdGhyb3cgX25vdEltcGxlbWVudGVkKCdzZXRDb29raWUnKTsgfTtcbiAgICByZXR1cm4gRG9taW5vQWRhcHRlcjtcbn0oX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1QnJvd3NlckRvbUFkYXB0ZXIpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBwbGF0Zm9ybSBzdGF0ZS5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIFBsYXRmb3JtU3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhdGZvcm1TdGF0ZShfZG9jKSB7XG4gICAgICAgIHRoaXMuX2RvYyA9IF9kb2M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHBsYXRmb3JtIHRvIHN0cmluZy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBwbGF0Zm9ybSB0byBzdHJpbmcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGF0Zm9ybVN0YXRlLnByb3RvdHlwZS5yZW5kZXJUb1N0cmluZyA9IC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHBsYXRmb3JtIHRvIHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcmlhbGl6ZURvY3VtZW50KHRoaXMuX2RvYyk7IH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBET00gc3RhdGUuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBET00gc3RhdGUuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGF0Zm9ybVN0YXRlLnByb3RvdHlwZS5nZXREb2N1bWVudCA9IC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgRE9NIHN0YXRlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG9jOyB9O1xuICAgIFBsYXRmb3JtU3RhdGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFBsYXRmb3JtU3RhdGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5ET0NVTUVOVCxdIH0sXSB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFBsYXRmb3JtU3RhdGU7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgeGhyMiA9IHJlcXVpcmUoJ3hocjInKTtcbnZhciBpc0Fic29sdXRlVXJsID0gL15bYS16QS1aXFwtXFwrLl0rOlxcL1xcLy87XG4vKipcbiAqIEBwYXJhbSB7P30gdXJsXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJlcXVlc3RVcmwodXJsJCQxKSB7XG4gICAgaWYgKCFpc0Fic29sdXRlVXJsLnRlc3QodXJsJCQxKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkxzIHJlcXVlc3RlZCB2aWEgSHR0cCBvbiB0aGUgc2VydmVyIG11c3QgYmUgYWJzb2x1dGUuIFVSTDogXCIgKyB1cmwkJDEpO1xuICAgIH1cbn1cbnZhciBTZXJ2ZXJYaHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VydmVyWGhyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclhoci5wcm90b3R5cGUuYnVpbGQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyB4aHIyLlhNTEh0dHBSZXF1ZXN0KCk7IH07XG4gICAgU2VydmVyWGhyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBTZXJ2ZXJYaHIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gU2VydmVyWGhyO1xufSgpKTtcbnZhciBTZXJ2ZXJYc3JmU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VydmVyWHNyZlN0cmF0ZWd5KCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyWHNyZlN0cmF0ZWd5LnByb3RvdHlwZS5jb25maWd1cmVSZXF1ZXN0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXEpIHsgfTtcbiAgICBTZXJ2ZXJYc3JmU3RyYXRlZ3kuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlcnZlclhzcmZTdHJhdGVneS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBTZXJ2ZXJYc3JmU3RyYXRlZ3k7XG59KCkpO1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIFpvbmVNYWNyb1Rhc2tXcmFwcGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFpvbmVNYWNyb1Rhc2tXcmFwcGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFpvbmVNYWNyb1Rhc2tXcmFwcGVyLnByb3RvdHlwZS53cmFwID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFzayA9IC8qKiBAdHlwZSB7P30gKi8gKChudWxsKSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1YiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzYXZlZFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzYXZlZEVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjaGVkdWxlVGFzayA9IGZ1bmN0aW9uIChfdGFzaykge1xuICAgICAgICAgICAgICAgIHRhc2sgPSBfdGFzaztcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGVnYXRlID0gX3RoaXMuZGVsZWdhdGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgc3ViID0gZGVsZWdhdGUuc3Vic2NyaWJlKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHNhdmVkUmVzdWx0ID0gcmVzOyB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGh0dHAgb2JzZXJ2YWJsZSB3YXMgY29tcGxldGVkIHR3aWNlLiBUaGlzIHNob3VsZG5cXCd0IGhhcHBlbiwgcGxlYXNlIGZpbGUgYSBidWcuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2F2ZWRFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRhc2suaW52b2tlKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBodHRwIG9ic2VydmFibGUgd2FzIGNvbXBsZXRlZCB0d2ljZS4gVGhpcyBzaG91bGRuXFwndCBoYXBwZW4sIHBsZWFzZSBmaWxlIGEgYnVnLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLmludm9rZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhbmNlbFRhc2sgPSBmdW5jdGlvbiAoX3Rhc2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhdmVkRXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3Ioc2F2ZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHNhdmVkUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gTW9ja0JhY2tlbmQgZm9yIEh0dHAgaXMgc3luY2hyb25vdXMsIHdoaWNoIG1lYW5zIHRoYXQgaWYgc2NoZWR1bGVUYXNrIGlzIGJ5XG4gICAgICAgICAgICAvLyBzY2hlZHVsZU1hY3JvVGFzaywgdGhlIHJlcXVlc3Qgd2lsbCBoaXQgTW9ja0JhY2tlbmQgYW5kIHRoZSByZXNwb25zZSB3aWxsIGJlXG4gICAgICAgICAgICAvLyBzZW50LCBjYXVzaW5nIHRhc2suaW52b2tlKCkgdG8gYmUgY2FsbGVkLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gX3Rhc2sgPSBab25lLmN1cnJlbnQuc2NoZWR1bGVNYWNyb1Rhc2soJ1pvbmVNYWNyb1Rhc2tXcmFwcGVyLnN1YnNjcmliZScsIG9uQ29tcGxldGUsIHt9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LCBjYW5jZWxUYXNrKTtcbiAgICAgICAgICAgIHNjaGVkdWxlVGFzayhfdGFzayk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZWQgJiYgdGFzaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnpvbmUuY2FuY2VsVGFzayh0YXNrKTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWm9uZU1hY3JvVGFza1dyYXBwZXI7XG59KCkpO1xudmFyIFpvbmVNYWNyb1Rhc2tDb25uZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhab25lTWFjcm9UYXNrQ29ubmVjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBab25lTWFjcm9UYXNrQ29ubmVjdGlvbihyZXF1ZXN0LCBiYWNrZW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICBfdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgdmFsaWRhdGVSZXF1ZXN0VXJsKHJlcXVlc3QudXJsKTtcbiAgICAgICAgX3RoaXMucmVzcG9uc2UgPSBfdGhpcy53cmFwKHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWm9uZU1hY3JvVGFza0Nvbm5lY3Rpb24ucHJvdG90eXBlLmRlbGVnYXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uID0gdGhpcy5iYWNrZW5kLmNyZWF0ZUNvbm5lY3Rpb24ocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUgez99ICovICh0aGlzLmxhc3RDb25uZWN0aW9uLnJlc3BvbnNlKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShab25lTWFjcm9UYXNrQ29ubmVjdGlvbi5wcm90b3R5cGUsIFwicmVhZHlTdGF0ZVwiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmxhc3RDb25uZWN0aW9uID8gdGhpcy5sYXN0Q29ubmVjdGlvbi5yZWFkeVN0YXRlIDogX2FuZ3VsYXJfaHR0cC5SZWFkeVN0YXRlLlVuc2VudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFpvbmVNYWNyb1Rhc2tDb25uZWN0aW9uO1xufShab25lTWFjcm9UYXNrV3JhcHBlcikpO1xudmFyIFpvbmVNYWNyb1Rhc2tCYWNrZW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFpvbmVNYWNyb1Rhc2tCYWNrZW5kKGJhY2tlbmQpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBab25lTWFjcm9UYXNrQmFja2VuZC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab25lTWFjcm9UYXNrQ29ubmVjdGlvbihyZXF1ZXN0LCB0aGlzLmJhY2tlbmQpO1xuICAgIH07XG4gICAgcmV0dXJuIFpvbmVNYWNyb1Rhc2tCYWNrZW5kO1xufSgpKTtcbnZhciBab25lQ2xpZW50QmFja2VuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9uZUNsaWVudEJhY2tlbmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWm9uZUNsaWVudEJhY2tlbmQoYmFja2VuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFpvbmVDbGllbnRCYWNrZW5kLnByb3RvdHlwZS5oYW5kbGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXF1ZXN0KSB7IHJldHVybiB0aGlzLndyYXAocmVxdWVzdCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBab25lQ2xpZW50QmFja2VuZC5wcm90b3R5cGUuZGVsZWdhdGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuaGFuZGxlKHJlcXVlc3QpO1xuICAgIH07XG4gICAgcmV0dXJuIFpvbmVDbGllbnRCYWNrZW5kO1xufShab25lTWFjcm9UYXNrV3JhcHBlcikpO1xuLyoqXG4gKiBAcGFyYW0gez99IHhockJhY2tlbmRcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaHR0cEZhY3RvcnkoeGhyQmFja2VuZCwgb3B0aW9ucykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hY3JvQmFja2VuZCA9IG5ldyBab25lTWFjcm9UYXNrQmFja2VuZCh4aHJCYWNrZW5kKTtcbiAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2h0dHAuSHR0cChtYWNyb0JhY2tlbmQsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGJhY2tlbmRcbiAqIEBwYXJhbSB7P30gaW50ZXJjZXB0b3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB6b25lV3JhcHBlZEludGVyY2VwdGluZ0hhbmRsZXIoYmFja2VuZCwgaW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVhbEJhY2tlbmQgPSBfYW5ndWxhcl9jb21tb25faHR0cC7JtWludGVyY2VwdGluZ0hhbmRsZXIoYmFja2VuZCwgaW50ZXJjZXB0b3JzKTtcbiAgICByZXR1cm4gbmV3IFpvbmVDbGllbnRCYWNrZW5kKHJlYWxCYWNrZW5kKTtcbn1cbnZhciBTRVJWRVJfSFRUUF9QUk9WSURFUlMgPSBbXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9odHRwLkh0dHAsIHVzZUZhY3Rvcnk6IGh0dHBGYWN0b3J5LCBkZXBzOiBbX2FuZ3VsYXJfaHR0cC5YSFJCYWNrZW5kLCBfYW5ndWxhcl9odHRwLlJlcXVlc3RPcHRpb25zXSB9LFxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfaHR0cC5Ccm93c2VyWGhyLCB1c2VDbGFzczogU2VydmVyWGhyIH0sIHsgcHJvdmlkZTogX2FuZ3VsYXJfaHR0cC5YU1JGU3RyYXRlZ3ksIHVzZUNsYXNzOiBTZXJ2ZXJYc3JmU3RyYXRlZ3kgfSxcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvbW1vbl9odHRwLlhockZhY3RvcnksIHVzZUNsYXNzOiBTZXJ2ZXJYaHIgfSwge1xuICAgICAgICBwcm92aWRlOiBfYW5ndWxhcl9jb21tb25faHR0cC5IdHRwSGFuZGxlcixcbiAgICAgICAgdXNlRmFjdG9yeTogem9uZVdyYXBwZWRJbnRlcmNlcHRpbmdIYW5kbGVyLFxuICAgICAgICBkZXBzOiBbX2FuZ3VsYXJfY29tbW9uX2h0dHAuSHR0cEJhY2tlbmQsIFtuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBfYW5ndWxhcl9jb21tb25faHR0cC5IVFRQX0lOVEVSQ0VQVE9SU11dXG4gICAgfVxuXTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDb25maWcgb2JqZWN0IHBhc3NlZCB0byBpbml0aWFsaXplIHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqIEByZWNvcmRcbiAqL1xuXG4vKipcbiAqIFRoZSBESSB0b2tlbiBmb3Igc2V0dGluZyB0aGUgaW5pdGlhbCBjb25maWcgZm9yIHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIElOSVRJQUxfQ09ORklHID0gbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0aW9uVG9rZW4oJ1NlcnZlci5JTklUSUFMX0NPTkZJRycpO1xuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGNhbGxpbmcgYHJlbmRlck1vZHVsZUZhY3RvcnlgIG9yIGByZW5kZXJNb2R1bGVgIGp1c3RcbiAqIGJlZm9yZSBjdXJyZW50IHBsYXRmb3JtIHN0YXRlIGlzIHJlbmRlcmVkIHRvIHN0cmluZy5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIEJFRk9SRV9BUFBfU0VSSUFMSVpFRCA9IG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdGlvblRva2VuKCdTZXJ2ZXIuUkVOREVSX01PRFVMRV9IT09LJyk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSB1cmxTdHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVXJsKHVybFN0cikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnNlZFVybCA9IHVybC5wYXJzZSh1cmxTdHIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXJzZWRVcmwucGF0aG5hbWUgfHwgJycsXG4gICAgICAgIHNlYXJjaDogcGFyc2VkVXJsLnNlYXJjaCB8fCAnJyxcbiAgICAgICAgaGFzaDogcGFyc2VkVXJsLmhhc2ggfHwgJycsXG4gICAgfTtcbn1cbi8qKlxuICogU2VydmVyLXNpZGUgaW1wbGVtZW50YXRpb24gb2YgVVJMIHN0YXRlLiBJbXBsZW1lbnRzIGBwYXRobmFtZWAsIGBzZWFyY2hgLCBhbmQgYGhhc2hgXG4gKiBidXQgbm90IHRoZSBzdGF0ZSBzdGFjay5cbiAqL1xudmFyIFNlcnZlclBsYXRmb3JtTG9jYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VydmVyUGxhdGZvcm1Mb2NhdGlvbihfZG9jLCBfY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2RvYyA9IF9kb2M7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMuaGFzaCA9ICcnO1xuICAgICAgICB0aGlzLl9oYXNoVXBkYXRlID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmZpZyA9IC8qKiBAdHlwZSB7P30gKi8gKF9jb25maWcpO1xuICAgICAgICBpZiAoISFjb25maWcgJiYgISFjb25maWcudXJsKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJzZWRVcmwgPSBwYXJzZVVybChjb25maWcudXJsKTtcbiAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWU7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaCA9IHBhcnNlZFVybC5zZWFyY2g7XG4gICAgICAgICAgICB0aGlzLmhhc2ggPSBwYXJzZWRVcmwuaGFzaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmdldEJhc2VIcmVmRnJvbURPTSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAoKF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmdldEJhc2VIcmVmKHRoaXMuX2RvYykpKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5vblBvcFN0YXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIC8vIE5vLW9wOiBhIHN0YXRlIHN0YWNrIGlzIG5vdCBpbXBsZW1lbnRlZCwgc29cbiAgICAgICAgLy8gbm8gZXZlbnRzIHdpbGwgZXZlciBjb21lLlxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUub25IYXNoQ2hhbmdlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZuKSB7IHRoaXMuX2hhc2hVcGRhdGUuc3Vic2NyaWJlKGZuKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwidXJsXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiXCIgKyB0aGlzLnBhdGhuYW1lICsgdGhpcy5zZWFyY2ggKyB0aGlzLmhhc2g7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG9sZFVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuc2V0SGFzaCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG9sZFVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZhbHVlLCBvbGRVcmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaGFzaCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIHRoZSBoYXNoIGhhcyBub3QgY2hhbmdlZC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcykpLmhhc2ggPSB2YWx1ZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3VXJsID0gdGhpcy51cmw7XG4gICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9oYXNoVXBkYXRlLm5leHQoLyoqIEB0eXBlIHs/fSAqLyAoeyB0eXBlOiAnaGFzaGNoYW5nZScsIG9sZFVybDogb2xkVXJsLCBuZXdVcmw6IG5ld1VybCB9KSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gdGl0bGVcbiAgICAgKiBAcGFyYW0gez99IG5ld1VybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gdGl0bGVcbiAgICAgKiBAcGFyYW0gez99IG5ld1VybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgbmV3VXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZFVybCA9IHRoaXMudXJsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJzZWRVcmwgPSBwYXJzZVVybChuZXdVcmwpO1xuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcykpLnBhdGhuYW1lID0gcGFyc2VkVXJsLnBhdGhuYW1lO1xuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcykpLnNlYXJjaCA9IHBhcnNlZFVybC5zZWFyY2g7XG4gICAgICAgIHRoaXMuc2V0SGFzaChwYXJzZWRVcmwuaGFzaCwgb2xkVXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVcbiAgICAgKiBAcGFyYW0gez99IHRpdGxlXG4gICAgICogQHBhcmFtIHs/fSBuZXdVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLnB1c2hTdGF0ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVcbiAgICAgKiBAcGFyYW0gez99IHRpdGxlXG4gICAgICogQHBhcmFtIHs/fSBuZXdVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIG5ld1VybCkge1xuICAgICAgICB0aGlzLnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIG5ld1VybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmZvcndhcmQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmJhY2sgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTsgfTtcbiAgICBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBTZXJ2ZXJQbGF0Zm9ybUxvY2F0aW9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsXSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW0lOSVRJQUxfQ09ORklHLF0gfSxdIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gU2VydmVyUGxhdGZvcm1Mb2NhdGlvbjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gZm5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNjaGVkdWxlTWljcm9UYXNrKGZuKSB7XG4gICAgWm9uZS5jdXJyZW50LnNjaGVkdWxlTWljcm9UYXNrKCdzY2hlZHVsZU1pY3JvdGFzaycsIGZuKTtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEVNUFRZX0FSUkFZID0gW107XG52YXIgU2VydmVyUmVuZGVyZXJGYWN0b3J5MiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyKG5nWm9uZSwgZG9jdW1lbnQsIHNoYXJlZFN0eWxlc0hvc3QpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5zaGFyZWRTdHlsZXNIb3N0ID0gc2hhcmVkU3R5bGVzSG9zdDtcbiAgICAgICAgdGhpcy5yZW5kZXJlckJ5Q29tcElkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IG5ldyBfYW5ndWxhcl9jb21waWxlci5Eb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0UmVuZGVyZXIgPSBuZXcgRGVmYXVsdFNlcnZlclJlbmRlcmVyMihkb2N1bWVudCwgbmdab25lLCB0aGlzLnNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VydmVyUmVuZGVyZXJGYWN0b3J5Mi5wcm90b3R5cGUuY3JlYXRlUmVuZGVyZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCB0eXBlKSB7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHlwZS5lbmNhcHN1bGF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTmF0aXZlOlxuICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkOiB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyQnlDb21wSWQuZ2V0KHR5cGUuaWQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIgPSBuZXcgRW11bGF0ZWRFbmNhcHN1bGF0aW9uU2VydmVyUmVuZGVyZXIyKHRoaXMuZG9jdW1lbnQsIHRoaXMubmdab25lLCB0aGlzLnNoYXJlZFN0eWxlc0hvc3QsIHRoaXMuc2NoZW1hLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlckJ5Q29tcElkLnNldCh0eXBlLmlkLCByZW5kZXJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICgvKiogQHR5cGUgez99ICovIChyZW5kZXJlcikpLmFwcGx5VG9Ib3N0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmU6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgZW5jYXBzdWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoZSBzZXJ2ZXIhJyk7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyQnlDb21wSWQuaGFzKHR5cGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWZsYXR0ZW5TdHlsZXModHlwZS5pZCwgdHlwZS5zdHlsZXMsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFyZWRTdHlsZXNIb3N0LmFkZFN0eWxlcyhzdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyQnlDb21wSWQuc2V0KHR5cGUuaWQsIHRoaXMuZGVmYXVsdFJlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcnZlclJlbmRlcmVyRmFjdG9yeTIucHJvdG90eXBlLmJlZ2luID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyLnByb3RvdHlwZS5lbmQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgfTtcbiAgICBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsXSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVTaGFyZWRTdHlsZXNIb3N0LCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlcnZlclJlbmRlcmVyRmFjdG9yeTI7XG59KCkpO1xudmFyIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdFNlcnZlclJlbmRlcmVyMihkb2N1bWVudCwgbmdab25lLCBzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUsIG5hbWVzcGFjZSwgZGVidWdJbmZvKSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5jcmVhdGVFbGVtZW50TlMoX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1TkFNRVNQQUNFX1VSSVNbbmFtZXNwYWNlXSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmNyZWF0ZUVsZW1lbnQobmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5jcmVhdGVDb21tZW50ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZhbHVlLCBkZWJ1Z0luZm8pIHsgcmV0dXJuIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmNyZWF0ZUNvbW1lbnQodmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBkZWJ1Z0luZm9cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLmNyZWF0ZVRleHQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodmFsdWUsIGRlYnVnSW5mbykgeyByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuY3JlYXRlVGV4dE5vZGUodmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gbmV3Q2hpbGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJlbnQsIG5ld0NoaWxkKSB7IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmFwcGVuZENoaWxkKHBhcmVudCwgbmV3Q2hpbGQpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxuICAgICAqIEBwYXJhbSB7P30gcmVmQ2hpbGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxuICAgICAqIEBwYXJhbSB7P30gcmVmQ2hpbGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJlbnQsIG5ld0NoaWxkLCByZWZDaGlsZCkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5pbnNlcnRCZWZvcmUocGFyZW50LCByZWZDaGlsZCwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gb2xkQ2hpbGRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG9sZENoaWxkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFyZW50LCBvbGRDaGlsZCkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5yZW1vdmVDaGlsZChwYXJlbnQsIG9sZENoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3Rvck9yTm9kZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuc2VsZWN0Um9vdEVsZW1lbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yT3JOb2RlXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbDtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rvck9yTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVsID0gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucXVlcnlTZWxlY3Rvcih0aGlzLmRvY3VtZW50LCBzZWxlY3Rvck9yTm9kZSk7XG4gICAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlbGVjdG9yIFxcXCJcIiArIHNlbGVjdG9yT3JOb2RlICsgXCJcXFwiIGRpZCBub3QgbWF0Y2ggYW55IGVsZW1lbnRzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwgPSBzZWxlY3Rvck9yTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5jbGVhck5vZGVzKGVsKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5wYXJlbnROb2RlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucGFyZW50RWxlbWVudChub2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLm5leHRTaWJsaW5nID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkubmV4dFNpYmxpbmcobm9kZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuc2V0QXR0cmlidXRlTlMoZWwsIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtU5BTUVTUEFDRV9VUklTW25hbWVzcGFjZV0sIG5hbWVzcGFjZSArICc6JyArIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnNldEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIG5hbWVzcGFjZSkge1xuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5yZW1vdmVBdHRyaWJ1dGVOUyhlbCwgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1TkFNRVNQQUNFX1VSSVNbbmFtZXNwYWNlXSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5yZW1vdmVBdHRyaWJ1dGUoZWwsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5hZGRDbGFzcyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbCwgbmFtZSkgeyBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5hZGRDbGFzcyhlbCwgbmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUpIHsgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucmVtb3ZlQ2xhc3MoZWwsIG5hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gZmxhZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnNldFN0eWxlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBzdHlsZSwgdmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnNldFN0eWxlKGVsLCBzdHlsZSwgdmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcbiAgICAgKiBAcGFyYW0gez99IGZsYWdzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5yZW1vdmVTdHlsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHBhcmFtIHs/fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBzdHlsZSwgZmxhZ3MpIHtcbiAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkucmVtb3ZlU3R5bGUoZWwsIHN0eWxlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5faXNTYWZlVG9SZWZsZWN0UHJvcGVydHkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHRhZ05hbWVcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5TmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEuc2VjdXJpdHlDb250ZXh0KHRhZ05hbWUsIHByb3BlcnR5TmFtZSwgdHJ1ZSkgPT09XG4gICAgICAgICAgICB0aGlzLnNjaGVtYS5zZWN1cml0eUNvbnRleHQodGFnTmFtZSwgcHJvcGVydHlOYW1lLCBmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdFNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBjaGVja05vU3ludGhldGljUHJvcChuYW1lLCAncHJvcGVydHknKTtcbiAgICAgICAgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCkuc2V0UHJvcGVydHkoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgLy8gTWlycm9yIHByb3BlcnR5IHZhbHVlcyBmb3Iga25vd24gSFRNTCBlbGVtZW50IHByb3BlcnRpZXMgaW4gdGhlIGF0dHJpYnV0ZXMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ05hbWUgPSAoLyoqIEB0eXBlIHs/fSAqLyAoZWwudGFnTmFtZSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hLmhhc0VsZW1lbnQodGFnTmFtZSwgRU1QVFlfQVJSQVkpICYmXG4gICAgICAgICAgICB0aGlzLnNjaGVtYS5oYXNQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lLCBFTVBUWV9BUlJBWSkgJiZcbiAgICAgICAgICAgIHRoaXMuX2lzU2FmZVRvUmVmbGVjdFByb3BlcnR5KHRhZ05hbWUsIG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLnNldFZhbHVlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLnNldFRleHQobm9kZSwgdmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWZhdWx0U2VydmVyUmVuZGVyZXIyLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBOb3RlOiBXZSBhcmUgbm90IHVzaW5nIHRoZSBFdmVudHNQbHVnaW4gaGVyZSBhcyB0aGlzIGlzIG5vdCBuZWVkZWRcbiAgICAgICAgLy8gdG8gcnVuIG91ciB0ZXN0cy5cbiAgICAgICAgY2hlY2tOb1N5bnRoZXRpY1Byb3AoZXZlbnROYW1lLCAnbGlzdGVuZXInKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWwgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmdldEdsb2JhbEV2ZW50VGFyZ2V0KHRoaXMuZG9jdW1lbnQsIHRhcmdldCkgOiB0YXJnZXQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHNpZGVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5uZ1pvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCk7IH0pOyB9O1xuICAgICAgICByZXR1cm4gdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gKF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLm9uQW5kQ2FuY2VsKGVsLCBldmVudE5hbWUsIG91dHNpZGVIYW5kbGVyKSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRTZXJ2ZXJSZW5kZXJlcjI7XG59KCkpO1xudmFyIEFUX0NIQVJDT0RFID0gJ0AnLmNoYXJDb2RlQXQoMCk7XG4vKipcbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHBhcmFtIHs/fSBuYW1lS2luZFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2hlY2tOb1N5bnRoZXRpY1Byb3AobmFtZSwgbmFtZUtpbmQpIHtcbiAgICBpZiAobmFtZS5jaGFyQ29kZUF0KDApID09PSBBVF9DSEFSQ09ERSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3VuZCB0aGUgc3ludGhldGljIFwiICsgbmFtZUtpbmQgKyBcIiBcIiArIG5hbWUgKyBcIi4gUGxlYXNlIGluY2x1ZGUgZWl0aGVyIFxcXCJCcm93c2VyQW5pbWF0aW9uc01vZHVsZVxcXCIgb3IgXFxcIk5vb3BBbmltYXRpb25zTW9kdWxlXFxcIiBpbiB5b3VyIGFwcGxpY2F0aW9uLlwiKTtcbiAgICB9XG59XG52YXIgRW11bGF0ZWRFbmNhcHN1bGF0aW9uU2VydmVyUmVuZGVyZXIyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbXVsYXRlZEVuY2Fwc3VsYXRpb25TZXJ2ZXJSZW5kZXJlcjIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW11bGF0ZWRFbmNhcHN1bGF0aW9uU2VydmVyUmVuZGVyZXIyKGRvY3VtZW50LCBuZ1pvbmUsIHNoYXJlZFN0eWxlc0hvc3QsIHNjaGVtYSwgY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBuZ1pvbmUsIHNjaGVtYSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVmbGF0dGVuU3R5bGVzKGNvbXBvbmVudC5pZCwgY29tcG9uZW50LnN0eWxlcywgW10pO1xuICAgICAgICBzaGFyZWRTdHlsZXNIb3N0LmFkZFN0eWxlcyhzdHlsZXMpO1xuICAgICAgICBfdGhpcy5jb250ZW50QXR0ciA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtXNoaW1Db250ZW50QXR0cmlidXRlKGNvbXBvbmVudC5pZCk7XG4gICAgICAgIF90aGlzLmhvc3RBdHRyID0gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1c2hpbUhvc3RBdHRyaWJ1dGUoY29tcG9uZW50LmlkKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtdWxhdGVkRW5jYXBzdWxhdGlvblNlcnZlclJlbmRlcmVyMi5wcm90b3R5cGUuYXBwbHlUb0hvc3QgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7IF9zdXBlci5wcm90b3R5cGUuc2V0QXR0cmlidXRlLmNhbGwodGhpcywgZWxlbWVudCwgdGhpcy5ob3N0QXR0ciwgJycpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbXVsYXRlZEVuY2Fwc3VsYXRpb25TZXJ2ZXJSZW5kZXJlcjIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBhcmVudCwgbmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IF9zdXBlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudC5jYWxsKHRoaXMsIHBhcmVudCwgbmFtZSk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0QXR0cmlidXRlLmNhbGwodGhpcywgZWwsIHRoaXMuY29udGVudEF0dHIsICcnKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgcmV0dXJuIEVtdWxhdGVkRW5jYXBzdWxhdGlvblNlcnZlclJlbmRlcmVyMjtcbn0oRGVmYXVsdFNlcnZlclJlbmRlcmVyMikpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU2VydmVyU3R5bGVzSG9zdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VydmVyU3R5bGVzSG9zdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXJ2ZXJTdHlsZXNIb3N0KGRvYywgdHJhbnNpdGlvbklkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRvYyA9IGRvYztcbiAgICAgICAgX3RoaXMudHJhbnNpdGlvbklkID0gdHJhbnNpdGlvbklkO1xuICAgICAgICBfdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaGVhZCA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpLmdldEVsZW1lbnRzQnlUYWdOYW1lKGRvYywgJ2hlYWQnKVswXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJTdHlsZXNIb3N0LnByb3RvdHlwZS5fYWRkU3R5bGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWRhcHRlciA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtWdldERPTSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IGFkYXB0ZXIuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgYWRhcHRlci5zZXRUZXh0KGVsLCBzdHlsZSk7XG4gICAgICAgIGlmICghIXRoaXMudHJhbnNpdGlvbklkKSB7XG4gICAgICAgICAgICBhZGFwdGVyLnNldEF0dHJpYnV0ZShlbCwgJ25nLXRyYW5zaXRpb24nLCB0aGlzLnRyYW5zaXRpb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRhcHRlci5hcHBlbmRDaGlsZCh0aGlzLmhlYWQsIGVsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYWRkaXRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJ2ZXJTdHlsZXNIb3N0LnByb3RvdHlwZS5vblN0eWxlc0FkZGVkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhZGRpdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhZGRpdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYWRkaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7IHJldHVybiBfdGhpcy5fYWRkU3R5bGUoc3R5bGUpOyB9KTtcbiAgICB9O1xuICAgIFNlcnZlclN0eWxlc0hvc3QuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlcnZlclN0eWxlc0hvc3QuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5ET0NVTUVOVCxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1VFJBTlNJVElPTl9JRCxdIH0sXSB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlcnZlclN0eWxlc0hvc3Q7XG59KF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtVNoYXJlZFN0eWxlc0hvc3QpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIElOVEVSTkFMX1NFUlZFUl9QTEFURk9STV9QUk9WSURFUlMgPSBbXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsIHVzZUZhY3Rvcnk6IF9kb2N1bWVudCwgZGVwczogW19hbmd1bGFyX2NvcmUuSW5qZWN0b3JdIH0sXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlBMQVRGT1JNX0lELCB1c2VWYWx1ZTogX2FuZ3VsYXJfY29tbW9uLsm1UExBVEZPUk1fU0VSVkVSX0lEIH0sXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlBMQVRGT1JNX0lOSVRJQUxJWkVSLCB1c2VGYWN0b3J5OiBpbml0RG9taW5vQWRhcHRlciwgbXVsdGk6IHRydWUsIGRlcHM6IFtfYW5ndWxhcl9jb3JlLkluamVjdG9yXSB9LCB7XG4gICAgICAgIHByb3ZpZGU6IF9hbmd1bGFyX2NvbW1vbi5QbGF0Zm9ybUxvY2F0aW9uLFxuICAgICAgICB1c2VDbGFzczogU2VydmVyUGxhdGZvcm1Mb2NhdGlvbixcbiAgICAgICAgZGVwczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5ET0NVTUVOVCwgW19hbmd1bGFyX2NvcmUuT3B0aW9uYWwsIElOSVRJQUxfQ09ORklHXV1cbiAgICB9LFxuICAgIHsgcHJvdmlkZTogUGxhdGZvcm1TdGF0ZSwgZGVwczogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5ET0NVTUVOVF0gfSxcbiAgICAvLyBBZGQgc3BlY2lhbCBwcm92aWRlciB0aGF0IGFsbG93cyBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgcGxhdGZvcm1TZXJ2ZXIqIHRvIGJlIGNyZWF0ZWQuXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLsm1QUxMT1dfTVVMVElQTEVfUExBVEZPUk1TLCB1c2VWYWx1ZTogdHJ1ZSB9XG5dO1xuLyoqXG4gKiBAcGFyYW0gez99IGluamVjdG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbml0RG9taW5vQWRhcHRlcihpbmplY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IERvbWlub0FkYXB0ZXIubWFrZUN1cnJlbnQoKTsgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSByZW5kZXJlclxuICogQHBhcmFtIHs/fSBlbmdpbmVcbiAqIEBwYXJhbSB7P30gem9uZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVTZXJ2ZXJSZW5kZXJlckZhY3RvcnkocmVuZGVyZXIsIGVuZ2luZSwgem9uZSkge1xuICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyX2FuaW1hdGlvbnMuybVBbmltYXRpb25SZW5kZXJlckZhY3RvcnkocmVuZGVyZXIsIGVuZ2luZSwgem9uZSk7XG59XG52YXIgU0VSVkVSX1JFTkRFUl9QUk9WSURFUlMgPSBbXG4gICAgU2VydmVyUmVuZGVyZXJGYWN0b3J5MixcbiAgICB7XG4gICAgICAgIHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJGYWN0b3J5MixcbiAgICAgICAgdXNlRmFjdG9yeTogaW5zdGFudGlhdGVTZXJ2ZXJSZW5kZXJlckZhY3RvcnksXG4gICAgICAgIGRlcHM6IFtTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyLCBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuybVBbmltYXRpb25FbmdpbmUsIF9hbmd1bGFyX2NvcmUuTmdab25lXVxuICAgIH0sXG4gICAgU2VydmVyU3R5bGVzSG9zdCxcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci7JtVNoYXJlZFN0eWxlc0hvc3QsIHVzZUV4aXN0aW5nOiBTZXJ2ZXJTdHlsZXNIb3N0IH0sXG5dO1xuLyoqXG4gKiBUaGUgbmcgbW9kdWxlIGZvciB0aGUgc2VydmVyLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgU2VydmVyTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZlck1vZHVsZSgpIHtcbiAgICB9XG4gICAgU2VydmVyTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW19hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5Ccm93c2VyTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2h0dHAuSHR0cE1vZHVsZSwgX2FuZ3VsYXJfY29tbW9uX2h0dHAuSHR0cENsaWVudE1vZHVsZSwgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyX2FuaW1hdGlvbnMuTm9vcEFuaW1hdGlvbnNNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNFUlZFUl9SRU5ERVJfUFJPVklERVJTLFxuICAgICAgICAgICAgICAgICAgICAgICAgU0VSVkVSX0hUVFBfUFJPVklERVJTLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlRlc3RhYmlsaXR5LCB1c2VWYWx1ZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VydmVyTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIFNlcnZlck1vZHVsZTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5qZWN0b3JcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9kb2N1bWVudChpbmplY3Rvcikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmZpZyA9IGluamVjdG9yLmdldChJTklUSUFMX0NPTkZJRywgbnVsbCk7XG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcuZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRG9jdW1lbnQoY29uZmlnLmRvY3VtZW50LCBjb25maWcudXJsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVnZXRET00oKS5jcmVhdGVIdG1sRG9jdW1lbnQoKTtcbiAgICB9XG59XG4vKipcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgcGxhdGZvcm1TZXJ2ZXIgPSBfYW5ndWxhcl9jb3JlLmNyZWF0ZVBsYXRmb3JtRmFjdG9yeShfYW5ndWxhcl9jb3JlLnBsYXRmb3JtQ29yZSwgJ3NlcnZlcicsIElOVEVSTkFMX1NFUlZFUl9QTEFURk9STV9QUk9WSURFUlMpO1xuLyoqXG4gKiBUaGUgc2VydmVyIHBsYXRmb3JtIHRoYXQgc3VwcG9ydHMgdGhlIHJ1bnRpbWUgY29tcGlsZXIuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBwbGF0Zm9ybUR5bmFtaWNTZXJ2ZXIgPSBfYW5ndWxhcl9jb3JlLmNyZWF0ZVBsYXRmb3JtRmFjdG9yeShfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXJEeW5hbWljLsm1cGxhdGZvcm1Db3JlRHluYW1pYywgJ3NlcnZlckR5bmFtaWMnLCBJTlRFUk5BTF9TRVJWRVJfUExBVEZPUk1fUFJPVklERVJTKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IGRvY1xuICogQHBhcmFtIHs/fSBhcHBJZFxuICogQHBhcmFtIHs/fSB0cmFuc2ZlclN0b3JlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVUcmFuc2ZlclN0YXRlRmFjdG9yeShkb2MsIGFwcElkLCB0cmFuc2ZlclN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQuaWQgPSBhcHBJZCArICctc3RhdGUnO1xuICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgc2NyaXB0LnRleHRDb250ZW50ID0gX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1ZXNjYXBlSHRtbCh0cmFuc2ZlclN0b3JlLnRvSnNvbigpKTtcbiAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9O1xufVxuLyoqXG4gKiBOZ01vZHVsZSB0byBpbnN0YWxsIG9uIHRoZSBzZXJ2ZXIgc2lkZSB3aGlsZSB1c2luZyB0aGUgYFRyYW5zZmVyU3RhdGVgIHRvIHRyYW5zZmVyIHN0YXRlIGZyb21cbiAqIHNlcnZlciB0byBjbGllbnQuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBTZXJ2ZXJUcmFuc2ZlclN0YXRlTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZlclRyYW5zZmVyU3RhdGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIFNlcnZlclRyYW5zZmVyU3RhdGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5UcmFuc2ZlclN0YXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQkVGT1JFX0FQUF9TRVJJQUxJWkVELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IHNlcmlhbGl6ZVRyYW5zZmVyU3RhdGVGYWN0b3J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHM6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRE9DVU1FTlQsIF9hbmd1bGFyX2NvcmUuQVBQX0lELCBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuVHJhbnNmZXJTdGF0ZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlcnZlclRyYW5zZmVyU3RhdGVNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gU2VydmVyVHJhbnNmZXJTdGF0ZU1vZHVsZTtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBwbGF0Zm9ybUZhY3RvcnlcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2dldFBsYXRmb3JtKHBsYXRmb3JtRmFjdG9yeSwgb3B0aW9ucykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4dHJhUHJvdmlkZXJzID0gb3B0aW9ucy5leHRyYVByb3ZpZGVycyA/IG9wdGlvbnMuZXh0cmFQcm92aWRlcnMgOiBbXTtcbiAgICByZXR1cm4gcGxhdGZvcm1GYWN0b3J5KFtcbiAgICAgICAgeyBwcm92aWRlOiBJTklUSUFMX0NPTkZJRywgdXNlVmFsdWU6IHsgZG9jdW1lbnQ6IG9wdGlvbnMuZG9jdW1lbnQsIHVybDogb3B0aW9ucy51cmwgfSB9LFxuICAgICAgICBleHRyYVByb3ZpZGVyc1xuICAgIF0pO1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSBwbGF0Zm9ybVxuICogQHBhcmFtIHs/fSBtb2R1bGVSZWZQcm9taXNlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfcmVuZGVyKHBsYXRmb3JtLCBtb2R1bGVSZWZQcm9taXNlKSB7XG4gICAgcmV0dXJuIG1vZHVsZVJlZlByb21pc2UudGhlbihmdW5jdGlvbiAobW9kdWxlUmVmKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb25JZCA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLsm1VFJBTlNJVElPTl9JRCwgbnVsbCk7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW5kZXJNb2R1bGVbRmFjdG9yeV0oKSByZXF1aXJlcyB0aGUgdXNlIG9mIEJyb3dzZXJNb2R1bGUud2l0aFNlcnZlclRyYW5zaXRpb24oKSB0byBlbnN1cmVcXG50aGUgc2VydmVyLXJlbmRlcmVkIGFwcCBjYW4gYmUgcHJvcGVybHkgYm9vdHN0cmFwcGVkIGludG8gYSBjbGllbnQgYXBwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcHBsaWNhdGlvblJlZiA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoX2FuZ3VsYXJfY29yZS5BcHBsaWNhdGlvblJlZik7XG4gICAgICAgIHJldHVybiByeGpzX29wZXJhdG9yX3RvUHJvbWlzZS50b1Byb21pc2VcbiAgICAgICAgICAgIC5jYWxsKHJ4anNfb3BlcmF0b3JfZmlyc3QuZmlyc3QuY2FsbChyeGpzX29wZXJhdG9yX2ZpbHRlci5maWx0ZXIuY2FsbChhcHBsaWNhdGlvblJlZi5pc1N0YWJsZSwgZnVuY3Rpb24gKGlzU3RhYmxlKSB7IHJldHVybiBpc1N0YWJsZTsgfSkpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxhdGZvcm1TdGF0ZSA9IHBsYXRmb3JtLmluamVjdG9yLmdldChQbGF0Zm9ybVN0YXRlKTtcbiAgICAgICAgICAgIC8vIFJ1biBhbnkgQkVGT1JFX0FQUF9TRVJJQUxJWkVEIGNhbGxiYWNrcyBqdXN0IGJlZm9yZSByZW5kZXJpbmcgdG8gc3RyaW5nLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FsbGJhY2tzID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChCRUZPUkVfQVBQX1NFUklBTElaRUQsIG51bGwpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY2FsbGJhY2tzXzEgPSBjYWxsYmFja3M7IF9pIDwgY2FsbGJhY2tzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKC8qKiBAdHlwZSB7P30gKi8gZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGV4Y2VwdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0lnbm9yaW5nIEJFRk9SRV9BUFBfU0VSSUFMSVpFRCBFeGNlcHRpb246ICcsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0ID0gcGxhdGZvcm1TdGF0ZS5yZW5kZXJUb1N0cmluZygpO1xuICAgICAgICAgICAgcGxhdGZvcm0uZGVzdHJveSgpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJlbmRlcnMgYSBNb2R1bGUgdG8gc3RyaW5nLlxuICpcbiAqIGBkb2N1bWVudGAgaXMgdGhlIGZ1bGwgZG9jdW1lbnQgSFRNTCBvZiB0aGUgcGFnZSB0byByZW5kZXIsIGFzIGEgc3RyaW5nLlxuICogYHVybGAgaXMgdGhlIFVSTCBmb3IgdGhlIGN1cnJlbnQgcmVuZGVyIHJlcXVlc3QuXG4gKiBgZXh0cmFQcm92aWRlcnNgIGFyZSB0aGUgcGxhdGZvcm0gbGV2ZWwgcHJvdmlkZXJzIGZvciB0aGUgY3VycmVudCByZW5kZXIgcmVxdWVzdC5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgaW4gYSBwcm9kdWN0aW9uIHNlcnZlciBlbnZpcm9ubWVudC4gVXNlIHByZS1jb21waWxlZCB7XFxAbGluayBOZ01vZHVsZUZhY3Rvcnl9IHdpdGhcbiAqIHtcXEBsaW5rIHJlbmRlck1vZHVsZUZhY3Rvcnl9IGluc3RlYWQuXG4gKlxuICogXFxAZXhwZXJpbWVudGFsXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSBtb2R1bGVcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTW9kdWxlKG1vZHVsZSwgb3B0aW9ucykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXRmb3JtID0gX2dldFBsYXRmb3JtKHBsYXRmb3JtRHluYW1pY1NlcnZlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF9yZW5kZXIocGxhdGZvcm0sIHBsYXRmb3JtLmJvb3RzdHJhcE1vZHVsZShtb2R1bGUpKTtcbn1cbi8qKlxuICogUmVuZGVycyBhIHtcXEBsaW5rIE5nTW9kdWxlRmFjdG9yeX0gdG8gc3RyaW5nLlxuICpcbiAqIGBkb2N1bWVudGAgaXMgdGhlIGZ1bGwgZG9jdW1lbnQgSFRNTCBvZiB0aGUgcGFnZSB0byByZW5kZXIsIGFzIGEgc3RyaW5nLlxuICogYHVybGAgaXMgdGhlIFVSTCBmb3IgdGhlIGN1cnJlbnQgcmVuZGVyIHJlcXVlc3QuXG4gKiBgZXh0cmFQcm92aWRlcnNgIGFyZSB0aGUgcGxhdGZvcm0gbGV2ZWwgcHJvdmlkZXJzIGZvciB0aGUgY3VycmVudCByZW5kZXIgcmVxdWVzdC5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IG1vZHVsZUZhY3RvcnlcbiAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTW9kdWxlRmFjdG9yeShtb2R1bGVGYWN0b3J5LCBvcHRpb25zKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxhdGZvcm0gPSBfZ2V0UGxhdGZvcm0ocGxhdGZvcm1TZXJ2ZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBfcmVuZGVyKHBsYXRmb3JtLCBwbGF0Zm9ybS5ib290c3RyYXBNb2R1bGVGYWN0b3J5KG1vZHVsZUZhY3RvcnkpKTtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFxcQHN0YWJsZVxuICovXG52YXIgVkVSU0lPTiA9IG5ldyBfYW5ndWxhcl9jb3JlLlZlcnNpb24oJzUuMi4zJyk7XG5cbmV4cG9ydHMuUGxhdGZvcm1TdGF0ZSA9IFBsYXRmb3JtU3RhdGU7XG5leHBvcnRzLlNlcnZlck1vZHVsZSA9IFNlcnZlck1vZHVsZTtcbmV4cG9ydHMucGxhdGZvcm1EeW5hbWljU2VydmVyID0gcGxhdGZvcm1EeW5hbWljU2VydmVyO1xuZXhwb3J0cy5wbGF0Zm9ybVNlcnZlciA9IHBsYXRmb3JtU2VydmVyO1xuZXhwb3J0cy5CRUZPUkVfQVBQX1NFUklBTElaRUQgPSBCRUZPUkVfQVBQX1NFUklBTElaRUQ7XG5leHBvcnRzLklOSVRJQUxfQ09ORklHID0gSU5JVElBTF9DT05GSUc7XG5leHBvcnRzLlNlcnZlclRyYW5zZmVyU3RhdGVNb2R1bGUgPSBTZXJ2ZXJUcmFuc2ZlclN0YXRlTW9kdWxlO1xuZXhwb3J0cy5yZW5kZXJNb2R1bGUgPSByZW5kZXJNb2R1bGU7XG5leHBvcnRzLnJlbmRlck1vZHVsZUZhY3RvcnkgPSByZW5kZXJNb2R1bGVGYWN0b3J5O1xuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjtcbmV4cG9ydHMuybVJTlRFUk5BTF9TRVJWRVJfUExBVEZPUk1fUFJPVklERVJTID0gSU5URVJOQUxfU0VSVkVSX1BMQVRGT1JNX1BST1ZJREVSUztcbmV4cG9ydHMuybVTRVJWRVJfUkVOREVSX1BST1ZJREVSUyA9IFNFUlZFUl9SRU5ERVJfUFJPVklERVJTO1xuZXhwb3J0cy7JtVNlcnZlclJlbmRlcmVyRmFjdG9yeTIgPSBTZXJ2ZXJSZW5kZXJlckZhY3RvcnkyO1xuZXhwb3J0cy7JtWggPSBTRVJWRVJfSFRUUF9QUk9WSURFUlM7XG5leHBvcnRzLsm1ZCA9IFNlcnZlclhocjtcbmV4cG9ydHMuybVlID0gU2VydmVyWHNyZlN0cmF0ZWd5O1xuZXhwb3J0cy7JtWYgPSBodHRwRmFjdG9yeTtcbmV4cG9ydHMuybVnID0gem9uZVdyYXBwZWRJbnRlcmNlcHRpbmdIYW5kbGVyO1xuZXhwb3J0cy7JtWEgPSBpbnN0YW50aWF0ZVNlcnZlclJlbmRlcmVyRmFjdG9yeTtcbmV4cG9ydHMuybVjID0gU2VydmVyU3R5bGVzSG9zdDtcbmV4cG9ydHMuybViID0gc2VyaWFsaXplVHJhbnNmZXJTdGF0ZUZhY3Rvcnk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybS1zZXJ2ZXIudW1kLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tc2VydmVyL2J1bmRsZXMvcGxhdGZvcm0tc2VydmVyLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxKSkoNik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NS4yLjNcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnJvd3NlcicsIFsnZXhwb3J0cycsICdAYW5ndWxhci9hbmltYXRpb25zJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLmFuaW1hdGlvbnMgPSBnbG9iYWwubmcuYW5pbWF0aW9ucyB8fCB7fSwgZ2xvYmFsLm5nLmFuaW1hdGlvbnMuYnJvd3NlciA9IHt9KSxnbG9iYWwubmcuYW5pbWF0aW9ucykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsX2FuZ3VsYXJfYW5pbWF0aW9ucykgeyAndXNlIHN0cmljdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjUuMi4zXG4gKiAoYykgMjAxMC0yMDE4IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IHBsYXllcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplR3JvdXBQbGF5ZXIocGxheWVycykge1xuICAgIHN3aXRjaCAocGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9hbmltYXRpb25zLk5vb3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIHBsYXllcnNbMF07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnMuybVBbmltYXRpb25Hcm91cFBsYXllcihwbGF5ZXJzKTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZHJpdmVyXG4gKiBAcGFyYW0gez99IG5vcm1hbGl6ZXJcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAqIEBwYXJhbSB7Pz19IHByZVN0eWxlc1xuICogQHBhcmFtIHs/PX0gcG9zdFN0eWxlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplS2V5ZnJhbWVzKGRyaXZlciwgbm9ybWFsaXplciwgZWxlbWVudCwga2V5ZnJhbWVzLCBwcmVTdHlsZXMsIHBvc3RTdHlsZXMpIHtcbiAgICBpZiAocHJlU3R5bGVzID09PSB2b2lkIDApIHsgcHJlU3R5bGVzID0ge307IH1cbiAgICBpZiAocG9zdFN0eWxlcyA9PT0gdm9pZCAwKSB7IHBvc3RTdHlsZXMgPSB7fTsgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWRLZXlmcmFtZXMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2aW91c09mZnNldCA9IC0xO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzS2V5ZnJhbWUgPSBudWxsO1xuICAgIGtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrZikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXQgPSAvKiogQHR5cGUgez99ICovIChrZlsnb2Zmc2V0J10pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1NhbWVPZmZzZXQgPSBvZmZzZXQgPT0gcHJldmlvdXNPZmZzZXQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWRLZXlmcmFtZSA9IChpc1NhbWVPZmZzZXQgJiYgcHJldmlvdXNLZXlmcmFtZSkgfHwge307XG4gICAgICAgIE9iamVjdC5rZXlzKGtmKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVkUHJvcCA9IHByb3A7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVkVmFsdWUgPSBrZltwcm9wXTtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnb2Zmc2V0Jykge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplci5ub3JtYWxpemVQcm9wZXJ0eU5hbWUobm9ybWFsaXplZFByb3AsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChub3JtYWxpemVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9hbmltYXRpb25zLsm1UFJFX1NUWUxFOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFZhbHVlID0gcHJlU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFZhbHVlID0gcG9zdFN0eWxlc1twcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVyLm5vcm1hbGl6ZVN0eWxlVmFsdWUocHJvcCwgbm9ybWFsaXplZFByb3AsIG5vcm1hbGl6ZWRWYWx1ZSwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1hbGl6ZWRLZXlmcmFtZVtub3JtYWxpemVkUHJvcF0gPSBub3JtYWxpemVkVmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzU2FtZU9mZnNldCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZEtleWZyYW1lcy5wdXNoKG5vcm1hbGl6ZWRLZXlmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNLZXlmcmFtZSA9IG5vcm1hbGl6ZWRLZXlmcmFtZTtcbiAgICAgICAgcHJldmlvdXNPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfSk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTElORV9TVEFSVCA9ICdcXG4gLSAnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gYW5pbWF0ZSBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcnM6XCIgKyBMSU5FX1NUQVJUICsgZXJyb3JzLmpvaW4oTElORV9TVEFSVCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZEtleWZyYW1lcztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwbGF5ZXJcbiAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gKiBAcGFyYW0gez99IGV2ZW50XG4gKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBsaXN0ZW5PblBsYXllcihwbGF5ZXIsIGV2ZW50TmFtZSwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgcGxheWVyLm9uU3RhcnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soZXZlbnQgJiYgY29weUFuaW1hdGlvbkV2ZW50KGV2ZW50LCAnc3RhcnQnLCBwbGF5ZXIudG90YWxUaW1lKSk7IH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCAmJiBjb3B5QW5pbWF0aW9uRXZlbnQoZXZlbnQsICdkb25lJywgcGxheWVyLnRvdGFsVGltZSkpOyB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soZXZlbnQgJiYgY29weUFuaW1hdGlvbkV2ZW50KGV2ZW50LCAnZGVzdHJveScsIHBsYXllci50b3RhbFRpbWUpKTsgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZVxuICogQHBhcmFtIHs/PX0gcGhhc2VOYW1lXG4gKiBAcGFyYW0gez89fSB0b3RhbFRpbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvcHlBbmltYXRpb25FdmVudChlLCBwaGFzZU5hbWUsIHRvdGFsVGltZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGV2ZW50ID0gbWFrZUFuaW1hdGlvbkV2ZW50KGUuZWxlbWVudCwgZS50cmlnZ2VyTmFtZSwgZS5mcm9tU3RhdGUsIGUudG9TdGF0ZSwgcGhhc2VOYW1lIHx8IGUucGhhc2VOYW1lLCB0b3RhbFRpbWUgPT0gdW5kZWZpbmVkID8gZS50b3RhbFRpbWUgOiB0b3RhbFRpbWUpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRhdGEgPSAoLyoqIEB0eXBlIHs/fSAqLyAoZSkpWydfZGF0YSddO1xuICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKGV2ZW50KSlbJ19kYXRhJ10gPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSB0cmlnZ2VyTmFtZVxuICogQHBhcmFtIHs/fSBmcm9tU3RhdGVcbiAqIEBwYXJhbSB7P30gdG9TdGF0ZVxuICogQHBhcmFtIHs/PX0gcGhhc2VOYW1lXG4gKiBAcGFyYW0gez89fSB0b3RhbFRpbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG1ha2VBbmltYXRpb25FdmVudChlbGVtZW50LCB0cmlnZ2VyTmFtZSwgZnJvbVN0YXRlLCB0b1N0YXRlLCBwaGFzZU5hbWUsIHRvdGFsVGltZSkge1xuICAgIGlmIChwaGFzZU5hbWUgPT09IHZvaWQgMCkgeyBwaGFzZU5hbWUgPSAnJzsgfVxuICAgIGlmICh0b3RhbFRpbWUgPT09IHZvaWQgMCkgeyB0b3RhbFRpbWUgPSAwOyB9XG4gICAgcmV0dXJuIHsgZWxlbWVudDogZWxlbWVudCwgdHJpZ2dlck5hbWU6IHRyaWdnZXJOYW1lLCBmcm9tU3RhdGU6IGZyb21TdGF0ZSwgdG9TdGF0ZTogdG9TdGF0ZSwgcGhhc2VOYW1lOiBwaGFzZU5hbWUsIHRvdGFsVGltZTogdG90YWxUaW1lIH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbWFwXG4gKiBAcGFyYW0gez99IGtleVxuICogQHBhcmFtIHs/fSBkZWZhdWx0VmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE9yU2V0QXNJbk1hcChtYXAsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWU7XG4gICAgaWYgKG1hcCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgbWFwLnNldChrZXksIHZhbHVlID0gZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBtYXBba2V5XTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXBba2V5XSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29tbWFuZFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyc2VUaW1lbGluZUNvbW1hbmQoY29tbWFuZCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlcGFyYXRvclBvcyA9IGNvbW1hbmQuaW5kZXhPZignOicpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gY29tbWFuZC5zdWJzdHJpbmcoMSwgc2VwYXJhdG9yUG9zKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhY3Rpb24gPSBjb21tYW5kLnN1YnN0cihzZXBhcmF0b3JQb3MgKyAxKTtcbiAgICByZXR1cm4gW2lkLCBhY3Rpb25dO1xufVxudmFyIF9jb250YWlucyA9IGZ1bmN0aW9uIChlbG0xLCBlbG0yKSB7IHJldHVybiBmYWxzZTsgfTtcbnZhciBfbWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG52YXIgX3F1ZXJ5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSkge1xuICAgIHJldHVybiBbXTtcbn07XG5pZiAodHlwZW9mIEVsZW1lbnQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyB0aGlzIGlzIHdlbGwgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vyc1xuICAgIF9jb250YWlucyA9IGZ1bmN0aW9uIChlbG0xLCBlbG0yKSB7IHJldHVybiAvKiogQHR5cGUgez99ICovIChlbG0xLmNvbnRhaW5zKGVsbTIpKTsgfTtcbiAgICBpZiAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICAgICAgICBfbWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvcikgeyByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3RvID0gLyoqIEB0eXBlIHs/fSAqLyAoRWxlbWVudC5wcm90b3R5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbl8xID0gcHJvdG8ubWF0Y2hlc1NlbGVjdG9yIHx8IHByb3RvLm1vek1hdGNoZXNTZWxlY3RvciB8fCBwcm90by5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgcHJvdG8ub01hdGNoZXNTZWxlY3RvciB8fCBwcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG4gICAgICAgIGlmIChmbl8xKSB7XG4gICAgICAgICAgICBfbWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvcikgeyByZXR1cm4gZm5fMS5hcHBseShlbGVtZW50LCBbc2VsZWN0b3JdKTsgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcXVlcnkgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbG0gPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvcFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNWZW5kb3JQcmVmaXgocHJvcCkge1xuICAgIC8vIFdlYmtpdCBpcyB0aGUgb25seSByZWFsIHBvcHVsYXIgdmVuZG9yIHByZWZpeCBub3dhZGF5c1xuICAgIC8vIGNjOiBodHRwOi8vc2hvdWxkaXByZWZpeC5jb20vXG4gICAgcmV0dXJuIHByb3Auc3Vic3RyaW5nKDEsIDYpID09ICdlYmtpdCc7IC8vIHdlYmtpdCBvciBXZWJraXRcbn1cbnZhciBfQ0FDSEVEX0JPRFkgPSBudWxsO1xudmFyIF9JU19XRUJLSVQgPSBmYWxzZTtcbi8qKlxuICogQHBhcmFtIHs/fSBwcm9wXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlUHJvcGVydHkocHJvcCkge1xuICAgIGlmICghX0NBQ0hFRF9CT0RZKSB7XG4gICAgICAgIF9DQUNIRURfQk9EWSA9IGdldEJvZHlOb2RlKCkgfHwge307XG4gICAgICAgIF9JU19XRUJLSVQgPSAvKiogQHR5cGUgez99ICovICgoX0NBQ0hFRF9CT0RZKSkuc3R5bGUgPyAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIC8qKiBAdHlwZSB7P30gKi8gKChfQ0FDSEVEX0JPRFkpKS5zdHlsZSkgOiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdHJ1ZTtcbiAgICBpZiAoLyoqIEB0eXBlIHs/fSAqLyAoKF9DQUNIRURfQk9EWSkpLnN0eWxlICYmICFjb250YWluc1ZlbmRvclByZWZpeChwcm9wKSkge1xuICAgICAgICByZXN1bHQgPSBwcm9wIGluIC8qKiBAdHlwZSB7P30gKi8gKChfQ0FDSEVEX0JPRFkpKS5zdHlsZTtcbiAgICAgICAgaWYgKCFyZXN1bHQgJiYgX0lTX1dFQktJVCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FtZWxQcm9wID0gJ1dlYmtpdCcgKyBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zdWJzdHIoMSk7XG4gICAgICAgICAgICByZXN1bHQgPSBjYW1lbFByb3AgaW4gLyoqIEB0eXBlIHs/fSAqLyAoKF9DQUNIRURfQk9EWSkpLnN0eWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldEJvZHlOb2RlKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxudmFyIG1hdGNoZXNFbGVtZW50ID0gX21hdGNoZXM7XG52YXIgY29udGFpbnNFbGVtZW50ID0gX2NvbnRhaW5zO1xudmFyIGludm9rZVF1ZXJ5ID0gX3F1ZXJ5O1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgTm9vcEFuaW1hdGlvbkRyaXZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb29wQW5pbWF0aW9uRHJpdmVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3BcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLnZhbGlkYXRlU3R5bGVQcm9wZXJ0eSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHZhbGlkYXRlU3R5bGVQcm9wZXJ0eShwcm9wKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5tYXRjaGVzRWxlbWVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc0VsZW1lbnQoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbG0xXG4gICAgICogQHBhcmFtIHs/fSBlbG0yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5jb250YWluc0VsZW1lbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsbTFcbiAgICAgKiBAcGFyYW0gez99IGVsbTJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbG0xLCBlbG0yKSB7IHJldHVybiBjb250YWluc0VsZW1lbnQoZWxtMSwgZWxtMik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbXVsdGlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLnF1ZXJ5ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbXVsdGlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVF1ZXJ5KGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHByb3BcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLmNvbXB1dGVTdHlsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmF1bHRWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8ICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHBhcmFtIHs/PX0gcHJldmlvdXNQbGF5ZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5hbmltYXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHBhcmFtIHs/PX0gcHJldmlvdXNQbGF5ZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwga2V5ZnJhbWVzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgcHJldmlvdXNQbGF5ZXJzKSB7XG4gICAgICAgIGlmIChwcmV2aW91c1BsYXllcnMgPT09IHZvaWQgMCkgeyBwcmV2aW91c1BsYXllcnMgPSBbXTsgfVxuICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnMuTm9vcEFuaW1hdGlvblBsYXllcigpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vb3BBbmltYXRpb25Ecml2ZXI7XG59KCkpO1xuLyoqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQW5pbWF0aW9uRHJpdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkRyaXZlcigpIHtcbiAgICB9XG4gICAgQW5pbWF0aW9uRHJpdmVyLk5PT1AgPSBuZXcgTm9vcEFuaW1hdGlvbkRyaXZlcigpO1xuICAgIHJldHVybiBBbmltYXRpb25Ecml2ZXI7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgT05FX1NFQ09ORCA9IDEwMDA7XG52YXIgU1VCU1RJVFVUSU9OX0VYUFJfU1RBUlQgPSAne3snO1xudmFyIFNVQlNUSVRVVElPTl9FWFBSX0VORCA9ICd9fSc7XG52YXIgRU5URVJfQ0xBU1NOQU1FID0gJ25nLWVudGVyJztcbnZhciBMRUFWRV9DTEFTU05BTUUgPSAnbmctbGVhdmUnO1xuXG5cbnZhciBOR19UUklHR0VSX0NMQVNTTkFNRSA9ICduZy10cmlnZ2VyJztcbnZhciBOR19UUklHR0VSX1NFTEVDVE9SID0gJy5uZy10cmlnZ2VyJztcbnZhciBOR19BTklNQVRJTkdfQ0xBU1NOQU1FID0gJ25nLWFuaW1hdGluZyc7XG52YXIgTkdfQU5JTUFUSU5HX1NFTEVDVE9SID0gJy5uZy1hbmltYXRpbmcnO1xuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZXNvbHZlVGltaW5nVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcyA9ICgvKiogQHR5cGUgez99ICovICh2YWx1ZSkpLm1hdGNoKC9eKC0/W1xcLlxcZF0rKShtP3MpLyk7XG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMilcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIF9jb252ZXJ0VGltZVZhbHVlVG9NUyhwYXJzZUZsb2F0KG1hdGNoZXNbMV0pLCBtYXRjaGVzWzJdKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHBhcmFtIHs/fSB1bml0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfY29udmVydFRpbWVWYWx1ZVRvTVModmFsdWUsIHVuaXQpIHtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKiBPTkVfU0VDT05EO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gbXMgb3Igc29tZXRoaW5nIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdGltaW5nc1xuICogQHBhcmFtIHs/fSBlcnJvcnNcbiAqIEBwYXJhbSB7Pz19IGFsbG93TmVnYXRpdmVWYWx1ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUaW1pbmcodGltaW5ncywgZXJyb3JzLCBhbGxvd05lZ2F0aXZlVmFsdWVzKSB7XG4gICAgcmV0dXJuIHRpbWluZ3MuaGFzT3duUHJvcGVydHkoJ2R1cmF0aW9uJykgPyAvKiogQHR5cGUgez99ICovICh0aW1pbmdzKSA6XG4gICAgICAgIHBhcnNlVGltZUV4cHJlc3Npb24oLyoqIEB0eXBlIHs/fSAqLyAodGltaW5ncyksIGVycm9ycywgYWxsb3dOZWdhdGl2ZVZhbHVlcyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXhwXG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHBhcmFtIHs/PX0gYWxsb3dOZWdhdGl2ZVZhbHVlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyc2VUaW1lRXhwcmVzc2lvbihleHAsIGVycm9ycywgYWxsb3dOZWdhdGl2ZVZhbHVlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZ2V4ID0gL14oLT9bXFwuXFxkXSspKG0/cykoPzpcXHMrKC0/W1xcLlxcZF0rKShtP3MpKT8oPzpcXHMrKFstYS16XSsoPzpcXCguKz9cXCkpPykpPyQvaTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdXJhdGlvbjtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxheSA9IDA7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWFzaW5nID0gJyc7XG4gICAgaWYgKHR5cGVvZiBleHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoZXMgPSBleHAubWF0Y2gocmVnZXgpO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJUaGUgcHJvdmlkZWQgdGltaW5nIHZhbHVlIFxcXCJcIiArIGV4cCArIFwiXFxcIiBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiAwLCBkZWxheTogMCwgZWFzaW5nOiAnJyB9O1xuICAgICAgICB9XG4gICAgICAgIGR1cmF0aW9uID0gX2NvbnZlcnRUaW1lVmFsdWVUb01TKHBhcnNlRmxvYXQobWF0Y2hlc1sxXSksIG1hdGNoZXNbMl0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxheU1hdGNoID0gbWF0Y2hlc1szXTtcbiAgICAgICAgaWYgKGRlbGF5TWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsYXkgPSBfY29udmVydFRpbWVWYWx1ZVRvTVMoTWF0aC5mbG9vcihwYXJzZUZsb2F0KGRlbGF5TWF0Y2gpKSwgbWF0Y2hlc1s0XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWFzaW5nVmFsID0gbWF0Y2hlc1s1XTtcbiAgICAgICAgaWYgKGVhc2luZ1ZhbCkge1xuICAgICAgICAgICAgZWFzaW5nID0gZWFzaW5nVmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkdXJhdGlvbiA9IC8qKiBAdHlwZSB7P30gKi8gKGV4cCk7XG4gICAgfVxuICAgIGlmICghYWxsb3dOZWdhdGl2ZVZhbHVlcykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydEluZGV4ID0gZXJyb3JzLmxlbmd0aDtcbiAgICAgICAgaWYgKGR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJEdXJhdGlvbiB2YWx1ZXMgYmVsb3cgMCBhcmUgbm90IGFsbG93ZWQgZm9yIHRoaXMgYW5pbWF0aW9uIHN0ZXAuXCIpO1xuICAgICAgICAgICAgY29udGFpbnNFcnJvcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxheSA8IDApIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiRGVsYXkgdmFsdWVzIGJlbG93IDAgYXJlIG5vdCBhbGxvd2VkIGZvciB0aGlzIGFuaW1hdGlvbiBzdGVwLlwiKTtcbiAgICAgICAgICAgIGNvbnRhaW5zRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbnNFcnJvcnMpIHtcbiAgICAgICAgICAgIGVycm9ycy5zcGxpY2Uoc3RhcnRJbmRleCwgMCwgXCJUaGUgcHJvdmlkZWQgdGltaW5nIHZhbHVlIFxcXCJcIiArIGV4cCArIFwiXFxcIiBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkdXJhdGlvbjogZHVyYXRpb24sIGRlbGF5OiBkZWxheSwgZWFzaW5nOiBlYXNpbmcgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBvYmpcbiAqIEBwYXJhbSB7Pz19IGRlc3RpbmF0aW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb3B5T2JqKG9iaiwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAoZGVzdGluYXRpb24gPT09IHZvaWQgMCkgeyBkZXN0aW5hdGlvbiA9IHt9OyB9XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IGRlc3RpbmF0aW9uW3Byb3BdID0gb2JqW3Byb3BdOyB9KTtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3R5bGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZXMoc3R5bGVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplZFN0eWxlcyA9IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGNvcHlTdHlsZXMoZGF0YSwgZmFsc2UsIG5vcm1hbGl6ZWRTdHlsZXMpOyB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvcHlTdHlsZXMoc3R5bGVzLCBmYWxzZSwgbm9ybWFsaXplZFN0eWxlcyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkU3R5bGVzO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0eWxlc1xuICogQHBhcmFtIHs/fSByZWFkUHJvdG90eXBlXG4gKiBAcGFyYW0gez89fSBkZXN0aW5hdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29weVN0eWxlcyhzdHlsZXMsIHJlYWRQcm90b3R5cGUsIGRlc3RpbmF0aW9uKSB7XG4gICAgaWYgKGRlc3RpbmF0aW9uID09PSB2b2lkIDApIHsgZGVzdGluYXRpb24gPSB7fTsgfVxuICAgIGlmIChyZWFkUHJvdG90eXBlKSB7XG4gICAgICAgIC8vIHdlIG1ha2UgdXNlIG9mIGEgZm9yLWluIGxvb3Agc28gdGhhdCB0aGVcbiAgICAgICAgLy8gcHJvdG90eXBpY2FsbHkgaW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICAgIC8vIHJldmVhbGVkIGZyb20gdGhlIGJhY2tGaWxsIG1hcFxuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wXSA9IHN0eWxlc1twcm9wXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29weU9iaihzdHlsZXMsIGRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gc3R5bGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gICAgaWYgKGVsZW1lbnRbJ3N0eWxlJ10pIHtcbiAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYW1lbFByb3AgPSBkYXNoQ2FzZVRvQ2FtZWxDYXNlKHByb3ApO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtjYW1lbFByb3BdID0gc3R5bGVzW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBzdHlsZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVyYXNlU3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICAgIGlmIChlbGVtZW50WydzdHlsZSddKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FtZWxQcm9wID0gZGFzaENhc2VUb0NhbWVsQ2FzZShwcm9wKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbY2FtZWxQcm9wXSA9ICcnO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3RlcHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KHN0ZXBzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RlcHMpKSB7XG4gICAgICAgIGlmIChzdGVwcy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBzdGVwc1swXTtcbiAgICAgICAgcmV0dXJuIF9hbmd1bGFyX2FuaW1hdGlvbnMuc2VxdWVuY2Uoc3RlcHMpO1xuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAoc3RlcHMpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcGFyYW0gez99IG9wdGlvbnNcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlUGFyYW1zKHZhbHVlLCBvcHRpb25zLCBlcnJvcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXMgPSBvcHRpb25zLnBhcmFtcyB8fCB7fTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVzID0gZXh0cmFjdFN0eWxlUGFyYW1zKHZhbHVlKTtcbiAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtcy5oYXNPd25Qcm9wZXJ0eSh2YXJOYW1lKSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiVW5hYmxlIHRvIHJlc29sdmUgdGhlIGxvY2FsIGFuaW1hdGlvbiBwYXJhbSBcIiArIHZhck5hbWUgKyBcIiBpbiB0aGUgZ2l2ZW4gbGlzdCBvZiB2YWx1ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbnZhciBQQVJBTV9SRUdFWCA9IG5ldyBSZWdFeHAoU1VCU1RJVFVUSU9OX0VYUFJfU1RBUlQgKyBcIlxcXFxzKiguKz8pXFxcXHMqXCIgKyBTVUJTVElUVVRJT05fRVhQUl9FTkQsICdnJyk7XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RTdHlsZVBhcmFtcyh2YWx1ZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtcyA9IFtdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAobWF0Y2ggPSBQQVJBTV9SRUdFWC5leGVjKHZhbCkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKG1hdGNoWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgUEFSQU1fUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHBhcmFtIHs/fSBwYXJhbXNcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVBhcmFtcyh2YWx1ZSwgcGFyYW1zLCBlcnJvcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5hbCA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyID0gb3JpZ2luYWwucmVwbGFjZShQQVJBTV9SRUdFWCwgZnVuY3Rpb24gKF8sIHZhck5hbWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYWxWYWwgPSBwYXJhbXNbdmFyTmFtZV07XG4gICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCB0aGUgdmFsdWUgd2FzIG5ldmVyIG92ZXJpZGRlbiBieSB0aGUgZGF0YSBwYXNzZWQgaW4gYnkgdGhlIHVzZXJcbiAgICAgICAgaWYgKCFwYXJhbXMuaGFzT3duUHJvcGVydHkodmFyTmFtZSkpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiUGxlYXNlIHByb3ZpZGUgYSB2YWx1ZSBmb3IgdGhlIGFuaW1hdGlvbiBwYXJhbSBcIiArIHZhck5hbWUpO1xuICAgICAgICAgICAgbG9jYWxWYWwgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxWYWwudG9TdHJpbmcoKTtcbiAgICB9KTtcbiAgICAvLyB3ZSBkbyB0aGlzIHRvIGFzc2VydCB0aGF0IG51bWVyaWMgdmFsdWVzIHN0YXkgYXMgdGhleSBhcmVcbiAgICByZXR1cm4gc3RyID09IG9yaWdpbmFsID8gdmFsdWUgOiBzdHI7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaXRlcmF0b3JcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyciA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgd2hpbGUgKCFpdGVtLmRvbmUpIHtcbiAgICAgICAgYXJyLnB1c2goaXRlbS52YWx1ZSk7XG4gICAgICAgIGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc291cmNlXG4gKiBAcGFyYW0gez99IGRlc3RpbmF0aW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5cbnZhciBEQVNIX0NBU0VfUkVHRVhQID0gLy0rKFthLXowLTldKS9nO1xuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoREFTSF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZHVyYXRpb25cbiAqIEBwYXJhbSB7P30gZGVsYXlcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFsbG93UHJldmlvdXNQbGF5ZXJTdHlsZXNNZXJnZShkdXJhdGlvbiwgZGVsYXkpIHtcbiAgICByZXR1cm4gZHVyYXRpb24gPT09IDAgfHwgZGVsYXkgPT09IDA7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmlzaXRvclxuICogQHBhcmFtIHs/fSBub2RlXG4gKiBAcGFyYW0gez99IGNvbnRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHZpc2l0RHNsTm9kZSh2aXNpdG9yLCBub2RlLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSA3IC8qIFRyaWdnZXIgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRyaWdnZXIobm9kZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMCAvKiBTdGF0ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RhdGUobm9kZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMSAvKiBUcmFuc2l0aW9uICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUcmFuc2l0aW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDIgLyogU2VxdWVuY2UgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNlcXVlbmNlKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDMgLyogR3JvdXAgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEdyb3VwKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDQgLyogQW5pbWF0ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0ZShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSA1IC8qIEtleWZyYW1lcyAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0S2V5ZnJhbWVzKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDYgLyogU3R5bGUgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFN0eWxlKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDggLyogUmVmZXJlbmNlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2Uobm9kZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgOSAvKiBBbmltYXRlQ2hpbGQgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGVDaGlsZChub2RlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAxMCAvKiBBbmltYXRlUmVmICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRlUmVmKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDExIC8qIFF1ZXJ5ICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRRdWVyeShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAxMiAvKiBTdGFnZ2VyICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdGFnZ2VyKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgYW5pbWF0aW9uIG1ldGFkYXRhIG5vZGUgI1wiICsgbm9kZS50eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBBTllfU1RBVEUgPSAnKic7XG4vKipcbiAqIEBwYXJhbSB7P30gdHJhbnNpdGlvblZhbHVlXG4gKiBAcGFyYW0gez99IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyc2VUcmFuc2l0aW9uRXhwcih0cmFuc2l0aW9uVmFsdWUsIGVycm9ycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb25zID0gW107XG4gICAgaWYgKHR5cGVvZiB0cmFuc2l0aW9uVmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKHRyYW5zaXRpb25WYWx1ZSkpXG4gICAgICAgICAgICAuc3BsaXQoL1xccyosXFxzKi8pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBwYXJzZUlubmVyVHJhbnNpdGlvblN0cihzdHIsIGV4cHJlc3Npb25zLCBlcnJvcnMpOyB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goLyoqIEB0eXBlIHs/fSAqLyAodHJhbnNpdGlvblZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBleHByZXNzaW9ucztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBldmVudFN0clxuICogQHBhcmFtIHs/fSBleHByZXNzaW9uc1xuICogQHBhcmFtIHs/fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW5uZXJUcmFuc2l0aW9uU3RyKGV2ZW50U3RyLCBleHByZXNzaW9ucywgZXJyb3JzKSB7XG4gICAgaWYgKGV2ZW50U3RyWzBdID09ICc6Jykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBwYXJzZUFuaW1hdGlvbkFsaWFzKGV2ZW50U3RyLCBlcnJvcnMpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRTdHIgPSAvKiogQHR5cGUgez99ICovIChyZXN1bHQpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaCA9IGV2ZW50U3RyLm1hdGNoKC9eKFxcKnxbLVxcd10rKVxccyooPD9bPS1dPilcXHMqKFxcKnxbLVxcd10rKSQvKTtcbiAgICBpZiAobWF0Y2ggPT0gbnVsbCB8fCBtYXRjaC5sZW5ndGggPCA0KSB7XG4gICAgICAgIGVycm9ycy5wdXNoKFwiVGhlIHByb3ZpZGVkIHRyYW5zaXRpb24gZXhwcmVzc2lvbiBcXFwiXCIgKyBldmVudFN0ciArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZyb21TdGF0ZSA9IG1hdGNoWzFdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlcGFyYXRvciA9IG1hdGNoWzJdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvU3RhdGUgPSBtYXRjaFszXTtcbiAgICBleHByZXNzaW9ucy5wdXNoKG1ha2VMYW1iZGFGcm9tU3RhdGVzKGZyb21TdGF0ZSwgdG9TdGF0ZSkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRnVsbEFueVN0YXRlRXhwciA9IGZyb21TdGF0ZSA9PSBBTllfU1RBVEUgJiYgdG9TdGF0ZSA9PSBBTllfU1RBVEU7XG4gICAgaWYgKHNlcGFyYXRvclswXSA9PSAnPCcgJiYgIWlzRnVsbEFueVN0YXRlRXhwcikge1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKG1ha2VMYW1iZGFGcm9tU3RhdGVzKHRvU3RhdGUsIGZyb21TdGF0ZSkpO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBhbGlhc1xuICogQHBhcmFtIHs/fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9uQWxpYXMoYWxpYXMsIGVycm9ycykge1xuICAgIHN3aXRjaCAoYWxpYXMpIHtcbiAgICAgICAgY2FzZSAnOmVudGVyJzpcbiAgICAgICAgICAgIHJldHVybiAndm9pZCA9PiAqJztcbiAgICAgICAgY2FzZSAnOmxlYXZlJzpcbiAgICAgICAgICAgIHJldHVybiAnKiA9PiB2b2lkJztcbiAgICAgICAgY2FzZSAnOmluY3JlbWVudCc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZyb21TdGF0ZSwgdG9TdGF0ZSkgeyByZXR1cm4gcGFyc2VGbG9hdCh0b1N0YXRlKSA+IHBhcnNlRmxvYXQoZnJvbVN0YXRlKTsgfTtcbiAgICAgICAgY2FzZSAnOmRlY3JlbWVudCc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZyb21TdGF0ZSwgdG9TdGF0ZSkgeyByZXR1cm4gcGFyc2VGbG9hdCh0b1N0YXRlKSA8IHBhcnNlRmxvYXQoZnJvbVN0YXRlKTsgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKFwiVGhlIHRyYW5zaXRpb24gYWxpYXMgdmFsdWUgXFxcIlwiICsgYWxpYXMgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiAnKiA9PiAqJztcbiAgICB9XG59XG4vLyBETyBOT1QgUkVGQUNUT1IgLi4uIGtlZXAgdGhlIGZvbGxvdyBzZXQgaW5zdGFudGlhdGlvbnNcbi8vIHdpdGggdGhlIHZhbHVlcyBpbnRhY3QgKGNsb3N1cmUgY29tcGlsZXIgZm9yIHNvbWUgcmVhc29uXG4vLyByZW1vdmVzIGZvbGxvdy11cCBsaW5lcyB0aGF0IGFkZCB0aGUgdmFsdWVzIG91dHNpZGUgb2Zcbi8vIHRoZSBjb25zdHJ1Y3Rvci4uLlxudmFyIFRSVUVfQk9PTEVBTl9WQUxVRVMgPSBuZXcgU2V0KFsndHJ1ZScsICcxJ10pO1xudmFyIEZBTFNFX0JPT0xFQU5fVkFMVUVTID0gbmV3IFNldChbJ2ZhbHNlJywgJzAnXSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbGhzXG4gKiBAcGFyYW0gez99IHJoc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbWFrZUxhbWJkYUZyb21TdGF0ZXMobGhzLCByaHMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBMSFNfTUFUQ0hfQk9PTEVBTiA9IFRSVUVfQk9PTEVBTl9WQUxVRVMuaGFzKGxocykgfHwgRkFMU0VfQk9PTEVBTl9WQUxVRVMuaGFzKGxocyk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gUkhTX01BVENIX0JPT0xFQU4gPSBUUlVFX0JPT0xFQU5fVkFMVUVTLmhhcyhyaHMpIHx8IEZBTFNFX0JPT0xFQU5fVkFMVUVTLmhhcyhyaHMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZnJvbVN0YXRlLCB0b1N0YXRlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxoc01hdGNoID0gbGhzID09IEFOWV9TVEFURSB8fCBsaHMgPT0gZnJvbVN0YXRlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaHNNYXRjaCA9IHJocyA9PSBBTllfU1RBVEUgfHwgcmhzID09IHRvU3RhdGU7XG4gICAgICAgIGlmICghbGhzTWF0Y2ggJiYgTEhTX01BVENIX0JPT0xFQU4gJiYgdHlwZW9mIGZyb21TdGF0ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBsaHNNYXRjaCA9IGZyb21TdGF0ZSA/IFRSVUVfQk9PTEVBTl9WQUxVRVMuaGFzKGxocykgOiBGQUxTRV9CT09MRUFOX1ZBTFVFUy5oYXMobGhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJoc01hdGNoICYmIFJIU19NQVRDSF9CT09MRUFOICYmIHR5cGVvZiB0b1N0YXRlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJoc01hdGNoID0gdG9TdGF0ZSA/IFRSVUVfQk9PTEVBTl9WQUxVRVMuaGFzKHJocykgOiBGQUxTRV9CT09MRUFOX1ZBTFVFUy5oYXMocmhzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGhzTWF0Y2ggJiYgcmhzTWF0Y2g7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFNFTEZfVE9LRU4gPSAnOnNlbGYnO1xudmFyIFNFTEZfVE9LRU5fUkVHRVggPSBuZXcgUmVnRXhwKFwicypcIiArIFNFTEZfVE9LRU4gKyBcInMqLD9cIiwgJ2cnKTtcbi8qKlxuICogQHBhcmFtIHs/fSBkcml2ZXJcbiAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBidWlsZEFuaW1hdGlvbkFzdChkcml2ZXIsIG1ldGFkYXRhLCBlcnJvcnMpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yKGRyaXZlcikuYnVpbGQobWV0YWRhdGEsIGVycm9ycyk7XG59XG52YXIgUk9PVF9TRUxFQ1RPUiA9ICcnO1xudmFyIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yKF9kcml2ZXIpIHtcbiAgICAgICAgdGhpcy5fZHJpdmVyID0gX2RyaXZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuYnVpbGQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgZXJyb3JzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRleHQgPSBuZXcgQW5pbWF0aW9uQXN0QnVpbGRlckNvbnRleHQoZXJyb3JzKTtcbiAgICAgICAgdGhpcy5fcmVzZXRDb250ZXh0U3R5bGVUaW1pbmdTdGF0ZShjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKHZpc2l0RHNsTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YSksIGNvbnRleHQpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl9yZXNldENvbnRleHRTdHlsZVRpbWluZ1N0YXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yID0gUk9PVF9TRUxFQ1RPUjtcbiAgICAgICAgY29udGV4dC5jb2xsZWN0ZWRTdHlsZXMgPSB7fTtcbiAgICAgICAgY29udGV4dC5jb2xsZWN0ZWRTdHlsZXNbUk9PVF9TRUxFQ1RPUl0gPSB7fTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZSA9IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcmlnZ2VyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5Q291bnQgPSBjb250ZXh0LnF1ZXJ5Q291bnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBDb3VudCA9IGNvbnRleHQuZGVwQ291bnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0ZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKG1ldGFkYXRhLm5hbWUuY2hhckF0KDApID09ICdAJykge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaCgnYW5pbWF0aW9uIHRyaWdnZXJzIGNhbm5vdCBiZSBwcmVmaXhlZCB3aXRoIGFuIGBAYCBzaWduIChlLmcuIHRyaWdnZXIoXFwnQGZvb1xcJywgWy4uLl0pKScpO1xuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc2V0Q29udGV4dFN0eWxlVGltaW5nU3RhdGUoY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoZGVmLnR5cGUgPT0gMCAvKiBTdGF0ZSAqLykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlRGVmXzEgPSAvKiogQHR5cGUgez99ICovIChkZWYpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVfMSA9IHN0YXRlRGVmXzEubmFtZTtcbiAgICAgICAgICAgICAgICBuYW1lXzEuc3BsaXQoL1xccyosXFxzKi8pLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVEZWZfMS5uYW1lID0gbjtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVzLnB1c2goX3RoaXMudmlzaXRTdGF0ZShzdGF0ZURlZl8xLCBjb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdGVEZWZfMS5uYW1lID0gbmFtZV8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLnR5cGUgPT0gMSAvKiBUcmFuc2l0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGlvbiA9IF90aGlzLnZpc2l0VHJhbnNpdGlvbigvKiogQHR5cGUgez99ICovIChkZWYpLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBxdWVyeUNvdW50ICs9IHRyYW5zaXRpb24ucXVlcnlDb3VudDtcbiAgICAgICAgICAgICAgICBkZXBDb3VudCArPSB0cmFuc2l0aW9uLmRlcENvdW50O1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKCdvbmx5IHN0YXRlKCkgYW5kIHRyYW5zaXRpb24oKSBkZWZpbml0aW9ucyBjYW4gc2l0IGluc2lkZSBvZiBhIHRyaWdnZXIoKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IDcgLyogVHJpZ2dlciAqLyxcbiAgICAgICAgICAgIG5hbWU6IG1ldGFkYXRhLm5hbWUsIHN0YXRlczogc3RhdGVzLCB0cmFuc2l0aW9uczogdHJhbnNpdGlvbnMsIHF1ZXJ5Q291bnQ6IHF1ZXJ5Q291bnQsIGRlcENvdW50OiBkZXBDb3VudCxcbiAgICAgICAgICAgIG9wdGlvbnM6IG51bGxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0YXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlQXN0ID0gdGhpcy52aXNpdFN0eWxlKG1ldGFkYXRhLnN0eWxlcywgY29udGV4dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdFBhcmFtcyA9IChtZXRhZGF0YS5vcHRpb25zICYmIG1ldGFkYXRhLm9wdGlvbnMucGFyYW1zKSB8fCBudWxsO1xuICAgICAgICBpZiAoc3R5bGVBc3QuY29udGFpbnNEeW5hbWljU3R5bGVzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtaXNzaW5nU3Vic18xID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zXzEgPSBhc3RQYXJhbXMgfHwge307XG4gICAgICAgICAgICBzdHlsZUFzdC5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc09ial8xID0gLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXNPYmpfMSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdFN0eWxlUGFyYW1zKHN0eWxlc09ial8xW3Byb3BdKS5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtc18xLmhhc093blByb3BlcnR5KHN1YikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1N1YnNfMS5hZGQoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobWlzc2luZ1N1YnNfMS5zaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWlzc2luZ1N1YnNBcnIgPSBpdGVyYXRvclRvQXJyYXkobWlzc2luZ1N1YnNfMS52YWx1ZXMoKSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcInN0YXRlKFxcXCJcIiArIG1ldGFkYXRhLm5hbWUgKyBcIlxcXCIsIC4uLikgbXVzdCBkZWZpbmUgZGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCB0aGUgZm9sbG93aW5nIHN0eWxlIHN1YnN0aXR1dGlvbnM6IFwiICsgbWlzc2luZ1N1YnNBcnIuam9pbignLCAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IDAgLyogU3RhdGUgKi8sXG4gICAgICAgICAgICBuYW1lOiBtZXRhZGF0YS5uYW1lLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlQXN0LFxuICAgICAgICAgICAgb3B0aW9uczogYXN0UGFyYW1zID8geyBwYXJhbXM6IGFzdFBhcmFtcyB9IDogbnVsbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJhbnNpdGlvbiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnF1ZXJ5Q291bnQgPSAwO1xuICAgICAgICBjb250ZXh0LmRlcENvdW50ID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0aW9uID0gdmlzaXREc2xOb2RlKHRoaXMsIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KG1ldGFkYXRhLmFuaW1hdGlvbiksIGNvbnRleHQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVycyA9IHBhcnNlVHJhbnNpdGlvbkV4cHIobWV0YWRhdGEuZXhwciwgY29udGV4dC5lcnJvcnMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBUcmFuc2l0aW9uICovLFxuICAgICAgICAgICAgbWF0Y2hlcnM6IG1hdGNoZXJzLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiBhbmltYXRpb24sXG4gICAgICAgICAgICBxdWVyeUNvdW50OiBjb250ZXh0LnF1ZXJ5Q291bnQsXG4gICAgICAgICAgICBkZXBDb3VudDogY29udGV4dC5kZXBDb3VudCxcbiAgICAgICAgICAgIG9wdGlvbnM6IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucylcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNlcXVlbmNlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAyIC8qIFNlcXVlbmNlICovLFxuICAgICAgICAgICAgc3RlcHM6IG1ldGFkYXRhLnN0ZXBzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gdmlzaXREc2xOb2RlKF90aGlzLCBzLCBjb250ZXh0KTsgfSksXG4gICAgICAgICAgICBvcHRpb25zOiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRHcm91cCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1cnRoZXN0VGltZSA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ZXBzID0gbWV0YWRhdGEuc3RlcHMubWFwKGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lckFzdCA9IHZpc2l0RHNsTm9kZShfdGhpcywgc3RlcCwgY29udGV4dCk7XG4gICAgICAgICAgICBmdXJ0aGVzdFRpbWUgPSBNYXRoLm1heChmdXJ0aGVzdFRpbWUsIGNvbnRleHQuY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGlubmVyQXN0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZSA9IGZ1cnRoZXN0VGltZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IDMgLyogR3JvdXAgKi8sXG4gICAgICAgICAgICBzdGVwczogc3RlcHMsXG4gICAgICAgICAgICBvcHRpb25zOiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ0FzdCA9IGNvbnN0cnVjdFRpbWluZ0FzdChtZXRhZGF0YS50aW1pbmdzLCBjb250ZXh0LmVycm9ycyk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzID0gdGltaW5nQXN0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZUFzdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVNZXRhZGF0YSA9IG1ldGFkYXRhLnN0eWxlcyA/IG1ldGFkYXRhLnN0eWxlcyA6IF9hbmd1bGFyX2FuaW1hdGlvbnMuc3R5bGUoe30pO1xuICAgICAgICBpZiAoc3R5bGVNZXRhZGF0YS50eXBlID09IDUgLyogS2V5ZnJhbWVzICovKSB7XG4gICAgICAgICAgICBzdHlsZUFzdCA9IHRoaXMudmlzaXRLZXlmcmFtZXMoLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGVNZXRhZGF0YSksIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVNZXRhZGF0YV8xID0gLyoqIEB0eXBlIHs/fSAqLyAobWV0YWRhdGEuc3R5bGVzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghc3R5bGVNZXRhZGF0YV8xKSB7XG4gICAgICAgICAgICAgICAgaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3U3R5bGVEYXRhID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHRpbWluZ0FzdC5lYXNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGVEYXRhWydlYXNpbmcnXSA9IHRpbWluZ0FzdC5lYXNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlTWV0YWRhdGFfMSA9IF9hbmd1bGFyX2FuaW1hdGlvbnMuc3R5bGUobmV3U3R5bGVEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbWUgKz0gdGltaW5nQXN0LmR1cmF0aW9uICsgdGltaW5nQXN0LmRlbGF5O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gX3N0eWxlQXN0ID0gdGhpcy52aXNpdFN0eWxlKHN0eWxlTWV0YWRhdGFfMSwgY29udGV4dCk7XG4gICAgICAgICAgICBfc3R5bGVBc3QuaXNFbXB0eVN0ZXAgPSBpc0VtcHR5O1xuICAgICAgICAgICAgc3R5bGVBc3QgPSBfc3R5bGVBc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogNCAvKiBBbmltYXRlICovLFxuICAgICAgICAgICAgdGltaW5nczogdGltaW5nQXN0LFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlQXN0LFxuICAgICAgICAgICAgb3B0aW9uczogbnVsbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3R5bGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fbWFrZVN0eWxlQXN0KG1ldGFkYXRhLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVTdHlsZUFzdChhc3QsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl9tYWtlU3R5bGVBc3QgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFkYXRhLnN0eWxlcykpIHtcbiAgICAgICAgICAgICgvKiogQHR5cGUgez99ICovIChtZXRhZGF0YS5zdHlsZXMpKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVR1cGxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZVR1cGxlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZVR1cGxlID09IF9hbmd1bGFyX2FuaW1hdGlvbnMuQVVUT19TVFlMRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGVUdXBsZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlRoZSBwcm92aWRlZCBzdHlsZSBzdHJpbmcgdmFsdWUgXCIgKyBzdHlsZVR1cGxlICsgXCIgaXMgbm90IGFsbG93ZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCgvKiogQHR5cGUgez99ICovIChzdHlsZVR1cGxlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXMucHVzaChtZXRhZGF0YS5zdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5zRHluYW1pY1N0eWxlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xsZWN0ZWRFYXNpbmcgPSBudWxsO1xuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVEYXRhKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3R5bGVEYXRhKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlTWFwID0gLyoqIEB0eXBlIHs/fSAqLyAoc3R5bGVEYXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlYXNpbmcgPSBzdHlsZU1hcFsnZWFzaW5nJ107XG4gICAgICAgICAgICAgICAgaWYgKGVhc2luZykge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRFYXNpbmcgPSAvKiogQHR5cGUgez99ICovIChlYXNpbmcpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3R5bGVNYXBbJ2Vhc2luZyddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5zRHluYW1pY1N0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gc3R5bGVNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gc3R5bGVNYXBbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudG9TdHJpbmcoKS5pbmRleE9mKFNVQlNUSVRVVElPTl9FWFBSX1NUQVJUKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnNEeW5hbWljU3R5bGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiA2IC8qIFN0eWxlICovLFxuICAgICAgICAgICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgICAgICAgICBlYXNpbmc6IGNvbGxlY3RlZEVhc2luZyxcbiAgICAgICAgICAgIG9mZnNldDogbWV0YWRhdGEub2Zmc2V0LCBjb250YWluc0R5bmFtaWNTdHlsZXM6IGNvbnRhaW5zRHluYW1pY1N0eWxlcyxcbiAgICAgICAgICAgIG9wdGlvbnM6IG51bGxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlU3R5bGVBc3QgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1pbmdzID0gY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3M7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICBpZiAodGltaW5ncyAmJiBzdGFydFRpbWUgPiAwKSB7XG4gICAgICAgICAgICBzdGFydFRpbWUgLT0gdGltaW5ncy5kdXJhdGlvbiArIHRpbWluZ3MuZGVsYXk7XG4gICAgICAgIH1cbiAgICAgICAgYXN0LnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0dXBsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0dXBsZSA9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0dXBsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2RyaXZlci52YWxpZGF0ZVN0eWxlUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlRoZSBwcm92aWRlZCBhbmltYXRpb24gcHJvcGVydHkgXFxcIlwiICsgcHJvcCArIFwiXFxcIiBpcyBub3QgYSBzdXBwb3J0ZWQgQ1NTIHByb3BlcnR5IGZvciBhbmltYXRpb25zXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbGxlY3RlZFN0eWxlcyA9IGNvbnRleHQuY29sbGVjdGVkU3R5bGVzWy8qKiBAdHlwZSB7P30gKi8gKChjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yKSldO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbGxlY3RlZEVudHJ5ID0gY29sbGVjdGVkU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZUNvbGxlY3RlZFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGVkRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSAhPSBlbmRUaW1lICYmIHN0YXJ0VGltZSA+PSBjb2xsZWN0ZWRFbnRyeS5zdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWUgPD0gY29sbGVjdGVkRW50cnkuZW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlRoZSBDU1MgcHJvcGVydHkgXFxcIlwiICsgcHJvcCArIFwiXFxcIiB0aGF0IGV4aXN0cyBiZXR3ZWVuIHRoZSB0aW1lcyBvZiBcXFwiXCIgKyBjb2xsZWN0ZWRFbnRyeS5zdGFydFRpbWUgKyBcIm1zXFxcIiBhbmQgXFxcIlwiICsgY29sbGVjdGVkRW50cnkuZW5kVGltZSArIFwibXNcXFwiIGlzIGFsc28gYmVpbmcgYW5pbWF0ZWQgaW4gYSBwYXJhbGxlbCBhbmltYXRpb24gYmV0d2VlbiB0aGUgdGltZXMgb2YgXFxcIlwiICsgc3RhcnRUaW1lICsgXCJtc1xcXCIgYW5kIFxcXCJcIiArIGVuZFRpbWUgKyBcIm1zXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbGxlY3RlZFN0eWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYWx3YXlzIGNob29zZSB0aGUgc21hbGxlciBzdGFydCB0aW1lIHZhbHVlIHNpbmNlIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gaGF2ZSBhIHJlY29yZCBvZiB0aGUgZW50aXJlIGFuaW1hdGlvbiB3aW5kb3cgd2hlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN0eWxlIHByb3BlcnR5IGlzIGJlaW5nIGFuaW1hdGVkIGluIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gY29sbGVjdGVkRW50cnkuc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQ29sbGVjdGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkU3R5bGVzW3Byb3BdID0geyBzdGFydFRpbWU6IHN0YXJ0VGltZSwgZW5kVGltZTogZW5kVGltZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlU3R5bGVQYXJhbXModHVwbGVbcHJvcF0sIGNvbnRleHQub3B0aW9ucywgY29udGV4dC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWZyYW1lcyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB7IHR5cGU6IDUgLyogS2V5ZnJhbWVzICovLCBzdHlsZXM6IFtdLCBvcHRpb25zOiBudWxsIH07XG4gICAgICAgIGlmICghY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goXCJrZXlmcmFtZXMoKSBtdXN0IGJlIHBsYWNlZCBpbnNpZGUgb2YgYSBjYWxsIHRvIGFuaW1hdGUoKVwiKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTUFYX0tFWUZSQU1FX09GRlNFVCA9IDE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvdGFsS2V5ZnJhbWVzV2l0aE9mZnNldHMgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldHNPdXRPZk9yZGVyID0gZmFsc2U7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleWZyYW1lc091dE9mUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSBtZXRhZGF0YS5zdGVwcy5tYXAoZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGUkJDEgPSBfdGhpcy5fbWFrZVN0eWxlQXN0KHN0eWxlcywgY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXRWYWwgPSBzdHlsZSQkMS5vZmZzZXQgIT0gbnVsbCA/IHN0eWxlJCQxLm9mZnNldCA6IGNvbnN1bWVPZmZzZXQoc3R5bGUkJDEuc3R5bGVzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0VmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3RhbEtleWZyYW1lc1dpdGhPZmZzZXRzKys7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gc3R5bGUkJDEub2Zmc2V0ID0gb2Zmc2V0VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ZnJhbWVzT3V0T2ZSYW5nZSA9IGtleWZyYW1lc091dE9mUmFuZ2UgfHwgb2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiAxO1xuICAgICAgICAgICAgb2Zmc2V0c091dE9mT3JkZXIgPSBvZmZzZXRzT3V0T2ZPcmRlciB8fCBvZmZzZXQgPCBwcmV2aW91c09mZnNldDtcbiAgICAgICAgICAgIHByZXZpb3VzT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGUkJDE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ZnJhbWVzT3V0T2ZSYW5nZSkge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlBsZWFzZSBlbnN1cmUgdGhhdCBhbGwga2V5ZnJhbWUgb2Zmc2V0cyBhcmUgYmV0d2VlbiAwIGFuZCAxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXRzT3V0T2ZPcmRlcikge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIlBsZWFzZSBlbnN1cmUgdGhhdCBhbGwga2V5ZnJhbWUgb2Zmc2V0cyBhcmUgaW4gb3JkZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuZ3RoID0gbWV0YWRhdGEuc3RlcHMubGVuZ3RoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnZW5lcmF0ZWRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodG90YWxLZXlmcmFtZXNXaXRoT2Zmc2V0cyA+IDAgJiYgdG90YWxLZXlmcmFtZXNXaXRoT2Zmc2V0cyA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcIk5vdCBhbGwgc3R5bGUoKSBzdGVwcyB3aXRoaW4gdGhlIGRlY2xhcmVkIGtleWZyYW1lcygpIGNvbnRhaW4gb2Zmc2V0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b3RhbEtleWZyYW1lc1dpdGhPZmZzZXRzID09IDApIHtcbiAgICAgICAgICAgIGdlbmVyYXRlZE9mZnNldCA9IE1BWF9LRVlGUkFNRV9PRkZTRVQgLyAobGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGltaXQgPSBsZW5ndGggLSAxO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRBbmltYXRlVGltaW5ncyA9IC8qKiBAdHlwZSB7P30gKi8gKChjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncykpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRlRHVyYXRpb24gPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZHVyYXRpb247XG4gICAgICAgIGtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrZiwgaSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gZ2VuZXJhdGVkT2Zmc2V0ID4gMCA/IChpID09IGxpbWl0ID8gMSA6IChnZW5lcmF0ZWRPZmZzZXQgKiBpKSkgOiBvZmZzZXRzW2ldO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHVyYXRpb25VcFRvVGhpc0ZyYW1lID0gb2Zmc2V0ICogYW5pbWF0ZUR1cmF0aW9uO1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lICsgY3VycmVudEFuaW1hdGVUaW1pbmdzLmRlbGF5ICsgZHVyYXRpb25VcFRvVGhpc0ZyYW1lO1xuICAgICAgICAgICAgY3VycmVudEFuaW1hdGVUaW1pbmdzLmR1cmF0aW9uID0gZHVyYXRpb25VcFRvVGhpc0ZyYW1lO1xuICAgICAgICAgICAgX3RoaXMuX3ZhbGlkYXRlU3R5bGVBc3Qoa2YsIGNvbnRleHQpO1xuICAgICAgICAgICAga2Yub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYXN0LnN0eWxlcy5wdXNoKGtmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IDggLyogUmVmZXJlbmNlICovLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiB2aXNpdERzbE5vZGUodGhpcywgbm9ybWFsaXplQW5pbWF0aW9uRW50cnkobWV0YWRhdGEuYW5pbWF0aW9uKSwgY29udGV4dCksXG4gICAgICAgICAgICBvcHRpb25zOiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlQ2hpbGQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5kZXBDb3VudCsrO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogOSAvKiBBbmltYXRlQ2hpbGQgKi8sXG4gICAgICAgICAgICBvcHRpb25zOiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlUmVmID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAxMCAvKiBBbmltYXRlUmVmICovLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiB0aGlzLnZpc2l0UmVmZXJlbmNlKG1ldGFkYXRhLmFuaW1hdGlvbiwgY29udGV4dCksXG4gICAgICAgICAgICBvcHRpb25zOiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdWVyeSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRTZWxlY3RvciA9IC8qKiBAdHlwZSB7P30gKi8gKChjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnMgPSAvKiogQHR5cGUgez99ICovICgobWV0YWRhdGEub3B0aW9ucyB8fCB7fSkpO1xuICAgICAgICBjb250ZXh0LnF1ZXJ5Q291bnQrKztcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnkgPSBtZXRhZGF0YTtcbiAgICAgICAgdmFyIF9hID0gbm9ybWFsaXplU2VsZWN0b3IobWV0YWRhdGEuc2VsZWN0b3IpLCBzZWxlY3RvciA9IF9hWzBdLCBpbmNsdWRlU2VsZiA9IF9hWzFdO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yID1cbiAgICAgICAgICAgIHBhcmVudFNlbGVjdG9yLmxlbmd0aCA/IChwYXJlbnRTZWxlY3RvciArICcgJyArIHNlbGVjdG9yKSA6IHNlbGVjdG9yO1xuICAgICAgICBnZXRPclNldEFzSW5NYXAoY29udGV4dC5jb2xsZWN0ZWRTdHlsZXMsIGNvbnRleHQuY3VycmVudFF1ZXJ5U2VsZWN0b3IsIHt9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0aW9uID0gdmlzaXREc2xOb2RlKHRoaXMsIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KG1ldGFkYXRhLmFuaW1hdGlvbiksIGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeSA9IG51bGw7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5U2VsZWN0b3IgPSBwYXJlbnRTZWxlY3RvcjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IDExIC8qIFF1ZXJ5ICovLFxuICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICAgICAgbGltaXQ6IG9wdGlvbnMubGltaXQgfHwgMCxcbiAgICAgICAgICAgIG9wdGlvbmFsOiAhIW9wdGlvbnMub3B0aW9uYWwsIGluY2x1ZGVTZWxmOiBpbmNsdWRlU2VsZiwgYW5pbWF0aW9uOiBhbmltYXRpb24sXG4gICAgICAgICAgICBvcmlnaW5hbFNlbGVjdG9yOiBtZXRhZGF0YS5zZWxlY3RvcixcbiAgICAgICAgICAgIG9wdGlvbnM6IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucylcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkFzdEJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0YWdnZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnRRdWVyeSkge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChcInN0YWdnZXIoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBvZiBxdWVyeSgpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSBtZXRhZGF0YS50aW1pbmdzID09PSAnZnVsbCcgP1xuICAgICAgICAgICAgeyBkdXJhdGlvbjogMCwgZGVsYXk6IDAsIGVhc2luZzogJ2Z1bGwnIH0gOlxuICAgICAgICAgICAgcmVzb2x2ZVRpbWluZyhtZXRhZGF0YS50aW1pbmdzLCBjb250ZXh0LmVycm9ycywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAxMiAvKiBTdGFnZ2VyICovLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiB2aXNpdERzbE5vZGUodGhpcywgbm9ybWFsaXplQW5pbWF0aW9uRW50cnkobWV0YWRhdGEuYW5pbWF0aW9uKSwgY29udGV4dCksIHRpbWluZ3M6IHRpbWluZ3MsXG4gICAgICAgICAgICBvcHRpb25zOiBudWxsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc0FtcGVyc2FuZCA9IHNlbGVjdG9yLnNwbGl0KC9cXHMqLFxccyovKS5maW5kKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4gPT0gU0VMRl9UT0tFTjsgfSkgPyB0cnVlIDogZmFsc2U7XG4gICAgaWYgKGhhc0FtcGVyc2FuZCkge1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoU0VMRl9UT0tFTl9SRUdFWCwgJycpO1xuICAgIH1cbiAgICAvLyB0aGUgOmVudGVyIGFuZCA6bGVhdmUgc2VsZWN0b3JzIGFyZSBmaWxsZWQgaW4gYXQgcnVudGltZSBkdXJpbmcgdGltZWxpbmUgYnVpbGRpbmdcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoL0BcXCovZywgTkdfVFJJR0dFUl9TRUxFQ1RPUilcbiAgICAgICAgLnJlcGxhY2UoL0BcXHcrL2csIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gTkdfVFJJR0dFUl9TRUxFQ1RPUiArICctJyArIG1hdGNoLnN1YnN0cigxKTsgfSlcbiAgICAgICAgLnJlcGxhY2UoLzphbmltYXRpbmcvZywgTkdfQU5JTUFUSU5HX1NFTEVDVE9SKTtcbiAgICByZXR1cm4gW3NlbGVjdG9yLCBoYXNBbXBlcnNhbmRdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG9ialxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1zKG9iaikge1xuICAgIHJldHVybiBvYmogPyBjb3B5T2JqKG9iaikgOiBudWxsO1xufVxudmFyIEFuaW1hdGlvbkFzdEJ1aWxkZXJDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkFzdEJ1aWxkZXJDb250ZXh0KGVycm9ycykge1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5xdWVyeUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5kZXBDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFRyYW5zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRRdWVyeSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFF1ZXJ5U2VsZWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRlVGltaW5ncyA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmNvbGxlY3RlZFN0eWxlcyA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQW5pbWF0aW9uQXN0QnVpbGRlckNvbnRleHQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHN0eWxlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29uc3VtZU9mZnNldChzdHlsZXMpIHtcbiAgICBpZiAodHlwZW9mIHN0eWxlcyA9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gbnVsbDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZXMpKSB7XG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVR1cGxlKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3R5bGVUdXBsZSkgJiYgc3R5bGVUdXBsZS5oYXNPd25Qcm9wZXJ0eSgnb2Zmc2V0JykpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvYmogPSAvKiogQHR5cGUgez99ICovIChzdHlsZVR1cGxlKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KC8qKiBAdHlwZSB7P30gKi8gKG9ialsnb2Zmc2V0J10pKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqWydvZmZzZXQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHN0eWxlcykgJiYgc3R5bGVzLmhhc093blByb3BlcnR5KCdvZmZzZXQnKSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvYmogPSAvKiogQHR5cGUgez99ICovIChzdHlsZXMpO1xuICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KC8qKiBAdHlwZSB7P30gKi8gKG9ialsnb2Zmc2V0J10pKTtcbiAgICAgICAgZGVsZXRlIG9ialsnb2Zmc2V0J107XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RUaW1pbmdBc3QodmFsdWUsIGVycm9ycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ3MgPSBudWxsO1xuICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZHVyYXRpb24nKSkge1xuICAgICAgICB0aW1pbmdzID0gLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHVyYXRpb24gPSByZXNvbHZlVGltaW5nKC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKSwgZXJyb3JzKS5kdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIG1ha2VUaW1pbmdBc3QoLyoqIEB0eXBlIHs/fSAqLyAoZHVyYXRpb24pLCAwLCAnJyk7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0clZhbHVlID0gLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRHluYW1pYyA9IHN0clZhbHVlLnNwbGl0KC9cXHMrLykuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gdi5jaGFyQXQoMCkgPT0gJ3snICYmIHYuY2hhckF0KDEpID09ICd7JzsgfSk7XG4gICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSAvKiogQHR5cGUgez99ICovIChtYWtlVGltaW5nQXN0KDAsIDAsICcnKSk7XG4gICAgICAgIGFzdC5keW5hbWljID0gdHJ1ZTtcbiAgICAgICAgYXN0LnN0clZhbHVlID0gc3RyVmFsdWU7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUgez99ICovIChhc3QpO1xuICAgIH1cbiAgICB0aW1pbmdzID0gdGltaW5ncyB8fCByZXNvbHZlVGltaW5nKHN0clZhbHVlLCBlcnJvcnMpO1xuICAgIHJldHVybiBtYWtlVGltaW5nQXN0KHRpbWluZ3MuZHVyYXRpb24sIHRpbWluZ3MuZGVsYXksIHRpbWluZ3MuZWFzaW5nKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBvcHRpb25zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gY29weU9iaihvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnNbJ3BhcmFtcyddKSB7XG4gICAgICAgICAgICBvcHRpb25zWydwYXJhbXMnXSA9IC8qKiBAdHlwZSB7P30gKi8gKChub3JtYWxpemVQYXJhbXMob3B0aW9uc1sncGFyYW1zJ10pKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZHVyYXRpb25cbiAqIEBwYXJhbSB7P30gZGVsYXlcbiAqIEBwYXJhbSB7P30gZWFzaW5nXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtYWtlVGltaW5nQXN0KGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgcmV0dXJuIHsgZHVyYXRpb246IGR1cmF0aW9uLCBkZWxheTogZGVsYXksIGVhc2luZzogZWFzaW5nIH07XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQHJlY29yZFxuICovXG5cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IGtleWZyYW1lc1xuICogQHBhcmFtIHs/fSBwcmVTdHlsZVByb3BzXG4gKiBAcGFyYW0gez99IHBvc3RTdHlsZVByb3BzXG4gKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gKiBAcGFyYW0gez99IGRlbGF5XG4gKiBAcGFyYW0gez89fSBlYXNpbmdcbiAqIEBwYXJhbSB7Pz19IHN1YlRpbWVsaW5lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVUaW1lbGluZUluc3RydWN0aW9uKGVsZW1lbnQsIGtleWZyYW1lcywgcHJlU3R5bGVQcm9wcywgcG9zdFN0eWxlUHJvcHMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBzdWJUaW1lbGluZSkge1xuICAgIGlmIChlYXNpbmcgPT09IHZvaWQgMCkgeyBlYXNpbmcgPSBudWxsOyB9XG4gICAgaWYgKHN1YlRpbWVsaW5lID09PSB2b2lkIDApIHsgc3ViVGltZWxpbmUgPSBmYWxzZTsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDEgLyogVGltZWxpbmVBbmltYXRpb24gKi8sXG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIGtleWZyYW1lczoga2V5ZnJhbWVzLFxuICAgICAgICBwcmVTdHlsZVByb3BzOiBwcmVTdHlsZVByb3BzLFxuICAgICAgICBwb3N0U3R5bGVQcm9wczogcG9zdFN0eWxlUHJvcHMsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgICB0b3RhbFRpbWU6IGR1cmF0aW9uICsgZGVsYXksIGVhc2luZzogZWFzaW5nLCBzdWJUaW1lbGluZTogc3ViVGltZWxpbmVcbiAgICB9O1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgRWxlbWVudEluc3RydWN0aW9uTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRJbnN0cnVjdGlvbk1hcCgpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRJbnN0cnVjdGlvbk1hcC5wcm90b3R5cGUuY29uc3VtZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5zdHJ1Y3Rpb25zID0gdGhpcy5fbWFwLmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudEluc3RydWN0aW9uTWFwLnByb3RvdHlwZS5hcHBlbmQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIGluc3RydWN0aW9ucykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleGlzdGluZ0luc3RydWN0aW9ucyA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmICghZXhpc3RpbmdJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoZWxlbWVudCwgZXhpc3RpbmdJbnN0cnVjdGlvbnMgPSBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhpc3RpbmdJbnN0cnVjdGlvbnMucHVzaC5hcHBseShleGlzdGluZ0luc3RydWN0aW9ucywgaW5zdHJ1Y3Rpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudEluc3RydWN0aW9uTWFwLnByb3RvdHlwZS5oYXMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiB0aGlzLl9tYXAuaGFzKGVsZW1lbnQpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudEluc3RydWN0aW9uTWFwLnByb3RvdHlwZS5jbGVhciA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9tYXAuY2xlYXIoKTsgfTtcbiAgICByZXR1cm4gRWxlbWVudEluc3RydWN0aW9uTWFwO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIE9ORV9GUkFNRV9JTl9NSUxMSVNFQ09ORFMgPSAxO1xudmFyIEVOVEVSX1RPS0VOID0gJzplbnRlcic7XG52YXIgRU5URVJfVE9LRU5fUkVHRVggPSBuZXcgUmVnRXhwKEVOVEVSX1RPS0VOLCAnZycpO1xudmFyIExFQVZFX1RPS0VOID0gJzpsZWF2ZSc7XG52YXIgTEVBVkVfVE9LRU5fUkVHRVggPSBuZXcgUmVnRXhwKExFQVZFX1RPS0VOLCAnZycpO1xuLyoqXG4gKiBAcGFyYW0gez99IGRyaXZlclxuICogQHBhcmFtIHs/fSByb290RWxlbWVudFxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEBwYXJhbSB7P30gZW50ZXJDbGFzc05hbWVcbiAqIEBwYXJhbSB7P30gbGVhdmVDbGFzc05hbWVcbiAqIEBwYXJhbSB7Pz19IHN0YXJ0aW5nU3R5bGVzXG4gKiBAcGFyYW0gez89fSBmaW5hbFN0eWxlc1xuICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXG4gKiBAcGFyYW0gez89fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQW5pbWF0aW9uVGltZWxpbmVzKGRyaXZlciwgcm9vdEVsZW1lbnQsIGFzdCwgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lLCBzdGFydGluZ1N0eWxlcywgZmluYWxTdHlsZXMsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKSB7XG4gICAgaWYgKHN0YXJ0aW5nU3R5bGVzID09PSB2b2lkIDApIHsgc3RhcnRpbmdTdHlsZXMgPSB7fTsgfVxuICAgIGlmIChmaW5hbFN0eWxlcyA9PT0gdm9pZCAwKSB7IGZpbmFsU3R5bGVzID0ge307IH1cbiAgICBpZiAoZXJyb3JzID09PSB2b2lkIDApIHsgZXJyb3JzID0gW107IH1cbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IoKS5idWlsZEtleWZyYW1lcyhkcml2ZXIsIHJvb3RFbGVtZW50LCBhc3QsIGVudGVyQ2xhc3NOYW1lLCBsZWF2ZUNsYXNzTmFtZSwgc3RhcnRpbmdTdHlsZXMsIGZpbmFsU3R5bGVzLCBvcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMsIGVycm9ycyk7XG59XG52YXIgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRyaXZlclxuICAgICAqIEBwYXJhbSB7P30gcm9vdEVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gZW50ZXJDbGFzc05hbWVcbiAgICAgKiBAcGFyYW0gez99IGxlYXZlQ2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHs/fSBzdGFydGluZ1N0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gZmluYWxTdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBzdWJJbnN0cnVjdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLmJ1aWxkS2V5ZnJhbWVzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBkcml2ZXJcbiAgICAgKiBAcGFyYW0gez99IHJvb3RFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGVudGVyQ2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHs/fSBsZWF2ZUNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRpbmdTdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IGZpbmFsU3R5bGVzXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXG4gICAgICogQHBhcmFtIHs/PX0gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZHJpdmVyLCByb290RWxlbWVudCwgYXN0LCBlbnRlckNsYXNzTmFtZSwgbGVhdmVDbGFzc05hbWUsIHN0YXJ0aW5nU3R5bGVzLCBmaW5hbFN0eWxlcywgb3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zLCBlcnJvcnMpIHtcbiAgICAgICAgaWYgKGVycm9ycyA9PT0gdm9pZCAwKSB7IGVycm9ycyA9IFtdOyB9XG4gICAgICAgIHN1Ykluc3RydWN0aW9ucyA9IHN1Ykluc3RydWN0aW9ucyB8fCBuZXcgRWxlbWVudEluc3RydWN0aW9uTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRleHQgPSBuZXcgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0KGRyaXZlciwgcm9vdEVsZW1lbnQsIHN1Ykluc3RydWN0aW9ucywgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lLCBlcnJvcnMsIFtdKTtcbiAgICAgICAgY29udGV4dC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUuc2V0U3R5bGVzKFtzdGFydGluZ1N0eWxlc10sIG51bGwsIGNvbnRleHQuZXJyb3JzLCBvcHRpb25zKTtcbiAgICAgICAgdmlzaXREc2xOb2RlKHRoaXMsIGFzdCwgY29udGV4dCk7XG4gICAgICAgIC8vIHRoaXMgY2hlY2tzIHRvIHNlZSBpZiBhbiBhY3R1YWwgYW5pbWF0aW9uIGhhcHBlbmVkXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWVsaW5lcyA9IGNvbnRleHQudGltZWxpbmVzLmZpbHRlcihmdW5jdGlvbiAodGltZWxpbmUpIHsgcmV0dXJuIHRpbWVsaW5lLmNvbnRhaW5zQW5pbWF0aW9uKCk7IH0pO1xuICAgICAgICBpZiAodGltZWxpbmVzLmxlbmd0aCAmJiBPYmplY3Qua2V5cyhmaW5hbFN0eWxlcykubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0bCA9IHRpbWVsaW5lc1t0aW1lbGluZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoIXRsLmFsbG93T25seVRpbWVsaW5lU3R5bGVzKCkpIHtcbiAgICAgICAgICAgICAgICB0bC5zZXRTdHlsZXMoW2ZpbmFsU3R5bGVzXSwgbnVsbCwgY29udGV4dC5lcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lbGluZXMubGVuZ3RoID8gdGltZWxpbmVzLm1hcChmdW5jdGlvbiAodGltZWxpbmUpIHsgcmV0dXJuIHRpbWVsaW5lLmJ1aWxkS2V5ZnJhbWVzKCk7IH0pIDpcbiAgICAgICAgICAgIFtjcmVhdGVUaW1lbGluZUluc3RydWN0aW9uKHJvb3RFbGVtZW50LCBbXSwgW10sIFtdLCAwLCAwLCAnJywgZmFsc2UpXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyaWdnZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAvLyB0aGVzZSB2YWx1ZXMgYXJlIG5vdCB2aXNpdGVkIGluIHRoaXMgQVNUXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGF0ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIHRoZXNlIHZhbHVlcyBhcmUgbm90IHZpc2l0ZWQgaW4gdGhpcyBBU1RcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyYW5zaXRpb24gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAvLyB0aGVzZSB2YWx1ZXMgYXJlIG5vdCB2aXNpdGVkIGluIHRoaXMgQVNUXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlQ2hpbGQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50SW5zdHJ1Y3Rpb25zID0gY29udGV4dC5zdWJJbnN0cnVjdGlvbnMuY29uc3VtZShjb250ZXh0LmVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudEluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJDb250ZXh0ID0gY29udGV4dC5jcmVhdGVTdWJDb250ZXh0KGFzdC5vcHRpb25zKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kVGltZSA9IHRoaXMuX3Zpc2l0U3ViSW5zdHJ1Y3Rpb25zKGVsZW1lbnRJbnN0cnVjdGlvbnMsIGlubmVyQ29udGV4dCwgLyoqIEB0eXBlIHs/fSAqLyAoaW5uZXJDb250ZXh0Lm9wdGlvbnMpKTtcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWUgIT0gZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvIHRoaXMgb24gdGhlIHVwcGVyIGNvbnRleHQgYmVjYXVzZSB3ZSBjcmVhdGVkIGEgc3ViIGNvbnRleHQgZm9yXG4gICAgICAgICAgICAgICAgLy8gdGhlIHN1YiBjaGlsZCBhbmltYXRpb25zXG4gICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoZW5kVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlUmVmID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJDb250ZXh0ID0gY29udGV4dC5jcmVhdGVTdWJDb250ZXh0KGFzdC5vcHRpb25zKTtcbiAgICAgICAgaW5uZXJDb250ZXh0LnRyYW5zZm9ybUludG9OZXdUaW1lbGluZSgpO1xuICAgICAgICB0aGlzLnZpc2l0UmVmZXJlbmNlKGFzdC5hbmltYXRpb24sIGlubmVyQ29udGV4dCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWUpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25zXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRTdWJJbnN0cnVjdGlvbnMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uc1xuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGluc3RydWN0aW9ucywgY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVydGhlc3RUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbC1jYXNlIGZvciB3aGVuIGEgdXNlciB3YW50cyB0byBza2lwIGEgc3ViXG4gICAgICAgIC8vIGFuaW1hdGlvbiBmcm9tIGJlaW5nIGZpcmVkIGVudGlyZWx5LlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT0gbnVsbCA/IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmR1cmF0aW9uKSA6IG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGF5ID0gb3B0aW9ucy5kZWxheSAhPSBudWxsID8gcmVzb2x2ZVRpbWluZ1ZhbHVlKG9wdGlvbnMuZGVsYXkpIDogbnVsbDtcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0cnVjdGlvblRpbWluZ3MgPSBjb250ZXh0LmFwcGVuZEluc3RydWN0aW9uVG9UaW1lbGluZShpbnN0cnVjdGlvbiwgZHVyYXRpb24sIGRlbGF5KTtcbiAgICAgICAgICAgICAgICBmdXJ0aGVzdFRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChmdXJ0aGVzdFRpbWUsIGluc3RydWN0aW9uVGltaW5ncy5kdXJhdGlvbiArIGluc3RydWN0aW9uVGltaW5ncy5kZWxheSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVydGhlc3RUaW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC51cGRhdGVPcHRpb25zKGFzdC5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgdmlzaXREc2xOb2RlKHRoaXMsIGFzdC5hbmltYXRpb24sIGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNlcXVlbmNlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ViQ29udGV4dENvdW50ID0gY29udGV4dC5zdWJDb250ZXh0Q291bnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eCA9IGNvbnRleHQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnMgPSBhc3Qub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMucGFyYW1zIHx8IG9wdGlvbnMuZGVsYXkpKSB7XG4gICAgICAgICAgICBjdHggPSBjb250ZXh0LmNyZWF0ZVN1YkNvbnRleHQob3B0aW9ucyk7XG4gICAgICAgICAgICBjdHgudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWxheSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5wcmV2aW91c05vZGUudHlwZSA9PSA2IC8qIFN0eWxlICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5jdXJyZW50VGltZWxpbmUuc25hcHNob3RDdXJyZW50U3R5bGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5wcmV2aW91c05vZGUgPSBERUZBVUxUX05PT1BfUFJFVklPVVNfTk9ERTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsYXkgPSByZXNvbHZlVGltaW5nVmFsdWUob3B0aW9ucy5kZWxheSk7XG4gICAgICAgICAgICAgICAgY3R4LmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhc3Quc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhc3Quc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gdmlzaXREc2xOb2RlKF90aGlzLCBzLCBjdHgpOyB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgaGVyZSBqdXN0IGluY2FzZSB0aGUgaW5uZXIgc3RlcHMgb25seSBjb250YWluIG9yIGVuZCB3aXRoIGEgc3R5bGUoKSBjYWxsXG4gICAgICAgICAgICBjdHguY3VycmVudFRpbWVsaW5lLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSgpO1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHNvbWUgYW5pbWF0aW9uIGZ1bmN0aW9uIHdpdGhpbiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIGVuZGVkIHVwIGNyZWF0aW5nIGEgc3ViIHRpbWVsaW5lICh3aGljaCBtZWFucyB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8gdGltZWxpbmUgY2Fubm90IG92ZXJsYXAgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIHNlcXVlbmNlKVxuICAgICAgICAgICAgaWYgKGN0eC5zdWJDb250ZXh0Q291bnQgPiBzdWJDb250ZXh0Q291bnQpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRHcm91cCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyVGltZWxpbmVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1cnRoZXN0VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxheSA9IGFzdC5vcHRpb25zICYmIGFzdC5vcHRpb25zLmRlbGF5ID8gcmVzb2x2ZVRpbWluZ1ZhbHVlKGFzdC5vcHRpb25zLmRlbGF5KSA6IDA7XG4gICAgICAgIGFzdC5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lckNvbnRleHQgPSBjb250ZXh0LmNyZWF0ZVN1YkNvbnRleHQoYXN0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgaW5uZXJDb250ZXh0LmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlzaXREc2xOb2RlKF90aGlzLCBzLCBpbm5lckNvbnRleHQpO1xuICAgICAgICAgICAgZnVydGhlc3RUaW1lID0gTWF0aC5tYXgoZnVydGhlc3RUaW1lLCBpbm5lckNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIGlubmVyVGltZWxpbmVzLnB1c2goaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIG9wZXJhdGlvbiBpcyBydW4gYWZ0ZXIgdGhlIEFTVCBsb29wIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgdGltZWxpbmUncyBjb2xsZWN0ZWQgc3R5bGVzIHdlcmUgdXBkYXRlZCB0aGVuXG4gICAgICAgIC8vIGl0IHdvdWxkIHBhc3MgaW4gaW52YWxpZCBkYXRhIGludG8gdGhlIG5ldy10by1iZSBmb3JrZWQgaXRlbXNcbiAgICAgICAgaW5uZXJUaW1lbGluZXMuZm9yRWFjaChmdW5jdGlvbiAodGltZWxpbmUpIHsgcmV0dXJuIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLm1lcmdlVGltZWxpbmVDb2xsZWN0ZWRTdHlsZXModGltZWxpbmUpOyB9KTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoZnVydGhlc3RUaW1lKTtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0VGltaW5nID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCgvKiogQHR5cGUgez99ICovIChhc3QpKS5keW5hbWljKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJWYWx1ZSA9ICgvKiogQHR5cGUgez99ICovIChhc3QpKS5zdHJWYWx1ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWluZ1ZhbHVlID0gY29udGV4dC5wYXJhbXMgPyBpbnRlcnBvbGF0ZVBhcmFtcyhzdHJWYWx1ZSwgY29udGV4dC5wYXJhbXMsIGNvbnRleHQuZXJyb3JzKSA6IHN0clZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVUaW1pbmcodGltaW5nVmFsdWUsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBhc3QuZHVyYXRpb24sIGRlbGF5OiBhc3QuZGVsYXksIGVhc2luZzogYXN0LmVhc2luZyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbmltYXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5ncyA9IGNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzID0gdGhpcy5fdmlzaXRUaW1pbmcoYXN0LnRpbWluZ3MsIGNvbnRleHQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lbGluZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lO1xuICAgICAgICBpZiAodGltaW5ncy5kZWxheSkge1xuICAgICAgICAgICAgY29udGV4dC5pbmNyZW1lbnRUaW1lKHRpbWluZ3MuZGVsYXkpO1xuICAgICAgICAgICAgdGltZWxpbmUuc25hcHNob3RDdXJyZW50U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGUkJDEgPSBhc3Quc3R5bGU7XG4gICAgICAgIGlmIChzdHlsZSQkMS50eXBlID09IDUgLyogS2V5ZnJhbWVzICovKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0S2V5ZnJhbWVzKHN0eWxlJCQxLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuaW5jcmVtZW50VGltZSh0aW1pbmdzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRTdHlsZSgvKiogQHR5cGUgez99ICovIChzdHlsZSQkMSksIGNvbnRleHQpO1xuICAgICAgICAgICAgdGltZWxpbmUuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0eWxlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltZWxpbmUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGltaW5ncyA9IC8qKiBAdHlwZSB7P30gKi8gKChjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncykpO1xuICAgICAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlIGZvciB3aGVuIGEgc3R5bGUoKSBjYWxsXG4gICAgICAgIC8vIGRpcmVjdGx5IGZvbGxvd3MgIGFuIGFuaW1hdGUoKSBjYWxsIChidXQgbm90IGluc2lkZSBvZiBhbiBhbmltYXRlKCkgY2FsbClcbiAgICAgICAgaWYgKCF0aW1pbmdzICYmIHRpbWVsaW5lLmdldEN1cnJlbnRTdHlsZVByb3BlcnRpZXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRpbWVsaW5lLmZvcndhcmRGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVhc2luZyA9ICh0aW1pbmdzICYmIHRpbWluZ3MuZWFzaW5nKSB8fCBhc3QuZWFzaW5nO1xuICAgICAgICBpZiAoYXN0LmlzRW1wdHlTdGVwKSB7XG4gICAgICAgICAgICB0aW1lbGluZS5hcHBseUVtcHR5U3RlcChlYXNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGltZWxpbmUuc2V0U3R5bGVzKGFzdC5zdHlsZXMsIGVhc2luZywgY29udGV4dC5lcnJvcnMsIGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXlmcmFtZXMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSAvKiogQHR5cGUgez99ICovICgoY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUaW1lID0gKC8qKiBAdHlwZSB7P30gKi8gKChjb250ZXh0LmN1cnJlbnRUaW1lbGluZSkpKS5kdXJhdGlvbjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHVyYXRpb24gPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZHVyYXRpb247XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRpbWVsaW5lID0gaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgaW5uZXJUaW1lbGluZS5lYXNpbmcgPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZWFzaW5nO1xuICAgICAgICBhc3Quc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IHN0ZXAub2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICBpbm5lclRpbWVsaW5lLmZvcndhcmRUaW1lKG9mZnNldCAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGlubmVyVGltZWxpbmUuc2V0U3R5bGVzKHN0ZXAuc3R5bGVzLCBzdGVwLmVhc2luZywgY29udGV4dC5lcnJvcnMsIGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgICAgICBpbm5lclRpbWVsaW5lLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBwYXJlbnQgdGltZWxpbmUgZ2V0cyBhbGwgdGhlIHN0eWxlcyBmcm9tXG4gICAgICAgIC8vIHRoZSBjaGlsZCBldmVuIGlmIHRoZSBuZXcgdGltZWxpbmUgYmVsb3cgaXMgbm90IHVzZWRcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUubWVyZ2VUaW1lbGluZUNvbGxlY3RlZFN0eWxlcyhpbm5lclRpbWVsaW5lKTtcbiAgICAgICAgLy8gd2UgZG8gdGhpcyBiZWNhdXNlIHRoZSB3aW5kb3cgYmV0d2VlbiB0aGlzIHRpbWVsaW5lIGFuZCB0aGUgc3ViIHRpbWVsaW5lXG4gICAgICAgIC8vIHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgc3R5bGVzIHdpdGhpbiBhcmUgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGV5IHdlcmUgYmVmb3JlXG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKHN0YXJ0VGltZSArIGR1cmF0aW9uKTtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdWVyeSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGluIHRoZSBldmVudCB0aGF0IHRoZSBmaXJzdCBzdGVwIGJlZm9yZSB0aGlzIGlzIGEgc3R5bGUgc3RlcCB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGVuc3VyZSB0aGUgc3R5bGVzIGFyZSBhcHBsaWVkIGJlZm9yZSB0aGUgY2hpbGRyZW4gYXJlIGFuaW1hdGVkXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0gLyoqIEB0eXBlIHs/fSAqLyAoKGFzdC5vcHRpb25zIHx8IHt9KSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGF5ID0gb3B0aW9ucy5kZWxheSA/IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KSA6IDA7XG4gICAgICAgIGlmIChkZWxheSAmJiAoY29udGV4dC5wcmV2aW91c05vZGUudHlwZSA9PT0gNiAvKiBTdHlsZSAqLyB8fFxuICAgICAgICAgICAgKHN0YXJ0VGltZSA9PSAwICYmIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmdldEN1cnJlbnRTdHlsZVByb3BlcnRpZXMoKS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUuc25hcHNob3RDdXJyZW50U3R5bGVzKCk7XG4gICAgICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IERFRkFVTFRfTk9PUF9QUkVWSU9VU19OT0RFO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1cnRoZXN0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxtcyA9IGNvbnRleHQuaW52b2tlUXVlcnkoYXN0LnNlbGVjdG9yLCBhc3Qub3JpZ2luYWxTZWxlY3RvciwgYXN0LmxpbWl0LCBhc3QuaW5jbHVkZVNlbGYsIG9wdGlvbnMub3B0aW9uYWwgPyB0cnVlIDogZmFsc2UsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IGVsbXMubGVuZ3RoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzYW1lRWxlbWVudFRpbWVsaW5lID0gbnVsbDtcbiAgICAgICAgZWxtcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeUluZGV4ID0gaTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucywgZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBpbm5lckNvbnRleHQuZGVsYXlOZXh0U3RlcChkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gY29udGV4dC5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2FtZUVsZW1lbnRUaW1lbGluZSA9IGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aXNpdERzbE5vZGUoX3RoaXMsIGFzdC5hbmltYXRpb24sIGlubmVyQ29udGV4dCk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGhlcmUganVzdCBpbmNhc2UgdGhlIGlubmVyIHN0ZXBzIG9ubHkgY29udGFpbiBvciBlbmRcbiAgICAgICAgICAgIC8vIHdpdGggYSBzdHlsZSgpIGNhbGwgKHdoaWNoIGlzIGhlcmUgdG8gc2lnbmFsIHRoYXQgdGhpcyBpcyBhIHByZXBhcmF0b3J5XG4gICAgICAgICAgICAvLyBjYWxsIHRvIHN0eWxlIGFuIGVsZW1lbnQgYmVmb3JlIGl0IGlzIGFuaW1hdGVkIGFnYWluKVxuICAgICAgICAgICAgaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZS5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZFRpbWUgPSBpbm5lckNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgZnVydGhlc3RUaW1lID0gTWF0aC5tYXgoZnVydGhlc3RUaW1lLCBlbmRUaW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5SW5kZXggPSAwO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeVRvdGFsID0gMDtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoZnVydGhlc3RUaW1lKTtcbiAgICAgICAgaWYgKHNhbWVFbGVtZW50VGltZWxpbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLm1lcmdlVGltZWxpbmVDb2xsZWN0ZWRTdHlsZXMoc2FtZUVsZW1lbnRUaW1lbGluZSk7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN0YWdnZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRDb250ZXh0ID0gLyoqIEB0eXBlIHs/fSAqLyAoKGNvbnRleHQucGFyZW50Q29udGV4dCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0bCA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1pbmdzID0gYXN0LnRpbWluZ3M7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGR1cmF0aW9uID0gTWF0aC5hYnModGltaW5ncy5kdXJhdGlvbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1heFRpbWUgPSBkdXJhdGlvbiAqIChjb250ZXh0LmN1cnJlbnRRdWVyeVRvdGFsIC0gMSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGF5ID0gZHVyYXRpb24gKiBjb250ZXh0LmN1cnJlbnRRdWVyeUluZGV4O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFnZ2VyVHJhbnNmb3JtZXIgPSB0aW1pbmdzLmR1cmF0aW9uIDwgMCA/ICdyZXZlcnNlJyA6IHRpbWluZ3MuZWFzaW5nO1xuICAgICAgICBzd2l0Y2ggKHN0YWdnZXJUcmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgY2FzZSAncmV2ZXJzZSc6XG4gICAgICAgICAgICAgICAgZGVsYXkgPSBtYXhUaW1lIC0gZGVsYXk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmdWxsJzpcbiAgICAgICAgICAgICAgICBkZWxheSA9IHBhcmVudENvbnRleHQuY3VycmVudFN0YWdnZXJUaW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWVsaW5lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmU7XG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgdGltZWxpbmUuZGVsYXlOZXh0U3RlcChkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRpbmdUaW1lID0gdGltZWxpbmUuY3VycmVudFRpbWU7XG4gICAgICAgIHZpc2l0RHNsTm9kZSh0aGlzLCBhc3QuYW5pbWF0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgICAgIC8vIHRpbWUgPSBkdXJhdGlvbiArIGRlbGF5XG4gICAgICAgIC8vIHRoZSByZWFzb24gd2h5IHRoaXMgY29tcHV0YXRpb24gaXMgc28gY29tcGxleCBpcyBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBpbm5lciB0aW1lbGluZSBtYXkgZWl0aGVyIGhhdmUgYSBkZWxheSB2YWx1ZSBvciBhIHN0cmV0Y2hlZFxuICAgICAgICAvLyBrZXlmcmFtZSBkZXBlbmRpbmcgb24gaWYgYSBzdWJ0aW1lbGluZSBpcyBub3QgdXNlZCBvciBpcyB1c2VkLlxuICAgICAgICBwYXJlbnRDb250ZXh0LmN1cnJlbnRTdGFnZ2VyVGltZSA9XG4gICAgICAgICAgICAodGwuY3VycmVudFRpbWUgLSBzdGFydGluZ1RpbWUpICsgKHRsLnN0YXJ0VGltZSAtIHBhcmVudENvbnRleHQuY3VycmVudFRpbWVsaW5lLnN0YXJ0VGltZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uVGltZWxpbmVCdWlsZGVyVmlzaXRvcjtcbn0oKSk7XG52YXIgREVGQVVMVF9OT09QX1BSRVZJT1VTX05PREUgPSAvKiogQHR5cGUgez99ICovICh7fSk7XG52YXIgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dChfZHJpdmVyLCBlbGVtZW50LCBzdWJJbnN0cnVjdGlvbnMsIF9lbnRlckNsYXNzTmFtZSwgX2xlYXZlQ2xhc3NOYW1lLCBlcnJvcnMsIHRpbWVsaW5lcywgaW5pdGlhbFRpbWVsaW5lKSB7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc3ViSW5zdHJ1Y3Rpb25zID0gc3ViSW5zdHJ1Y3Rpb25zO1xuICAgICAgICB0aGlzLl9lbnRlckNsYXNzTmFtZSA9IF9lbnRlckNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5fbGVhdmVDbGFzc05hbWUgPSBfbGVhdmVDbGFzc05hbWU7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLnRpbWVsaW5lcyA9IHRpbWVsaW5lcztcbiAgICAgICAgdGhpcy5wYXJlbnRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZpb3VzTm9kZSA9IERFRkFVTFRfTk9PUF9QUkVWSU9VU19OT0RFO1xuICAgICAgICB0aGlzLnN1YkNvbnRleHRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRRdWVyeUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50UXVlcnlUb3RhbCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YWdnZXJUaW1lID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZWxpbmUgPSBpbml0aWFsVGltZWxpbmUgfHwgbmV3IFRpbWVsaW5lQnVpbGRlcih0aGlzLl9kcml2ZXIsIGVsZW1lbnQsIDApO1xuICAgICAgICB0aW1lbGluZXMucHVzaCh0aGlzLmN1cnJlbnRUaW1lbGluZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLCBcInBhcmFtc1wiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm9wdGlvbnMucGFyYW1zOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBza2lwSWZFeGlzdHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUudXBkYXRlT3B0aW9ucyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IHNraXBJZkV4aXN0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG9wdGlvbnMsIHNraXBJZkV4aXN0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld09wdGlvbnMgPSAvKiogQHR5cGUgez99ICovIChvcHRpb25zKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9uc1RvVXBkYXRlID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBOT1RFOiB0aGlzIHdpbGwgZ2V0IHBhdGNoZWQgdXAgd2hlbiBvdGhlciBhbmltYXRpb24gbWV0aG9kcyBzdXBwb3J0IGR1cmF0aW9uIG92ZXJyaWRlc1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5kdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9uc1RvVXBkYXRlKSkuZHVyYXRpb24gPSByZXNvbHZlVGltaW5nVmFsdWUobmV3T3B0aW9ucy5kdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld09wdGlvbnMuZGVsYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9uc1RvVXBkYXRlLmRlbGF5ID0gcmVzb2x2ZVRpbWluZ1ZhbHVlKG5ld09wdGlvbnMuZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld1BhcmFtcyA9IG5ld09wdGlvbnMucGFyYW1zO1xuICAgICAgICBpZiAobmV3UGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXNUb1VwZGF0ZV8xID0gLyoqIEB0eXBlIHs/fSAqLyAoKG9wdGlvbnNUb1VwZGF0ZS5wYXJhbXMpKTtcbiAgICAgICAgICAgIGlmICghcGFyYW1zVG9VcGRhdGVfMSkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1RvVXBkYXRlXzEgPSB0aGlzLm9wdGlvbnMucGFyYW1zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhuZXdQYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBJZkV4aXN0cyB8fCAhcGFyYW1zVG9VcGRhdGVfMS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNUb1VwZGF0ZV8xW25hbWVdID0gaW50ZXJwb2xhdGVQYXJhbXMobmV3UGFyYW1zW25hbWVdLCBwYXJhbXNUb1VwZGF0ZV8xLCBfdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dC5wcm90b3R5cGUuX2NvcHlPcHRpb25zID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkUGFyYW1zXzEgPSB0aGlzLm9wdGlvbnMucGFyYW1zO1xuICAgICAgICAgICAgaWYgKG9sZFBhcmFtc18xKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zXzEgPSBvcHRpb25zWydwYXJhbXMnXSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9sZFBhcmFtc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHBhcmFtc18xW25hbWVdID0gb2xkUGFyYW1zXzFbbmFtZV07IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBuZXdUaW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLmNyZWF0ZVN1YkNvbnRleHQgPSAvKipcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Pz19IG5ld1RpbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChvcHRpb25zLCBlbGVtZW50LCBuZXdUaW1lKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFyZ2V0ID0gZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRleHQgPSBuZXcgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0KHRoaXMuX2RyaXZlciwgdGFyZ2V0LCB0aGlzLnN1Ykluc3RydWN0aW9ucywgdGhpcy5fZW50ZXJDbGFzc05hbWUsIHRoaXMuX2xlYXZlQ2xhc3NOYW1lLCB0aGlzLmVycm9ycywgdGhpcy50aW1lbGluZXMsIHRoaXMuY3VycmVudFRpbWVsaW5lLmZvcmsodGFyZ2V0LCBuZXdUaW1lIHx8IDApKTtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSB0aGlzLnByZXZpb3VzTm9kZTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSB0aGlzLmN1cnJlbnRBbmltYXRlVGltaW5ncztcbiAgICAgICAgY29udGV4dC5vcHRpb25zID0gdGhpcy5fY29weU9wdGlvbnMoKTtcbiAgICAgICAgY29udGV4dC51cGRhdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeUluZGV4ID0gdGhpcy5jdXJyZW50UXVlcnlJbmRleDtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IHRoaXMuY3VycmVudFF1ZXJ5VG90YWw7XG4gICAgICAgIGNvbnRleHQucGFyZW50Q29udGV4dCA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3ViQ29udGV4dENvdW50Kys7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gbmV3VGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez89fSBuZXdUaW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmV3VGltZSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzTm9kZSA9IERFRkFVTFRfTk9PUF9QUkVWSU9VU19OT0RFO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lbGluZSA9IHRoaXMuY3VycmVudFRpbWVsaW5lLmZvcmsodGhpcy5lbGVtZW50LCBuZXdUaW1lKTtcbiAgICAgICAgdGhpcy50aW1lbGluZXMucHVzaCh0aGlzLmN1cnJlbnRUaW1lbGluZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaW1lbGluZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25cbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0LnByb3RvdHlwZS5hcHBlbmRJbnN0cnVjdGlvblRvVGltZWxpbmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBkdXJhdGlvblxuICAgICAqIEBwYXJhbSB7P30gZGVsYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgZHVyYXRpb24sIGRlbGF5KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZWRUaW1pbmdzID0ge1xuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uICE9IG51bGwgPyBkdXJhdGlvbiA6IGluc3RydWN0aW9uLmR1cmF0aW9uLFxuICAgICAgICAgICAgZGVsYXk6IHRoaXMuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lICsgKGRlbGF5ICE9IG51bGwgPyBkZWxheSA6IDApICsgaW5zdHJ1Y3Rpb24uZGVsYXksXG4gICAgICAgICAgICBlYXNpbmc6ICcnXG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJ1aWxkZXIgPSBuZXcgU3ViVGltZWxpbmVCdWlsZGVyKHRoaXMuX2RyaXZlciwgaW5zdHJ1Y3Rpb24uZWxlbWVudCwgaW5zdHJ1Y3Rpb24ua2V5ZnJhbWVzLCBpbnN0cnVjdGlvbi5wcmVTdHlsZVByb3BzLCBpbnN0cnVjdGlvbi5wb3N0U3R5bGVQcm9wcywgdXBkYXRlZFRpbWluZ3MsIGluc3RydWN0aW9uLnN0cmV0Y2hTdGFydGluZ0tleWZyYW1lKTtcbiAgICAgICAgdGhpcy50aW1lbGluZXMucHVzaChidWlsZGVyKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRUaW1pbmdzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0aW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLmluY3JlbWVudFRpbWUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHRpbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVsaW5lLmZvcndhcmRUaW1lKHRoaXMuY3VycmVudFRpbWVsaW5lLmR1cmF0aW9uICsgdGltZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLmRlbGF5TmV4dFN0ZXAgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgLy8gbmVnYXRpdmUgZGVsYXlzIGFyZSBub3QgeWV0IHN1cHBvcnRlZFxuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lbGluZS5kZWxheU5leHRTdGVwKGRlbGF5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gb3JpZ2luYWxTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbGltaXRcbiAgICAgKiBAcGFyYW0gez99IGluY2x1ZGVTZWxmXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25hbFxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UaW1lbGluZUNvbnRleHQucHJvdG90eXBlLmludm9rZVF1ZXJ5ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gb3JpZ2luYWxTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbGltaXRcbiAgICAgKiBAcGFyYW0gez99IGluY2x1ZGVTZWxmXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25hbFxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc2VsZWN0b3IsIG9yaWdpbmFsU2VsZWN0b3IsIGxpbWl0LCBpbmNsdWRlU2VsZiwgb3B0aW9uYWwsIGVycm9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChpbmNsdWRlU2VsZikge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9yLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGlmIDpzZWxmIGlzIG9ubHkgdXNlZCB0aGVuIHRoZSBzZWxlY3RvciBpcyBlbXB0eVxuICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKEVOVEVSX1RPS0VOX1JFR0VYLCAnLicgKyB0aGlzLl9lbnRlckNsYXNzTmFtZSk7XG4gICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoTEVBVkVfVE9LRU5fUkVHRVgsICcuJyArIHRoaXMuX2xlYXZlQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG11bHRpID0gbGltaXQgIT0gMTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRzID0gdGhpcy5fZHJpdmVyLnF1ZXJ5KHRoaXMuZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gbGltaXQgPCAwID8gZWxlbWVudHMuc2xpY2UoZWxlbWVudHMubGVuZ3RoICsgbGltaXQsIGVsZW1lbnRzLmxlbmd0aCkgOlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5zbGljZSgwLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9uYWwgJiYgcmVzdWx0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJgcXVlcnkoXFxcIlwiICsgb3JpZ2luYWxTZWxlY3RvciArIFwiXFxcIilgIHJldHVybmVkIHplcm8gZWxlbWVudHMuIChVc2UgYHF1ZXJ5KFxcXCJcIiArIG9yaWdpbmFsU2VsZWN0b3IgKyBcIlxcXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlgIGlmIHlvdSB3aXNoIHRvIGFsbG93IHRoaXMuKVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25UaW1lbGluZUNvbnRleHQ7XG59KCkpO1xudmFyIFRpbWVsaW5lQnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lbGluZUJ1aWxkZXIoX2RyaXZlciwgZWxlbWVudCwgc3RhcnRUaW1lLCBfZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwKSB7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAgPSBfZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNLZXlmcmFtZSA9IHt9O1xuICAgICAgICB0aGlzLl9jdXJyZW50S2V5ZnJhbWUgPSB7fTtcbiAgICAgICAgdGhpcy5fa2V5ZnJhbWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zdHlsZVN1bW1hcnkgPSB7fTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1N0eWxlcyA9IHt9O1xuICAgICAgICB0aGlzLl9iYWNrRmlsbCA9IHt9O1xuICAgICAgICB0aGlzLl9jdXJyZW50RW1wdHlTdGVwS2V5ZnJhbWUgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMgPSBPYmplY3QuY3JlYXRlKHRoaXMuX2JhY2tGaWxsLCB7fSk7XG4gICAgICAgIHRoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzID0gLyoqIEB0eXBlIHs/fSAqLyAoKHRoaXMuX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cC5nZXQoZWxlbWVudCkpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcykge1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMgPSB0aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwLnNldChlbGVtZW50LCB0aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2FkS2V5ZnJhbWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmNvbnRhaW5zQW5pbWF0aW9uID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fa2V5ZnJhbWVzLnNpemUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFN0eWxlUHJvcGVydGllcygpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuZ2V0Q3VycmVudFN0eWxlUHJvcGVydGllcyA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY3VycmVudEtleWZyYW1lKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZSwgXCJjdXJyZW50VGltZVwiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnN0YXJ0VGltZSArIHRoaXMuZHVyYXRpb247IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVsYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuZGVsYXlOZXh0U3RlcCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVsYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICAvLyBpbiB0aGUgZXZlbnQgdGhhdCBhIHN0eWxlKCkgc3RlcCBpcyBwbGFjZWQgcmlnaHQgYmVmb3JlIGEgc3RhZ2dlcigpXG4gICAgICAgIC8vIGFuZCB0aGF0IHN0eWxlKCkgc3RlcCBpcyB0aGUgdmVyeSBmaXJzdCBzdHlsZSgpIHZhbHVlIGluIHRoZSBhbmltYXRpb25cbiAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIG1ha2UgYSBjb3B5IG9mIHRoZSBrZXlmcmFtZSBbMCwgY29weSwgMV0gc28gdGhhdCB0aGUgZGVsYXlcbiAgICAgICAgLy8gcHJvcGVybHkgYXBwbGllcyB0aGUgc3R5bGUoKSB2YWx1ZXMgdG8gd29yayB3aXRoIHRoZSBzdGFnZ2VyLi4uXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc1ByZVN0eWxlU3RlcCA9IHRoaXMuX2tleWZyYW1lcy5zaXplID09IDEgJiYgT2JqZWN0LmtleXModGhpcy5fcGVuZGluZ1N0eWxlcykubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5kdXJhdGlvbiB8fCBoYXNQcmVTdHlsZVN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZFRpbWUodGhpcy5jdXJyZW50VGltZSArIGRlbGF5KTtcbiAgICAgICAgICAgIGlmIChoYXNQcmVTdHlsZVN0ZXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBzaG90Q3VycmVudFN0eWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgKz0gZGVsYXk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Pz19IGN1cnJlbnRUaW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmZvcmsgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBjdXJyZW50VGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgIHJldHVybiBuZXcgVGltZWxpbmVCdWlsZGVyKHRoaXMuX2RyaXZlciwgZWxlbWVudCwgY3VycmVudFRpbWUgfHwgdGhpcy5jdXJyZW50VGltZSwgdGhpcy5fZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5fbG9hZEtleWZyYW1lID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50S2V5ZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzS2V5ZnJhbWUgPSB0aGlzLl9jdXJyZW50S2V5ZnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudEtleWZyYW1lID0gLyoqIEB0eXBlIHs/fSAqLyAoKHRoaXMuX2tleWZyYW1lcy5nZXQodGhpcy5kdXJhdGlvbikpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50S2V5ZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSA9IE9iamVjdC5jcmVhdGUodGhpcy5fYmFja0ZpbGwsIHt9KTtcbiAgICAgICAgICAgIHRoaXMuX2tleWZyYW1lcy5zZXQodGhpcy5kdXJhdGlvbiwgdGhpcy5fY3VycmVudEtleWZyYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmZvcndhcmRGcmFtZSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmR1cmF0aW9uICs9IE9ORV9GUkFNRV9JTl9NSUxMSVNFQ09ORFM7XG4gICAgICAgIHRoaXMuX2xvYWRLZXlmcmFtZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0aW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmZvcndhcmRUaW1lID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB0aW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICB0aGlzLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSgpO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gdGltZTtcbiAgICAgICAgdGhpcy5fbG9hZEtleWZyYW1lKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3BcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLl91cGRhdGVTdHlsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3N0eWxlU3VtbWFyeVtwcm9wXSA9IHsgdGltZTogdGhpcy5jdXJyZW50VGltZSwgdmFsdWU6IHZhbHVlIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuYWxsb3dPbmx5VGltZWxpbmVTdHlsZXMgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRFbXB0eVN0ZXBLZXlmcmFtZSAhPT0gdGhpcy5fY3VycmVudEtleWZyYW1lOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmFwcGx5RW1wdHlTdGVwID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlYXNpbmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGVhc2luZykge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNLZXlmcmFtZVsnZWFzaW5nJ10gPSBlYXNpbmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBhbmltYXRlKGR1cmF0aW9uKTpcbiAgICAgICAgLy8gYWxsIG1pc3Npbmcgc3R5bGVzIGFyZSBmaWxsZWQgd2l0aCBhIGAqYCB2YWx1ZSB0aGVuXG4gICAgICAgIC8vIGlmIGFueSBkZXN0aW5hdGlvbiBzdHlsZXMgYXJlIGZpbGxlZCBpbiBsYXRlciBvbiB0aGUgc2FtZVxuICAgICAgICAvLyBrZXlmcmFtZSB0aGVuIHRoZXkgd2lsbCBvdmVycmlkZSB0aGUgb3ZlcnJpZGRlbiBzdHlsZXNcbiAgICAgICAgLy8gV2UgdXNlIGBfZ2xvYmFsVGltZWxpbmVTdHlsZXNgIGhlcmUgYmVjYXVzZSB0aGVyZSBtYXkgYmVcbiAgICAgICAgLy8gc3R5bGVzIGluIHByZXZpb3VzIGtleWZyYW1lcyB0aGF0IGFyZSBub3QgcHJlc2VudCBpbiB0aGlzIHRpbWVsaW5lXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBfdGhpcy5fYmFja0ZpbGxbcHJvcF0gPSBfdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXNbcHJvcF0gfHwgX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFO1xuICAgICAgICAgICAgX3RoaXMuX2N1cnJlbnRLZXlmcmFtZVtwcm9wXSA9IF9hbmd1bGFyX2FuaW1hdGlvbnMuQVVUT19TVFlMRTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRFbXB0eVN0ZXBLZXlmcmFtZSA9IHRoaXMuX2N1cnJlbnRLZXlmcmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGVhc2luZ1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVCdWlsZGVyLnByb3RvdHlwZS5zZXRTdHlsZXMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBlYXNpbmdcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpbnB1dCwgZWFzaW5nLCBlcnJvcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGVhc2luZykge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNLZXlmcmFtZVsnZWFzaW5nJ10gPSBlYXNpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJhbXMpIHx8IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSBmbGF0dGVuU3R5bGVzKGlucHV0LCB0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcyk7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsID0gaW50ZXJwb2xhdGVQYXJhbXMoc3R5bGVzW3Byb3BdLCBwYXJhbXMsIGVycm9ycyk7XG4gICAgICAgICAgICBfdGhpcy5fcGVuZGluZ1N0eWxlc1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYmFja0ZpbGxbcHJvcF0gPSBfdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMuaGFzT3duUHJvcGVydHkocHJvcCkgP1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXNbcHJvcF0gOlxuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlU3R5bGUocHJvcCwgdmFsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuYXBwbHlTdHlsZXNUb0tleWZyYW1lID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IHRoaXMuX3BlbmRpbmdTdHlsZXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3BzID0gT2JqZWN0LmtleXMoc3R5bGVzKTtcbiAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9wZW5kaW5nU3R5bGVzID0ge307XG4gICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IHN0eWxlc1twcm9wXTtcbiAgICAgICAgICAgIF90aGlzLl9jdXJyZW50S2V5ZnJhbWVbcHJvcF0gPSB2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9jdXJyZW50S2V5ZnJhbWUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY3VycmVudEtleWZyYW1lW3Byb3BdID0gX3RoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLnNuYXBzaG90Q3VycmVudFN0eWxlcyA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9sb2NhbFRpbWVsaW5lU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSBfdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlc1twcm9wXTtcbiAgICAgICAgICAgIF90aGlzLl9wZW5kaW5nU3R5bGVzW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVN0eWxlKHByb3AsIHZhbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmdldEZpbmFsS2V5ZnJhbWUgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2tleWZyYW1lcy5nZXQodGhpcy5kdXJhdGlvbik7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUsIFwicHJvcGVydGllc1wiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wZXJ0aWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gdGhpcy5fY3VycmVudEtleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGltZWxpbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUubWVyZ2VUaW1lbGluZUNvbGxlY3RlZFN0eWxlcyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGltZWxpbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0aW1lbGluZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aW1lbGluZS5fc3R5bGVTdW1tYXJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzMCA9IF90aGlzLl9zdHlsZVN1bW1hcnlbcHJvcF07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzMSA9IHRpbWVsaW5lLl9zdHlsZVN1bW1hcnlbcHJvcF07XG4gICAgICAgICAgICBpZiAoIWRldGFpbHMwIHx8IGRldGFpbHMxLnRpbWUgPiBkZXRhaWxzMC50aW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVN0eWxlKHByb3AsIGRldGFpbHMxLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuYnVpbGRLZXlmcmFtZXMgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlU3R5bGVQcm9wcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdFN0eWxlUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRW1wdHkgPSB0aGlzLl9rZXlmcmFtZXMuc2l6ZSA9PT0gMSAmJiB0aGlzLmR1cmF0aW9uID09PSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaW5hbEtleWZyYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLl9rZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5ZnJhbWUsIHRpbWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbmFsS2V5ZnJhbWUgPSBjb3B5U3R5bGVzKGtleWZyYW1lLCB0cnVlKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGZpbmFsS2V5ZnJhbWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGZpbmFsS2V5ZnJhbWVbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IF9hbmd1bGFyX2FuaW1hdGlvbnMuybVQUkVfU1RZTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlU3R5bGVQcm9wcy5hZGQocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IF9hbmd1bGFyX2FuaW1hdGlvbnMuQVVUT19TVFlMRSkge1xuICAgICAgICAgICAgICAgICAgICBwb3N0U3R5bGVQcm9wcy5hZGQocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleWZyYW1lWydvZmZzZXQnXSA9IHRpbWUgLyBfdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWVzLnB1c2goZmluYWxLZXlmcmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVQcm9wcyA9IHByZVN0eWxlUHJvcHMuc2l6ZSA/IGl0ZXJhdG9yVG9BcnJheShwcmVTdHlsZVByb3BzLnZhbHVlcygpKSA6IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3N0UHJvcHMgPSBwb3N0U3R5bGVQcm9wcy5zaXplID8gaXRlcmF0b3JUb0FycmF5KHBvc3RTdHlsZVByb3BzLnZhbHVlcygpKSA6IFtdO1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGEgMC1zZWNvbmQgYW5pbWF0aW9uICh3aGljaCBpcyBkZXNpZ25lZCBqdXN0IHRvIHBsYWNlIHN0eWxlcyBvbnNjcmVlbilcbiAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtmMCA9IGZpbmFsS2V5ZnJhbWVzWzBdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2YxID0gY29weU9iaihrZjApO1xuICAgICAgICAgICAga2YwWydvZmZzZXQnXSA9IDA7XG4gICAgICAgICAgICBrZjFbJ29mZnNldCddID0gMTtcbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWVzID0gW2tmMCwga2YxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlVGltZWxpbmVJbnN0cnVjdGlvbih0aGlzLmVsZW1lbnQsIGZpbmFsS2V5ZnJhbWVzLCBwcmVQcm9wcywgcG9zdFByb3BzLCB0aGlzLmR1cmF0aW9uLCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5lYXNpbmcsIGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lbGluZUJ1aWxkZXI7XG59KCkpO1xudmFyIFN1YlRpbWVsaW5lQnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViVGltZWxpbmVCdWlsZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YlRpbWVsaW5lQnVpbGRlcihkcml2ZXIsIGVsZW1lbnQsIGtleWZyYW1lcywgcHJlU3R5bGVQcm9wcywgcG9zdFN0eWxlUHJvcHMsIHRpbWluZ3MsIF9zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSkge1xuICAgICAgICBpZiAoX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lID09PSB2b2lkIDApIHsgX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZHJpdmVyLCBlbGVtZW50LCB0aW1pbmdzLmRlbGF5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgX3RoaXMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgICAgICBfdGhpcy5wcmVTdHlsZVByb3BzID0gcHJlU3R5bGVQcm9wcztcbiAgICAgICAgX3RoaXMucG9zdFN0eWxlUHJvcHMgPSBwb3N0U3R5bGVQcm9wcztcbiAgICAgICAgX3RoaXMuX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lID0gX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lO1xuICAgICAgICBfdGhpcy50aW1pbmdzID0geyBkdXJhdGlvbjogdGltaW5ncy5kdXJhdGlvbiwgZGVsYXk6IHRpbWluZ3MuZGVsYXksIGVhc2luZzogdGltaW5ncy5lYXNpbmcgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN1YlRpbWVsaW5lQnVpbGRlci5wcm90b3R5cGUuY29udGFpbnNBbmltYXRpb24gPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5ZnJhbWVzLmxlbmd0aCA+IDE7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdWJUaW1lbGluZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkS2V5ZnJhbWVzID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnRpbWluZ3MsIGRlbGF5ID0gX2EuZGVsYXksIGR1cmF0aW9uID0gX2EuZHVyYXRpb24sIGVhc2luZyA9IF9hLmVhc2luZztcbiAgICAgICAgaWYgKHRoaXMuX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lICYmIGRlbGF5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdLZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvdGFsVGltZSA9IGR1cmF0aW9uICsgZGVsYXk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydGluZ0dhcCA9IGRlbGF5IC8gdG90YWxUaW1lO1xuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHN0YXJ0aW5nIGtleWZyYW1lIG5vdyBzdGFydHMgb25jZSB0aGUgZGVsYXkgaXMgZG9uZVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3Rmlyc3RLZXlmcmFtZSA9IGNvcHlTdHlsZXMoa2V5ZnJhbWVzWzBdLCBmYWxzZSk7XG4gICAgICAgICAgICBuZXdGaXJzdEtleWZyYW1lWydvZmZzZXQnXSA9IDA7XG4gICAgICAgICAgICBuZXdLZXlmcmFtZXMucHVzaChuZXdGaXJzdEtleWZyYW1lKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZEZpcnN0S2V5ZnJhbWUgPSBjb3B5U3R5bGVzKGtleWZyYW1lc1swXSwgZmFsc2UpO1xuICAgICAgICAgICAgb2xkRmlyc3RLZXlmcmFtZVsnb2Zmc2V0J10gPSByb3VuZE9mZnNldChzdGFydGluZ0dhcCk7XG4gICAgICAgICAgICBuZXdLZXlmcmFtZXMucHVzaChvbGRGaXJzdEtleWZyYW1lKTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIFdoZW4gdGhlIGtleWZyYW1lIGlzIHN0cmV0Y2hlZCB0aGVuIGl0IG1lYW5zIHRoYXQgdGhlIGRlbGF5IGJlZm9yZSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0cyBpcyBnb25lLiBJbnN0ZWFkIHRoZSBmaXJzdCBrZXlmcmFtZSBpcyBwbGFjZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgYW5kIGl0IGlzIHRoZW4gY29waWVkIHRvIHdoZXJlIGl0IHN0YXJ0cyB3aGVuIHRoZSBvcmlnaW5hbCBkZWxheSBpcyBvdmVyLiBUaGlzIGJhc2ljYWxseVxuICAgICAgICAgICAgICAgICAgICBtZWFucyBub3RoaW5nIGFuaW1hdGVzIGR1cmluZyB0aGF0IGRlbGF5LCBidXQgdGhlIHN0eWxlcyBhcmUgc3RpbGwgcmVuZGVyZXJlZC4gRm9yIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgdG8gd29yayB0aGUgb3JpZ2luYWwgb2Zmc2V0IHZhbHVlcyB0aGF0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBrZXlmcmFtZXMgbXVzdCBiZSBcIndhcnBlZFwiXG4gICAgICAgICAgICAgICAgICAgIHNvIHRoYXQgdGhleSBjYW4gdGFrZSB0aGUgbmV3IGtleWZyYW1lICsgZGVsYXkgaW50byBhY2NvdW50LlxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5PTEwMDAsIGR1cmF0aW9uPTEwMDAsIGtleWZyYW1lcyA9IDAgLjUgMVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHR1cm5zIGludG9cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBkZWxheT0wLCBkdXJhdGlvbj0yMDAwLCBrZXlmcmFtZXMgPSAwIC4zMyAuNjYgMVxuICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBvZmZzZXRzIGJldHdlZW4gMSAuLi4gbiAtMSBhcmUgYWxsIHdhcnBlZCBieSB0aGUga2V5ZnJhbWUgc3RyZXRjaFxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGltaXQgPSBrZXlmcmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDE7IGkgPD0gbGltaXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtmID0gY29weVN0eWxlcyhrZXlmcmFtZXNbaV0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRPZmZzZXQgPSAvKiogQHR5cGUgez99ICovIChrZlsnb2Zmc2V0J10pO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRpbWVBdEtleWZyYW1lID0gZGVsYXkgKyBvbGRPZmZzZXQgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBrZlsnb2Zmc2V0J10gPSByb3VuZE9mZnNldCh0aW1lQXRLZXlmcmFtZSAvIHRvdGFsVGltZSk7XG4gICAgICAgICAgICAgICAgbmV3S2V5ZnJhbWVzLnB1c2goa2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlIG5ldyBzdGFydGluZyBrZXlmcmFtZSBzaG91bGQgYmUgYWRkZWQgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRvdGFsVGltZTtcbiAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIGVhc2luZyA9ICcnO1xuICAgICAgICAgICAga2V5ZnJhbWVzID0gbmV3S2V5ZnJhbWVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVUaW1lbGluZUluc3RydWN0aW9uKHRoaXMuZWxlbWVudCwga2V5ZnJhbWVzLCB0aGlzLnByZVN0eWxlUHJvcHMsIHRoaXMucG9zdFN0eWxlUHJvcHMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCB0cnVlKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJUaW1lbGluZUJ1aWxkZXI7XG59KFRpbWVsaW5lQnVpbGRlcikpO1xuLyoqXG4gKiBAcGFyYW0gez99IG9mZnNldFxuICogQHBhcmFtIHs/PX0gZGVjaW1hbFBvaW50c1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcm91bmRPZmZzZXQob2Zmc2V0LCBkZWNpbWFsUG9pbnRzKSB7XG4gICAgaWYgKGRlY2ltYWxQb2ludHMgPT09IHZvaWQgMCkgeyBkZWNpbWFsUG9pbnRzID0gMzsgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIG11bHQgPSBNYXRoLnBvdygxMCwgZGVjaW1hbFBvaW50cyAtIDEpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG9mZnNldCAqIG11bHQpIC8gbXVsdDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHBhcmFtIHs/fSBhbGxTdHlsZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TdHlsZXMoaW5wdXQsIGFsbFN0eWxlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IHt9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFByb3BlcnRpZXM7XG4gICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuID09PSAnKicpIHtcbiAgICAgICAgICAgIGFsbFByb3BlcnRpZXMgPSBhbGxQcm9wZXJ0aWVzIHx8IE9iamVjdC5rZXlzKGFsbFN0eWxlcyk7XG4gICAgICAgICAgICBhbGxQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgc3R5bGVzW3Byb3BdID0gX2FuZ3VsYXJfYW5pbWF0aW9ucy5BVVRPX1NUWUxFOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvcHlTdHlsZXMoLyoqIEB0eXBlIHs/fSAqLyAodG9rZW4pLCBmYWxzZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHlsZXM7XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBBbmltYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKF9kcml2ZXIsIGlucHV0KSB7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBidWlsZEFuaW1hdGlvbkFzdChfZHJpdmVyLCBpbnB1dCwgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yTWVzc2FnZSA9IFwiYW5pbWF0aW9uIHZhbGlkYXRpb24gZmFpbGVkOlxcblwiICsgZXJyb3JzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbmltYXRpb25Bc3QgPSBhc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRpbmdTdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IGRlc3RpbmF0aW9uU3R5bGVzXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmJ1aWxkVGltZWxpbmVzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzdGFydGluZ1N0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gZGVzdGluYXRpb25TdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBzdWJJbnN0cnVjdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzdGFydGluZ1N0eWxlcywgZGVzdGluYXRpb25TdHlsZXMsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IEFycmF5LmlzQXJyYXkoc3RhcnRpbmdTdHlsZXMpID8gbm9ybWFsaXplU3R5bGVzKHN0YXJ0aW5nU3R5bGVzKSA6IC8qKiBAdHlwZSB7P30gKi8gKHN0YXJ0aW5nU3R5bGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVzdCA9IEFycmF5LmlzQXJyYXkoZGVzdGluYXRpb25TdHlsZXMpID8gbm9ybWFsaXplU3R5bGVzKGRlc3RpbmF0aW9uU3R5bGVzKSA6IC8qKiBAdHlwZSB7P30gKi8gKGRlc3RpbmF0aW9uU3R5bGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XG4gICAgICAgIHN1Ykluc3RydWN0aW9ucyA9IHN1Ykluc3RydWN0aW9ucyB8fCBuZXcgRWxlbWVudEluc3RydWN0aW9uTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IGJ1aWxkQW5pbWF0aW9uVGltZWxpbmVzKHRoaXMuX2RyaXZlciwgZWxlbWVudCwgdGhpcy5fYW5pbWF0aW9uQXN0LCBFTlRFUl9DTEFTU05BTUUsIExFQVZFX0NMQVNTTkFNRSwgc3RhcnQsIGRlc3QsIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yTWVzc2FnZSA9IFwiYW5pbWF0aW9uIGJ1aWxkaW5nIGZhaWxlZDpcXG5cIiArIGVycm9ycy5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb247XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEFuaW1hdGlvblN0eWxlTm9ybWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXI7XG59KCkpO1xuLyoqXG4gKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICovXG52YXIgTm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5TmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVQcm9wZXJ0eU5hbWUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5TmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocHJvcGVydHlOYW1lLCBlcnJvcnMpIHsgcmV0dXJuIHByb3BlcnR5TmFtZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVzZXJQcm92aWRlZFByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSBub3JtYWxpemVkUHJvcGVydHlcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVN0eWxlVmFsdWUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHVzZXJQcm92aWRlZFByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSBub3JtYWxpemVkUHJvcGVydHlcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1c2VyUHJvdmlkZWRQcm9wZXJ0eSwgbm9ybWFsaXplZFByb3BlcnR5LCB2YWx1ZSwgZXJyb3JzKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUgez99ICovICh2YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplcjtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU5hbWVcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplUHJvcGVydHlOYW1lID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU5hbWVcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgZXJyb3JzKSB7XG4gICAgICAgIHJldHVybiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKHByb3BlcnR5TmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVzZXJQcm92aWRlZFByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSBub3JtYWxpemVkUHJvcGVydHlcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVN0eWxlVmFsdWUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHVzZXJQcm92aWRlZFByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSBub3JtYWxpemVkUHJvcGVydHlcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh1c2VyUHJvdmlkZWRQcm9wZXJ0eSwgbm9ybWFsaXplZFByb3BlcnR5LCB2YWx1ZSwgZXJyb3JzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXQgPSAnJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyVmFsID0gdmFsdWUudG9TdHJpbmcoKS50cmltKCk7XG4gICAgICAgIGlmIChESU1FTlNJT05BTF9QUk9QX01BUFtub3JtYWxpemVkUHJvcGVydHldICYmIHZhbHVlICE9PSAwICYmIHZhbHVlICE9PSAnMCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWxBbmRTdWZmaXhNYXRjaCA9IHZhbHVlLm1hdGNoKC9eWystXT9bXFxkXFwuXSsoW2Etel0qKSQvKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsQW5kU3VmZml4TWF0Y2ggJiYgdmFsQW5kU3VmZml4TWF0Y2hbMV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goXCJQbGVhc2UgcHJvdmlkZSBhIENTUyB1bml0IHZhbHVlIGZvciBcIiArIHVzZXJQcm92aWRlZFByb3BlcnR5ICsgXCI6XCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJWYWwgKyB1bml0O1xuICAgIH07XG4gICAgcmV0dXJuIFdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXI7XG59KEFuaW1hdGlvblN0eWxlTm9ybWFsaXplcikpO1xudmFyIERJTUVOU0lPTkFMX1BST1BfTUFQID0gbWFrZUJvb2xlYW5NYXAoJ3dpZHRoLGhlaWdodCxtaW5XaWR0aCxtaW5IZWlnaHQsbWF4V2lkdGgsbWF4SGVpZ2h0LGxlZnQsdG9wLGJvdHRvbSxyaWdodCxmb250U2l6ZSxvdXRsaW5lV2lkdGgsb3V0bGluZU9mZnNldCxwYWRkaW5nVG9wLHBhZGRpbmdMZWZ0LHBhZGRpbmdCb3R0b20scGFkZGluZ1JpZ2h0LG1hcmdpblRvcCxtYXJnaW5MZWZ0LG1hcmdpbkJvdHRvbSxtYXJnaW5SaWdodCxib3JkZXJSYWRpdXMsYm9yZGVyV2lkdGgsYm9yZGVyVG9wV2lkdGgsYm9yZGVyTGVmdFdpZHRoLGJvcmRlclJpZ2h0V2lkdGgsYm9yZGVyQm90dG9tV2lkdGgsdGV4dEluZGVudCxwZXJzcGVjdGl2ZSdcbiAgICAuc3BsaXQoJywnKSk7XG4vKipcbiAqIEBwYXJhbSB7P30ga2V5c1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbWFrZUJvb2xlYW5NYXAoa2V5cykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBtYXBba2V5XSA9IHRydWU7IH0pO1xuICAgIHJldHVybiBtYXA7XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQHJlY29yZFxuICovXG5cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXG4gKiBAcGFyYW0gez99IGZyb21TdGF0ZVxuICogQHBhcmFtIHs/fSB0b1N0YXRlXG4gKiBAcGFyYW0gez99IGlzUmVtb3ZhbFRyYW5zaXRpb25cbiAqIEBwYXJhbSB7P30gZnJvbVN0eWxlc1xuICogQHBhcmFtIHs/fSB0b1N0eWxlc1xuICogQHBhcmFtIHs/fSB0aW1lbGluZXNcbiAqIEBwYXJhbSB7P30gcXVlcmllZEVsZW1lbnRzXG4gKiBAcGFyYW0gez99IHByZVN0eWxlUHJvcHNcbiAqIEBwYXJhbSB7P30gcG9zdFN0eWxlUHJvcHNcbiAqIEBwYXJhbSB7Pz19IGVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbkluc3RydWN0aW9uKGVsZW1lbnQsIHRyaWdnZXJOYW1lLCBmcm9tU3RhdGUsIHRvU3RhdGUsIGlzUmVtb3ZhbFRyYW5zaXRpb24sIGZyb21TdHlsZXMsIHRvU3R5bGVzLCB0aW1lbGluZXMsIHF1ZXJpZWRFbGVtZW50cywgcHJlU3R5bGVQcm9wcywgcG9zdFN0eWxlUHJvcHMsIGVycm9ycykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAgLyogVHJhbnNpdGlvbkFuaW1hdGlvbiAqLyxcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgdHJpZ2dlck5hbWU6IHRyaWdnZXJOYW1lLFxuICAgICAgICBpc1JlbW92YWxUcmFuc2l0aW9uOiBpc1JlbW92YWxUcmFuc2l0aW9uLFxuICAgICAgICBmcm9tU3RhdGU6IGZyb21TdGF0ZSxcbiAgICAgICAgZnJvbVN0eWxlczogZnJvbVN0eWxlcyxcbiAgICAgICAgdG9TdGF0ZTogdG9TdGF0ZSxcbiAgICAgICAgdG9TdHlsZXM6IHRvU3R5bGVzLFxuICAgICAgICB0aW1lbGluZXM6IHRpbWVsaW5lcyxcbiAgICAgICAgcXVlcmllZEVsZW1lbnRzOiBxdWVyaWVkRWxlbWVudHMsXG4gICAgICAgIHByZVN0eWxlUHJvcHM6IHByZVN0eWxlUHJvcHMsXG4gICAgICAgIHBvc3RTdHlsZVByb3BzOiBwb3N0U3R5bGVQcm9wcyxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICB9O1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgRU1QVFlfT0JKRUNUID0ge307XG52YXIgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkoX3RyaWdnZXJOYW1lLCBhc3QsIF9zdGF0ZVN0eWxlcykge1xuICAgICAgICB0aGlzLl90cmlnZ2VyTmFtZSA9IF90cmlnZ2VyTmFtZTtcbiAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgIHRoaXMuX3N0YXRlU3R5bGVzID0gX3N0YXRlU3R5bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uRmFjdG9yeS5wcm90b3R5cGUubWF0Y2ggPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY3VycmVudFN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG9uZU9yTW9yZVRyYW5zaXRpb25zTWF0Y2godGhpcy5hc3QubWF0Y2hlcnMsIGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVOYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkucHJvdG90eXBlLmJ1aWxkU3R5bGVzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZU5hbWVcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoc3RhdGVOYW1lLCBwYXJhbXMsIGVycm9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYWNrdXBTdGF0ZVN0eWxlciA9IHRoaXMuX3N0YXRlU3R5bGVzWycqJ107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlU3R5bGVyID0gdGhpcy5fc3RhdGVTdHlsZXNbc3RhdGVOYW1lXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFja3VwU3R5bGVzID0gYmFja3VwU3RhdGVTdHlsZXIgPyBiYWNrdXBTdGF0ZVN0eWxlci5idWlsZFN0eWxlcyhwYXJhbXMsIGVycm9ycykgOiB7fTtcbiAgICAgICAgcmV0dXJuIHN0YXRlU3R5bGVyID8gc3RhdGVTdHlsZXIuYnVpbGRTdHlsZXMocGFyYW1zLCBlcnJvcnMpIDogYmFja3VwU3R5bGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkcml2ZXJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P30gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/fSBlbnRlckNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7P30gbGVhdmVDbGFzc05hbWVcbiAgICAgKiBAcGFyYW0gez89fSBjdXJyZW50T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Pz19IG5leHRPcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gc3ViSW5zdHJ1Y3Rpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uRmFjdG9yeS5wcm90b3R5cGUuYnVpbGQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGRyaXZlclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXG4gICAgICogQHBhcmFtIHs/fSBuZXh0U3RhdGVcbiAgICAgKiBAcGFyYW0gez99IGVudGVyQ2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHs/fSBsZWF2ZUNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IGN1cnJlbnRPcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gbmV4dE9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBzdWJJbnN0cnVjdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChkcml2ZXIsIGVsZW1lbnQsIGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlLCBlbnRlckNsYXNzTmFtZSwgbGVhdmVDbGFzc05hbWUsIGN1cnJlbnRPcHRpb25zLCBuZXh0T3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2l0aW9uQW5pbWF0aW9uUGFyYW1zID0gdGhpcy5hc3Qub3B0aW9ucyAmJiB0aGlzLmFzdC5vcHRpb25zLnBhcmFtcyB8fCBFTVBUWV9PQkpFQ1Q7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRBbmltYXRpb25QYXJhbXMgPSBjdXJyZW50T3B0aW9ucyAmJiBjdXJyZW50T3B0aW9ucy5wYXJhbXMgfHwgRU1QVFlfT0JKRUNUO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50U3RhdGVTdHlsZXMgPSB0aGlzLmJ1aWxkU3R5bGVzKGN1cnJlbnRTdGF0ZSwgY3VycmVudEFuaW1hdGlvblBhcmFtcywgZXJyb3JzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dEFuaW1hdGlvblBhcmFtcyA9IG5leHRPcHRpb25zICYmIG5leHRPcHRpb25zLnBhcmFtcyB8fCBFTVBUWV9PQkpFQ1Q7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHRTdGF0ZVN0eWxlcyA9IHRoaXMuYnVpbGRTdHlsZXMobmV4dFN0YXRlLCBuZXh0QW5pbWF0aW9uUGFyYW1zLCBlcnJvcnMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkRWxlbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3N0U3R5bGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzUmVtb3ZhbCA9IG5leHRTdGF0ZSA9PT0gJ3ZvaWQnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRpb25PcHRpb25zID0geyBwYXJhbXM6IF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uQW5pbWF0aW9uUGFyYW1zLCBuZXh0QW5pbWF0aW9uUGFyYW1zKSB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aW1lbGluZXMgPSBidWlsZEFuaW1hdGlvblRpbWVsaW5lcyhkcml2ZXIsIGVsZW1lbnQsIHRoaXMuYXN0LmFuaW1hdGlvbiwgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lLCBjdXJyZW50U3RhdGVTdHlsZXMsIG5leHRTdGF0ZVN0eWxlcywgYW5pbWF0aW9uT3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zLCBlcnJvcnMpO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zaXRpb25JbnN0cnVjdGlvbihlbGVtZW50LCB0aGlzLl90cmlnZ2VyTmFtZSwgY3VycmVudFN0YXRlLCBuZXh0U3RhdGUsIGlzUmVtb3ZhbCwgY3VycmVudFN0YXRlU3R5bGVzLCBuZXh0U3RhdGVTdHlsZXMsIFtdLCBbXSwgcHJlU3R5bGVNYXAsIHBvc3RTdHlsZU1hcCwgZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lbGluZXMuZm9yRWFjaChmdW5jdGlvbiAodGwpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsbSA9IHRsLmVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVQcm9wcyA9IGdldE9yU2V0QXNJbk1hcChwcmVTdHlsZU1hcCwgZWxtLCB7fSk7XG4gICAgICAgICAgICB0bC5wcmVTdHlsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHByZVByb3BzW3Byb3BdID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3N0UHJvcHMgPSBnZXRPclNldEFzSW5NYXAocG9zdFN0eWxlTWFwLCBlbG0sIHt9KTtcbiAgICAgICAgICAgIHRsLnBvc3RTdHlsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHBvc3RQcm9wc1twcm9wXSA9IHRydWU7IH0pO1xuICAgICAgICAgICAgaWYgKGVsbSAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHF1ZXJpZWRFbGVtZW50cy5hZGQoZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRFbGVtZW50c0xpc3QgPSBpdGVyYXRvclRvQXJyYXkocXVlcmllZEVsZW1lbnRzLnZhbHVlcygpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zaXRpb25JbnN0cnVjdGlvbihlbGVtZW50LCB0aGlzLl90cmlnZ2VyTmFtZSwgY3VycmVudFN0YXRlLCBuZXh0U3RhdGUsIGlzUmVtb3ZhbCwgY3VycmVudFN0YXRlU3R5bGVzLCBuZXh0U3RhdGVTdHlsZXMsIHRpbWVsaW5lcywgcXVlcmllZEVsZW1lbnRzTGlzdCwgcHJlU3R5bGVNYXAsIHBvc3RTdHlsZU1hcCk7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3Rvcnk7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IG1hdGNoRm5zXG4gKiBAcGFyYW0gez99IGN1cnJlbnRTdGF0ZVxuICogQHBhcmFtIHs/fSBuZXh0U3RhdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG9uZU9yTW9yZVRyYW5zaXRpb25zTWF0Y2gobWF0Y2hGbnMsIGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKSB7XG4gICAgcmV0dXJuIG1hdGNoRm5zLnNvbWUoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbihjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSk7IH0pO1xufVxudmFyIEFuaW1hdGlvblN0YXRlU3R5bGVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlU3R5bGVzKHN0eWxlcywgZGVmYXVsdFBhcmFtcykge1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgdGhpcy5kZWZhdWx0UGFyYW1zID0gZGVmYXVsdFBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uU3RhdGVTdHlsZXMucHJvdG90eXBlLmJ1aWxkU3R5bGVzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBhcmFtcywgZXJyb3JzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbmFsU3R5bGVzID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbWJpbmVkUGFyYW1zID0gY29weU9iaih0aGlzLmRlZmF1bHRQYXJhbXMpO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29tYmluZWRQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHlsZXMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlT2JqXzEgPSAvKiogQHR5cGUgez99ICovICh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVPYmpfMSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSBzdHlsZU9ial8xW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGludGVycG9sYXRlUGFyYW1zKHZhbCwgY29tYmluZWRQYXJhbXMsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxTdHlsZXNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmluYWxTdHlsZXM7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uU3RhdGVTdHlsZXM7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKiBAcGFyYW0gez99IG5hbWVcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBidWlsZFRyaWdnZXIobmFtZSwgYXN0KSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb25UcmlnZ2VyKG5hbWUsIGFzdCk7XG59XG4vKipcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKi9cbnZhciBBbmltYXRpb25UcmlnZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyaWdnZXIobmFtZSwgYXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXN0ID0gYXN0O1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25GYWN0b3JpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB7fTtcbiAgICAgICAgYXN0LnN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlZmF1bHRQYXJhbXMgPSAoYXN0Lm9wdGlvbnMgJiYgYXN0Lm9wdGlvbnMucGFyYW1zKSB8fCB7fTtcbiAgICAgICAgICAgIF90aGlzLnN0YXRlc1thc3QubmFtZV0gPSBuZXcgQW5pbWF0aW9uU3RhdGVTdHlsZXMoYXN0LnN0eWxlLCBkZWZhdWx0UGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJhbGFuY2VQcm9wZXJ0aWVzKHRoaXMuc3RhdGVzLCAndHJ1ZScsICcxJyk7XG4gICAgICAgIGJhbGFuY2VQcm9wZXJ0aWVzKHRoaXMuc3RhdGVzLCAnZmFsc2UnLCAnMCcpO1xuICAgICAgICBhc3QudHJhbnNpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICBfdGhpcy50cmFuc2l0aW9uRmFjdG9yaWVzLnB1c2gobmV3IEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5KG5hbWUsIGFzdCwgX3RoaXMuc3RhdGVzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZhbGxiYWNrVHJhbnNpdGlvbiA9IGNyZWF0ZUZhbGxiYWNrVHJhbnNpdGlvbihuYW1lLCB0aGlzLnN0YXRlcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25UcmlnZ2VyLnByb3RvdHlwZSwgXCJjb250YWluc1F1ZXJpZXNcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5hc3QucXVlcnlDb3VudCA+IDA7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXG4gICAgICogQHBhcmFtIHs/fSBuZXh0U3RhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyaWdnZXIucHJvdG90eXBlLm1hdGNoVHJhbnNpdGlvbiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXG4gICAgICogQHBhcmFtIHs/fSBuZXh0U3RhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeSA9IHRoaXMudHJhbnNpdGlvbkZhY3Rvcmllcy5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLm1hdGNoKGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlKTsgfSk7XG4gICAgICAgIHJldHVybiBlbnRyeSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50U3RhdGVcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmlnZ2VyLnByb3RvdHlwZS5tYXRjaFN0eWxlcyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFN0YXRlXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGN1cnJlbnRTdGF0ZSwgcGFyYW1zLCBlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFsbGJhY2tUcmFuc2l0aW9uLmJ1aWxkU3R5bGVzKGN1cnJlbnRTdGF0ZSwgcGFyYW1zLCBlcnJvcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdGlvblRyaWdnZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXG4gKiBAcGFyYW0gez99IHN0YXRlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2tUcmFuc2l0aW9uKHRyaWdnZXJOYW1lLCBzdGF0ZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVycyA9IFtmdW5jdGlvbiAoZnJvbVN0YXRlLCB0b1N0YXRlKSB7IHJldHVybiB0cnVlOyB9XTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRpb24gPSB7IHR5cGU6IDIgLyogU2VxdWVuY2UgKi8sIHN0ZXBzOiBbXSwgb3B0aW9uczogbnVsbCB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zaXRpb24gPSB7XG4gICAgICAgIHR5cGU6IDEgLyogVHJhbnNpdGlvbiAqLyxcbiAgICAgICAgYW5pbWF0aW9uOiBhbmltYXRpb24sXG4gICAgICAgIG1hdGNoZXJzOiBtYXRjaGVycyxcbiAgICAgICAgb3B0aW9uczogbnVsbCxcbiAgICAgICAgcXVlcnlDb3VudDogMCxcbiAgICAgICAgZGVwQ291bnQ6IDBcbiAgICB9O1xuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uVHJhbnNpdGlvbkZhY3RvcnkodHJpZ2dlck5hbWUsIHRyYW5zaXRpb24sIHN0YXRlcyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gb2JqXG4gKiBAcGFyYW0gez99IGtleTFcbiAqIEBwYXJhbSB7P30ga2V5MlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYmFsYW5jZVByb3BlcnRpZXMob2JqLCBrZXkxLCBrZXkyKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkxKSkge1xuICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkyKSkge1xuICAgICAgICAgICAgb2JqW2tleTJdID0gb2JqW2tleTFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkyKSkge1xuICAgICAgICBvYmpba2V5MV0gPSBvYmpba2V5Ml07XG4gICAgfVxufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgRU1QVFlfSU5TVFJVQ1RJT05fTUFQID0gbmV3IEVsZW1lbnRJbnN0cnVjdGlvbk1hcCgpO1xudmFyIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lKF9kcml2ZXIsIF9ub3JtYWxpemVyKSB7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBfbm9ybWFsaXplcjtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLl9wbGF5ZXJzQnlJZCA9IHt9O1xuICAgICAgICB0aGlzLnBsYXllcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaWQsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBidWlsZEFuaW1hdGlvbkFzdCh0aGlzLl9kcml2ZXIsIG1ldGFkYXRhLCBlcnJvcnMpO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGJ1aWxkIHRoZSBhbmltYXRpb24gZHVlIHRvIHRoZSBmb2xsb3dpbmcgZXJyb3JzOiBcIiArIGVycm9ycy5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnNbaWRdID0gYXN0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlcbiAgICAgKiBAcGFyYW0gez99IHByZVN0eWxlc1xuICAgICAqIEBwYXJhbSB7Pz19IHBvc3RTdHlsZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYnVpbGRQbGF5ZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGlcbiAgICAgKiBAcGFyYW0gez99IHByZVN0eWxlc1xuICAgICAqIEBwYXJhbSB7Pz19IHBvc3RTdHlsZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpLCBwcmVTdHlsZXMsIHBvc3RTdHlsZXMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGkuZWxlbWVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ZnJhbWVzID0gbm9ybWFsaXplS2V5ZnJhbWVzKHRoaXMuX2RyaXZlciwgdGhpcy5fbm9ybWFsaXplciwgZWxlbWVudCwgaS5rZXlmcmFtZXMsIHByZVN0eWxlcywgcG9zdFN0eWxlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcml2ZXIuYW5pbWF0ZShlbGVtZW50LCBrZXlmcmFtZXMsIGkuZHVyYXRpb24sIGkuZGVsYXksIGkuZWFzaW5nLCBbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmNyZWF0ZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaWQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX2FuaW1hdGlvbnNbaWRdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0cnVjdGlvbnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF1dG9TdHlsZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChhc3QpIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IGJ1aWxkQW5pbWF0aW9uVGltZWxpbmVzKHRoaXMuX2RyaXZlciwgZWxlbWVudCwgYXN0LCBFTlRFUl9DTEFTU05BTUUsIExFQVZFX0NMQVNTTkFNRSwge30sIHt9LCBvcHRpb25zLCBFTVBUWV9JTlNUUlVDVElPTl9NQVAsIGVycm9ycyk7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlcyA9IGdldE9yU2V0QXNJbk1hcChhdXRvU3R5bGVzTWFwLCBpbnN0LmVsZW1lbnQsIHt9KTtcbiAgICAgICAgICAgICAgICBpbnN0LnBvc3RTdHlsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHN0eWxlc1twcm9wXSA9IG51bGw7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCgnVGhlIHJlcXVlc3RlZCBhbmltYXRpb24gZG9lc25cXCd0IGV4aXN0IG9yIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkJyk7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSB0aGUgYW5pbWF0aW9uIGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yczogXCIgKyBlcnJvcnMuam9pbihcIlxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXV0b1N0eWxlc01hcC5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZXMsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBzdHlsZXNbcHJvcF0gPSBfdGhpcy5fZHJpdmVyLmNvbXB1dGVTdHlsZShlbGVtZW50LCBwcm9wLCBfYW5ndWxhcl9hbmltYXRpb25zLkFVVE9fU1RZTEUpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBpbnN0cnVjdGlvbnMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSBhdXRvU3R5bGVzTWFwLmdldChpLmVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9idWlsZFBsYXllcihpLCB7fSwgc3R5bGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIocGxheWVycyk7XG4gICAgICAgIHRoaXMuX3BsYXllcnNCeUlkW2lkXSA9IHBsYXllcjtcbiAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kZXN0cm95KGlkKTsgfSk7XG4gICAgICAgIHRoaXMucGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSB0aGlzLl9nZXRQbGF5ZXIoaWQpO1xuICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fcGxheWVyc0J5SWRbaWRdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IHRoaXMucGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGltZWxpbmVBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9nZXRQbGF5ZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gdGhpcy5fcGxheWVyc0J5SWRbaWRdO1xuICAgICAgICBpZiAoIXBsYXllcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdGhlIHRpbWVsaW5lIHBsYXllciByZWZlcmVuY2VkIGJ5IFwiICsgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUubGlzdGVuID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHRyaWdnZXJOYW1lLCBmcm9tU3RhdGUsIHRvU3RhdGUgYXJlIGFsbCBpZ25vcmVkIGZvciB0aW1lbGluZSBhbmltYXRpb25zXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VFdmVudCA9IG1ha2VBbmltYXRpb25FdmVudChlbGVtZW50LCAnJywgJycsICcnKTtcbiAgICAgICAgbGlzdGVuT25QbGF5ZXIodGhpcy5fZ2V0UGxheWVyKGlkKSwgZXZlbnROYW1lLCBiYXNlRXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5jb21tYW5kID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29tbWFuZFxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBjb21tYW5kLCBhcmdzKSB7XG4gICAgICAgIGlmIChjb21tYW5kID09ICdyZWdpc3RlcicpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoaWQsIC8qKiBAdHlwZSB7P30gKi8gKGFyZ3NbMF0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZCA9PSAnY3JlYXRlJykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9ucyA9IC8qKiBAdHlwZSB7P30gKi8gKChhcmdzWzBdIHx8IHt9KSk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZShpZCwgZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gdGhpcy5fZ2V0UGxheWVyKGlkKTtcbiAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlICdwbGF5JzpcbiAgICAgICAgICAgICAgICBwbGF5ZXIucGxheSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGF1c2UnOlxuICAgICAgICAgICAgICAgIHBsYXllci5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVzZXQnOlxuICAgICAgICAgICAgICAgIHBsYXllci5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVzdGFydCc6XG4gICAgICAgICAgICAgICAgcGxheWVyLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaCc6XG4gICAgICAgICAgICAgICAgcGxheWVyLmZpbmlzaCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgICAgICAgICAgcGxheWVyLmluaXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NldFBvc2l0aW9uJzpcbiAgICAgICAgICAgICAgICBwbGF5ZXIuc2V0UG9zaXRpb24ocGFyc2VGbG9hdCgvKiogQHR5cGUgez99ICovIChhcmdzWzBdKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVzdHJveSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KGlkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRpbWVsaW5lQW5pbWF0aW9uRW5naW5lO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFFVRVVFRF9DTEFTU05BTUUgPSAnbmctYW5pbWF0ZS1xdWV1ZWQnO1xudmFyIFFVRVVFRF9TRUxFQ1RPUiA9ICcubmctYW5pbWF0ZS1xdWV1ZWQnO1xudmFyIERJU0FCTEVEX0NMQVNTTkFNRSA9ICduZy1hbmltYXRlLWRpc2FibGVkJztcbnZhciBESVNBQkxFRF9TRUxFQ1RPUiA9ICcubmctYW5pbWF0ZS1kaXNhYmxlZCc7XG52YXIgU1RBUl9DTEFTU05BTUUgPSAnbmctc3Rhci1pbnNlcnRlZCc7XG52YXIgU1RBUl9TRUxFQ1RPUiA9ICcubmctc3Rhci1pbnNlcnRlZCc7XG52YXIgRU1QVFlfUExBWUVSX0FSUkFZID0gW107XG52YXIgTlVMTF9SRU1PVkFMX1NUQVRFID0ge1xuICAgIG5hbWVzcGFjZUlkOiAnJyxcbiAgICBzZXRGb3JSZW1vdmFsOiBudWxsLFxuICAgIGhhc0FuaW1hdGlvbjogZmFsc2UsXG4gICAgcmVtb3ZlZEJlZm9yZVF1ZXJpZWQ6IGZhbHNlXG59O1xudmFyIE5VTExfUkVNT1ZFRF9RVUVSSUVEX1NUQVRFID0ge1xuICAgIG5hbWVzcGFjZUlkOiAnJyxcbiAgICBzZXRGb3JSZW1vdmFsOiBudWxsLFxuICAgIGhhc0FuaW1hdGlvbjogZmFsc2UsXG4gICAgcmVtb3ZlZEJlZm9yZVF1ZXJpZWQ6IHRydWVcbn07XG4vKipcbiAqIEByZWNvcmRcbiAqL1xuXG52YXIgUkVNT1ZBTF9GTEFHID0gJ19fbmdfcmVtb3ZlZCc7XG4vKipcbiAqIEByZWNvcmRcbiAqL1xuXG52YXIgU3RhdGVWYWx1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZVZhbHVlKGlucHV0LCBuYW1lc3BhY2VJZCkge1xuICAgICAgICBpZiAobmFtZXNwYWNlSWQgPT09IHZvaWQgMCkgeyBuYW1lc3BhY2VJZCA9ICcnOyB9XG4gICAgICAgIHRoaXMubmFtZXNwYWNlSWQgPSBuYW1lc3BhY2VJZDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNPYmogPSBpbnB1dCAmJiBpbnB1dC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBpc09iaiA/IGlucHV0Wyd2YWx1ZSddIDogaW5wdXQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSBub3JtYWxpemVUcmlnZ2VyVmFsdWUodmFsdWUpO1xuICAgICAgICBpZiAoaXNPYmopIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnMgPSBjb3B5T2JqKC8qKiBAdHlwZSB7P30gKi8gKGlucHV0KSk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uc1sndmFsdWUnXTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlVmFsdWUucHJvdG90eXBlLCBcInBhcmFtc1wiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAvKiogQHR5cGUgez99ICovICh0aGlzLm9wdGlvbnMucGFyYW1zKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZVZhbHVlLnByb3RvdHlwZS5hYnNvcmJPcHRpb25zID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdQYXJhbXMgPSBvcHRpb25zLnBhcmFtcztcbiAgICAgICAgaWYgKG5ld1BhcmFtcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkUGFyYW1zXzEgPSAvKiogQHR5cGUgez99ICovICgodGhpcy5vcHRpb25zLnBhcmFtcykpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3UGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFBhcmFtc18xW3Byb3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFyYW1zXzFbcHJvcF0gPSBuZXdQYXJhbXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZVZhbHVlO1xufSgpKTtcbnZhciBWT0lEX1ZBTFVFID0gJ3ZvaWQnO1xudmFyIERFRkFVTFRfU1RBVEVfVkFMVUUgPSBuZXcgU3RhdGVWYWx1ZShWT0lEX1ZBTFVFKTtcbnZhciBERUxFVEVEX1NUQVRFX1ZBTFVFID0gbmV3IFN0YXRlVmFsdWUoJ0RFTEVURUQnKTtcbnZhciBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UoaWQsIGhvc3RFbGVtZW50LCBfZW5naW5lKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLl9lbmdpbmUgPSBfZW5naW5lO1xuICAgICAgICB0aGlzLnBsYXllcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fZWxlbWVudExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faG9zdENsYXNzTmFtZSA9ICduZy10bnMtJyArIGlkO1xuICAgICAgICBhZGRDbGFzcyhob3N0RWxlbWVudCwgdGhpcy5faG9zdENsYXNzTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGhhc2VcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUsIHBoYXNlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX3RyaWdnZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbGlzdGVuIG9uIHRoZSBhbmltYXRpb24gdHJpZ2dlciBldmVudCBcXFwiXCIgKyBwaGFzZSArIFwiXFxcIiBiZWNhdXNlIHRoZSBhbmltYXRpb24gdHJpZ2dlciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGRvZXNuJ3QgZXhpc3QhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaGFzZSA9PSBudWxsIHx8IHBoYXNlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbGlzdGVuIG9uIHRoZSBhbmltYXRpb24gdHJpZ2dlciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGJlY2F1c2UgdGhlIHByb3ZpZGVkIGV2ZW50IGlzIHVuZGVmaW5lZCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1RyaWdnZXJFdmVudFZhbGlkKHBoYXNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHByb3ZpZGVkIGFuaW1hdGlvbiB0cmlnZ2VyIGV2ZW50IFxcXCJcIiArIHBoYXNlICsgXCJcXFwiIGZvciB0aGUgYW5pbWF0aW9uIHRyaWdnZXIgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkIVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ZW5lcnMgPSBnZXRPclNldEFzSW5NYXAodGhpcy5fZWxlbWVudExpc3RlbmVycywgZWxlbWVudCwgW10pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkYXRhID0geyBuYW1lOiBuYW1lLCBwaGFzZTogcGhhc2UsIGNhbGxiYWNrOiBjYWxsYmFjayB9O1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChkYXRhKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlcnNXaXRoU3RhdGVzID0gZ2V0T3JTZXRBc0luTWFwKHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQsIGVsZW1lbnQsIHt9KTtcbiAgICAgICAgaWYgKCF0cmlnZ2Vyc1dpdGhTdGF0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIE5HX1RSSUdHRVJfQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIE5HX1RSSUdHRVJfQ0xBU1NOQU1FICsgJy0nICsgbmFtZSk7XG4gICAgICAgICAgICB0cmlnZ2Vyc1dpdGhTdGF0ZXNbbmFtZV0gPSBERUZBVUxUX1NUQVRFX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB0aGUgZXZlbnQgbGlzdGVuZXIgaXMgcmVtb3ZlZCBBRlRFUiB0aGUgZmx1c2ggaGFzIG9jY3VycmVkIHN1Y2hcbiAgICAgICAgICAgIC8vIHRoYXQgbGVhdmUgYW5pbWF0aW9ucyBjYWxsYmFja3MgY2FuIGZpcmUgKG90aGVyd2lzZSBpZiB0aGUgbm9kZVxuICAgICAgICAgICAgLy8gaXMgcmVtb3ZlZCBpbiBiZXR3ZWVuIHRoZW4gdGhlIGxpc3RlbmVycyB3b3VsZCBiZSBkZXJlZ2lzdGVyZWQpXG4gICAgICAgICAgICAvLyB0aGUgZXZlbnQgbGlzdGVuZXIgaXMgcmVtb3ZlZCBBRlRFUiB0aGUgZmx1c2ggaGFzIG9jY3VycmVkIHN1Y2hcbiAgICAgICAgICAgIC8vIHRoYXQgbGVhdmUgYW5pbWF0aW9ucyBjYWxsYmFja3MgY2FuIGZpcmUgKG90aGVyd2lzZSBpZiB0aGUgbm9kZVxuICAgICAgICAgICAgLy8gaXMgcmVtb3ZlZCBpbiBiZXR3ZWVuIHRoZW4gdGhlIGxpc3RlbmVycyB3b3VsZCBiZSBkZXJlZ2lzdGVyZWQpXG4gICAgICAgICAgICBfdGhpcy5fZW5naW5lLmFmdGVyRmx1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3RyaWdnZXJzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmlnZ2Vyc1dpdGhTdGF0ZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUucmVnaXN0ZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUsIGFzdCkge1xuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIC8vIHRocm93XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2Vyc1tuYW1lXSA9IGFzdDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLl9nZXRUcmlnZ2VyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyID0gdGhpcy5fdHJpZ2dlcnNbbmFtZV07XG4gICAgICAgIGlmICghdHJpZ2dlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHByb3ZpZGVkIGFuaW1hdGlvbiB0cmlnZ2VyIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmlnZ2VyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSB0cmlnZ2VyTmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VG9GYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUudHJpZ2dlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gdHJpZ2dlck5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdFRvRmFsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCB0cmlnZ2VyTmFtZSwgdmFsdWUsIGRlZmF1bHRUb0ZhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkZWZhdWx0VG9GYWxsYmFjayA9PT0gdm9pZCAwKSB7IGRlZmF1bHRUb0ZhbGxiYWNrID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyID0gdGhpcy5fZ2V0VHJpZ2dlcih0cmlnZ2VyTmFtZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IG5ldyBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyKHRoaXMuaWQsIHRyaWdnZXJOYW1lLCBlbGVtZW50KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlcnNXaXRoU3RhdGVzID0gdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmICghdHJpZ2dlcnNXaXRoU3RhdGVzKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBOR19UUklHR0VSX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBOR19UUklHR0VSX0NMQVNTTkFNRSArICctJyArIHRyaWdnZXJOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuc2V0KGVsZW1lbnQsIHRyaWdnZXJzV2l0aFN0YXRlcyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmcm9tU3RhdGUgPSB0cmlnZ2Vyc1dpdGhTdGF0ZXNbdHJpZ2dlck5hbWVdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b1N0YXRlID0gbmV3IFN0YXRlVmFsdWUodmFsdWUsIHRoaXMuaWQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc09iaiA9IHZhbHVlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCd2YWx1ZScpO1xuICAgICAgICBpZiAoIWlzT2JqICYmIGZyb21TdGF0ZSkge1xuICAgICAgICAgICAgdG9TdGF0ZS5hYnNvcmJPcHRpb25zKGZyb21TdGF0ZS5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0cmlnZ2Vyc1dpdGhTdGF0ZXNbdHJpZ2dlck5hbWVdID0gdG9TdGF0ZTtcbiAgICAgICAgaWYgKCFmcm9tU3RhdGUpIHtcbiAgICAgICAgICAgIGZyb21TdGF0ZSA9IERFRkFVTFRfU1RBVEVfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZnJvbVN0YXRlID09PSBERUxFVEVEX1NUQVRFX1ZBTFVFKSB7XG4gICAgICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzUmVtb3ZhbCA9IHRvU3RhdGUudmFsdWUgPT09IFZPSURfVkFMVUU7XG4gICAgICAgIC8vIG5vcm1hbGx5IHRoaXMgaXNuJ3QgcmVhY2hlZCBieSBoZXJlLCBob3dldmVyLCBpZiBhbiBvYmplY3QgZXhwcmVzc2lvblxuICAgICAgICAvLyBpcyBwYXNzZWQgaW4gdGhlbiBpdCBtYXkgYmUgYSBuZXcgb2JqZWN0IGVhY2ggdGltZS4gQ29tcGFyaW5nIHRoZSB2YWx1ZVxuICAgICAgICAvLyBpcyBpbXBvcnRhbnQgc2luY2UgdGhhdCB3aWxsIHN0YXkgdGhlIHNhbWUgZGVzcGl0ZSB0aGVyZSBiZWluZyBhIG5ldyBvYmplY3QuXG4gICAgICAgIC8vIFRoZSByZW1vdmFsIGFyYyBoZXJlIGlzIHNwZWNpYWwgY2FzZWQgYmVjYXVzZSB0aGUgc2FtZSBlbGVtZW50IGlzIHRyaWdnZXJlZFxuICAgICAgICAvLyB0d2ljZSBpbiB0aGUgZXZlbnQgdGhhdCBpdCBjb250YWlucyBhbmltYXRpb25zIG9uIHRoZSBvdXRlci9pbm5lciBwb3J0aW9uc1xuICAgICAgICAvLyBvZiB0aGUgaG9zdCBjb250YWluZXJcbiAgICAgICAgaWYgKCFpc1JlbW92YWwgJiYgZnJvbVN0YXRlLnZhbHVlID09PSB0b1N0YXRlLnZhbHVlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgZGVzcGl0ZSB0aGUgdmFsdWUgbm90IGNoYW5naW5nLCBzb21lIGlubmVyIHBhcmFtc1xuICAgICAgICAgICAgLy8gaGF2ZSBjaGFuZ2VkIHdoaWNoIG1lYW5zIHRoYXQgdGhlIGFuaW1hdGlvbiBmaW5hbCBzdHlsZXMgbmVlZCB0byBiZSBhcHBsaWVkXG4gICAgICAgICAgICBpZiAoIW9iakVxdWFscyhmcm9tU3RhdGUucGFyYW1zLCB0b1N0YXRlLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmcm9tU3R5bGVzXzEgPSB0cmlnZ2VyLm1hdGNoU3R5bGVzKGZyb21TdGF0ZS52YWx1ZSwgZnJvbVN0YXRlLnBhcmFtcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b1N0eWxlc18xID0gdHJpZ2dlci5tYXRjaFN0eWxlcyh0b1N0YXRlLnZhbHVlLCB0b1N0YXRlLnBhcmFtcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUucmVwb3J0RXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5hZnRlckZsdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyYXNlU3R5bGVzKGVsZW1lbnQsIGZyb21TdHlsZXNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTdHlsZXMoZWxlbWVudCwgdG9TdHlsZXNfMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzT25FbGVtZW50ID0gZ2V0T3JTZXRBc0luTWFwKHRoaXMuX2VuZ2luZS5wbGF5ZXJzQnlFbGVtZW50LCBlbGVtZW50LCBbXSk7XG4gICAgICAgIHBsYXllcnNPbkVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAvLyBvbmx5IHJlbW92ZSB0aGUgcGxheWVyIGlmIGl0IGlzIHF1ZXVlZCBvbiB0aGUgRVhBQ1Qgc2FtZSB0cmlnZ2VyL25hbWVzcGFjZVxuICAgICAgICAgICAgLy8gd2Ugb25seSBhbHNvIGRlYWwgd2l0aCBxdWV1ZWQgcGxheWVycyBoZXJlIGJlY2F1c2UgaWYgdGhlIGFuaW1hdGlvbiBoYXNcbiAgICAgICAgICAgIC8vIHN0YXJ0ZWQgdGhlbiB3ZSB3YW50IHRvIGtlZXAgdGhlIHBsYXllciBhbGl2ZSB1bnRpbCB0aGUgZmx1c2ggaGFwcGVuc1xuICAgICAgICAgICAgLy8gKHdoaWNoIGlzIHdoZXJlIHRoZSBwcmV2aW91c1BsYXllcnMgYXJlIHBhc3NlZCBpbnRvIHRoZSBuZXcgcGFseWVyKVxuICAgICAgICAgICAgaWYgKHBsYXllci5uYW1lc3BhY2VJZCA9PSBfdGhpcy5pZCAmJiBwbGF5ZXIudHJpZ2dlck5hbWUgPT0gdHJpZ2dlck5hbWUgJiYgcGxheWVyLnF1ZXVlZCkge1xuICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2l0aW9uID0gdHJpZ2dlci5tYXRjaFRyYW5zaXRpb24oZnJvbVN0YXRlLnZhbHVlLCB0b1N0YXRlLnZhbHVlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNGYWxsYmFja1RyYW5zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRUb0ZhbGxiYWNrKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyYW5zaXRpb24gPSB0cmlnZ2VyLmZhbGxiYWNrVHJhbnNpdGlvbjtcbiAgICAgICAgICAgIGlzRmFsbGJhY2tUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbmdpbmUudG90YWxRdWV1ZWRQbGF5ZXJzKys7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyBlbGVtZW50OiBlbGVtZW50LCB0cmlnZ2VyTmFtZTogdHJpZ2dlck5hbWUsIHRyYW5zaXRpb246IHRyYW5zaXRpb24sIGZyb21TdGF0ZTogZnJvbVN0YXRlLCB0b1N0YXRlOiB0b1N0YXRlLCBwbGF5ZXI6IHBsYXllciwgaXNGYWxsYmFja1RyYW5zaXRpb246IGlzRmFsbGJhY2tUcmFuc2l0aW9uIH0pO1xuICAgICAgICBpZiAoIWlzRmFsbGJhY2tUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBRVUVVRURfQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgIHBsYXllci5vblN0YXJ0KGZ1bmN0aW9uICgpIHsgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgUVVFVUVEX0NMQVNTTkFNRSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHBsYXllci5vbkRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBfdGhpcy5wbGF5ZXJzLmluZGV4T2YocGxheWVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGxheWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVycyA9IF90aGlzLl9lbmdpbmUucGxheWVyc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAocGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4XzEgPSBwbGF5ZXJzLmluZGV4T2YocGxheWVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhfMSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllcnMuc3BsaWNlKGluZGV4XzEsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgIHBsYXllcnNPbkVsZW1lbnQucHVzaChwbGF5ZXIpO1xuICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5kZXJlZ2lzdGVyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBkZWxldGUgdGhpcy5fdHJpZ2dlcnNbbmFtZV07XG4gICAgICAgIHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVNYXAsIGVsZW1lbnQpIHsgZGVsZXRlIHN0YXRlTWFwW25hbWVdOyB9KTtcbiAgICAgICAgdGhpcy5fZWxlbWVudExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcnMsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIF90aGlzLl9lbGVtZW50TGlzdGVuZXJzLnNldChlbGVtZW50LCBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkubmFtZSAhPSBuYW1lOyB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5jbGVhckVsZW1lbnRDYWNoZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50UGxheWVycyA9IHRoaXMuX2VuZ2luZS5wbGF5ZXJzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnRQbGF5ZXJzKSB7XG4gICAgICAgICAgICBlbGVtZW50UGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5kZXN0cm95KCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnBsYXllcnNCeUVsZW1lbnQuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvb3RFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gYW5pbWF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUuX3NpZ25hbFJlbW92YWxGb3JJbm5lclRyaWdnZXJzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSByb290RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGFuaW1hdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyb290RWxlbWVudCwgY29udGV4dCwgYW5pbWF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYW5pbWF0ZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGUgPSBmYWxzZTsgfVxuICAgICAgICAvLyBlbXVsYXRlIGEgbGVhdmUgYW5pbWF0aW9uIGZvciBhbGwgaW5uZXIgbm9kZXMgd2l0aGluIHRoaXMgbm9kZS5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGFuaW1hdGlvbnMgZm91bmQgZm9yIGFueSBvZiB0aGUgbm9kZXMgdGhlbiBjbGVhciB0aGUgY2FjaGVcbiAgICAgICAgLy8gZm9yIHRoZSBlbGVtZW50LlxuICAgICAgICB0aGlzLl9lbmdpbmUuZHJpdmVyLnF1ZXJ5KHJvb3RFbGVtZW50LCBOR19UUklHR0VSX1NFTEVDVE9SLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChlbG0pIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBhbiBpbm5lciByZW1vdmUoKSBvcGVyYXRpb24gaGFzIGFscmVhZHkga2lja2VkIG9mZlxuICAgICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBvbiB0aGlzIGVsZW1lbnQuLi5cbiAgICAgICAgICAgIGlmIChlbG1bUkVNT1ZBTF9GTEFHXSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lc3BhY2VzID0gX3RoaXMuX2VuZ2luZS5mZXRjaE5hbWVzcGFjZXNCeUVsZW1lbnQoZWxtKTtcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2VzLnNpemUpIHtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzLmZvckVhY2goZnVuY3Rpb24gKG5zKSB7IHJldHVybiBucy50cmlnZ2VyTGVhdmVBbmltYXRpb24oZWxtLCBjb250ZXh0LCBmYWxzZSwgdHJ1ZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJFbGVtZW50Q2FjaGUoZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcGFyYW0gez89fSBkZXN0cm95QWZ0ZXJDb21wbGV0ZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmF1bHRUb0ZhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS50cmlnZ2VyTGVhdmVBbmltYXRpb24gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcGFyYW0gez89fSBkZXN0cm95QWZ0ZXJDb21wbGV0ZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmF1bHRUb0ZhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCwgZGVzdHJveUFmdGVyQ29tcGxldGUsIGRlZmF1bHRUb0ZhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXJTdGF0ZXMgPSB0aGlzLl9lbmdpbmUuc3RhdGVzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKHRyaWdnZXJTdGF0ZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnNfMSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModHJpZ2dlclN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlck5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoZWNrIGlzIGhlcmUgaW4gdGhlIGV2ZW50IHRoYXQgYW4gZWxlbWVudCBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgLy8gdHdpY2UgKGJvdGggb24gdGhlIGhvc3QgbGV2ZWwgYW5kIHRoZSBjb21wb25lbnQgbGV2ZWwpXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl90cmlnZ2Vyc1t0cmlnZ2VyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gX3RoaXMudHJpZ2dlcihlbGVtZW50LCB0cmlnZ2VyTmFtZSwgVk9JRF9WQUxVRSwgZGVmYXVsdFRvRmFsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzXzEucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocGxheWVyc18xLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5tYXJrRWxlbWVudEFzUmVtb3ZlZCh0aGlzLmlkLCBlbGVtZW50LCB0cnVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzdHJveUFmdGVyQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzXzEpLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZW5naW5lLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLnByZXBhcmVMZWF2ZUFuaW1hdGlvbkxpc3RlbmVycyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlzdGVuZXJzID0gdGhpcy5fZWxlbWVudExpc3RlbmVycy5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0ZWRUcmlnZ2Vyc18xID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlck5hbWUgPSBsaXN0ZW5lci5uYW1lO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkVHJpZ2dlcnNfMS5oYXModHJpZ2dlck5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmlzaXRlZFRyaWdnZXJzXzEuYWRkKHRyaWdnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyID0gX3RoaXMuX3RyaWdnZXJzW3RyaWdnZXJOYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2l0aW9uID0gdHJpZ2dlci5mYWxsYmFja1RyYW5zaXRpb247XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFN0YXRlcyA9IC8qKiBAdHlwZSB7P30gKi8gKChfdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5nZXQoZWxlbWVudCkpKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmcm9tU3RhdGUgPSBlbGVtZW50U3RhdGVzW3RyaWdnZXJOYW1lXSB8fCBERUZBVUxUX1NUQVRFX1ZBTFVFO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvU3RhdGUgPSBuZXcgU3RhdGVWYWx1ZShWT0lEX1ZBTFVFKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBuZXcgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcihfdGhpcy5pZCwgdHJpZ2dlck5hbWUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9lbmdpbmUudG90YWxRdWV1ZWRQbGF5ZXJzKys7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTmFtZTogdHJpZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZyb21TdGF0ZTogZnJvbVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICB0b1N0YXRlOiB0b1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICBwbGF5ZXI6IHBsYXllcixcbiAgICAgICAgICAgICAgICAgICAgaXNGYWxsYmFja1RyYW5zaXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZU5vZGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZ2luZSA9IHRoaXMuX2VuZ2luZTtcbiAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRFbGVtZW50Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbFJlbW92YWxGb3JJbm5lclRyaWdnZXJzKGVsZW1lbnQsIGNvbnRleHQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBhICogPT4gVk9JRCBhbmltYXRpb24gd2FzIGRldGVjdGVkIGFuZCBraWNrZWQgb2ZmXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXJMZWF2ZUFuaW1hdGlvbihlbGVtZW50LCBjb250ZXh0LCB0cnVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gZmluZCB0aGUgcGxheWVyIHRoYXQgaXMgYW5pbWF0aW5nIGFuZCBtYWtlIHN1cmUgdGhhdCB0aGVcbiAgICAgICAgLy8gcmVtb3ZhbCBpcyBkZWxheWVkIHVudGlsIHRoYXQgcGxheWVyIGhhcyBjb21wbGV0ZWRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbnNQb3RlbnRpYWxQYXJlbnRUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmIChlbmdpbmUudG90YWxBbmltYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50UGxheWVycyA9IGVuZ2luZS5wbGF5ZXJzLmxlbmd0aCA/IGVuZ2luZS5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5nZXQoZWxlbWVudCkgOiBbXTtcbiAgICAgICAgICAgIC8vIHdoZW4gdGhpcyBgaWYgc3RhdGVtZW50YCBkb2VzIG5vdCBjb250aW51ZSBmb3J3YXJkIGl0IG1lYW5zIHRoYXRcbiAgICAgICAgICAgIC8vIGEgcHJldmlvdXMgYW5pbWF0aW9uIHF1ZXJ5IGhhcyBzZWxlY3RlZCB0aGUgY3VycmVudCBlbGVtZW50IGFuZFxuICAgICAgICAgICAgLy8gaXMgYW5pbWF0aW5nIGl0LiBJbiB0aGlzIHNpdHVhdGlvbiB3YW50IHRvIGNvbnRpbnVlIGZvd2FyZHMgYW5kXG4gICAgICAgICAgICAvLyBhbGxvdyB0aGUgZWxlbWVudCB0byBiZSBxdWV1ZWQgdXAgZm9yIGFuaW1hdGlvbiBsYXRlci5cbiAgICAgICAgICAgIGlmIChjdXJyZW50UGxheWVycyAmJiBjdXJyZW50UGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250YWluc1BvdGVudGlhbFBhcmVudFRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50XzEgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJlbnRfMSA9IHBhcmVudF8xLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpZ2dlcnMgPSBlbmdpbmUuc3RhdGVzQnlFbGVtZW50LmdldChwYXJlbnRfMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnNQb3RlbnRpYWxQYXJlbnRUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGF0IHRoaXMgc3RhZ2Ugd2Uga25vdyB0aGF0IHRoZSBlbGVtZW50IHdpbGwgZWl0aGVyIGdldCByZW1vdmVkXG4gICAgICAgIC8vIGR1cmluZyBmbHVzaCBvciB3aWxsIGJlIHBpY2tlZCB1cCBieSBhIHBhcmVudCBxdWVyeS4gRWl0aGVyIHdheVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGZpcmUgdGhlIGxpc3RlbmVycyBmb3IgdGhpcyBlbGVtZW50IHdoZW4gaXQgRE9FUyBnZXRcbiAgICAgICAgLy8gcmVtb3ZlZCAob25jZSB0aGUgcXVlcnkgcGFyZW50IGFuaW1hdGlvbiBpcyBkb25lIG9yIGFmdGVyIGZsdXNoKVxuICAgICAgICB0aGlzLnByZXBhcmVMZWF2ZUFuaW1hdGlvbkxpc3RlbmVycyhlbGVtZW50KTtcbiAgICAgICAgLy8gd2hldGhlciBvciBub3QgYSBwYXJlbnQgaGFzIGFuIGFuaW1hdGlvbiB3ZSBuZWVkIHRvIGRlbGF5IHRoZSBkZWZlcnJhbCBvZiB0aGUgbGVhdmVcbiAgICAgICAgLy8gb3BlcmF0aW9uIHVudGlsIHdlIGhhdmUgbW9yZSBpbmZvcm1hdGlvbiAod2hpY2ggd2UgZG8gYWZ0ZXIgZmx1c2goKSBoYXMgYmVlbiBjYWxsZWQpXG4gICAgICAgIGlmIChjb250YWluc1BvdGVudGlhbFBhcmVudFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGVuZ2luZS5tYXJrRWxlbWVudEFzUmVtb3ZlZCh0aGlzLmlkLCBlbGVtZW50LCBmYWxzZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBkbyB0aGlzIGFmdGVyIHRoZSBmbHVzaCBoYXMgb2NjdXJyZWQgc3VjaFxuICAgICAgICAgICAgLy8gdGhhdCB0aGUgY2FsbGJhY2tzIGNhbiBiZSBmaXJlZFxuICAgICAgICAgICAgZW5naW5lLmFmdGVyRmx1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xlYXJFbGVtZW50Q2FjaGUoZWxlbWVudCk7IH0pO1xuICAgICAgICAgICAgZW5naW5lLmRlc3Ryb3lJbm5lckFuaW1hdGlvbnMoZWxlbWVudCk7XG4gICAgICAgICAgICBlbmdpbmUuX29uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZS5wcm90b3R5cGUuaW5zZXJ0Tm9kZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50KSB7IGFkZENsYXNzKGVsZW1lbnQsIHRoaXMuX2hvc3RDbGFzc05hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWljcm90YXNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmRyYWluUXVldWVkVHJhbnNpdGlvbnMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG1pY3JvdGFza0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWljcm90YXNrSWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuX3F1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBlbnRyeS5wbGF5ZXI7XG4gICAgICAgICAgICBpZiAocGxheWVyLmRlc3Ryb3llZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gZW50cnkuZWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpc3RlbmVycyA9IF90aGlzLl9lbGVtZW50TGlzdGVuZXJzLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm5hbWUgPT0gZW50cnkudHJpZ2dlck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VFdmVudCA9IG1ha2VBbmltYXRpb25FdmVudChlbGVtZW50LCBlbnRyeS50cmlnZ2VyTmFtZSwgZW50cnkuZnJvbVN0YXRlLnZhbHVlLCBlbnRyeS50b1N0YXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgvKiogQHR5cGUgez99ICovIChiYXNlRXZlbnQpKVsnX2RhdGEnXSA9IG1pY3JvdGFza0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuT25QbGF5ZXIoZW50cnkucGxheWVyLCBsaXN0ZW5lci5waGFzZSwgYmFzZUV2ZW50LCBsaXN0ZW5lci5jYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbGF5ZXIubWFya2VkRm9yRGVzdHJveSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9lbmdpbmUuYWZ0ZXJGbHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyB3ZSBjYW4gZGVzdHJveSB0aGUgZWxlbWVudCBwcm9wZXJseSBzaW5jZSB0aGUgZXZlbnQgbGlzdGVuZXJzIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVlbiBib3VuZCB0byB0aGUgcGxheWVyXG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIGlmIGRlcENvdW50ID09IDAgdGhlbSBtb3ZlIHRvIGZyb250XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaWYgYSBjb250YWlucyBiIHRoZW4gbW92ZSBiYWNrXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMCA9IGEudHJhbnNpdGlvbi5hc3QuZGVwQ291bnQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMSA9IGIudHJhbnNpdGlvbi5hc3QuZGVwQ291bnQ7XG4gICAgICAgICAgICBpZiAoZDAgPT0gMCB8fCBkMSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQwIC0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2VuZ2luZS5kcml2ZXIuY29udGFpbnNFbGVtZW50KGEuZWxlbWVudCwgYi5lbGVtZW50KSA/IDEgOiAtMTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UucHJvdG90eXBlLmRlc3Ryb3kgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMucGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIHRoaXMuX3NpZ25hbFJlbW92YWxGb3JJbm5lclRyaWdnZXJzKHRoaXMuaG9zdEVsZW1lbnQsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlLnByb3RvdHlwZS5lbGVtZW50Q29udGFpbnNEYXRhID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluc0RhdGEgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgY29udGFpbnNEYXRhID1cbiAgICAgICAgICAgICh0aGlzLl9xdWV1ZS5maW5kKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkuZWxlbWVudCA9PT0gZWxlbWVudDsgfSkgPyB0cnVlIDogZmFsc2UpIHx8IGNvbnRhaW5zRGF0YTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zRGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlO1xufSgpKTtcbi8qKlxuICogQHJlY29yZFxuICovXG5cbnZhciBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUoZHJpdmVyLCBfbm9ybWFsaXplcikge1xuICAgICAgICB0aGlzLmRyaXZlciA9IGRyaXZlcjtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplciA9IF9ub3JtYWxpemVyO1xuICAgICAgICB0aGlzLnBsYXllcnMgPSBbXTtcbiAgICAgICAgdGhpcy5uZXdIb3N0RWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGxheWVyc0J5RWxlbWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdGF0ZXNCeUVsZW1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy50b3RhbEFuaW1hdGlvbnMgPSAwO1xuICAgICAgICB0aGlzLnRvdGFsUXVldWVkUGxheWVycyA9IDA7XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZUxvb2t1cCA9IHt9O1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0ID0gW107XG4gICAgICAgIHRoaXMuX2ZsdXNoRm5zID0gW107XG4gICAgICAgIHRoaXMuX3doZW5RdWlldEZucyA9IFtdO1xuICAgICAgICB0aGlzLm5hbWVzcGFjZXNCeUhvc3RFbGVtZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMub25SZW1vdmFsQ29tcGxldGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkgeyB9O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9vblJlbW92YWxDb21wbGV0ZSA9IC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkgeyB0aGlzLm9uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGNvbnRleHQpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZSwgXCJxdWV1ZWRQbGF5ZXJzXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX25hbWVzcGFjZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAobnMpIHtcbiAgICAgICAgICAgICAgICBucy5wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyLnF1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBsYXllcnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5jcmVhdGVOYW1lc3BhY2UgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IG5ldyBBbmltYXRpb25UcmFuc2l0aW9uTmFtZXNwYWNlKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCwgdGhpcyk7XG4gICAgICAgIGlmIChob3N0RWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWxhbmNlTmFtZXNwYWNlTGlzdChucywgaG9zdEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVmZXIgdGhpcyBsYXRlciB1bnRpbCBmbHVzaCBkdXJpbmcgd2hlbiB0aGUgaG9zdCBlbGVtZW50IGhhc1xuICAgICAgICAgICAgLy8gYmVlbiBpbnNlcnRlZCBzbyB0aGF0IHdlIGtub3cgZXhhY3RseSB3aGVyZSB0byBwbGFjZSBpdCBpblxuICAgICAgICAgICAgLy8gdGhlIG5hbWVzcGFjZSBsaXN0XG4gICAgICAgICAgICB0aGlzLm5ld0hvc3RFbGVtZW50cy5zZXQoaG9zdEVsZW1lbnQsIG5zKTtcbiAgICAgICAgICAgIC8vIGdpdmVuIHRoYXQgdGhpcyBob3N0IGVsZW1lbnQgaXMgYXBhcnQgb2YgdGhlIGFuaW1hdGlvbiBjb2RlLCBpdFxuICAgICAgICAgICAgLy8gbWF5IG9yIG1heSBub3QgYmUgaW5zZXJ0ZWQgYnkgYSBwYXJlbnQgbm9kZSB0aGF0IGlzIGFuIG9mIGFuXG4gICAgICAgICAgICAvLyBhbmltYXRpb24gcmVuZGVyZXIgdHlwZS4gSWYgdGhpcyBoYXBwZW5zIHRoZW4gd2UgY2FuIHN0aWxsIGhhdmVcbiAgICAgICAgICAgIC8vIGFjY2VzcyB0byB0aGlzIGl0ZW0gd2hlbiB3ZSBxdWVyeSBmb3IgOmVudGVyIG5vZGVzLiBJZiB0aGUgcGFyZW50XG4gICAgICAgICAgICAvLyBpcyBhIHJlbmRlcmVyIHRoZW4gdGhlIHNldCBkYXRhLXN0cnVjdHVyZSB3aWxsIG5vcm1hbGl6ZSB0aGUgZW50cnlcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdEVudGVyRWxlbWVudChob3N0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVzcGFjZUxvb2t1cFtuYW1lc3BhY2VJZF0gPSBucztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbnNcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fYmFsYW5jZU5hbWVzcGFjZUxpc3QgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5zXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5zLCBob3N0RWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW1pdCA9IHRoaXMuX25hbWVzcGFjZUxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxpbWl0ID49IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBsaW1pdDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0TmFtZXNwYWNlID0gdGhpcy5fbmFtZXNwYWNlTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kcml2ZXIuY29udGFpbnNFbGVtZW50KG5leHROYW1lc3BhY2UuaG9zdEVsZW1lbnQsIGhvc3RFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LnNwbGljZShpICsgMSwgMCwgbnMpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LnNwbGljZSgwLCAwLCBucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lc3BhY2VMaXN0LnB1c2gobnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZXNwYWNlc0J5SG9zdEVsZW1lbnQuc2V0KGhvc3RFbGVtZW50LCBucyk7XG4gICAgICAgIHJldHVybiBucztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gdGhpcy5fbmFtZXNwYWNlTG9va3VwW25hbWVzcGFjZUlkXTtcbiAgICAgICAgaWYgKCFucykge1xuICAgICAgICAgICAgbnMgPSB0aGlzLmNyZWF0ZU5hbWVzcGFjZShuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBucztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHRyaWdnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnJlZ2lzdGVyVHJpZ2dlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHRyaWdnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgbmFtZSwgdHJpZ2dlcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX25hbWVzcGFjZUxvb2t1cFtuYW1lc3BhY2VJZF07XG4gICAgICAgIGlmIChucyAmJiBucy5yZWdpc3RlcihuYW1lLCB0cmlnZ2VyKSkge1xuICAgICAgICAgICAgdGhpcy50b3RhbEFuaW1hdGlvbnMrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW5hbWVzcGFjZUlkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKTtcbiAgICAgICAgdGhpcy5hZnRlckZsdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWVzcGFjZXNCeUhvc3RFbGVtZW50LmRlbGV0ZShucy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuX25hbWVzcGFjZUxvb2t1cFtuYW1lc3BhY2VJZF07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IF90aGlzLl9uYW1lc3BhY2VMaXN0LmluZGV4T2YobnMpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbmFtZXNwYWNlTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZnRlckZsdXNoQW5pbWF0aW9uc0RvbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gbnMuZGVzdHJveShjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fZmV0Y2hOYW1lc3BhY2UgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHRoaXMuX25hbWVzcGFjZUxvb2t1cFtpZF07IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5mZXRjaE5hbWVzcGFjZXNCeUVsZW1lbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIG5vcm1hbGx5IHRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBuYW1lc3BhY2UgcGVyIGVsZW1lbnQsIGhvd2V2ZXJcbiAgICAgICAgLy8gaWYgQHRyaWdnZXJzIGFyZSBwbGFjZWQgb24gYm90aCB0aGUgY29tcG9uZW50IGVsZW1lbnQgYW5kIHRoZW5cbiAgICAgICAgLy8gaXRzIGhvc3QgZWxlbWVudCAod2l0aGluIHRoZSBjb21wb25lbnQgY29kZSkgdGhlbiB0aGVyZSB3aWxsIGJlXG4gICAgICAgIC8vIHR3byBuYW1lc3BhY2VzIHJldHVybmVkLiBXZSB1c2UgYSBzZXQgaGVyZSB0byBzaW1wbHkgdGhlIGRlZHVwZVxuICAgICAgICAvLyBvZiBuYW1lc3BhY2VzIGluY2FzZSB0aGVyZSBhcmUgbXVsdGlwbGUgdHJpZ2dlcnMgYm90aCB0aGUgZWxtIGFuZCBob3N0XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVzcGFjZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRTdGF0ZXMgPSB0aGlzLnN0YXRlc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50U3RhdGVzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudFN0YXRlcyk7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zSWQgPSBlbGVtZW50U3RhdGVzW2tleXNbaV1dLm5hbWVzcGFjZUlkO1xuICAgICAgICAgICAgICAgIGlmIChuc0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5zID0gdGhpcy5fZmV0Y2hOYW1lc3BhY2UobnNJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlcy5hZGQobnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lc3BhY2VzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLnRyaWdnZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5fZmV0Y2hOYW1lc3BhY2UobmFtZXNwYWNlSWQpLnRyaWdnZXIoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBpbnNlcnRCZWZvcmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmluc2VydE5vZGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IGluc2VydEJlZm9yZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwYXJlbnQsIGluc2VydEJlZm9yZSkge1xuICAgICAgICBpZiAoIWlzRWxlbWVudE5vZGUoZWxlbWVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igd2hlbiBhbiBlbGVtZW50IGlzIHJlbW92ZWQgYW5kIHJlaW5zZXJ0ZWQgKG1vdmUgb3BlcmF0aW9uKVxuICAgICAgICAvLyB3aGVuIHRoaXMgb2NjdXJzIHdlIGRvIG5vdCB3YW50IHRvIHVzZSB0aGUgZWxlbWVudCBmb3IgZGVsZXRpb24gbGF0ZXJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IC8qKiBAdHlwZSB7P30gKi8gKGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSk7XG4gICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbCkge1xuICAgICAgICAgICAgZGV0YWlscy5zZXRGb3JSZW1vdmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgdGhlIG5hbWVzcGFjZUlkIGlzIGJsYW5rIHRoZW4gdGhlIGNhbGxlclxuICAgICAgICAvLyBjb2RlIGRvZXMgbm90IGNvbnRhaW4gYW55IGFuaW1hdGlvbiBjb2RlIGluIGl0LCBidXQgaXQgaXNcbiAgICAgICAgLy8ganVzdCBiZWluZyBjYWxsZWQgc28gdGhhdCB0aGUgbm9kZSBpcyBtYXJrZWQgYXMgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgaWYgKG5hbWVzcGFjZUlkKSB7XG4gICAgICAgICAgICB0aGlzLl9mZXRjaE5hbWVzcGFjZShuYW1lc3BhY2VJZCkuaW5zZXJ0Tm9kZShlbGVtZW50LCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgKmRpcmVjdGl2ZXMgYW5kIGhvc3QgZWxlbWVudHMgYXJlIGluc2VydGVkIGJlZm9yZVxuICAgICAgICBpZiAoaW5zZXJ0QmVmb3JlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3RFbnRlckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuY29sbGVjdEVudGVyRWxlbWVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHsgdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzLnB1c2goZWxlbWVudCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUubWFya0VsZW1lbnRBc0Rpc2FibGVkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkTm9kZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlZE5vZGVzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBESVNBQkxFRF9DTEFTU05BTUUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzYWJsZWROb2Rlcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWROb2Rlcy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBESVNBQkxFRF9DTEFTU05BTUUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZW1vdmVOb2RlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghaXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5fb25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnMgPSBuYW1lc3BhY2VJZCA/IHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKSA6IG51bGw7XG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgICAgbnMucmVtb3ZlTm9kZShlbGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFya0VsZW1lbnRBc1JlbW92ZWQobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGZhbHNlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Pz19IGhhc0FuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLm1hcmtFbGVtZW50QXNSZW1vdmVkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Pz19IGhhc0FuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgaGFzQW5pbWF0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50W1JFTU9WQUxfRkxBR10gPSB7XG4gICAgICAgICAgICBuYW1lc3BhY2VJZDogbmFtZXNwYWNlSWQsXG4gICAgICAgICAgICBzZXRGb3JSZW1vdmFsOiBjb250ZXh0LCBoYXNBbmltYXRpb246IGhhc0FuaW1hdGlvbixcbiAgICAgICAgICAgIHJlbW92ZWRCZWZvcmVRdWVyaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGhhc2VcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwaGFzZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgZWxlbWVudCwgbmFtZSwgcGhhc2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hOYW1lc3BhY2UobmFtZXNwYWNlSWQpLmxpc3RlbihlbGVtZW50LCBuYW1lLCBwaGFzZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVudHJ5XG4gICAgICogQHBhcmFtIHs/fSBzdWJUaW1lbGluZXNcbiAgICAgKiBAcGFyYW0gez99IGVudGVyQ2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHs/fSBsZWF2ZUNsYXNzTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2J1aWxkSW5zdHJ1Y3Rpb24gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVudHJ5XG4gICAgICogQHBhcmFtIHs/fSBzdWJUaW1lbGluZXNcbiAgICAgKiBAcGFyYW0gez99IGVudGVyQ2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHs/fSBsZWF2ZUNsYXNzTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVudHJ5LCBzdWJUaW1lbGluZXMsIGVudGVyQ2xhc3NOYW1lLCBsZWF2ZUNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gZW50cnkudHJhbnNpdGlvbi5idWlsZCh0aGlzLmRyaXZlciwgZW50cnkuZWxlbWVudCwgZW50cnkuZnJvbVN0YXRlLnZhbHVlLCBlbnRyeS50b1N0YXRlLnZhbHVlLCBlbnRlckNsYXNzTmFtZSwgbGVhdmVDbGFzc05hbWUsIGVudHJ5LmZyb21TdGF0ZS5vcHRpb25zLCBlbnRyeS50b1N0YXRlLm9wdGlvbnMsIHN1YlRpbWVsaW5lcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lckVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmRlc3Ryb3lJbm5lckFuaW1hdGlvbnMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lckVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRzID0gdGhpcy5kcml2ZXIucXVlcnkoY29udGFpbmVyRWxlbWVudCwgTkdfVFJJR0dFUl9TRUxFQ1RPUiwgdHJ1ZSk7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIF90aGlzLmRlc3Ryb3lBY3RpdmVBbmltYXRpb25zRm9yRWxlbWVudChlbGVtZW50KTsgfSk7XG4gICAgICAgIGlmICh0aGlzLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLmRyaXZlci5xdWVyeShjb250YWluZXJFbGVtZW50LCBOR19BTklNQVRJTkdfU0VMRUNUT1IsIHRydWUpO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBfdGhpcy5maW5pc2hBY3RpdmVRdWVyaWVkQW5pbWF0aW9uT25FbGVtZW50KGVsZW1lbnQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGVzdHJveUFjdGl2ZUFuaW1hdGlvbnNGb3JFbGVtZW50ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gdGhpcy5wbGF5ZXJzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKHBsYXllcnMpIHtcbiAgICAgICAgICAgIHBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciB3aGVuIGFuIGVsZW1lbnQgaXMgc2V0IGZvciBkZXN0cnVjdGlvbiwgYnV0IGhhc24ndCBzdGFydGVkLlxuICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgc2l0dWF0aW9uIHdlIHdhbnQgdG8gZGVsYXkgdGhlIGRlc3RydWN0aW9uIHVudGlsIHRoZSBmbHVzaCBvY2N1cnNcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IGFueSBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gdGhlIHBsYXllciBhcmUgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIucXVldWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5tYXJrZWRGb3JEZXN0cm95ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGVNYXAgPSB0aGlzLnN0YXRlc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChzdGF0ZU1hcCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RhdGVNYXApLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXJOYW1lKSB7IHJldHVybiBzdGF0ZU1hcFt0cmlnZ2VyTmFtZV0gPSBERUxFVEVEX1NUQVRFX1ZBTFVFOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5maW5pc2hBY3RpdmVRdWVyaWVkQW5pbWF0aW9uT25FbGVtZW50ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXJzID0gdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChwbGF5ZXJzKSB7XG4gICAgICAgICAgICBwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmZpbmlzaCgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS53aGVuUmVuZGVyaW5nRG9uZSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpbWl6ZUdyb3VwUGxheWVyKF90aGlzLnBsYXllcnMpLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucHJvY2Vzc0xlYXZlTm9kZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IC8qKiBAdHlwZSB7P30gKi8gKGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSk7XG4gICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHByZXZlbnQgaXQgZnJvbSByZW1vdmluZyBpdCB0d2ljZVxuICAgICAgICAgICAgZWxlbWVudFtSRU1PVkFMX0ZMQUddID0gTlVMTF9SRU1PVkFMX1NUQVRFO1xuICAgICAgICAgICAgaWYgKGRldGFpbHMubmFtZXNwYWNlSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lJbm5lckFuaW1hdGlvbnMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnMgPSB0aGlzLl9mZXRjaE5hbWVzcGFjZShkZXRhaWxzLm5hbWVzcGFjZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbnMuY2xlYXJFbGVtZW50Q2FjaGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgZGV0YWlscy5zZXRGb3JSZW1vdmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kcml2ZXIubWF0Y2hlc0VsZW1lbnQoZWxlbWVudCwgRElTQUJMRURfU0VMRUNUT1IpKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtFbGVtZW50QXNEaXNhYmxlZChlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcml2ZXIucXVlcnkoZWxlbWVudCwgRElTQUJMRURfU0VMRUNUT1IsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIF90aGlzLm1hcmtFbGVtZW50QXNEaXNhYmxlZChlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gbWljcm90YXNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmZsdXNoID0gLyoqXG4gICAgICogQHBhcmFtIHs/PX0gbWljcm90YXNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChtaWNyb3Rhc2tJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobWljcm90YXNrSWQgPT09IHZvaWQgMCkgeyBtaWNyb3Rhc2tJZCA9IC0xOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMubmV3SG9zdEVsZW1lbnRzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMubmV3SG9zdEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5zLCBlbGVtZW50KSB7IHJldHVybiBfdGhpcy5fYmFsYW5jZU5hbWVzcGFjZUxpc3QobnMsIGVsZW1lbnQpOyB9KTtcbiAgICAgICAgICAgIHRoaXMubmV3SG9zdEVsZW1lbnRzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG90YWxBbmltYXRpb25zICYmIHRoaXMuY29sbGVjdGVkRW50ZXJFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbG0gPSB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWxtLCBTVEFSX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX25hbWVzcGFjZUxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICAodGhpcy50b3RhbFF1ZXVlZFBsYXllcnMgfHwgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsZWFudXBGbnMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGxheWVycyA9IHRoaXMuX2ZsdXNoQW5pbWF0aW9ucyhjbGVhbnVwRm5zLCBtaWNyb3Rhc2tJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgY2xlYW51cEZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwRm5zW2ldKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTGVhdmVOb2RlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxRdWV1ZWRQbGF5ZXJzID0gMDtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9mbHVzaEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgIHRoaXMuX2ZsdXNoRm5zID0gW107XG4gICAgICAgIGlmICh0aGlzLl93aGVuUXVpZXRGbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyB3ZSBtb3ZlIHRoZXNlIG92ZXIgdG8gYSB2YXJpYWJsZSBzbyB0aGF0XG4gICAgICAgICAgICAvLyBpZiBhbnkgbmV3IGNhbGxiYWNrcyBhcmUgcmVnaXN0ZXJlZCBpbiBhbm90aGVyXG4gICAgICAgICAgICAvLyBmbHVzaCB0aGV5IGRvIG5vdCBwb3B1bGF0ZSB0aGUgZXhpc3Rpbmcgc2V0XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWlldEZuc18xID0gdGhpcy5fd2hlblF1aWV0Rm5zO1xuICAgICAgICAgICAgdGhpcy5fd2hlblF1aWV0Rm5zID0gW107XG4gICAgICAgICAgICBpZiAocGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnMpLm9uRG9uZShmdW5jdGlvbiAoKSB7IHF1aWV0Rm5zXzEuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1aWV0Rm5zXzEuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVycm9ycykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcHJvY2VzcyBhbmltYXRpb25zIGR1ZSB0byB0aGUgZm9sbG93aW5nIGZhaWxlZCB0cmlnZ2VyIHRyYW5zaXRpb25zXFxuIFwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2xlYW51cEZuc1xuICAgICAqIEBwYXJhbSB7P30gbWljcm90YXNrSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9mbHVzaEFuaW1hdGlvbnMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGNsZWFudXBGbnNcbiAgICAgKiBAcGFyYW0gez99IG1pY3JvdGFza0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY2xlYW51cEZucywgbWljcm90YXNrSWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ViVGltZWxpbmVzID0gbmV3IEVsZW1lbnRJbnN0cnVjdGlvbk1hcCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBza2lwcGVkUGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBza2lwcGVkUGxheWVyc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVldWVkSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUHJlU3R5bGVFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUG9zdFN0eWxlRWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpc2FibGVkRWxlbWVudHNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBkaXNhYmxlZEVsZW1lbnRzU2V0LmFkZChub2RlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzVGhhdEFyZURpc2FibGVkID0gX3RoaXMuZHJpdmVyLnF1ZXJ5KG5vZGUsIFFVRVVFRF9TRUxFQ1RPUiwgdHJ1ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGlfMSA9IDA7IGlfMSA8IG5vZGVzVGhhdEFyZURpc2FibGVkLmxlbmd0aDsgaV8xKyspIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZEVsZW1lbnRzU2V0LmFkZChub2Rlc1RoYXRBcmVEaXNhYmxlZFtpXzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvZHlOb2RlID0gZ2V0Qm9keU5vZGUoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsVHJpZ2dlckVsZW1lbnRzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlc0J5RWxlbWVudC5rZXlzKCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRlck5vZGVNYXAgPSBidWlsZFJvb3RNYXAoYWxsVHJpZ2dlckVsZW1lbnRzLCB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMpO1xuICAgICAgICAvLyB0aGlzIG11c3Qgb2NjdXIgYmVmb3JlIHRoZSBpbnN0cnVjdGlvbnMgYXJlIGJ1aWx0IGJlbG93IHN1Y2ggdGhhdFxuICAgICAgICAvLyB0aGUgOmVudGVyIHF1ZXJpZXMgbWF0Y2ggdGhlIGVsZW1lbnRzIChzaW5jZSB0aGUgdGltZWxpbmUgcXVlcmllc1xuICAgICAgICAvLyBhcmUgZmlyZWQgZHVyaW5nIGluc3RydWN0aW9uIGJ1aWxkaW5nKS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50ZXJOb2RlTWFwSWRzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDtcbiAgICAgICAgZW50ZXJOb2RlTWFwLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzLCByb290KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc05hbWUgPSBFTlRFUl9DTEFTU05BTUUgKyBpKys7XG4gICAgICAgICAgICBlbnRlck5vZGVNYXBJZHMuc2V0KHJvb3QsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBhZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbExlYXZlTm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVyZ2VkTGVhdmVOb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVhdmVOb2Rlc1dpdGhvdXRBbmltYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGlfMiA9IDA7IGlfMiA8IHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50cy5sZW5ndGg7IGlfMisrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzW2lfMl07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzID0gLyoqIEB0eXBlIHs/fSAqLyAoZWxlbWVudFtSRU1PVkFMX0ZMQUddKTtcbiAgICAgICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbCkge1xuICAgICAgICAgICAgICAgIGFsbExlYXZlTm9kZXMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBtZXJnZWRMZWF2ZU5vZGVzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWlscy5oYXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcml2ZXIucXVlcnkoZWxlbWVudCwgU1RBUl9TRUxFQ1RPUiwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoZWxtKSB7IHJldHVybiBtZXJnZWRMZWF2ZU5vZGVzLmFkZChlbG0pOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlTm9kZXNXaXRob3V0QW5pbWF0aW9ucy5hZGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlYXZlTm9kZU1hcElkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVhdmVOb2RlTWFwID0gYnVpbGRSb290TWFwKGFsbFRyaWdnZXJFbGVtZW50cywgQXJyYXkuZnJvbShtZXJnZWRMZWF2ZU5vZGVzKSk7XG4gICAgICAgIGxlYXZlTm9kZU1hcC5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcywgcm9vdCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NOYW1lID0gTEVBVkVfQ0xBU1NOQU1FICsgaSsrO1xuICAgICAgICAgICAgbGVhdmVOb2RlTWFwSWRzLnNldChyb290LCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhbnVwRm5zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZW50ZXJOb2RlTWFwLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzLCByb290KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NOYW1lID0gLyoqIEB0eXBlIHs/fSAqLyAoKGVudGVyTm9kZU1hcElkcy5nZXQocm9vdCkpKTtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiByZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGVhdmVOb2RlTWFwLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzLCByb290KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NOYW1lID0gLyoqIEB0eXBlIHs/fSAqLyAoKGxlYXZlTm9kZU1hcElkcy5nZXQocm9vdCkpKTtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiByZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWxsTGVhdmVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IF90aGlzLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvbmVvdXNUcmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGlfMyA9IHRoaXMuX25hbWVzcGFjZUxpc3QubGVuZ3RoIC0gMTsgaV8zID49IDA7IGlfMy0tKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IHRoaXMuX25hbWVzcGFjZUxpc3RbaV8zXTtcbiAgICAgICAgICAgIG5zLmRyYWluUXVldWVkVHJhbnNpdGlvbnMobWljcm90YXNrSWQpLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gZW50cnkucGxheWVyO1xuICAgICAgICAgICAgICAgIGFsbFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBlbnRyeS5lbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmICghYm9keU5vZGUgfHwgIV90aGlzLmRyaXZlci5jb250YWluc0VsZW1lbnQoYm9keU5vZGUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVhdmVDbGFzc05hbWUgPSAvKiogQHR5cGUgez99ICovICgobGVhdmVOb2RlTWFwSWRzLmdldChlbGVtZW50KSkpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudGVyQ2xhc3NOYW1lID0gLyoqIEB0eXBlIHs/fSAqLyAoKGVudGVyTm9kZU1hcElkcy5nZXQoZWxlbWVudCkpKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0cnVjdGlvbiA9IC8qKiBAdHlwZSB7P30gKi8gKChfdGhpcy5fYnVpbGRJbnN0cnVjdGlvbihlbnRyeSwgc3ViVGltZWxpbmVzLCBlbnRlckNsYXNzTmFtZSwgbGVhdmVDbGFzc05hbWUpKSk7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLmVycm9ycyAmJiBpbnN0cnVjdGlvbi5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9uZW91c1RyYW5zaXRpb25zLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIGEgdW5tYXRjaGVkIHRyYW5zaXRpb24gaXMgcXVldWVkIHRvIGdvIHRoZW4gaXQgU0hPVUxEIE5PVCByZW5kZXJcbiAgICAgICAgICAgICAgICAvLyBhbiBhbmltYXRpb24gYW5kIGNhbmNlbCB0aGUgcHJldmlvdXNseSBydW5uaW5nIGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmFsbGJhY2tUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5vblN0YXJ0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVyYXNlU3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLmZyb21TdHlsZXMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRTdHlsZXMoZWxlbWVudCwgaW5zdHJ1Y3Rpb24udG9TdHlsZXMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBpZiBhIHBhcmVudCBhbmltYXRpb24gdXNlcyB0aGlzIGFuaW1hdGlvbiBhcyBhIHN1YiB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBpdCB3aWxsIGluc3RydWN0IHRoZSB0aW1lbGluZSBidWlsZGVyIHRvIG5vdCBhZGQgYSBwbGF5ZXIgZGVsYXksIGJ1dFxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgc3RyZXRjaCB0aGUgZmlyc3Qga2V5ZnJhbWUgZ2FwIHVwIHVudGlsIHRoZSBhbmltYXRpb24gc3RhcnRzLiBUaGVcbiAgICAgICAgICAgICAgICAvLyByZWFzb24gdGhpcyBpcyBpbXBvcnRhbnQgaXMgdG8gcHJldmVudCBleHRyYSBpbml0aWFsaXphdGlvbiBzdHlsZXMgZnJvbSBiZWluZ1xuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVkIGJ5IHRoZSB1c2VyIGluIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24udGltZWxpbmVzLmZvckVhY2goZnVuY3Rpb24gKHRsKSB7IHJldHVybiB0bC5zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSA9IHRydWU7IH0pO1xuICAgICAgICAgICAgICAgIHN1YlRpbWVsaW5lcy5hcHBlbmQoZWxlbWVudCwgaW5zdHJ1Y3Rpb24udGltZWxpbmVzKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0dXBsZSA9IHsgaW5zdHJ1Y3Rpb246IGluc3RydWN0aW9uLCBwbGF5ZXI6IHBsYXllciwgZWxlbWVudDogZWxlbWVudCB9O1xuICAgICAgICAgICAgICAgIHF1ZXVlZEluc3RydWN0aW9ucy5wdXNoKHR1cGxlKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5xdWVyaWVkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZ2V0T3JTZXRBc0luTWFwKHF1ZXJpZWRFbGVtZW50cywgZWxlbWVudCwgW10pLnB1c2gocGxheWVyKTsgfSk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24ucHJlU3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJpbmdNYXAsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcHMgPSBPYmplY3Qua2V5cyhzdHJpbmdNYXApO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXRWYWxfMSA9IC8qKiBAdHlwZSB7P30gKi8gKChhbGxQcmVTdHlsZUVsZW1lbnRzLmdldChlbGVtZW50KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXRWYWxfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFByZVN0eWxlRWxlbWVudHMuc2V0KGVsZW1lbnQsIHNldFZhbF8xID0gbmV3IFNldCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHNldFZhbF8xLmFkZChwcm9wKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5wb3N0U3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJpbmdNYXAsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcHMgPSBPYmplY3Qua2V5cyhzdHJpbmdNYXApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXRWYWwgPSAvKiogQHR5cGUgez99ICovICgoYWxsUG9zdFN0eWxlRWxlbWVudHMuZ2V0KGVsZW1lbnQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxQb3N0U3R5bGVFbGVtZW50cy5zZXQoZWxlbWVudCwgc2V0VmFsID0gbmV3IFNldCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBzZXRWYWwuYWRkKHByb3ApOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvbmVvdXNUcmFuc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yc18xID0gW107XG4gICAgICAgICAgICBlcnJvbmVvdXNUcmFuc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgIGVycm9yc18xLnB1c2goXCJAXCIgKyBpbnN0cnVjdGlvbi50cmlnZ2VyTmFtZSArIFwiIGhhcyBmYWlsZWQgZHVlIHRvOlxcblwiKTsgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICgoaW5zdHJ1Y3Rpb24uZXJyb3JzKSkuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGVycm9yc18xLnB1c2goXCItIFwiICsgZXJyb3IgKyBcIlxcblwiKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFsbFBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoZXJyb3JzXzEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFByZXZpb3VzUGxheWVyc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gdGhpcyBtYXAgd29ya3MgdG8gdGVsbCB3aGljaCBlbGVtZW50IGluIHRoZSBET00gdHJlZSBpcyBjb250YWluZWQgYnlcbiAgICAgICAgLy8gd2hpY2ggYW5pbWF0aW9uLiBGdXJ0aGVyIGRvd24gYmVsb3cgdGhpcyBtYXAgd2lsbCBnZXQgcG9wdWxhdGVkIG9uY2VcbiAgICAgICAgLy8gdGhlIHBsYXllcnMgYXJlIGJ1aWx0IGFuZCBpbiBkb2luZyBzbyBpdCBjYW4gZWZmaWNpZW50bHkgZmlndXJlIG91dFxuICAgICAgICAvLyBpZiBhIHN1YiBwbGF5ZXIgaXMgc2tpcHBlZCBkdWUgdG8gYSBwYXJlbnQgcGxheWVyIGhhdmluZyBwcmlvcml0eS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0aW9uRWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgcXVldWVkSW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gZW50cnkuZWxlbWVudDtcbiAgICAgICAgICAgIGlmIChzdWJUaW1lbGluZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRWxlbWVudE1hcC5zZXQoZWxlbWVudCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2JlZm9yZUFuaW1hdGlvbkJ1aWxkKGVudHJ5LnBsYXllci5uYW1lc3BhY2VJZCwgZW50cnkuaW5zdHJ1Y3Rpb24sIGFsbFByZXZpb3VzUGxheWVyc01hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBza2lwcGVkUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSBwbGF5ZXIuZWxlbWVudDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzUGxheWVycyA9IF90aGlzLl9nZXRQcmV2aW91c1BsYXllcnMoZWxlbWVudCwgZmFsc2UsIHBsYXllci5uYW1lc3BhY2VJZCwgcGxheWVyLnRyaWdnZXJOYW1lLCBudWxsKTtcbiAgICAgICAgICAgIHByZXZpb3VzUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2UGxheWVyKSB7XG4gICAgICAgICAgICAgICAgZ2V0T3JTZXRBc0luTWFwKGFsbFByZXZpb3VzUGxheWVyc01hcCwgZWxlbWVudCwgW10pLnB1c2gocHJldlBsYXllcik7XG4gICAgICAgICAgICAgICAgcHJldlBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIG5vZGVzIHRoYXQgd2lsbCBiZSByZW1vdmVkIChlaXRoZXIgYnkpXG4gICAgICAgIC8vIGhhdmluZyB0aGVpciBvd24gbGVhdmUgYW5pbWF0aW9ucyBvciBieSBiZWluZyBxdWVyaWVkIGluIGEgY29udGFpbmVyXG4gICAgICAgIC8vIHRoYXQgd2lsbCBiZSByZW1vdmVkIG9uY2UgYSBwYXJlbnQgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLiBUaGUgaWRlYVxuICAgICAgICAvLyBoZXJlIGlzIHRoYXQgKiBzdHlsZXMgbXVzdCBiZSBpZGVudGljYWwgdG8gISBzdHlsZXMgYmVjYXVzZSBvZlxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoKiBpcyBhbHNvIGZpbGxlZCBpbiBieSBkZWZhdWx0IGluIG1hbnkgcGxhY2VzKS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlICogc3R5bGVzIHdpbGwgcmV0dXJuIGFuIGVtcHR5IHZhbHVlIG9yIGF1dG8gc2luY2UgdGhlIGVsZW1lbnRcbiAgICAgICAgLy8gdGhhdCBpcyBiZWluZyBnZXRDb21wdXRlZFN0eWxlJ2Qgd2lsbCBub3QgYmUgdmlzaWJsZSAoc2luY2UgKiA9IGRlc3RpbmF0aW9uKVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXBsYWNlTm9kZXMgPSBhbGxMZWF2ZU5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VQb3N0U3R5bGVzQXNQcmUobm9kZSwgYWxsUHJlU3R5bGVFbGVtZW50cywgYWxsUG9zdFN0eWxlRWxlbWVudHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUE9TVCBTVEFHRTogZmlsbCB0aGUgKiBzdHlsZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdFN0eWxlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsTGVhdmVRdWVyaWVkTm9kZXMgPSBjbG9ha0FuZENvbXB1dGVTdHlsZXMocG9zdFN0eWxlc01hcCwgdGhpcy5kcml2ZXIsIGxlYXZlTm9kZXNXaXRob3V0QW5pbWF0aW9ucywgYWxsUG9zdFN0eWxlRWxlbWVudHMsIF9hbmd1bGFyX2FuaW1hdGlvbnMuQVVUT19TVFlMRSk7XG4gICAgICAgIGFsbExlYXZlUXVlcmllZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlUG9zdFN0eWxlc0FzUHJlKG5vZGUsIGFsbFByZVN0eWxlRWxlbWVudHMsIGFsbFBvc3RTdHlsZUVsZW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUFJFIFNUQUdFOiBmaWxsIHRoZSAhIHN0eWxlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVTdHlsZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGVudGVyTm9kZU1hcC5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcywgcm9vdCkge1xuICAgICAgICAgICAgY2xvYWtBbmRDb21wdXRlU3R5bGVzKHByZVN0eWxlc01hcCwgX3RoaXMuZHJpdmVyLCBuZXcgU2V0KG5vZGVzKSwgYWxsUHJlU3R5bGVFbGVtZW50cywgX2FuZ3VsYXJfYW5pbWF0aW9ucy7JtVBSRV9TVFlMRSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXBsYWNlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdCA9IHBvc3RTdHlsZXNNYXAuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlID0gcHJlU3R5bGVzTWFwLmdldChub2RlKTtcbiAgICAgICAgICAgIHBvc3RTdHlsZXNNYXAuc2V0KG5vZGUsIC8qKiBAdHlwZSB7P30gKi8gKF9fYXNzaWduKHt9LCBwb3N0LCBwcmUpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290UGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdWJQbGF5ZXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIE5PX1BBUkVOVF9BTklNQVRJT05fRUxFTUVOVF9ERVRFQ1RFRCA9IHt9O1xuICAgICAgICBxdWV1ZWRJbnN0cnVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZW50cnkuZWxlbWVudCwgcGxheWVyID0gZW50cnkucGxheWVyLCBpbnN0cnVjdGlvbiA9IGVudHJ5Lmluc3RydWN0aW9uO1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IGl0IHdhcyBuZXZlciBjb25zdW1lZCBieSBhIHBhcmVudCBhbmltYXRpb24gd2hpY2hcbiAgICAgICAgICAgIC8vIG1lYW5zIHRoYXQgaXQgaXMgaW5kZXBlbmRlbnQgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgc2V0IGZvciBhbmltYXRpb25cbiAgICAgICAgICAgIGlmIChzdWJUaW1lbGluZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkRWxlbWVudHNTZXQuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0U3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWRQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgZmxvdyB1cCB0aGUgRE9NIGFuZCBxdWVyeSB0aGUgbWFwIHRvIGZpZ3VyZSBvdXRcbiAgICAgICAgICAgICAgICAvLyBpZiBhIHBhcmVudCBhbmltYXRpb24gaGFzIHByaW9yaXR5IG92ZXIgaXQuIEluIHRoZSBzaXR1YXRpb25cbiAgICAgICAgICAgICAgICAvLyB0aGF0IGEgcGFyZW50IGlzIGRldGVjdGVkIHRoZW4gaXQgd2lsbCBjYW5jZWwgdGhlIGxvb3AuIElmXG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyBpcyBkZXRlY3RlZCwgb3IgaXQgdGFrZXMgYSBmZXcgaG9wcyB0byBmaW5kIGEgcGFyZW50LFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gaXQgd2lsbCBmaWxsIGluIHRoZSBtaXNzaW5nIG5vZGVzIGFuZCBzaWduYWwgdGhlbSBhcyBoYXZpbmdcbiAgICAgICAgICAgICAgICAvLyBhIGRldGVjdGVkIHBhcmVudCAob3IgYSBOT19QQVJFTlQgdmFsdWUgdmlhIGEgc3BlY2lhbCBjb25zdGFudCkuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50V2l0aEFuaW1hdGlvbl8xID0gTk9fUEFSRU5UX0FOSU1BVElPTl9FTEVNRU5UX0RFVEVDVEVEO1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25FbGVtZW50TWFwLnNpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsbSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudHNUb0FkZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWxtID0gZWxtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGVjdGVkUGFyZW50ID0gYW5pbWF0aW9uRWxlbWVudE1hcC5nZXQoZWxtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXRlY3RlZFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFdpdGhBbmltYXRpb25fMSA9IGRldGVjdGVkUGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50c1RvQWRkLnB1c2goZWxtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzVG9BZGQuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50KSB7IHJldHVybiBhbmltYXRpb25FbGVtZW50TWFwLnNldChwYXJlbnQsIHBhcmVudFdpdGhBbmltYXRpb25fMSk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclBsYXllciA9IF90aGlzLl9idWlsZEFuaW1hdGlvbihwbGF5ZXIubmFtZXNwYWNlSWQsIGluc3RydWN0aW9uLCBhbGxQcmV2aW91c1BsYXllcnNNYXAsIHNraXBwZWRQbGF5ZXJzTWFwLCBwcmVTdHlsZXNNYXAsIHBvc3RTdHlsZXNNYXApO1xuICAgICAgICAgICAgICAgIHBsYXllci5zZXRSZWFsUGxheWVyKGlubmVyUGxheWVyKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50V2l0aEFuaW1hdGlvbl8xID09PSBOT19QQVJFTlRfQU5JTUFUSU9OX0VMRU1FTlRfREVURUNURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50UGxheWVycyA9IF90aGlzLnBsYXllcnNCeUVsZW1lbnQuZ2V0KHBhcmVudFdpdGhBbmltYXRpb25fMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRQbGF5ZXJzICYmIHBhcmVudFBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXIucGFyZW50UGxheWVyID0gb3B0aW1pemVHcm91cFBsYXllcihwYXJlbnRQbGF5ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJhc2VTdHlsZXMoZWxlbWVudCwgaW5zdHJ1Y3Rpb24uZnJvbVN0eWxlcyk7XG4gICAgICAgICAgICAgICAgcGxheWVyLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRTdHlsZXMoZWxlbWVudCwgaW5zdHJ1Y3Rpb24udG9TdHlsZXMpOyB9KTtcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBzdGlsbCBtaWdodCBiZSBhIGFuY2VzdG9yIHBsYXllciBhbmltYXRpbmcgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgdGhlcmVmb3JlIHdlIHdpbGwgc3RpbGwgYWRkIGl0IGFzIGEgc3ViIHBsYXllclxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXRzIGFuaW1hdGlvbiBtYXkgYmUgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICBzdWJQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZWRFbGVtZW50c1NldC5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGZpbmQgYWxsIG9mIHRoZSBzdWIgcGxheWVycycgY29ycmVzcG9uZGluZyBpbm5lciBhbmltYXRpb24gcGxheWVyXG4gICAgICAgIHN1YlBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAvLyBldmVuIGlmIGFueSBwbGF5ZXJzIGFyZSBub3QgZm91bmQgZm9yIGEgc3ViIGFuaW1hdGlvbiB0aGVuIGl0XG4gICAgICAgICAgICAvLyB3aWxsIHN0aWxsIGNvbXBsZXRlIGl0c2VsZiBhZnRlciB0aGUgbmV4dCB0aWNrIHNpbmNlIGl0J3MgTm9vcFxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyc0ZvckVsZW1lbnQgPSBza2lwcGVkUGxheWVyc01hcC5nZXQocGxheWVyLmVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHBsYXllcnNGb3JFbGVtZW50ICYmIHBsYXllcnNGb3JFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyUGxheWVyID0gb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzRm9yRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcGxheWVyLnNldFJlYWxQbGF5ZXIoaW5uZXJQbGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3QgYWN0dWFsbHkgcGxheSB0aGUgYW5pbWF0aW9uIGlzXG4gICAgICAgIC8vIGJlY2F1c2UgYWxsIHRoYXQgYSBza2lwcGVkIHBsYXllciBpcyBkZXNpZ25lZCB0byBkbyBpcyB0b1xuICAgICAgICAvLyBmaXJlIHRoZSBzdGFydC9kb25lIHRyYW5zaXRpb24gY2FsbGJhY2sgZXZlbnRzXG4gICAgICAgIHNraXBwZWRQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgaWYgKHBsYXllci5wYXJlbnRQbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuc3luY1BsYXllckV2ZW50cyhwbGF5ZXIucGFyZW50UGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBydW4gdGhyb3VnaCBhbGwgb2YgdGhlIHF1ZXVlZCByZW1vdmFscyBhbmQgc2VlIGlmIHRoZXlcbiAgICAgICAgLy8gd2VyZSBwaWNrZWQgdXAgYnkgYSBxdWVyeS4gSWYgbm90IHRoZW4gcGVyZm9ybSB0aGUgcmVtb3ZhbFxuICAgICAgICAvLyBvcGVyYXRpb24gcmlnaHQgYXdheSB1bmxlc3MgYSBwYXJlbnQgYW5pbWF0aW9uIGlzIG9uZ29pbmcuXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaV80ID0gMDsgaV80IDwgYWxsTGVhdmVOb2Rlcy5sZW5ndGg7IGlfNCsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gYWxsTGVhdmVOb2Rlc1tpXzRdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IC8qKiBAdHlwZSB7P30gKi8gKGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBMRUFWRV9DTEFTU05BTUUpO1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGUgZWxlbWVudCBoYXMgYSByZW1vdmFsIGFuaW1hdGlvbiB0aGF0IGlzIGJlaW5nXG4gICAgICAgICAgICAvLyB0YWtlbiBjYXJlIG9mIGFuZCB0aGVyZWZvcmUgdGhlIGlubmVyIGVsZW1lbnRzIHdpbGwgaGFuZyBhcm91bmRcbiAgICAgICAgICAgIC8vIHVudGlsIHRoYXQgYW5pbWF0aW9uIGlzIG92ZXIgKG9yIHRoZSBwYXJlbnQgcXVlcmllZCBhbmltYXRpb24pXG4gICAgICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLmhhc0FuaW1hdGlvbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBbXTtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZWxlbWVudCBpcyBxdWVyaWVkIG9yIGlmIGl0IGNvbnRhaW5zIHF1ZXJpZWQgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoZW4gd2Ugd2FudCBmb3IgdGhlIGVsZW1lbnQgbm90IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgcGFnZVxuICAgICAgICAgICAgLy8gdW50aWwgdGhlIHF1ZXJpZWQgYW5pbWF0aW9ucyBoYXZlIGZpbmlzaGVkXG4gICAgICAgICAgICBpZiAocXVlcmllZEVsZW1lbnRzLnNpemUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkUGxheWVyUmVzdWx0cyA9IHF1ZXJpZWRFbGVtZW50cy5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJpZWRQbGF5ZXJSZXN1bHRzICYmIHF1ZXJpZWRQbGF5ZXJSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzLnB1c2guYXBwbHkocGxheWVycywgcXVlcmllZFBsYXllclJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVkSW5uZXJFbGVtZW50cyA9IHRoaXMuZHJpdmVyLnF1ZXJ5KGVsZW1lbnQsIE5HX0FOSU1BVElOR19TRUxFQ1RPUiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IHF1ZXJpZWRJbm5lckVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRQbGF5ZXJzID0gcXVlcmllZEVsZW1lbnRzLmdldChxdWVyaWVkSW5uZXJFbGVtZW50c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWVyaWVkUGxheWVycyAmJiBxdWVyaWVkUGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaC5hcHBseShwbGF5ZXJzLCBxdWVyaWVkUGxheWVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhY3RpdmVQbGF5ZXJzID0gcGxheWVycy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuICFwLmRlc3Ryb3llZDsgfSk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlUGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2Rlc0FmdGVyQW5pbWF0aW9uRG9uZSh0aGlzLCBlbGVtZW50LCBhY3RpdmVQbGF5ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIHNvIHRoZSBjbGVhbnVwIG1ldGhvZCBkb2Vzbid0IHJlbW92ZSB0aGVtXG4gICAgICAgIGFsbExlYXZlTm9kZXMubGVuZ3RoID0gMDtcbiAgICAgICAgcm9vdFBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICBfdGhpcy5wbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgIHBsYXllci5vbkRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBfdGhpcy5wbGF5ZXJzLmluZGV4T2YocGxheWVyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wbGF5ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBsYXllci5wbGF5KCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcm9vdFBsYXllcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5lbGVtZW50Q29udGFpbnNEYXRhID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5zRGF0YSA9IGZhbHNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzID0gLyoqIEB0eXBlIHs/fSAqLyAoZWxlbWVudFtSRU1PVkFMX0ZMQUddKTtcbiAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5zZXRGb3JSZW1vdmFsKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucGxheWVyc0J5RWxlbWVudC5oYXMoZWxlbWVudCkpXG4gICAgICAgICAgICBjb250YWluc0RhdGEgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5oYXMoZWxlbWVudCkpXG4gICAgICAgICAgICBjb250YWluc0RhdGEgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZXNCeUVsZW1lbnQuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKS5lbGVtZW50Q29udGFpbnNEYXRhKGVsZW1lbnQpIHx8IGNvbnRhaW5zRGF0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLmFmdGVyRmx1c2ggPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHsgdGhpcy5fZmx1c2hGbnMucHVzaChjYWxsYmFjayk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuYWZ0ZXJGbHVzaEFuaW1hdGlvbnNEb25lID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX3doZW5RdWlldEZucy5wdXNoKGNhbGxiYWNrKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGlzUXVlcmllZEVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7Pz19IHRyaWdnZXJOYW1lXG4gICAgICogQHBhcmFtIHs/PX0gdG9TdGF0ZVZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5fZ2V0UHJldmlvdXNQbGF5ZXJzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBpc1F1ZXJpZWRFbGVtZW50XG4gICAgICogQHBhcmFtIHs/PX0gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez89fSB0cmlnZ2VyTmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHRvU3RhdGVWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIGlzUXVlcmllZEVsZW1lbnQsIG5hbWVzcGFjZUlkLCB0cmlnZ2VyTmFtZSwgdG9TdGF0ZVZhbHVlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnMgPSBbXTtcbiAgICAgICAgaWYgKGlzUXVlcmllZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZWRFbGVtZW50UGxheWVycyA9IHRoaXMucGxheWVyc0J5UXVlcmllZEVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHF1ZXJpZWRFbGVtZW50UGxheWVycykge1xuICAgICAgICAgICAgICAgIHBsYXllcnMgPSBxdWVyaWVkRWxlbWVudFBsYXllcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50UGxheWVycyA9IHRoaXMucGxheWVyc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1JlbW92YWxBbmltYXRpb25fMSA9ICF0b1N0YXRlVmFsdWUgfHwgdG9TdGF0ZVZhbHVlID09IFZPSURfVkFMVUU7XG4gICAgICAgICAgICAgICAgZWxlbWVudFBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIucXVldWVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVtb3ZhbEFuaW1hdGlvbl8xICYmIHBsYXllci50cmlnZ2VyTmFtZSAhPSB0cmlnZ2VyTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzcGFjZUlkIHx8IHRyaWdnZXJOYW1lKSB7XG4gICAgICAgICAgICBwbGF5ZXJzID0gcGxheWVycy5maWx0ZXIoZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lc3BhY2VJZCAmJiBuYW1lc3BhY2VJZCAhPSBwbGF5ZXIubmFtZXNwYWNlSWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlck5hbWUgJiYgdHJpZ2dlck5hbWUgIT0gcGxheWVyLnRyaWdnZXJOYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxheWVycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBhbGxQcmV2aW91c1BsYXllcnNNYXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUucHJvdG90eXBlLl9iZWZvcmVBbmltYXRpb25CdWlsZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBhbGxQcmV2aW91c1BsYXllcnNNYXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgaW5zdHJ1Y3Rpb24sIGFsbFByZXZpb3VzUGxheWVyc01hcCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyTmFtZSA9IGluc3RydWN0aW9uLnRyaWdnZXJOYW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290RWxlbWVudCA9IGluc3RydWN0aW9uLmVsZW1lbnQ7XG4gICAgICAgIC8vIHdoZW4gYSByZW1vdmFsIGFuaW1hdGlvbiBvY2N1cnMsIEFMTCBwcmV2aW91cyBwbGF5ZXJzIGFyZSBjb2xsZWN0ZWRcbiAgICAgICAgLy8gYW5kIGRlc3Ryb3llZCAoZXZlbiBpZiB0aGV5IGFyZSBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IG5hbWVzcGFjZSlcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFyZ2V0TmFtZVNwYWNlSWQgPSBpbnN0cnVjdGlvbi5pc1JlbW92YWxUcmFuc2l0aW9uID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlSWQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldFRyaWdnZXJOYW1lID0gaW5zdHJ1Y3Rpb24uaXNSZW1vdmFsVHJhbnNpdGlvbiA/IHVuZGVmaW5lZCA6IHRyaWdnZXJOYW1lO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh0aW1lbGluZUluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50ID0gdGltZWxpbmVJbnN0cnVjdGlvbi5lbGVtZW50O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNRdWVyaWVkRWxlbWVudCA9IGVsZW1lbnQgIT09IHJvb3RFbGVtZW50O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVycyA9IGdldE9yU2V0QXNJbk1hcChhbGxQcmV2aW91c1BsYXllcnNNYXAsIGVsZW1lbnQsIFtdKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzUGxheWVycyA9IHRoaXNfMS5fZ2V0UHJldmlvdXNQbGF5ZXJzKGVsZW1lbnQsIGlzUXVlcmllZEVsZW1lbnQsIHRhcmdldE5hbWVTcGFjZUlkLCB0YXJnZXRUcmlnZ2VyTmFtZSwgaW5zdHJ1Y3Rpb24udG9TdGF0ZSk7XG4gICAgICAgICAgICBwcmV2aW91c1BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVhbFBsYXllciA9IC8qKiBAdHlwZSB7P30gKi8gKHBsYXllci5nZXRSZWFsUGxheWVyKCkpO1xuICAgICAgICAgICAgICAgIGlmIChyZWFsUGxheWVyLmJlZm9yZURlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbFBsYXllci5iZWZvcmVEZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBpbnN0cnVjdGlvbi50aW1lbGluZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGltZWxpbmVJbnN0cnVjdGlvbiA9IF9hW19pXTtcbiAgICAgICAgICAgIF9sb29wXzEodGltZWxpbmVJbnN0cnVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBuZWVkcyB0byBiZSBkb25lIHNvIHRoYXQgdGhlIFBSRS9QT1NUIHN0eWxlcyBjYW4gYmVcbiAgICAgICAgLy8gY29tcHV0ZWQgcHJvcGVybHkgd2l0aG91dCBpbnRlcmZlcmluZyB3aXRoIHRoZSBwcmV2aW91cyBhbmltYXRpb25cbiAgICAgICAgZXJhc2VTdHlsZXMocm9vdEVsZW1lbnQsIGluc3RydWN0aW9uLmZyb21TdHlsZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25cbiAgICAgKiBAcGFyYW0gez99IGFsbFByZXZpb3VzUGxheWVyc01hcFxuICAgICAqIEBwYXJhbSB7P30gc2tpcHBlZFBsYXllcnNNYXBcbiAgICAgKiBAcGFyYW0gez99IHByZVN0eWxlc01hcFxuICAgICAqIEBwYXJhbSB7P30gcG9zdFN0eWxlc01hcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2J1aWxkQW5pbWF0aW9uID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gaW5zdHJ1Y3Rpb25cbiAgICAgKiBAcGFyYW0gez99IGFsbFByZXZpb3VzUGxheWVyc01hcFxuICAgICAqIEBwYXJhbSB7P30gc2tpcHBlZFBsYXllcnNNYXBcbiAgICAgKiBAcGFyYW0gez99IHByZVN0eWxlc01hcFxuICAgICAqIEBwYXJhbSB7P30gcG9zdFN0eWxlc01hcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBpbnN0cnVjdGlvbiwgYWxsUHJldmlvdXNQbGF5ZXJzTWFwLCBza2lwcGVkUGxheWVyc01hcCwgcHJlU3R5bGVzTWFwLCBwb3N0U3R5bGVzTWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyaWdnZXJOYW1lID0gaW5zdHJ1Y3Rpb24udHJpZ2dlck5hbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3RFbGVtZW50ID0gaW5zdHJ1Y3Rpb24uZWxlbWVudDtcbiAgICAgICAgLy8gd2UgZmlyc3QgcnVuIHRoaXMgc28gdGhhdCB0aGUgcHJldmlvdXMgYW5pbWF0aW9uIHBsYXllclxuICAgICAgICAvLyBkYXRhIGNhbiBiZSBwYXNzZWQgaW50byB0aGUgc3VjY2Vzc2l2ZSBhbmltYXRpb24gcGxheWVyc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxRdWVyaWVkUGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxDb25zdW1lZEVsZW1lbnRzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxTdWJFbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsTmV3UGxheWVycyA9IGluc3RydWN0aW9uLnRpbWVsaW5lcy5tYXAoZnVuY3Rpb24gKHRpbWVsaW5lSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnQgPSB0aW1lbGluZUluc3RydWN0aW9uLmVsZW1lbnQ7XG4gICAgICAgICAgICBhbGxDb25zdW1lZEVsZW1lbnRzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgIC8vIEZJWE1FIChtYXRza28pOiBtYWtlIHN1cmUgdG8tYmUtcmVtb3ZlZCBhbmltYXRpb25zIGFyZSByZW1vdmVkIHByb3Blcmx5XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXRhaWxzID0gZWxlbWVudFtSRU1PVkFMX0ZMQUddO1xuICAgICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5yZW1vdmVkQmVmb3JlUXVlcmllZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2FuaW1hdGlvbnMuTm9vcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNRdWVyaWVkRWxlbWVudCA9IGVsZW1lbnQgIT09IHJvb3RFbGVtZW50O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNQbGF5ZXJzID0gZmxhdHRlbkdyb3VwUGxheWVycygoYWxsUHJldmlvdXNQbGF5ZXJzTWFwLmdldChlbGVtZW50KSB8fCBFTVBUWV9QTEFZRVJfQVJSQVkpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5nZXRSZWFsUGxheWVyKCk7IH0pKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgYGVsZW1lbnRgIGlzIG5vdCBhcGFydCBvZiB0aGUgQW5pbWF0aW9uUGxheWVyIGRlZmluaXRpb24sIGJ1dFxuICAgICAgICAgICAgICAgIC8vIE1vY2svV2ViQW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgZWxlbWVudCB3aXRoaW4gdGhlaXIgaW1wbGVtZW50YXRpb24uIFRoaXMgd2lsbCBiZSBhZGRlZCBpbiBBbmd1bGFyNSB0b1xuICAgICAgICAgICAgICAgIC8vIEFuaW1hdGlvblBsYXllclxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBwID0gLyoqIEB0eXBlIHs/fSAqLyAocCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBwLmVsZW1lbnQgPyBwcC5lbGVtZW50ID09PSBlbGVtZW50IDogZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0eWxlcyA9IHByZVN0eWxlc01hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3N0U3R5bGVzID0gcG9zdFN0eWxlc01hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlmcmFtZXMgPSBub3JtYWxpemVLZXlmcmFtZXMoX3RoaXMuZHJpdmVyLCBfdGhpcy5fbm9ybWFsaXplciwgZWxlbWVudCwgdGltZWxpbmVJbnN0cnVjdGlvbi5rZXlmcmFtZXMsIHByZVN0eWxlcywgcG9zdFN0eWxlcyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSBfdGhpcy5fYnVpbGRQbGF5ZXIodGltZWxpbmVJbnN0cnVjdGlvbiwga2V5ZnJhbWVzLCBwcmV2aW91c1BsYXllcnMpO1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoaXMgcGFydGljdWxhciBwbGF5ZXIgYmVsb25ncyB0byBhIHN1YiB0cmlnZ2VyLiBJdCBpc1xuICAgICAgICAgICAgLy8gaW1wb3J0YW50IHRoYXQgd2UgbWF0Y2ggdGhpcyBwbGF5ZXIgdXAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyAoQHRyaWdnZXIubGlzdGVuZXIpXG4gICAgICAgICAgICBpZiAodGltZWxpbmVJbnN0cnVjdGlvbi5zdWJUaW1lbGluZSAmJiBza2lwcGVkUGxheWVyc01hcCkge1xuICAgICAgICAgICAgICAgIGFsbFN1YkVsZW1lbnRzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1F1ZXJpZWRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd3JhcHBlZFBsYXllciA9IG5ldyBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyKG5hbWVzcGFjZUlkLCB0cmlnZ2VyTmFtZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgd3JhcHBlZFBsYXllci5zZXRSZWFsUGxheWVyKHBsYXllcik7XG4gICAgICAgICAgICAgICAgYWxsUXVlcmllZFBsYXllcnMucHVzaCh3cmFwcGVkUGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgICAgIH0pO1xuICAgICAgICBhbGxRdWVyaWVkUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIGdldE9yU2V0QXNJbk1hcChfdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudCwgcGxheWVyLmVsZW1lbnQsIFtdKS5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGV0ZU9yVW5zZXRJbk1hcChfdGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudCwgcGxheWVyLmVsZW1lbnQsIHBsYXllcik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsQ29uc3VtZWRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBhZGRDbGFzcyhlbGVtZW50LCBOR19BTklNQVRJTkdfQ0xBU1NOQU1FKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIoYWxsTmV3UGxheWVycyk7XG4gICAgICAgIHBsYXllci5vbkRlc3Ryb3koZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWxsQ29uc3VtZWRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiByZW1vdmVDbGFzcyhlbGVtZW50LCBOR19BTklNQVRJTkdfQ0xBU1NOQU1FKTsgfSk7XG4gICAgICAgICAgICBzZXRTdHlsZXMocm9vdEVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMgYmFzaWNhbGx5IG1ha2VzIGFsbCBvZiB0aGUgY2FsbGJhY2tzIGZvciBzdWIgZWxlbWVudCBhbmltYXRpb25zXG4gICAgICAgIC8vIGJlIGRlcGVuZGVudCBvbiB0aGUgdXBwZXIgcGxheWVycyBmb3Igd2hlbiB0aGV5IGZpbmlzaFxuICAgICAgICBhbGxTdWJFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IGdldE9yU2V0QXNJbk1hcChza2lwcGVkUGxheWVyc01hcCwgZWxlbWVudCwgW10pLnB1c2gocGxheWVyKTsgfSk7XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGluc3RydWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IHByZXZpb3VzUGxheWVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuX2J1aWxkUGxheWVyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnN0cnVjdGlvblxuICAgICAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXG4gICAgICogQHBhcmFtIHs/fSBwcmV2aW91c1BsYXllcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwga2V5ZnJhbWVzLCBwcmV2aW91c1BsYXllcnMpIHtcbiAgICAgICAgaWYgKGtleWZyYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcml2ZXIuYW5pbWF0ZShpbnN0cnVjdGlvbi5lbGVtZW50LCBrZXlmcmFtZXMsIGluc3RydWN0aW9uLmR1cmF0aW9uLCBpbnN0cnVjdGlvbi5kZWxheSwgaW5zdHJ1Y3Rpb24uZWFzaW5nLCBwcmV2aW91c1BsYXllcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igd2hlbiBhbiBlbXB0eSB0cmFuc2l0aW9ufGRlZmluaXRpb24gaXMgcHJvdmlkZWRcbiAgICAgICAgLy8gLi4uIHRoZXJlIGlzIG5vIHBvaW50IGluIHJlbmRlcmluZyBhbiBlbXB0eSBhbmltYXRpb25cbiAgICAgICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9hbmltYXRpb25zLk5vb3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lO1xufSgpKTtcbnZhciBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIobmFtZXNwYWNlSWQsIHRyaWdnZXJOYW1lLCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlSWQgPSBuYW1lc3BhY2VJZDtcbiAgICAgICAgdGhpcy50cmlnZ2VyTmFtZSA9IHRyaWdnZXJOYW1lO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLl9wbGF5ZXIgPSBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9ucy5Ob29wQW5pbWF0aW9uUGxheWVyKCk7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5zUmVhbFBsYXllciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9xdWV1ZWRDYWxsYmFja3MgPSB7fTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JEZXN0cm95ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucXVldWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwbGF5ZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnNldFJlYWxQbGF5ZXIgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHBsYXllclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fY29udGFpbnNSZWFsUGxheWVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9wbGF5ZXIgPSBwbGF5ZXI7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlZENhbGxiYWNrcykuZm9yRWFjaChmdW5jdGlvbiAocGhhc2UpIHtcbiAgICAgICAgICAgIF90aGlzLl9xdWV1ZWRDYWxsYmFja3NbcGhhc2VdLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBsaXN0ZW5PblBsYXllcihwbGF5ZXIsIHBoYXNlLCB1bmRlZmluZWQsIGNhbGxiYWNrKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9xdWV1ZWRDYWxsYmFja3MgPSB7fTtcbiAgICAgICAgdGhpcy5fY29udGFpbnNSZWFsUGxheWVyID0gdHJ1ZTtcbiAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMpKS5xdWV1ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZ2V0UmVhbFBsYXllciA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGxheWVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5zeW5jUGxheWVyRXZlbnRzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwbGF5ZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcCA9IC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuX3BsYXllcik7XG4gICAgICAgIGlmIChwLnRyaWdnZXJDYWxsYmFjaykge1xuICAgICAgICAgICAgcGxheWVyLm9uU3RhcnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gcC50cmlnZ2VyQ2FsbGJhY2soJ3N0YXJ0Jyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHBsYXllci5vbkRvbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZmluaXNoKCk7IH0pO1xuICAgICAgICBwbGF5ZXIub25EZXN0cm95KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRlc3Ryb3koKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5fcXVldWVFdmVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBnZXRPclNldEFzSW5NYXAodGhpcy5fcXVldWVkQ2FsbGJhY2tzLCBuYW1lLCBbXSkucHVzaChjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMucXVldWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZUV2ZW50KCdkb25lJywgZm4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXllci5vbkRvbmUoZm4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25TdGFydCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlRXZlbnQoJ3N0YXJ0JywgZm4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXllci5vblN0YXJ0KGZuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uRGVzdHJveSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlRXZlbnQoJ2Rlc3Ryb3knLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxheWVyLm9uRGVzdHJveShmbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmluaXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVyLmluaXQoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucXVldWVkID8gZmFsc2UgOiB0aGlzLl9wbGF5ZXIuaGFzU3RhcnRlZCgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGxheSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyAhdGhpcy5xdWV1ZWQgJiYgdGhpcy5fcGxheWVyLnBsYXkoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7ICF0aGlzLnF1ZXVlZCAmJiB0aGlzLl9wbGF5ZXIucGF1c2UoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgIXRoaXMucXVldWVkICYmIHRoaXMuX3BsYXllci5yZXN0YXJ0KCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVyLmZpbmlzaCgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcykpLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BsYXllci5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7ICF0aGlzLnF1ZXVlZCAmJiB0aGlzLl9wbGF5ZXIucmVzZXQoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocCkge1xuICAgICAgICBpZiAoIXRoaXMucXVldWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIuc2V0UG9zaXRpb24ocCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucXVldWVkID8gMCA6IHRoaXMuX3BsYXllci5nZXRQb3NpdGlvbigpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZSwgXCJ0b3RhbFRpbWVcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyLnRvdGFsVGltZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyogQGludGVybmFsICovXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaGFzZU5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25BbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnRyaWdnZXJDYWxsYmFjayA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhhc2VOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGhhc2VOYW1lKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHAgPSAvKiogQHR5cGUgez99ICovICh0aGlzLl9wbGF5ZXIpO1xuICAgICAgICBpZiAocC50cmlnZ2VyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHAudHJpZ2dlckNhbGxiYWNrKHBoYXNlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtYXBcbiAqIEBwYXJhbSB7P30ga2V5XG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZWxldGVPclVuc2V0SW5NYXAobWFwLCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudFZhbHVlcztcbiAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGN1cnJlbnRWYWx1ZXMgPSBtYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IGN1cnJlbnRWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBtYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN1cnJlbnRWYWx1ZXMgPSBtYXBba2V5XTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gY3VycmVudFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFZhbHVlcztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVHJpZ2dlclZhbHVlKHZhbHVlKSB7XG4gICAgLy8gd2UgdXNlIGAhPSBudWxsYCBoZXJlIGJlY2F1c2UgaXQncyB0aGUgbW9zdCBzaW1wbGVcbiAgICAvLyB3YXkgdG8gdGVzdCBhZ2FpbnN0IGEgXCJmYWxzeVwiIHZhbHVlIHdpdGhvdXQgbWl4aW5nXG4gICAgLy8gaW4gZW1wdHkgc3RyaW5ncyBvciBhIHplcm8gdmFsdWUuIERPIE5PVCBPUFRJTUlaRS5cbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogbnVsbDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlWydub2RlVHlwZSddID09PSAxO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNUcmlnZ2VyRXZlbnRWYWxpZChldmVudE5hbWUpIHtcbiAgICByZXR1cm4gZXZlbnROYW1lID09ICdzdGFydCcgfHwgZXZlbnROYW1lID09ICdkb25lJztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez89fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2xvYWtFbGVtZW50KGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkVmFsdWUgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogJ25vbmUnO1xuICAgIHJldHVybiBvbGRWYWx1ZTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZXNNYXBcbiAqIEBwYXJhbSB7P30gZHJpdmVyXG4gKiBAcGFyYW0gez99IGVsZW1lbnRzXG4gKiBAcGFyYW0gez99IGVsZW1lbnRQcm9wc01hcFxuICogQHBhcmFtIHs/fSBkZWZhdWx0U3R5bGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNsb2FrQW5kQ29tcHV0ZVN0eWxlcyh2YWx1ZXNNYXAsIGRyaXZlciwgZWxlbWVudHMsIGVsZW1lbnRQcm9wc01hcCwgZGVmYXVsdFN0eWxlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvYWtWYWxzID0gW107XG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gY2xvYWtWYWxzLnB1c2goY2xvYWtFbGVtZW50KGVsZW1lbnQpKTsgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmFpbGVkRWxlbWVudHMgPSBbXTtcbiAgICBlbGVtZW50UHJvcHNNYXAuZm9yRWFjaChmdW5jdGlvbiAocHJvcHMsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0ge307XG4gICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gc3R5bGVzW3Byb3BdID0gZHJpdmVyLmNvbXB1dGVTdHlsZShlbGVtZW50LCBwcm9wLCBkZWZhdWx0U3R5bGUpO1xuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gZWFzeSB3YXkgdG8gZGV0ZWN0IHRoaXMgYmVjYXVzZSBhIHN1YiBlbGVtZW50IGNvdWxkIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIC8vIGJ5IGEgcGFyZW50IGFuaW1hdGlvbiBlbGVtZW50IGJlaW5nIGRldGFjaGVkLlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbUkVNT1ZBTF9GTEFHXSA9IE5VTExfUkVNT1ZFRF9RVUVSSUVEX1NUQVRFO1xuICAgICAgICAgICAgICAgIGZhaWxlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YWx1ZXNNYXAuc2V0KGVsZW1lbnQsIHN0eWxlcyk7XG4gICAgfSk7XG4gICAgLy8gd2UgdXNlIGEgaW5kZXggdmFyaWFibGUgaGVyZSBzaW5jZSBTZXQuZm9yRWFjaChhLCBpKSBkb2VzIG5vdCByZXR1cm5cbiAgICAvLyBhbiBpbmRleCB2YWx1ZSBmb3IgdGhlIGNsb3N1cmUgKGJ1dCBpbnN0ZWFkIGp1c3QgdGhlIHZhbHVlKVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwO1xuICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGNsb2FrRWxlbWVudChlbGVtZW50LCBjbG9ha1ZhbHNbaSsrXSk7IH0pO1xuICAgIHJldHVybiBmYWlsZWRFbGVtZW50cztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSByb290c1xuICogQHBhcmFtIHs/fSBub2Rlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYnVpbGRSb290TWFwKHJvb3RzLCBub2Rlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3RNYXAgPSBuZXcgTWFwKCk7XG4gICAgcm9vdHMuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkgeyByZXR1cm4gcm9vdE1hcC5zZXQocm9vdCwgW10pOyB9KTtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiByb290TWFwO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIE5VTExfTk9ERSA9IDE7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZVNldCA9IG5ldyBTZXQobm9kZXMpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvY2FsUm9vdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gTlVMTF9OT0RFO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290ID0gbG9jYWxSb290TWFwLmdldChub2RlKTtcbiAgICAgICAgaWYgKHJvb3QpXG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocm9vdE1hcC5oYXMocGFyZW50KSkge1xuICAgICAgICAgICAgLy8gbmdJZiBpbnNpZGUgQHRyaWdnZXJcbiAgICAgICAgICAgIHJvb3QgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZVNldC5oYXMocGFyZW50KSkge1xuICAgICAgICAgICAgLy8gbmdJZiBpbnNpZGUgbmdJZlxuICAgICAgICAgICAgcm9vdCA9IE5VTExfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlY3Vyc2UgdXB3YXJkc1xuICAgICAgICAgICAgcm9vdCA9IGdldFJvb3QocGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBsb2NhbFJvb3RNYXAuc2V0KG5vZGUsIHJvb3QpO1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290ID0gZ2V0Um9vdChub2RlKTtcbiAgICAgICAgaWYgKHJvb3QgIT09IE5VTExfTk9ERSkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqLyAoKHJvb3RNYXAuZ2V0KHJvb3QpKSkucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByb290TWFwO1xufVxudmFyIENMQVNTRVNfQ0FDSEVfS0VZID0gJyQkY2xhc3Nlcyc7XG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBjbGFzc05hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzZXMgPSBlbGVtZW50W0NMQVNTRVNfQ0FDSEVfS0VZXTtcbiAgICAgICAgaWYgKCFjbGFzc2VzKSB7XG4gICAgICAgICAgICBjbGFzc2VzID0gZWxlbWVudFtDTEFTU0VTX0NBQ0hFX0tFWV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc2VzW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcGFyYW0gez99IGNsYXNzTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NlcyA9IGVsZW1lbnRbQ0xBU1NFU19DQUNIRV9LRVldO1xuICAgICAgICBpZiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgZGVsZXRlIGNsYXNzZXNbY2xhc3NOYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbmdpbmVcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBwbGF5ZXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZW1vdmVOb2Rlc0FmdGVyQW5pbWF0aW9uRG9uZShlbmdpbmUsIGVsZW1lbnQsIHBsYXllcnMpIHtcbiAgICBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnMpLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBlbmdpbmUucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KTsgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcGxheWVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkdyb3VwUGxheWVycyhwbGF5ZXJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmluYWxQbGF5ZXJzID0gW107XG4gICAgX2ZsYXR0ZW5Hcm91cFBsYXllcnNSZWN1cihwbGF5ZXJzLCBmaW5hbFBsYXllcnMpO1xuICAgIHJldHVybiBmaW5hbFBsYXllcnM7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcGxheWVyc1xuICogQHBhcmFtIHs/fSBmaW5hbFBsYXllcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9mbGF0dGVuR3JvdXBQbGF5ZXJzUmVjdXIocGxheWVycywgZmluYWxQbGF5ZXJzKSB7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gcGxheWVyc1tpXTtcbiAgICAgICAgaWYgKHBsYXllciBpbnN0YW5jZW9mIF9hbmd1bGFyX2FuaW1hdGlvbnMuybVBbmltYXRpb25Hcm91cFBsYXllcikge1xuICAgICAgICAgICAgX2ZsYXR0ZW5Hcm91cFBsYXllcnNSZWN1cihwbGF5ZXIucGxheWVycywgZmluYWxQbGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbmFsUGxheWVycy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKHBsYXllcikpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gYlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gb2JqRXF1YWxzKGEsIGIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrMSA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGsyID0gT2JqZWN0LmtleXMoYik7XG4gICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcCA9IGsxW2ldO1xuICAgICAgICBpZiAoIWIuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgYVtwcm9wXSAhPT0gYltwcm9wXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBhbGxQcmVTdHlsZUVsZW1lbnRzXG4gKiBAcGFyYW0gez99IGFsbFBvc3RTdHlsZUVsZW1lbnRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZXBsYWNlUG9zdFN0eWxlc0FzUHJlKGVsZW1lbnQsIGFsbFByZVN0eWxlRWxlbWVudHMsIGFsbFBvc3RTdHlsZUVsZW1lbnRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zdEVudHJ5ID0gYWxsUG9zdFN0eWxlRWxlbWVudHMuZ2V0KGVsZW1lbnQpO1xuICAgIGlmICghcG9zdEVudHJ5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlRW50cnkgPSBhbGxQcmVTdHlsZUVsZW1lbnRzLmdldChlbGVtZW50KTtcbiAgICBpZiAocHJlRW50cnkpIHtcbiAgICAgICAgcG9zdEVudHJ5LmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuICgocHJlRW50cnkpKS5hZGQoZGF0YSk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWxsUHJlU3R5bGVFbGVtZW50cy5zZXQoZWxlbWVudCwgcG9zdEVudHJ5KTtcbiAgICB9XG4gICAgYWxsUG9zdFN0eWxlRWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQW5pbWF0aW9uRW5naW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkVuZ2luZShfZHJpdmVyLCBub3JtYWxpemVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLm9uUmVtb3ZhbENvbXBsZXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZSA9IG5ldyBUcmFuc2l0aW9uQW5pbWF0aW9uRW5naW5lKF9kcml2ZXIsIG5vcm1hbGl6ZXIpO1xuICAgICAgICB0aGlzLl90aW1lbGluZUVuZ2luZSA9IG5ldyBUaW1lbGluZUFuaW1hdGlvbkVuZ2luZShfZHJpdmVyLCBub3JtYWxpemVyKTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5vblJlbW92YWxDb21wbGV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMub25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucmVnaXN0ZXJUcmlnZ2VyID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRJZFxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvbXBvbmVudElkLCBuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQsIG5hbWUsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhY2hlS2V5ID0gY29tcG9uZW50SWQgKyAnLScgKyBuYW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyID0gdGhpcy5fdHJpZ2dlckNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgaWYgKCF0cmlnZ2VyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IC8qKiBAdHlwZSB7P30gKi8gKGJ1aWxkQW5pbWF0aW9uQXN0KHRoaXMuX2RyaXZlciwgLyoqIEB0eXBlIHs/fSAqLyAobWV0YWRhdGEpLCBlcnJvcnMpKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaGFzIGZhaWxlZCB0byBidWlsZCBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcnM6XFxuIC0gXCIgKyBlcnJvcnMuam9pbihcIlxcbiAtIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyID0gYnVpbGRUcmlnZ2VyKG5hbWUsIGFzdCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2FjaGVbY2FjaGVLZXldID0gdHJpZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLnJlZ2lzdGVyVHJpZ2dlcihuYW1lc3BhY2VJZCwgbmFtZSwgdHJpZ2dlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUucmVnaXN0ZXIobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChuYW1lc3BhY2VJZCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmRlc3Ryb3kobmFtZXNwYWNlSWQsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBpbnNlcnRCZWZvcmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUub25JbnNlcnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IGluc2VydEJlZm9yZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwYXJlbnQsIGluc2VydEJlZm9yZSkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmluc2VydE5vZGUobmFtZXNwYWNlSWQsIGVsZW1lbnQsIHBhcmVudCwgaW5zZXJ0QmVmb3JlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUub25SZW1vdmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5yZW1vdmVOb2RlKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZGlzYWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5kaXNhYmxlQW5pbWF0aW9ucyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZGlzYWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIGRpc2FibGUpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5tYXJrRWxlbWVudEFzRGlzYWJsZWQoZWxlbWVudCwgZGlzYWJsZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUucHJvY2VzcyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZXNwYWNlSWRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5LmNoYXJBdCgwKSA9PSAnQCcpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHBhcnNlVGltZWxpbmVDb21tYW5kKHByb3BlcnR5KSwgaWQgPSBfYVswXSwgYWN0aW9uID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVFbmdpbmUuY29tbWFuZChpZCwgZWxlbWVudCwgYWN0aW9uLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUudHJpZ2dlcihuYW1lc3BhY2VJZCwgZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lc3BhY2VJZFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBldmVudFBoYXNlXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5saXN0ZW4gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVzcGFjZUlkXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50UGhhc2VcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGV2ZW50TmFtZSwgZXZlbnRQaGFzZSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gQEBsaXN0ZW5cbiAgICAgICAgaWYgKGV2ZW50TmFtZS5jaGFyQXQoMCkgPT0gJ0AnKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBwYXJzZVRpbWVsaW5lQ29tbWFuZChldmVudE5hbWUpLCBpZCA9IF9hWzBdLCBhY3Rpb24gPSBfYVsxXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZUVuZ2luZS5saXN0ZW4oaWQsIGVsZW1lbnQsIGFjdGlvbiwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmxpc3RlbihuYW1lc3BhY2VJZCwgZWxlbWVudCwgZXZlbnROYW1lLCBldmVudFBoYXNlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBtaWNyb3Rhc2tJZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uRW5naW5lLnByb3RvdHlwZS5mbHVzaCA9IC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG1pY3JvdGFza0lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWljcm90YXNrSWQpIHtcbiAgICAgICAgaWYgKG1pY3JvdGFza0lkID09PSB2b2lkIDApIHsgbWljcm90YXNrSWQgPSAtMTsgfVxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmZsdXNoKG1pY3JvdGFza0lkKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25FbmdpbmUucHJvdG90eXBlLCBcInBsYXllcnNcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgez99ICovICh0aGlzLl90cmFuc2l0aW9uRW5naW5lLnBsYXllcnMpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5fdGltZWxpbmVFbmdpbmUucGxheWVycykpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvbkVuZ2luZS5wcm90b3R5cGUud2hlblJlbmRlcmluZ0RvbmUgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUud2hlblJlbmRlcmluZ0RvbmUoKTsgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uRW5naW5lO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFdlYkFuaW1hdGlvbnNQbGF5ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2ViQW5pbWF0aW9uc1BsYXllcihlbGVtZW50LCBrZXlmcmFtZXMsIG9wdGlvbnMsIHByZXZpb3VzUGxheWVycykge1xuICAgICAgICBpZiAocHJldmlvdXNQbGF5ZXJzID09PSB2b2lkIDApIHsgcHJldmlvdXNQbGF5ZXJzID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5rZXlmcmFtZXMgPSBrZXlmcmFtZXM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucHJldmlvdXNQbGF5ZXJzID0gcHJldmlvdXNQbGF5ZXJzO1xuICAgICAgICB0aGlzLl9vbkRvbmVGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aW1lID0gMDtcbiAgICAgICAgdGhpcy5wYXJlbnRQbGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZpb3VzU3R5bGVzID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudFNuYXBzaG90ID0ge307XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9uc1snZHVyYXRpb24nXSk7XG4gICAgICAgIHRoaXMuX2RlbGF5ID0gLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9uc1snZGVsYXknXSkgfHwgMDtcbiAgICAgICAgdGhpcy50aW1lID0gdGhpcy5fZHVyYXRpb24gKyB0aGlzLl9kZWxheTtcbiAgICAgICAgaWYgKGFsbG93UHJldmlvdXNQbGF5ZXJTdHlsZXNNZXJnZSh0aGlzLl9kdXJhdGlvbiwgdGhpcy5fZGVsYXkpKSB7XG4gICAgICAgICAgICBwcmV2aW91c1BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gcGxheWVyLmN1cnJlbnRTbmFwc2hvdDtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIF90aGlzLnByZXZpb3VzU3R5bGVzW3Byb3BdID0gc3R5bGVzW3Byb3BdOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5pbml0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2J1aWxkUGxheWVyKCk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVQbGF5ZXJCZWZvcmVTdGFydCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fYnVpbGRQbGF5ZXIgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoc3R5bGVzKSB7IHJldHVybiBjb3B5U3R5bGVzKHN0eWxlcywgZmFsc2UpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNTdHlsZVByb3BzID0gT2JqZWN0LmtleXModGhpcy5wcmV2aW91c1N0eWxlcyk7XG4gICAgICAgIGlmIChwcmV2aW91c1N0eWxlUHJvcHMubGVuZ3RoICYmIGtleWZyYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0aW5nS2V5ZnJhbWVfMSA9IGtleWZyYW1lc1swXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1pc3NpbmdTdHlsZVByb3BzXzEgPSBbXTtcbiAgICAgICAgICAgIHByZXZpb3VzU3R5bGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydGluZ0tleWZyYW1lXzEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1N0eWxlUHJvcHNfMS5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydGluZ0tleWZyYW1lXzFbcHJvcF0gPSBfdGhpcy5wcmV2aW91c1N0eWxlc1twcm9wXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1pc3NpbmdTdHlsZVByb3BzXzEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZl8xID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2YgPSBrZXlmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdTdHlsZVByb3BzXzEuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2ZbcHJvcF0gPSBfY29tcHV0ZVN0eWxlKHNlbGZfMS5lbGVtZW50LCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAxOyBpIDwga2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMpKS5kb21QbGF5ZXIgPVxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcldlYkFuaW1hdGlvbih0aGlzLmVsZW1lbnQsIGtleWZyYW1lcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZmluYWxLZXlmcmFtZSA9IGtleWZyYW1lcy5sZW5ndGggPyBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdIDoge307XG4gICAgICAgIHRoaXMuZG9tUGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vbkZpbmlzaCgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX3ByZXBhcmVQbGF5ZXJCZWZvcmVTdGFydCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIHNvIHRoYXQgdGhlIHBsYXllciBkb2Vzbid0IHN0YXJ0IHRvIGFuaW1hdGUgcmlnaHQgYXdheVxuICAgICAgICBpZiAodGhpcy5fZGVsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RG9tUGxheWVyU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZG9tUGxheWVyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fdHJpZ2dlcldlYkFuaW1hdGlvbiA9IC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8ganNjb21waWxlciBkb2Vzbid0IHNlZW0gdG8ga25vdyBhbmltYXRlIGlzIGEgbmF0aXZlIHByb3BlcnR5IGJlY2F1c2UgaXQncyBub3QgZnVsbHlcbiAgICAgICAgLy8gc3VwcG9ydGVkIHlldCBhY3Jvc3MgY29tbW9uIGJyb3dzZXJzICh3ZSBwb2x5ZmlsbCBpdCBmb3IgRWRnZS9TYWZhcmkpIFtDTCAjMTQzNjMwOTI5XVxuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAoZWxlbWVudFsnYW5pbWF0ZSddKGtleWZyYW1lcywgb3B0aW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUub25TdGFydCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vblN0YXJ0Rm5zLnB1c2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLm9uRG9uZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkRvbmVGbnMucHVzaChmbik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUub25EZXN0cm95ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRGVzdHJveUZucy5wdXNoKGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnBsYXkgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYnVpbGRQbGF5ZXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbVBsYXllci5wbGF5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLmRvbVBsYXllci5wYXVzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgIHRoaXMuZG9tUGxheWVyLmZpbmlzaCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZXNldERvbVBsYXllclN0YXRlKCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLl9yZXNldERvbVBsYXllclN0YXRlID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbVBsYXllcikge1xuICAgICAgICAgICAgdGhpcy5kb21QbGF5ZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucmVzdGFydCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydGVkOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RG9tUGxheWVyU3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25EZXN0cm95Rm5zID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwKSB7IHRoaXMuZG9tUGxheWVyLmN1cnJlbnRUaW1lID0gcCAqIHRoaXMudGltZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRvbVBsYXllci5jdXJyZW50VGltZSAvIHRoaXMudGltZTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUsIFwidG90YWxUaW1lXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlbGF5ICsgdGhpcy5fZHVyYXRpb247IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuYmVmb3JlRGVzdHJveSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9maW5hbEtleWZyYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgIT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3Byb3BdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9maW5pc2hlZCA/IF90aGlzLl9maW5hbEtleWZyYW1lW3Byb3BdIDogX2NvbXB1dGVTdHlsZShfdGhpcy5lbGVtZW50LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTbmFwc2hvdCA9IHN0eWxlcztcbiAgICB9O1xuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhhc2VOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS50cmlnZ2VyQ2FsbGJhY2sgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBoYXNlTmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRob2RzID0gcGhhc2VOYW1lID09ICdzdGFydCcgPyB0aGlzLl9vblN0YXJ0Rm5zIDogdGhpcy5fb25Eb25lRm5zO1xuICAgICAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgbWV0aG9kcy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgcmV0dXJuIFdlYkFuaW1hdGlvbnNQbGF5ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEBwYXJhbSB7P30gcHJvcFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2NvbXB1dGVTdHlsZShlbGVtZW50LCBwcm9wKSB7XG4gICAgcmV0dXJuICgvKiogQHR5cGUgez99ICovICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSkpW3Byb3BdO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgV2ViQW5pbWF0aW9uc0RyaXZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zRHJpdmVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3BcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLnZhbGlkYXRlU3R5bGVQcm9wZXJ0eSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHZhbGlkYXRlU3R5bGVQcm9wZXJ0eShwcm9wKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zRHJpdmVyLnByb3RvdHlwZS5tYXRjaGVzRWxlbWVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc0VsZW1lbnQoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbG0xXG4gICAgICogQHBhcmFtIHs/fSBlbG0yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zRHJpdmVyLnByb3RvdHlwZS5jb250YWluc0VsZW1lbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsbTFcbiAgICAgKiBAcGFyYW0gez99IGVsbTJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbG0xLCBlbG0yKSB7IHJldHVybiBjb250YWluc0VsZW1lbnQoZWxtMSwgZWxtMik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbXVsdGlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLnF1ZXJ5ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbXVsdGlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVF1ZXJ5KGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHByb3BcbiAgICAgKiBAcGFyYW0gez89fSBkZWZhdWx0VmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLmNvbXB1dGVTdHlsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcHJvcFxuICAgICAqIEBwYXJhbSB7Pz19IGRlZmF1bHRWYWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAoKC8qKiBAdHlwZSB7P30gKi8gKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpKSlbcHJvcF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHBhcmFtIHs/PX0gcHJldmlvdXNQbGF5ZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXZWJBbmltYXRpb25zRHJpdmVyLnByb3RvdHlwZS5hbmltYXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgKiBAcGFyYW0gez99IGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHs/fSBkZWxheVxuICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICogQHBhcmFtIHs/PX0gcHJldmlvdXNQbGF5ZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwga2V5ZnJhbWVzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgcHJldmlvdXNQbGF5ZXJzKSB7XG4gICAgICAgIGlmIChwcmV2aW91c1BsYXllcnMgPT09IHZvaWQgMCkgeyBwcmV2aW91c1BsYXllcnMgPSBbXTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxsID0gZGVsYXkgPT0gMCA/ICdib3RoJyA6ICdmb3J3YXJkcyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllck9wdGlvbnMgPSB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgZGVsYXk6IGRlbGF5LCBmaWxsOiBmaWxsIH07XG4gICAgICAgIC8vIHdlIGNoZWNrIGZvciB0aGlzIHRvIGF2b2lkIGhhdmluZyBhIG51bGx8dW5kZWZpbmVkIHZhbHVlIGJlIHByZXNlbnRcbiAgICAgICAgLy8gZm9yIHRoZSBlYXNpbmcgKHdoaWNoIHJlc3VsdHMgaW4gYW4gZXJyb3IgZm9yIGNlcnRhaW4gYnJvd3NlcnMgIzk3NTIpXG4gICAgICAgIGlmIChlYXNpbmcpIHtcbiAgICAgICAgICAgIHBsYXllck9wdGlvbnNbJ2Vhc2luZyddID0gZWFzaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzV2ViQW5pbWF0aW9uUGxheWVycyA9IC8qKiBAdHlwZSB7P30gKi8gKHByZXZpb3VzUGxheWVycy5maWx0ZXIoZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyIGluc3RhbmNlb2YgV2ViQW5pbWF0aW9uc1BsYXllcjsgfSkpO1xuICAgICAgICByZXR1cm4gbmV3IFdlYkFuaW1hdGlvbnNQbGF5ZXIoZWxlbWVudCwga2V5ZnJhbWVzLCBwbGF5ZXJPcHRpb25zLCBwcmV2aW91c1dlYkFuaW1hdGlvblBsYXllcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFdlYkFuaW1hdGlvbnNEcml2ZXI7XG59KCkpO1xuLyoqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdXBwb3J0c1dlYkFuaW1hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgKC8qKiBAdHlwZSB7P30gKi8gKEVsZW1lbnQpKS5wcm90b3R5cGVbJ2FuaW1hdGUnXSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0cy5BbmltYXRpb25Ecml2ZXIgPSBBbmltYXRpb25Ecml2ZXI7XG5leHBvcnRzLsm1QW5pbWF0aW9uID0gQW5pbWF0aW9uO1xuZXhwb3J0cy7JtUFuaW1hdGlvblN0eWxlTm9ybWFsaXplciA9IEFuaW1hdGlvblN0eWxlTm9ybWFsaXplcjtcbmV4cG9ydHMuybVOb29wQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyID0gTm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplcjtcbmV4cG9ydHMuybVXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyID0gV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplcjtcbmV4cG9ydHMuybVOb29wQW5pbWF0aW9uRHJpdmVyID0gTm9vcEFuaW1hdGlvbkRyaXZlcjtcbmV4cG9ydHMuybVBbmltYXRpb25FbmdpbmUgPSBBbmltYXRpb25FbmdpbmU7XG5leHBvcnRzLsm1V2ViQW5pbWF0aW9uc0RyaXZlciA9IFdlYkFuaW1hdGlvbnNEcml2ZXI7XG5leHBvcnRzLsm1c3VwcG9ydHNXZWJBbmltYXRpb25zID0gc3VwcG9ydHNXZWJBbmltYXRpb25zO1xuZXhwb3J0cy7JtVdlYkFuaW1hdGlvbnNQbGF5ZXIgPSBXZWJBbmltYXRpb25zUGxheWVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5pbWF0aW9ucy1icm93c2VyLnVtZC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnVuZGxlcy9hbmltYXRpb25zLWJyb3dzZXIudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKSg0MCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnVuZGxlcy9hbmltYXRpb25zLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMSkpKDExOCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZmlsdGVyLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxKSkoODcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL2J1bmRsZXMvaHR0cC51bWQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1cmxcIlxuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XG52YXIgTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vTW91c2VFdmVudCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHt9XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IHtcbiAgLy8gWFhYXG4gIC8vIFNlZSBXZWJJREwgwqc0LjggZm9yIGRldGFpbHMgb24gb2JqZWN0IGV2ZW50IGhhbmRsZXJzXG4gIC8vIGFuZCBob3cgdGhleSBzaG91bGQgYmVoYXZlLiAgV2UgYWN0dWFsbHkgaGF2ZSB0byBhY2NlcHRcbiAgLy8gYW55IG9iamVjdCB0byBhZGRFdmVudExpc3RlbmVyLi4uIENhbid0IHR5cGUgY2hlY2sgaXQuXG4gIC8vIG9uIHJlZ2lzdHJhdGlvbi5cblxuICAvLyBYWFg6XG4gIC8vIENhcHR1cmluZyBldmVudCBsaXN0ZW5lcnMgYXJlIHNvcnQgb2YgcmFyZS4gIEkgdGhpbmsgSSBjYW4gb3B0aW1pemVcbiAgLy8gdGhlbSBzbyB0aGF0IGRpc3BhdGNoRXZlbnQgY2FuIHNraXAgdGhlIGNhcHR1cmluZyBwaGFzZSAob3IgbXVjaCBvZlxuICAvLyBpdCkuICBFYWNoIHRpbWUgYSBjYXB0dXJpbmcgbGlzdGVuZXIgaXMgYWRkZWQsIGluY3JlbWVudCBhIGZsYWcgb25cbiAgLy8gdGhlIHRhcmdldCBub2RlIGFuZCBlYWNoIG9mIGl0cyBhbmNlc3RvcnMuICBEZWNyZW1lbnQgd2hlbiByZW1vdmVkLlxuICAvLyBBbmQgdXBkYXRlIHRoZSBjb3VudGVyIHdoZW4gbm9kZXMgYXJlIGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlXG4gIC8vIHRyZWUgYXMgd2VsbC4gIFRoZW4sIGluIGRpc3BhdGNoIGV2ZW50LCB0aGUgY2FwdHVyaW5nIHBoYXNlIGNhblxuICAvLyBhYm9ydCBpZiBpdCBzZWVzIGFueSBub2RlIHdpdGggYSB6ZXJvIGNvdW50LlxuICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgaWYgKCFsaXN0ZW5lcikgcmV0dXJuO1xuICAgIGlmIChjYXB0dXJlID09PSB1bmRlZmluZWQpIGNhcHR1cmUgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykgdGhpcy5fbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1t0eXBlXSkgdGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG5cbiAgICAvLyBJZiB0aGlzIGxpc3RlbmVyIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCwganVzdCByZXR1cm5cbiAgICBmb3IodmFyIGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBsID0gbGlzdFtpXTtcbiAgICAgIGlmIChsLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJiBsLmNhcHR1cmUgPT09IGNhcHR1cmUpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBZGQgYW4gb2JqZWN0IHRvIHRoZSBsaXN0IG9mIGxpc3RlbmVyc1xuICAgIHZhciBvYmogPSB7IGxpc3RlbmVyOiBsaXN0ZW5lciwgY2FwdHVyZTogY2FwdHVyZSB9O1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIG9iai5mID0gbGlzdGVuZXI7XG4gICAgbGlzdC5wdXNoKG9iaik7XG4gIH0sXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmUpIHtcbiAgICBpZiAoY2FwdHVyZSA9PT0gdW5kZWZpbmVkKSBjYXB0dXJlID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gICAgICBpZiAobGlzdCkge1xuICAgICAgICAvLyBGaW5kIHRoZSBsaXN0ZW5lciBpbiB0aGUgbGlzdCBhbmQgcmVtb3ZlIGl0XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIG4gPSBsaXN0Lmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHZhciBsID0gbGlzdFtpXTtcbiAgICAgICAgICBpZiAobC5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiYgbC5jYXB0dXJlID09PSBjYXB0dXJlKSB7XG4gICAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyBUaGlzIGlzIHRoZSBwdWJsaWMgQVBJIGZvciBkaXNwYXRjaGluZyB1bnRydXN0ZWQgcHVibGljIGV2ZW50cy5cbiAgLy8gU2VlIF9kaXNwYXRjaEV2ZW50IGZvciB0aGUgaW1wbGVtZW50YXRpb25cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgIC8vIERpc3BhdGNoIGFuIHVudHJ1c3RlZCBldmVudFxuICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaEV2ZW50KGV2ZW50LCBmYWxzZSk7XG4gIH0sXG5cbiAgLy9cbiAgLy8gU2VlIERPTUNvcmUgwqc0LjRcbiAgLy8gWFhYOiBJJ2xsIHByb2JhYmx5IG5lZWQgYW5vdGhlciB2ZXJzaW9uIG9mIHRoaXMgbWV0aG9kIGZvclxuICAvLyBpbnRlcm5hbCB1c2UsIG9uZSB0aGF0IGRvZXMgbm90IHNldCBpc1RydXN0ZWQgdG8gZmFsc2UuXG4gIC8vIFhYWDogc2VlIERvY3VtZW50Ll9kaXNwYXRjaEV2ZW50OiBwZXJoYXBzIHRoYXQgYW5kIHRoaXMgY291bGRcbiAgLy8gY2FsbCBhIGNvbW1vbiBpbnRlcm5hbCBmdW5jdGlvbiB3aXRoIGRpZmZlcmVudCBzZXR0aW5ncyBvZlxuICAvLyBhIHRydXN0ZWQgYm9vbGVhbiBhcmd1bWVudFxuICAvL1xuICAvLyBYWFg6XG4gIC8vIFRoZSBzcGVjIGhhcyBjaGFuZ2VkIGluIGhvdyB0byBkZWFsIHdpdGggaGFuZGxlcnMgcmVnaXN0ZXJlZFxuICAvLyBvbiBpZGwgb3IgY29udGVudCBhdHRyaWJ1dGVzIHJhdGhlciB0aGFuIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cbiAgLy8gVXNlZCB0byBzYXkgdGhhdCB0aGV5IGFsd2F5cyByYW4gZmlyc3QuICBUaGF0J3MgaG93IHdlYmtpdCBkb2VzIGl0XG4gIC8vIFNwZWMgbm93IHNheXMgdGhhdCB0aGV5IHJ1biBpbiBhIHBvc2l0aW9uIGRldGVybWluZWQgYnlcbiAgLy8gd2hlbiB0aGV5IHdlcmUgZmlyc3Qgc2V0LiAgRkYgZG9lcyBpdCB0aGF0IHdheS4gIFNlZTpcbiAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI2V2ZW50LWhhbmRsZXJzXG4gIC8vXG4gIF9kaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiBfZGlzcGF0Y2hFdmVudChldmVudCwgdHJ1c3RlZCkge1xuICAgIGlmICh0eXBlb2YgdHJ1c3RlZCAhPT0gJ2Jvb2xlYW4nKSB0cnVzdGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gaW52b2tlKHRhcmdldCwgZXZlbnQpIHtcbiAgICAgIHZhciB0eXBlID0gZXZlbnQudHlwZSwgcGhhc2UgPSBldmVudC5ldmVudFBoYXNlO1xuICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IHRhcmdldDtcblxuICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGluZGl2aWR1YWwgaGFuZGxlciBkZWZpbmVkLCBpbnZva2UgaXQgZmlyc3RcbiAgICAgIC8vIFhYWDogc2VlIGNvbW1lbnQgYWJvdmU6IHRoaXMgc2hvdWxkbid0IGFsd2F5cyBiZSBmaXJzdC5cbiAgICAgIGlmIChwaGFzZSAhPT0gRXZlbnQuQ0FQVFVSSU5HX1BIQVNFICYmXG4gICAgICAgIHRhcmdldC5faGFuZGxlcnMgJiYgdGFyZ2V0Ll9oYW5kbGVyc1t0eXBlXSlcbiAgICAgIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0YXJnZXQuX2hhbmRsZXJzW3R5cGVdO1xuICAgICAgICB2YXIgcnY7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJ2PWhhbmRsZXIuY2FsbChldmVudC5jdXJyZW50VGFyZ2V0LCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGYgPSBoYW5kbGVyLmhhbmRsZUV2ZW50O1xuICAgICAgICAgIGlmICh0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hhbmRsZUV2ZW50IHByb3BlcnR5IG9mICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZXZlbnQgaGFuZGxlciBvYmplY3QgaXMnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIHJ2PWYuY2FsbChoYW5kbGVyLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2goZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgICAgICAgIGlmIChydiA9PT0gdHJ1ZSkgIC8vIEhpc3RvcmljYWwgYmFnZ2FnZVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYmVmb3JldW5sb2FkJzpcbiAgICAgICAgICAvLyBYWFg6IGV2ZW50dWFsbHkgd2UgbmVlZCBhIHNwZWNpYWwgY2FzZSBoZXJlXG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChydiA9PT0gZmFsc2UpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyBpbnZva2UgbGlzdCBsaXN0IG9mIGxpc3RlbmVycyBmb3IgdGhpcyB0YXJnZXQgYW5kIHR5cGVcbiAgICAgIHZhciBsaXN0ID0gdGFyZ2V0Ll9saXN0ZW5lcnMgJiYgdGFyZ2V0Ll9saXN0ZW5lcnNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpIHJldHVybjtcbiAgICAgIGxpc3QgPSBsaXN0LnNsaWNlKCk7XG4gICAgICBmb3IodmFyIGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKGV2ZW50Ll9pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQpIHJldHVybjtcbiAgICAgICAgdmFyIGwgPSBsaXN0W2ldO1xuICAgICAgICBpZiAoKHBoYXNlID09PSBFdmVudC5DQVBUVVJJTkdfUEhBU0UgJiYgIWwuY2FwdHVyZSkgfHxcbiAgICAgICAgICAocGhhc2UgPT09IEV2ZW50LkJVQkJMSU5HX1BIQVNFICYmIGwuY2FwdHVyZSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChsLmYpIHtcbiAgICAgICAgICBsLmYuY2FsbChldmVudC5jdXJyZW50VGFyZ2V0LCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGZuID0gbC5saXN0ZW5lci5oYW5kbGVFdmVudDtcbiAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGFuZGxlRXZlbnQgcHJvcGVydHkgb2YgZXZlbnQgbGlzdGVuZXIgb2JqZWN0IGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIGZuLmNhbGwobC5saXN0ZW5lciwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFldmVudC5faW5pdGlhbGl6ZWQgfHwgZXZlbnQuX2Rpc3BhdGNoaW5nKSB1dGlscy5JbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgIGV2ZW50LmlzVHJ1c3RlZCA9IHRydXN0ZWQ7XG5cbiAgICAvLyBCZWdpbiBkaXNwYXRjaGluZyB0aGUgZXZlbnQgbm93XG4gICAgZXZlbnQuX2Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuXG4gICAgLy8gQnVpbGQgdGhlIGxpc3Qgb2YgdGFyZ2V0cyBmb3IgdGhlIGNhcHR1cmluZyBhbmQgYnViYmxpbmcgcGhhc2VzXG4gICAgLy8gWFhYOiB3ZSdsbCBldmVudHVhbGx5IGhhdmUgdG8gYWRkIFdpbmRvdyB0byB0aGlzIGxpc3QuXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIGZvcih2YXIgbiA9IHRoaXMucGFyZW50Tm9kZTsgbjsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICAgIGFuY2VzdG9ycy5wdXNoKG4pO1xuXG4gICAgLy8gQ2FwdHVyaW5nIHBoYXNlXG4gICAgZXZlbnQuZXZlbnRQaGFzZSA9IEV2ZW50LkNBUFRVUklOR19QSEFTRTtcbiAgICBmb3IodmFyIGkgPSBhbmNlc3RvcnMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpbnZva2UoYW5jZXN0b3JzW2ldLCBldmVudCk7XG4gICAgICBpZiAoZXZlbnQuX3Byb3BhZ2F0aW9uU3RvcHBlZCkgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gQXQgdGFyZ2V0IHBoYXNlXG4gICAgaWYgKCFldmVudC5fcHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICBldmVudC5ldmVudFBoYXNlID0gRXZlbnQuQVRfVEFSR0VUO1xuICAgICAgaW52b2tlKHRoaXMsIGV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBCdWJibGluZyBwaGFzZVxuICAgIGlmIChldmVudC5idWJibGVzICYmICFldmVudC5fcHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICBldmVudC5ldmVudFBoYXNlID0gRXZlbnQuQlVCQkxJTkdfUEhBU0U7XG4gICAgICBmb3IodmFyIGlpID0gMCwgbm4gPSBhbmNlc3RvcnMubGVuZ3RoOyBpaSA8IG5uOyBpaSsrKSB7XG4gICAgICAgIGludm9rZShhbmNlc3RvcnNbaWldLCBldmVudCk7XG4gICAgICAgIGlmIChldmVudC5fcHJvcGFnYXRpb25TdG9wcGVkKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBldmVudC5fZGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICBldmVudC5ldmVudFBoYXNlID0gRXZlbnQuQVRfVEFSR0VUO1xuICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXG4gICAgLy8gRGVhbCB3aXRoIG1vdXNlIGV2ZW50cyBhbmQgZmlndXJlIG91dCB3aGVuXG4gICAgLy8gYSBjbGljayBoYXMgaGFwcGVuZWRcbiAgICBpZiAodHJ1c3RlZCAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJiBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcbiAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICB0aGlzLl9hcm1lZCA9IHtcbiAgICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgICAgdDogZXZlbnQudGltZVN0YW1wXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2VvdXQnOlxuICAgICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgICAgdGhpcy5fYXJtZWQgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICBpZiAodGhpcy5faXNDbGljayhldmVudCkpIHRoaXMuX2RvQ2xpY2soZXZlbnQpO1xuICAgICAgICB0aGlzLl9hcm1lZCA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuXG5cbiAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gIH0sXG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYSBjbGljayBvY2N1cnJlZFxuICAvLyBYWFggV2UgZG9uJ3Qgc3VwcG9ydCBkb3VibGUgY2xpY2tzIGZvciBub3dcbiAgX2lzQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuICh0aGlzLl9hcm1lZCAhPT0gbnVsbCAmJlxuICAgICAgICBldmVudC50eXBlID09PSAnbW91c2V1cCcgJiZcbiAgICAgICAgZXZlbnQuaXNUcnVzdGVkICYmXG4gICAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJlxuICAgICAgICBldmVudC50aW1lU3RhbXAgLSB0aGlzLl9hcm1lZC50IDwgMTAwMCAmJlxuICAgICAgICBNYXRoLmFicyhldmVudC5jbGllbnRYIC0gdGhpcy5fYXJtZWQueCkgPCAxMCAmJlxuICAgICAgICBNYXRoLmFicyhldmVudC5jbGllbnRZIC0gdGhpcy5fYXJtZWQuWSkgPCAxMCk7XG4gIH0sXG5cbiAgLy8gQ2xpY2tzIGFyZSBoYW5kbGVkIGxpa2UgdGhpczpcbiAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvZWxlbWVudHMuaHRtbCNpbnRlcmFjdGl2ZS1jb250ZW50LTBcbiAgLy9cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIHNpbWlsYXIgdG8gdGhlIEhUTUxFbGVtZW50LmNsaWNrKCkgbWV0aG9kXG4gIC8vIFRoZSBldmVudCBhcmd1bWVudCBtdXN0IGJlIHRoZSB0cnVzdGVkIG1vdXNldXAgZXZlbnRcbiAgX2RvQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2NsaWNrX2luX3Byb2dyZXNzKSByZXR1cm47XG4gICAgdGhpcy5fY2xpY2tfaW5fcHJvZ3Jlc3MgPSB0cnVlO1xuXG4gICAgLy8gRmluZCB0aGUgbmVhcmVzdCBlbmNsb3NpbmcgZWxlbWVudCB0aGF0IGlzIGFjdGl2YXRhYmxlXG4gICAgLy8gQW4gZWxlbWVudCBpcyBhY3RpdmF0YWJsZSBpZiBpdCBoYXMgYVxuICAgIC8vIF9wb3N0X2NsaWNrX2FjdGl2YXRpb25fc3RlcHMgaG9va1xuICAgIHZhciBhY3RpdmF0ZWQgPSB0aGlzO1xuICAgIHdoaWxlKGFjdGl2YXRlZCAmJiAhYWN0aXZhdGVkLl9wb3N0X2NsaWNrX2FjdGl2YXRpb25fc3RlcHMpXG4gICAgICBhY3RpdmF0ZWQgPSBhY3RpdmF0ZWQucGFyZW50Tm9kZTtcblxuICAgIGlmIChhY3RpdmF0ZWQgJiYgYWN0aXZhdGVkLl9wcmVfY2xpY2tfYWN0aXZhdGlvbl9zdGVwcykge1xuICAgICAgYWN0aXZhdGVkLl9wcmVfY2xpY2tfYWN0aXZhdGlvbl9zdGVwcygpO1xuICAgIH1cblxuICAgIHZhciBjbGljayA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xuICAgIGNsaWNrLmluaXRNb3VzZUV2ZW50KCdjbGljaycsIHRydWUsIHRydWUsXG4gICAgICB0aGlzLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcsIDEsXG4gICAgICBldmVudC5zY3JlZW5YLCBldmVudC5zY3JlZW5ZLFxuICAgICAgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSxcbiAgICAgIGV2ZW50LmN0cmxLZXksIGV2ZW50LmFsdEtleSxcbiAgICAgIGV2ZW50LnNoaWZ0S2V5LCBldmVudC5tZXRhS2V5LFxuICAgICAgZXZlbnQuYnV0dG9uLCBudWxsKTtcblxuICAgIHZhciByZXN1bHQgPSB0aGlzLl9kaXNwYXRjaEV2ZW50KGNsaWNrLCB0cnVlKTtcblxuICAgIGlmIChhY3RpdmF0ZWQpIHtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB3aGVyZSBoeXBlcmxpbmtzIGdldCBmb2xsb3dlZCwgZm9yIGV4YW1wbGUuXG4gICAgICAgIGlmIChhY3RpdmF0ZWQuX3Bvc3RfY2xpY2tfYWN0aXZhdGlvbl9zdGVwcylcbiAgICAgICAgICBhY3RpdmF0ZWQuX3Bvc3RfY2xpY2tfYWN0aXZhdGlvbl9zdGVwcyhjbGljayk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGFjdGl2YXRlZC5fY2FuY2VsbGVkX2FjdGl2YXRpb25fc3RlcHMpXG4gICAgICAgICAgYWN0aXZhdGVkLl9jYW5jZWxsZWRfYWN0aXZhdGlvbl9zdGVwcygpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvL1xuICAvLyBBbiBldmVudCBoYW5kbGVyIGlzIGxpa2UgYW4gZXZlbnQgbGlzdGVuZXIsIGJ1dCBpdCByZWdpc3RlcmVkXG4gIC8vIGJ5IHNldHRpbmcgYW4gSURMIG9yIGNvbnRlbnQgYXR0cmlidXRlIGxpa2Ugb25sb2FkIG9yIG9uY2xpY2suXG4gIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBvZiB0aGVzZSBhdCBhIHRpbWUgZm9yIGFueSBldmVudCB0eXBlLlxuICAvLyBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZCBmb3IgdGhlIGF0dHJpYnV0ZSBhY2Nlc3NvcnMgYW5kXG4gIC8vIGNvbnRlbnQgYXR0cmlidXRlIGhhbmRsZXJzIHRoYXQgbmVlZCB0byByZWdpc3RlciBldmVudHMgaGFuZGxlcnMuXG4gIC8vIFRoZSB0eXBlIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGluIGFkZEV2ZW50TGlzdGVuZXIoKS5cbiAgLy8gVGhlIGhhbmRsZXIgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgbGlzdGVuZXJzIGluIGFkZEV2ZW50TGlzdGVuZXI6XG4gIC8vIGl0IGNhbiBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdC4gUGFzcyBudWxsIHRvIHJlbW92ZSBhbnkgZXhpc3RpbmdcbiAgLy8gaGFuZGxlci4gIEhhbmRsZXJzIGFyZSBhbHdheXMgaW52b2tlZCBiZWZvcmUgYW55IGxpc3RlbmVycyBvZlxuICAvLyB0aGUgc2FtZSB0eXBlLiAgVGhleSBhcmUgbm90IGludm9rZWQgZHVyaW5nIHRoZSBjYXB0dXJpbmcgcGhhc2VcbiAgLy8gb2YgZXZlbnQgZGlzcGF0Y2guXG4gIC8vXG4gIF9zZXRFdmVudEhhbmRsZXI6IGZ1bmN0aW9uIF9zZXRFdmVudEhhbmRsZXIodHlwZSwgaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5faGFuZGxlcnMpIHRoaXMuX2hhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9oYW5kbGVyc1t0eXBlXSA9IGhhbmRsZXI7XG4gIH0sXG5cbiAgX2dldEV2ZW50SGFuZGxlcjogZnVuY3Rpb24gX2dldEV2ZW50SGFuZGxlcih0eXBlKSB7XG4gICAgcmV0dXJuICh0aGlzLl9oYW5kbGVycyAmJiB0aGlzLl9oYW5kbGVyc1t0eXBlXSkgfHwgbnVsbDtcbiAgfVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9FdmVudFRhcmdldC5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVUlFdmVudCA9IHJlcXVpcmUoJy4vVUlFdmVudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlRXZlbnQ7XG5cbmZ1bmN0aW9uIE1vdXNlRXZlbnQoKSB7XG4gIC8vIEp1c3QgdXNlIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yIHRvIGluaXRpYWxpemVcbiAgVUlFdmVudC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuc2NyZWVuWCA9IHRoaXMuc2NyZWVuWSA9IHRoaXMuY2xpZW50WCA9IHRoaXMuY2xpZW50WSA9IDA7XG4gIHRoaXMuY3RybEtleSA9IHRoaXMuYWx0S2V5ID0gdGhpcy5zaGlmdEtleSA9IHRoaXMubWV0YUtleSA9IGZhbHNlO1xuICB0aGlzLmJ1dHRvbiA9IDA7XG4gIHRoaXMuYnV0dG9ucyA9IDE7XG4gIHRoaXMucmVsYXRlZFRhcmdldCA9IG51bGw7XG59XG5Nb3VzZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVUlFdmVudC5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHsgdmFsdWU6IE1vdXNlRXZlbnQgfSxcbiAgaW5pdE1vdXNlRXZlbnQ6IHsgdmFsdWU6IGZ1bmN0aW9uKHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsXG4gICAgdmlldywgZGV0YWlsLFxuICAgIHNjcmVlblgsIHNjcmVlblksIGNsaWVudFgsIGNsaWVudFksXG4gICAgY3RybEtleSwgYWx0S2V5LCBzaGlmdEtleSwgbWV0YUtleSxcbiAgICBidXR0b24sIHJlbGF0ZWRUYXJnZXQpIHtcblxuICAgIHRoaXMuaW5pdEV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIHZpZXcsIGRldGFpbCk7XG4gICAgdGhpcy5zY3JlZW5YID0gc2NyZWVuWDtcbiAgICB0aGlzLnNjcmVlblkgPSBzY3JlZW5ZO1xuICAgIHRoaXMuY2xpZW50WCA9IGNsaWVudFg7XG4gICAgdGhpcy5jbGllbnRZID0gY2xpZW50WTtcbiAgICB0aGlzLmN0cmxLZXkgPSBjdHJsS2V5O1xuICAgIHRoaXMuYWx0S2V5ID0gYWx0S2V5O1xuICAgIHRoaXMuc2hpZnRLZXkgPSBzaGlmdEtleTtcbiAgICB0aGlzLm1ldGFLZXkgPSBtZXRhS2V5O1xuICAgIHRoaXMuYnV0dG9uID0gYnV0dG9uO1xuICAgIHN3aXRjaChidXR0b24pIHtcbiAgICBjYXNlIDA6IHRoaXMuYnV0dG9ucyA9IDE7IGJyZWFrO1xuICAgIGNhc2UgMTogdGhpcy5idXR0b25zID0gNDsgYnJlYWs7XG4gICAgY2FzZSAyOiB0aGlzLmJ1dHRvbnMgPSAyOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aGlzLmJ1dHRvbnMgPSAwOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZFRhcmdldDtcbiAgfX0sXG5cbiAgZ2V0TW9kaWZpZXJTdGF0ZTogeyB2YWx1ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgc3dpdGNoKGtleSkge1xuICAgIGNhc2UgXCJBbHRcIjogcmV0dXJuIHRoaXMuYWx0S2V5O1xuICAgIGNhc2UgXCJDb250cm9sXCI6IHJldHVybiB0aGlzLmN0cmxLZXk7XG4gICAgY2FzZSBcIlNoaWZ0XCI6IHJldHVybiB0aGlzLnNoaWZ0S2V5O1xuICAgIGNhc2UgXCJNZXRhXCI6IHJldHVybiB0aGlzLm1ldGFLZXk7XG4gICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfX1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Nb3VzZUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4vRXZlbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBVSUV2ZW50O1xuXG5mdW5jdGlvbiBVSUV2ZW50KCkge1xuICAvLyBKdXN0IHVzZSB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3RvciB0byBpbml0aWFsaXplXG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMudmlldyA9IG51bGw7IC8vIEZGIHVzZXMgdGhlIGN1cnJlbnQgd2luZG93XG4gIHRoaXMuZGV0YWlsID0gMDtcbn1cblVJRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHsgdmFsdWU6IFVJRXZlbnQgfSxcbiAgaW5pdFVJRXZlbnQ6IHsgdmFsdWU6IGZ1bmN0aW9uKHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIHZpZXcsIGRldGFpbCkge1xuICAgIHRoaXMuaW5pdEV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgdGhpcy5kZXRhaWwgPSBkZXRhaWw7XG4gIH19XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvVUlFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IERPTUV4Y2VwdGlvbjtcblxudmFyIElOREVYX1NJWkVfRVJSID0gMTtcbnZhciBISUVSQVJDSFlfUkVRVUVTVF9FUlIgPSAzO1xudmFyIFdST05HX0RPQ1VNRU5UX0VSUiA9IDQ7XG52YXIgSU5WQUxJRF9DSEFSQUNURVJfRVJSID0gNTtcbnZhciBOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIgPSA3O1xudmFyIE5PVF9GT1VORF9FUlIgPSA4O1xudmFyIE5PVF9TVVBQT1JURURfRVJSID0gOTtcbnZhciBJTlZBTElEX1NUQVRFX0VSUiA9IDExO1xudmFyIFNZTlRBWF9FUlIgPSAxMjtcbnZhciBJTlZBTElEX01PRElGSUNBVElPTl9FUlIgPSAxMztcbnZhciBOQU1FU1BBQ0VfRVJSID0gMTQ7XG52YXIgSU5WQUxJRF9BQ0NFU1NfRVJSID0gMTU7XG52YXIgVFlQRV9NSVNNQVRDSF9FUlIgPSAxNztcbnZhciBTRUNVUklUWV9FUlIgPSAxODtcbnZhciBORVRXT1JLX0VSUiA9IDE5O1xudmFyIEFCT1JUX0VSUiA9IDIwO1xudmFyIFVSTF9NSVNNQVRDSF9FUlIgPSAyMTtcbnZhciBRVU9UQV9FWENFRURFRF9FUlIgPSAyMjtcbnZhciBUSU1FT1VUX0VSUiA9IDIzO1xudmFyIElOVkFMSURfTk9ERV9UWVBFX0VSUiA9IDI0O1xudmFyIERBVEFfQ0xPTkVfRVJSID0gMjU7XG5cbi8vIENvZGUgdG8gbmFtZVxudmFyIG5hbWVzID0gW1xuICBudWxsLCAgLy8gTm8gZXJyb3Igd2l0aCBjb2RlIDBcbiAgJ0lOREVYX1NJWkVfRVJSJyxcbiAgbnVsbCwgLy8gaGlzdG9yaWNhbFxuICAnSElFUkFSQ0hZX1JFUVVFU1RfRVJSJyxcbiAgJ1dST05HX0RPQ1VNRU5UX0VSUicsXG4gICdJTlZBTElEX0NIQVJBQ1RFUl9FUlInLFxuICBudWxsLCAvLyBoaXN0b3JpY2FsXG4gICdOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlInLFxuICAnTk9UX0ZPVU5EX0VSUicsXG4gICdOT1RfU1VQUE9SVEVEX0VSUicsXG4gIG51bGwsIC8vIGhpc3RvcmljYWxcbiAgJ0lOVkFMSURfU1RBVEVfRVJSJyxcbiAgJ1NZTlRBWF9FUlInLFxuICAnSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSJyxcbiAgJ05BTUVTUEFDRV9FUlInLFxuICAnSU5WQUxJRF9BQ0NFU1NfRVJSJyxcbiAgbnVsbCwgLy8gaGlzdG9yaWNhbFxuICAnVFlQRV9NSVNNQVRDSF9FUlInLFxuICAnU0VDVVJJVFlfRVJSJyxcbiAgJ05FVFdPUktfRVJSJyxcbiAgJ0FCT1JUX0VSUicsXG4gICdVUkxfTUlTTUFUQ0hfRVJSJyxcbiAgJ1FVT1RBX0VYQ0VFREVEX0VSUicsXG4gICdUSU1FT1VUX0VSUicsXG4gICdJTlZBTElEX05PREVfVFlQRV9FUlInLFxuICAnREFUQV9DTE9ORV9FUlInLFxuXTtcblxuLy8gQ29kZSB0byBtZXNzYWdlXG4vLyBUaGVzZSBzdHJpbmdzIGFyZSBmcm9tIHRoZSAxMyBNYXkgMjAxMSBFZGl0b3IncyBEcmFmdCBvZiBET00gQ29yZS5cbi8vIGh0dHA6Ly9kdmNzLnczLm9yZy9oZy9kb21jb3JlL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sXG4vLyBDb3B5cmlnaHQgwqkgMjAxMSBXM0PCriAoTUlULCBFUkNJTSwgS2VpbyksIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBVc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgVzNDIERvY3VtZW50IExpY2Vuc2U6XG4vLyBodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMDIvY29weXJpZ2h0LWRvY3VtZW50cy0yMDAyMTIzMVxudmFyIG1lc3NhZ2VzID0gW1xuICBudWxsLCAgLy8gTm8gZXJyb3Igd2l0aCBjb2RlIDBcbiAgJ0lOREVYX1NJWkVfRVJSICgxKTogdGhlIGluZGV4IGlzIG5vdCBpbiB0aGUgYWxsb3dlZCByYW5nZScsXG4gIG51bGwsXG4gICdISUVSQVJDSFlfUkVRVUVTVF9FUlIgKDMpOiB0aGUgb3BlcmF0aW9uIHdvdWxkIHlpZWxkIGFuIGluY29ycmVjdCBub2RlcyBtb2RlbCcsXG4gICdXUk9OR19ET0NVTUVOVF9FUlIgKDQpOiB0aGUgb2JqZWN0IGlzIGluIHRoZSB3cm9uZyBEb2N1bWVudCwgYSBjYWxsIHRvIGltcG9ydE5vZGUgaXMgcmVxdWlyZWQnLFxuICAnSU5WQUxJRF9DSEFSQUNURVJfRVJSICg1KTogdGhlIHN0cmluZyBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMnLFxuICBudWxsLFxuICAnTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSICg3KTogdGhlIG9iamVjdCBjYW4gbm90IGJlIG1vZGlmaWVkJyxcbiAgJ05PVF9GT1VORF9FUlIgKDgpOiB0aGUgb2JqZWN0IGNhbiBub3QgYmUgZm91bmQgaGVyZScsXG4gICdOT1RfU1VQUE9SVEVEX0VSUiAoOSk6IHRoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQnLFxuICBudWxsLFxuICAnSU5WQUxJRF9TVEFURV9FUlIgKDExKTogdGhlIG9iamVjdCBpcyBpbiBhbiBpbnZhbGlkIHN0YXRlJyxcbiAgJ1NZTlRBWF9FUlIgKDEyKTogdGhlIHN0cmluZyBkaWQgbm90IG1hdGNoIHRoZSBleHBlY3RlZCBwYXR0ZXJuJyxcbiAgJ0lOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUiAoMTMpOiB0aGUgb2JqZWN0IGNhbiBub3QgYmUgbW9kaWZpZWQgaW4gdGhpcyB3YXknLFxuICAnTkFNRVNQQUNFX0VSUiAoMTQpOiB0aGUgb3BlcmF0aW9uIGlzIG5vdCBhbGxvd2VkIGJ5IE5hbWVzcGFjZXMgaW4gWE1MJyxcbiAgJ0lOVkFMSURfQUNDRVNTX0VSUiAoMTUpOiB0aGUgb2JqZWN0IGRvZXMgbm90IHN1cHBvcnQgdGhlIG9wZXJhdGlvbiBvciBhcmd1bWVudCcsXG4gIG51bGwsXG4gICdUWVBFX01JU01BVENIX0VSUiAoMTcpOiB0aGUgdHlwZSBvZiB0aGUgb2JqZWN0IGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCB0eXBlJyxcbiAgJ1NFQ1VSSVRZX0VSUiAoMTgpOiB0aGUgb3BlcmF0aW9uIGlzIGluc2VjdXJlJyxcbiAgJ05FVFdPUktfRVJSICgxOSk6IGEgbmV0d29yayBlcnJvciBvY2N1cnJlZCcsXG4gICdBQk9SVF9FUlIgKDIwKTogdGhlIHVzZXIgYWJvcnRlZCBhbiBvcGVyYXRpb24nLFxuICAnVVJMX01JU01BVENIX0VSUiAoMjEpOiB0aGUgZ2l2ZW4gVVJMIGRvZXMgbm90IG1hdGNoIGFub3RoZXIgVVJMJyxcbiAgJ1FVT1RBX0VYQ0VFREVEX0VSUiAoMjIpOiB0aGUgcXVvdGEgaGFzIGJlZW4gZXhjZWVkZWQnLFxuICAnVElNRU9VVF9FUlIgKDIzKTogYSB0aW1lb3V0IG9jY3VycmVkJyxcbiAgJ0lOVkFMSURfTk9ERV9UWVBFX0VSUiAoMjQpOiB0aGUgc3VwcGxpZWQgbm9kZSBpcyBpbnZhbGlkIG9yIGhhcyBhbiBpbnZhbGlkIGFuY2VzdG9yIGZvciB0aGlzIG9wZXJhdGlvbicsXG4gICdEQVRBX0NMT05FX0VSUiAoMjUpOiB0aGUgb2JqZWN0IGNhbiBub3QgYmUgY2xvbmVkLidcbl07XG5cbi8vIE5hbWUgdG8gY29kZVxudmFyIGNvbnN0YW50cyA9IHtcbiAgSU5ERVhfU0laRV9FUlI6IElOREVYX1NJWkVfRVJSLFxuICBET01TVFJJTkdfU0laRV9FUlI6IDIsIC8vIGhpc3RvcmljYWxcbiAgSElFUkFSQ0hZX1JFUVVFU1RfRVJSOiBISUVSQVJDSFlfUkVRVUVTVF9FUlIsXG4gIFdST05HX0RPQ1VNRU5UX0VSUjogV1JPTkdfRE9DVU1FTlRfRVJSLFxuICBJTlZBTElEX0NIQVJBQ1RFUl9FUlI6IElOVkFMSURfQ0hBUkFDVEVSX0VSUixcbiAgTk9fREFUQV9BTExPV0VEX0VSUjogNiwgLy8gaGlzdG9yaWNhbFxuICBOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlI6IE5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUixcbiAgTk9UX0ZPVU5EX0VSUjogTk9UX0ZPVU5EX0VSUixcbiAgTk9UX1NVUFBPUlRFRF9FUlI6IE5PVF9TVVBQT1JURURfRVJSLFxuICBJTlVTRV9BVFRSSUJVVEVfRVJSOiAxMCwgLy8gaGlzdG9yaWNhbFxuICBJTlZBTElEX1NUQVRFX0VSUjogSU5WQUxJRF9TVEFURV9FUlIsXG4gIFNZTlRBWF9FUlI6IFNZTlRBWF9FUlIsXG4gIElOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUjogSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSLFxuICBOQU1FU1BBQ0VfRVJSOiBOQU1FU1BBQ0VfRVJSLFxuICBJTlZBTElEX0FDQ0VTU19FUlI6IElOVkFMSURfQUNDRVNTX0VSUixcbiAgVkFMSURBVElPTl9FUlI6IDE2LCAvLyBoaXN0b3JpY2FsXG4gIFRZUEVfTUlTTUFUQ0hfRVJSOiBUWVBFX01JU01BVENIX0VSUixcbiAgU0VDVVJJVFlfRVJSOiBTRUNVUklUWV9FUlIsXG4gIE5FVFdPUktfRVJSOiBORVRXT1JLX0VSUixcbiAgQUJPUlRfRVJSOiBBQk9SVF9FUlIsXG4gIFVSTF9NSVNNQVRDSF9FUlI6IFVSTF9NSVNNQVRDSF9FUlIsXG4gIFFVT1RBX0VYQ0VFREVEX0VSUjogUVVPVEFfRVhDRUVERURfRVJSLFxuICBUSU1FT1VUX0VSUjogVElNRU9VVF9FUlIsXG4gIElOVkFMSURfTk9ERV9UWVBFX0VSUjogSU5WQUxJRF9OT0RFX1RZUEVfRVJSLFxuICBEQVRBX0NMT05FX0VSUjogREFUQV9DTE9ORV9FUlJcbn07XG5cbmZ1bmN0aW9uIERPTUV4Y2VwdGlvbihjb2RlKSB7XG4gIEVycm9yLmNhbGwodGhpcyk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB0aGlzLmNvZGUgPSBjb2RlO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcbiAgdGhpcy5uYW1lID0gbmFtZXNbY29kZV07XG59XG5ET01FeGNlcHRpb24ucHJvdG90eXBlLl9fcHJvdG9fXyA9IEVycm9yLnByb3RvdHlwZTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgY29uc3RhbnRzIG9uIERPTUV4Y2VwdGlvbiBhbmQgRE9NRXhjZXB0aW9uLnByb3RvdHlwZVxuZm9yKHZhciBjIGluIGNvbnN0YW50cykge1xuICB2YXIgdiA9IHsgdmFsdWU6IGNvbnN0YW50c1tjXSB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRE9NRXhjZXB0aW9uLCBjLCB2KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERPTUV4Y2VwdGlvbi5wcm90b3R5cGUsIGMsIHYpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9ET01FeGNlcHRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gKiBUaGlzIGZpbGUgZGVmaW5lcyBEb21pbm8gYmVoYXZpb3VyIHRoYXQgY2FuIGJlIGV4dGVybmFsbHkgY29uZmlndXJlZC5cbiAqIFRvIGNoYW5nZSB0aGVzZSBzZXR0aW5ncywgc2V0IHRoZSByZWxldmFudCBnbG9iYWwgcHJvcGVydHkgKmJlZm9yZSpcbiAqIHlvdSBjYWxsIGByZXF1aXJlKFwiZG9taW5vXCIpYC5cbiAqL1xuXG5leHBvcnRzLmlzQXBpV3JpdGFibGUgPSAhZ2xvYmFsLl9fZG9taW5vX2Zyb3plbl9fO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5leHBvcnRzLnByb3BlcnR5ID0gZnVuY3Rpb24oYXR0cikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhdHRyLnR5cGUpKSB7XG4gICAgdmFyIHZhbGlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBhdHRyLnR5cGUuZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhbGlkW3ZhbC52YWx1ZSB8fCB2YWxdID0gdmFsLmFsaWFzIHx8IHZhbDtcbiAgICB9KTtcbiAgICB2YXIgbWlzc2luZ1ZhbHVlRGVmYXVsdCA9IGF0dHIubWlzc2luZztcbiAgICBpZiAobWlzc2luZ1ZhbHVlRGVmYXVsdD09PXVuZGVmaW5lZCkgeyBtaXNzaW5nVmFsdWVEZWZhdWx0ID0gbnVsbDsgfVxuICAgIHZhciBpbnZhbGlkVmFsdWVEZWZhdWx0ID0gYXR0ci5pbnZhbGlkO1xuICAgIGlmIChpbnZhbGlkVmFsdWVEZWZhdWx0PT09dW5kZWZpbmVkKSB7IGludmFsaWRWYWx1ZURlZmF1bHQgPSBtaXNzaW5nVmFsdWVEZWZhdWx0OyB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5fZ2V0YXR0cihhdHRyLm5hbWUpO1xuICAgICAgICBpZiAodiA9PT0gbnVsbCkgcmV0dXJuIG1pc3NpbmdWYWx1ZURlZmF1bHQ7XG5cbiAgICAgICAgdiA9IHZhbGlkW3YudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHJldHVybiB2O1xuICAgICAgICBpZiAoaW52YWxpZFZhbHVlRGVmYXVsdCAhPT0gbnVsbCkgcmV0dXJuIGludmFsaWRWYWx1ZURlZmF1bHQ7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLl9zZXRhdHRyKGF0dHIubmFtZSwgdik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBlbHNlIGlmIChhdHRyLnR5cGUgPT09IEJvb2xlYW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKGF0dHIubmFtZSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgdGhpcy5fc2V0YXR0cihhdHRyLm5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBlbHNlIGlmIChhdHRyLnR5cGUgPT09IE51bWJlciB8fFxuICAgICAgICAgICBhdHRyLnR5cGUgPT09IFwibG9uZ1wiIHx8XG4gICAgICAgICAgIGF0dHIudHlwZSA9PT0gXCJ1bnNpZ25lZCBsb25nXCIgfHxcbiAgICAgICAgICAgYXR0ci50eXBlID09PSBcImxpbWl0ZWQgdW5zaWduZWQgbG9uZyB3aXRoIGZhbGxiYWNrXCIpIHtcbiAgICByZXR1cm4gbnVtYmVyUHJvcERlc2MoYXR0cik7XG4gIH1cbiAgZWxzZSBpZiAoIWF0dHIudHlwZSB8fCBhdHRyLnR5cGUgPT09IFN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZ2V0YXR0cihhdHRyLm5hbWUpIHx8ICcnOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIGlmIChhdHRyLnRyZWF0TnVsbEFzRW1wdHlTdHJpbmcgJiYgdiA9PT0gbnVsbCkgeyB2ID0gJyc7IH1cbiAgICAgICAgdGhpcy5fc2V0YXR0cihhdHRyLm5hbWUsIHYpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGF0dHIudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBhdHRyLnR5cGUoYXR0ci5uYW1lLCBhdHRyKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGRlZmluaXRpb24nKTtcbn07XG5cbi8vIFNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrLyNyZWZsZWN0XG4vL1xuLy8gZGVmdmFsIGlzIHRoZSBkZWZhdWx0IHZhbHVlLiBJZiBpdCBpcyBhIGZ1bmN0aW9uLCB0aGVuIHRoYXQgZnVuY3Rpb25cbi8vIHdpbGwgYmUgaW52b2tlZCBhcyBhIG1ldGhvZCBvZiB0aGUgZWxlbWVudCB0byBvYnRhaW4gdGhlIGRlZmF1bHQuXG4vLyBJZiBubyBkZWZhdWx0IGlzIHNwZWNpZmllZCBmb3IgYSBnaXZlbiBhdHRyaWJ1dGUsIHRoZW4gdGhlIGRlZmF1bHRcbi8vIGRlcGVuZHMgb24gdGhlIHR5cGUgb2YgdGhlIGF0dHJpYnV0ZSwgYnV0IHNpbmNlIHRoaXMgZnVuY3Rpb24gaGFuZGxlc1xuLy8gNCBpbnRlZ2VyIGNhc2VzLCB5b3UgbXVzdCBzcGVjaWZ5IHRoZSBkZWZhdWx0IHZhbHVlIGluIGVhY2ggY2FsbFxuLy9cbi8vIG1pbiBhbmQgbWF4IGRlZmluZSBhIHZhbGlkIHJhbmdlIGZvciBnZXR0aW5nIHRoZSBhdHRyaWJ1dGUuXG4vL1xuLy8gc2V0bWluIGRlZmluZXMgYSBtaW5pbXVtIHZhbHVlIHdoZW4gc2V0dGluZy4gIElmIHRoZSB2YWx1ZSBpcyBsZXNzXG4vLyB0aGFuIHRoYXQsIHRoZW4gdGhyb3cgSU5ERVhfU0laRV9FUlIuXG4vL1xuLy8gQ29udmVuaWVudGx5LCBKYXZhU2NyaXB0J3MgcGFyc2VJbnQgZnVuY3Rpb24gYXBwZWFycyB0byBiZVxuLy8gY29tcGF0aWJsZSB3aXRoIEhUTUwncyAncnVsZXMgZm9yIHBhcnNpbmcgaW50ZWdlcnMnXG5mdW5jdGlvbiBudW1iZXJQcm9wRGVzYyhhKSB7XG4gIHZhciBkZWY7XG4gIGlmKHR5cGVvZiBhLmRlZmF1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZWYgPSBhLmRlZmF1bHQ7XG4gIH1cbiAgZWxzZSBpZih0eXBlb2YgYS5kZWZhdWx0ID09PSAnbnVtYmVyJykge1xuICAgIGRlZiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYS5kZWZhdWx0OyB9O1xuICB9XG4gIGVsc2Uge1xuICAgIGRlZiA9IGZ1bmN0aW9uKCkgeyB1dGlscy5hc3NlcnQoZmFsc2UsIHR5cGVvZiBhLmRlZmF1bHQpOyB9O1xuICB9XG4gIHZhciB1bnNpZ25lZF9sb25nID0gKGEudHlwZSA9PT0gJ3Vuc2lnbmVkIGxvbmcnKTtcbiAgdmFyIHNpZ25lZF9sb25nID0gKGEudHlwZSA9PT0gJ2xvbmcnKTtcbiAgdmFyIHVuc2lnbmVkX2ZhbGxiYWNrID0gKGEudHlwZSA9PT0gJ2xpbWl0ZWQgdW5zaWduZWQgbG9uZyB3aXRoIGZhbGxiYWNrJyk7XG4gIHZhciBtaW4gPSBhLm1pbiwgbWF4ID0gYS5tYXgsIHNldG1pbiA9IGEuc2V0bWluO1xuICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodW5zaWduZWRfbG9uZykgbWluID0gMDtcbiAgICBpZiAoc2lnbmVkX2xvbmcpIG1pbiA9IC0weDgwMDAwMDAwO1xuICAgIGlmICh1bnNpZ25lZF9mYWxsYmFjaykgbWluID0gMTtcbiAgfVxuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodW5zaWduZWRfbG9uZyB8fCBzaWduZWRfbG9uZyB8fCB1bnNpZ25lZF9mYWxsYmFjaykgbWF4ID0gMHg3RkZGRkZGRjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdGhpcy5fZ2V0YXR0cihhLm5hbWUpO1xuICAgICAgdmFyIG4gPSBhLmZsb2F0ID8gcGFyc2VGbG9hdCh2KSA6IHBhcnNlSW50KHYsIDEwKTtcbiAgICAgIGlmICh2ID09PSBudWxsIHx8ICFpc0Zpbml0ZShuKSB8fCAobWluICE9PSB1bmRlZmluZWQgJiYgbiA8IG1pbikgfHwgKG1heCAhPT0gdW5kZWZpbmVkICYmIG4gPiBtYXgpKSB7XG4gICAgICAgIHJldHVybiBkZWYuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmICh1bnNpZ25lZF9sb25nIHx8IHNpZ25lZF9sb25nIHx8IHVuc2lnbmVkX2ZhbGxiYWNrKSB7XG4gICAgICAgIGlmICghL15bIFxcdFxcblxcZlxccl0qWy0rXT9bMC05XS8udGVzdCh2KSkgeyByZXR1cm4gZGVmLmNhbGwodGhpcyk7IH1cbiAgICAgICAgbiA9IG58MDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhLmZsb2F0KSB7IHYgPSBNYXRoLmZsb29yKHYpOyB9XG4gICAgICBpZiAoc2V0bWluICE9PSB1bmRlZmluZWQgJiYgdiA8IHNldG1pbikge1xuICAgICAgICB1dGlscy5JbmRleFNpemVFcnJvcihhLm5hbWUgKyAnIHNldCB0byAnICsgdik7XG4gICAgICB9XG4gICAgICBpZiAodW5zaWduZWRfbG9uZykge1xuICAgICAgICB2ID0gKHYgPCAwIHx8IHYgPiAweDdGRkZGRkZGKSA/IGRlZi5jYWxsKHRoaXMpIDpcbiAgICAgICAgICAodnwwKTsgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgfSBlbHNlIGlmICh1bnNpZ25lZF9mYWxsYmFjaykge1xuICAgICAgICB2ID0gKHYgPCAxIHx8IHYgPiAweDdGRkZGRkZGKSA/IGRlZi5jYWxsKHRoaXMpIDpcbiAgICAgICAgICAodnwwKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICB9IGVsc2UgaWYgKHNpZ25lZF9sb25nKSB7XG4gICAgICAgIHYgPSAodiA8IC0weDgwMDAwMDAwIHx8IHYgPiAweDdGRkZGRkZGKSA/IGRlZi5jYWxsKHRoaXMpIDpcbiAgICAgICAgICAodnwwKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRhdHRyKGEubmFtZSwgU3RyaW5nKHYpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIFRoaXMgaXMgYSB1dGlsaXR5IGZ1bmN0aW9uIGZvciBzZXR0aW5nIHVwIGNoYW5nZSBoYW5kbGVyIGZ1bmN0aW9uc1xuLy8gZm9yIGF0dHJpYnV0ZXMgbGlrZSAnaWQnIHRoYXQgcmVxdWlyZSBzcGVjaWFsIGhhbmRsaW5nIHdoZW4gdGhleSBjaGFuZ2UuXG5leHBvcnRzLnJlZ2lzdGVyQ2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uKGMsIG5hbWUsIGhhbmRsZXIpIHtcbiAgdmFyIHAgPSBjLnByb3RvdHlwZTtcblxuICAvLyBJZiBwIGRvZXMgbm90IGFscmVhZHkgaGF2ZSBpdHMgb3duIF9hdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyc1xuICAvLyB0aGVuIGNyZWF0ZSBvbmUgZm9yIGl0LCBpbmhlcml0aW5nIGZyb20gdGhlIGluaGVyaXRlZFxuICAvLyBfYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnMuIEF0IHRoZSB0b3AgKGZvciB0aGUgRWxlbWVudCBjbGFzcykgdGhlXG4gIC8vIF9hdHRyaWJ1dGVDaGFuZ2VIYW5kbGVycyBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkIHdpdGggYSBudWxsIHByb3RvdHlwZS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCwgJ19hdHRyaWJ1dGVDaGFuZ2VIYW5kbGVycycpKSB7XG4gICAgcC5fYXR0cmlidXRlQ2hhbmdlSGFuZGxlcnMgPVxuICAgICAgT2JqZWN0LmNyZWF0ZShwLl9hdHRyaWJ1dGVDaGFuZ2VIYW5kbGVycyB8fCBudWxsKTtcbiAgfVxuXG4gIHAuX2F0dHJpYnV0ZUNoYW5nZUhhbmRsZXJzW25hbWVdID0gaGFuZGxlcjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2F0dHJpYnV0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuLy8gRE9NVG9rZW5MaXN0IGltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9SYXlub3MvRE9NLXNoaW1cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Ub2tlbkxpc3Q7XG5cbmZ1bmN0aW9uIERPTVRva2VuTGlzdChnZXR0ZXIsIHNldHRlcikge1xuICB0aGlzLl9nZXRTdHJpbmcgPSBnZXR0ZXI7XG4gIHRoaXMuX3NldFN0cmluZyA9IHNldHRlcjtcbiAgZml4SW5kZXgodGhpcywgZ2V0TGlzdCh0aGlzKSk7XG59XG5cbkRPTVRva2VuTGlzdC5wcm90b3R5cGUgPSB7XG4gIGl0ZW06IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0cmluZygpLnNwbGl0KFwiIFwiKVtpbmRleF07XG4gIH0sXG5cbiAgY29udGFpbnM6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgdG9rZW4gPSBTdHJpbmcodG9rZW4pO1xuICAgIGhhbmRsZUVycm9ycyh0b2tlbik7XG4gICAgdmFyIGxpc3QgPSBnZXRMaXN0KHRoaXMpO1xuICAgIHJldHVybiBsaXN0LmluZGV4T2YodG9rZW4pID4gLTE7XG4gIH0sXG5cbiAgYWRkOiBmdW5jdGlvbih0b2tlbikge1xuICAgIGhhbmRsZUVycm9ycyh0b2tlbik7XG4gICAgdmFyIGxpc3QgPSBnZXRMaXN0KHRoaXMpO1xuICAgIGlmIChsaXN0LmluZGV4T2YodG9rZW4pID4gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGlzdC5wdXNoKHRva2VuKTtcbiAgICB0aGlzLl9zZXRTdHJpbmcobGlzdC5qb2luKFwiIFwiKS50cmltKCkpO1xuICAgIGZpeEluZGV4KHRoaXMsIGxpc3QpO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24odG9rZW4pIHtcbiAgICBoYW5kbGVFcnJvcnModG9rZW4pO1xuICAgIHZhciBsaXN0ID0gZ2V0TGlzdCh0aGlzKTtcbiAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YodG9rZW4pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB0aGlzLl9zZXRTdHJpbmcobGlzdC5qb2luKFwiIFwiKS50cmltKCkpO1xuICAgIH1cbiAgICBmaXhJbmRleCh0aGlzLCBsaXN0KTtcbiAgfSxcblxuICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSh0b2tlbikge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zKHRva2VuKSkge1xuICAgICAgdGhpcy5yZW1vdmUodG9rZW4pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKHRva2VuKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0cmluZygpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmaXhJbmRleChjbGlzdCwgbGlzdCkge1xuICBjbGlzdC5sZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY2xpc3RbaV0gPSBsaXN0W2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9ycyh0b2tlbikge1xuICBpZiAodG9rZW4gPT09IFwiXCIgfHwgdG9rZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIHV0aWxzLlN5bnRheEVycm9yKCk7XG4gIH1cbiAgaWYgKHRva2VuLmluZGV4T2YoXCIgXCIpID4gLTEpIHtcbiAgICB1dGlscy5JbnZhbGlkQ2hhcmFjdGVyRXJyb3IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMaXN0KGNsaXN0KSB7XG4gIHZhciBzdHIgPSBjbGlzdC5fZ2V0U3RyaW5nKCk7XG4gIGlmIChzdHIgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdChcIiBcIik7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvRE9NVG9rZW5MaXN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XG5cbnZhciBOb25Eb2N1bWVudFR5cGVDaGlsZE5vZGUgPSB7XG5cbiAgbmV4dEVsZW1lbnRTaWJsaW5nOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIHNpYnMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2RlcztcbiAgICAgIGZvcih2YXIgaSA9IHRoaXMuaW5kZXgrMSwgbiA9IHNpYnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChzaWJzW2ldLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgcmV0dXJuIHNpYnNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9fSxcblxuICBwcmV2aW91c0VsZW1lbnRTaWJsaW5nOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIHNpYnMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2RlcztcbiAgICAgIGZvcih2YXIgaSA9IHRoaXMuaW5kZXgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHNpYnNbaV0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSByZXR1cm4gc2lic1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH19XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Ob25Eb2N1bWVudFR5cGVDaGlsZE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBUZXh0O1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIENoYXJhY3RlckRhdGEgPSByZXF1aXJlKCcuL0NoYXJhY3RlckRhdGEnKTtcblxuZnVuY3Rpb24gVGV4dChkb2MsIGRhdGEpIHtcbiAgdGhpcy5ub2RlVHlwZSA9IE5vZGUuVEVYVF9OT0RFO1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBkb2M7XG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB0aGlzLl9pbmRleCA9IHVuZGVmaW5lZDtcbn1cblxudmFyIG5vZGVWYWx1ZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2RhdGE7IH0sXG4gIHNldDogZnVuY3Rpb24odikge1xuICAgIGlmICh2ID09PSB0aGlzLl9kYXRhKSByZXR1cm47XG4gICAgdGhpcy5fZGF0YSA9IHY7XG4gICAgaWYgKHRoaXMucm9vdGVkKVxuICAgICAgdGhpcy5vd25lckRvY3VtZW50Lm11dGF0ZVZhbHVlKHRoaXMpO1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUgJiZcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5fdGV4dGNoYW5nZWhvb2spXG4gICAgICB0aGlzLnBhcmVudE5vZGUuX3RleHRjaGFuZ2Vob29rKHRoaXMpO1xuICB9XG59O1xuXG5UZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2hhcmFjdGVyRGF0YS5wcm90b3R5cGUsIHtcbiAgbm9kZU5hbWU6IHsgdmFsdWU6IFwiI3RleHRcIiB9LFxuICAvLyBUaGVzZSB0aHJlZSBhdHRyaWJ1dGVzIGFyZSBhbGwgdGhlIHNhbWUuXG4gIC8vIFRoZSBkYXRhIGF0dHJpYnV0ZSBoYXMgYSBbVHJlYXROdWxsQXM9RW1wdHlTdHJpbmddIGJ1dCB3ZSdsbFxuICAvLyBpbXBsZW1lbnQgdGhhdCBhdCB0aGUgaW50ZXJmYWNlIGxldmVsXG4gIG5vZGVWYWx1ZTogbm9kZVZhbHVlLFxuICB0ZXh0Q29udGVudDogbm9kZVZhbHVlLFxuICBkYXRhOiBub2RlVmFsdWUsXG5cbiAgc3BsaXRUZXh0OiB7IHZhbHVlOiBmdW5jdGlvbiBzcGxpdFRleHQob2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA+IHRoaXMuX2RhdGEubGVuZ3RoIHx8IG9mZnNldCA8IDApIHV0aWxzLkluZGV4U2l6ZUVycm9yKCk7XG5cbiAgICB2YXIgbmV3ZGF0YSA9IHRoaXMuX2RhdGEuc3Vic3RyaW5nKG9mZnNldCksXG4gICAgICBuZXdub2RlID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld2RhdGEpO1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbClcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobmV3bm9kZSwgdGhpcy5uZXh0U2libGluZyk7XG5cbiAgICByZXR1cm4gbmV3bm9kZTtcbiAgfX0sXG5cbiAgLy8gWFhYXG4gIC8vIHdob2xlVGV4dCBhbmQgcmVwbGFjZVdob2xlVGV4dCgpIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0IGJlY2F1c2VcbiAgLy8gdGhlIERPTUNvcmUgc3BlY2lmaWNhdGlvbiBpcyBjb25zaWRlcmluZyByZW1vdmluZyBvciBhbHRlcmluZyB0aGVtLlxuICB3aG9sZVRleHQ6IHtnZXQ6IHV0aWxzLm55aSB9LFxuICByZXBsYWNlV2hvbGVUZXh0OiB7IHZhbHVlOiB1dGlscy5ueWkgfSxcblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgY2xvbmU6IHsgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgVGV4dCh0aGlzLm93bmVyRG9jdW1lbnQsIHRoaXMuX2RhdGEpO1xuICB9fSxcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL1RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBMZWFmO1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIEhpZXJhcmNoeVJlcXVlc3RFcnJvciA9IHV0aWxzLkhpZXJhcmNoeVJlcXVlc3RFcnJvcjtcbnZhciBOb3RGb3VuZEVycm9yID0gdXRpbHMuTm90Rm91bmRFcnJvcjtcblxuLy8gVGhpcyBjbGFzcyBkZWZpbmVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBub2RlIHN1YnR5cGVzIHRoYXRcbi8vIGNhbiBuZXZlciBoYXZlIGNoaWxkcmVuXG5mdW5jdGlvbiBMZWFmKCkge1xufVxuXG5MZWFmLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUsIHtcbiAgaGFzQ2hpbGROb2RlczogeyB2YWx1ZTogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfX0sXG4gIGZpcnN0Q2hpbGQ6IHsgdmFsdWU6IG51bGwgfSxcbiAgbGFzdENoaWxkOiB7IHZhbHVlOiBudWxsIH0sXG4gIGluc2VydEJlZm9yZTogeyB2YWx1ZTogZnVuY3Rpb24obm9kZSwgY2hpbGQpIHtcbiAgICBpZiAoIW5vZGUubm9kZVR5cGUpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIG5vZGUnKTtcbiAgICBIaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgfX0sXG4gIHJlcGxhY2VDaGlsZDogeyB2YWx1ZTogZnVuY3Rpb24obm9kZSwgY2hpbGQpIHtcbiAgICBpZiAoIW5vZGUubm9kZVR5cGUpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIG5vZGUnKTtcbiAgICBIaWVyYXJjaHlSZXF1ZXN0RXJyb3IoKTtcbiAgfX0sXG4gIHJlbW92ZUNoaWxkOiB7IHZhbHVlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLm5vZGVUeXBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBub2RlJyk7XG4gICAgTm90Rm91bmRFcnJvcigpO1xuICB9fSxcbiAgY2hpbGROb2RlczogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fY2hpbGROb2RlcykgdGhpcy5fY2hpbGROb2RlcyA9IFtdO1xuICAgIHJldHVybiB0aGlzLl9jaGlsZE5vZGVzO1xuICB9fVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0xlYWYuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50O1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIENoYXJhY3RlckRhdGEgPSByZXF1aXJlKCcuL0NoYXJhY3RlckRhdGEnKTtcblxuZnVuY3Rpb24gQ29tbWVudChkb2MsIGRhdGEpIHtcbiAgdGhpcy5ub2RlVHlwZSA9IE5vZGUuQ09NTUVOVF9OT0RFO1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBkb2M7XG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB0aGlzLl9pbmRleCA9IHVuZGVmaW5lZDtcbn1cblxudmFyIG5vZGVWYWx1ZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2RhdGE7IH0sXG4gIHNldDogZnVuY3Rpb24odikge1xuICAgIHRoaXMuX2RhdGEgPSB2O1xuICAgIGlmICh0aGlzLnJvb3RlZClcbiAgICAgIHRoaXMub3duZXJEb2N1bWVudC5tdXRhdGVWYWx1ZSh0aGlzKTtcbiAgfVxufTtcblxuQ29tbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENoYXJhY3RlckRhdGEucHJvdG90eXBlLCB7XG4gIG5vZGVOYW1lOiB7IHZhbHVlOiAnI2NvbW1lbnQnIH0sXG4gIG5vZGVWYWx1ZTogbm9kZVZhbHVlLFxuICB0ZXh0Q29udGVudDogbm9kZVZhbHVlLFxuICBkYXRhOiBub2RlVmFsdWUsXG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIGNsb25lOiB7IHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENvbW1lbnQodGhpcy5vd25lckRvY3VtZW50LCB0aGlzLl9kYXRhKTtcbiAgfX0sXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvQ29tbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9ICBEb2N1bWVudEZyYWdtZW50O1xuXG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIE5vZGVMaXN0ID0gcmVxdWlyZSgnLi9Ob2RlTGlzdCcpO1xudmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL0VsZW1lbnQnKTtcbnZhciBzZWxlY3QgPSByZXF1aXJlKCcuL3NlbGVjdCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBEb2N1bWVudEZyYWdtZW50KGRvYykge1xuICB0aGlzLm5vZGVUeXBlID0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBkb2M7XG4gIHRoaXMuY2hpbGROb2RlcyA9IFtdO1xufVxuXG5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUsIHtcbiAgbm9kZU5hbWU6IHsgdmFsdWU6ICcjZG9jdW1lbnQtZnJhZ21lbnQnIH0sXG4gIG5vZGVWYWx1ZTogeyBcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbigpIHt9XG4gIH0sXG4gIC8vIENvcHkgdGhlIHRleHQgY29udGVudCBnZXR0ZXIvc2V0dGVyIGZyb20gRWxlbWVudFxuICB0ZXh0Q29udGVudDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSwgJ3RleHRDb250ZW50JyksXG5cbiAgcXVlcnlTZWxlY3RvcjogeyB2YWx1ZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAvLyBpbXBsZW1lbnQgaW4gdGVybXMgb2YgcXVlcnlTZWxlY3RvckFsbFxuICAgIHZhciBub2RlcyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA/IG5vZGVzWzBdIDogbnVsbDtcbiAgfX0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IHsgdmFsdWU6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgLy8gY3JlYXRlIGEgY29udGV4dFxuICAgIHZhciBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAvLyBhZGQgc29tZSBtZXRob2RzIHRvIHRoZSBjb250ZXh0IGZvciB6ZXN0IGltcGxlbWVudGF0aW9uLCB3aXRob3V0XG4gICAgLy8gYWRkaW5nIHRoZW0gdG8gdGhlIHB1YmxpYyBEb2N1bWVudEZyYWdtZW50IEFQSVxuICAgIGNvbnRleHQuaXNIVE1MID0gdHJ1ZTsgLy8gaW4gSFRNTCBuYW1lc3BhY2UgKGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2gpXG4gICAgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IEVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lO1xuICAgIGNvbnRleHQubmV4dEVsZW1lbnQgPVxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSwgJ2ZpcnN0RWxlbWVudENoaWxkJykuXG4gICAgICBnZXQ7XG4gICAgLy8gaW52b2tlIHplc3RcbiAgICB2YXIgbm9kZXMgPSBzZWxlY3Qoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgIHJldHVybiBub2Rlcy5pdGVtID8gbm9kZXMgOiBuZXcgTm9kZUxpc3Qobm9kZXMpO1xuICB9fSxcblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgY2xvbmU6IHsgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEZyYWdtZW50KHRoaXMub3duZXJEb2N1bWVudCk7XG4gIH19LFxuICBpc0VxdWFsOiB7IHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsKG4pIHtcbiAgICAgIC8vIEFueSB0d28gZG9jdW1lbnQgZnJhZ21lbnRzIGFyZSBzaGFsbG93bHkgZXF1YWwuXG4gICAgICAvLyBOb2RlLmlzRXF1YWxOb2RlKCkgd2lsbCB0ZXN0IHRoZWlyIGNoaWxkcmVuIGZvciBlcXVhbGl0eVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH19LFxuXG4gIC8vIE5vbi1zdGFuZGFyZCwgYnV0IHVzZWZ1bCAoZ2l0aHViIGlzc3VlICM3MylcbiAgaW5uZXJIVE1MOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7IH0sXG4gICAgc2V0OiB1dGlscy5ueWlcbiAgfSxcbiAgb3V0ZXJIVE1MOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7IH0sXG4gICAgc2V0OiB1dGlscy5ueWlcbiAgfSxcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0RvY3VtZW50RnJhZ21lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb247XG5cbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XG52YXIgQ2hhcmFjdGVyRGF0YSA9IHJlcXVpcmUoJy4vQ2hhcmFjdGVyRGF0YScpO1xuXG5mdW5jdGlvbiBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oZG9jLCB0YXJnZXQsIGRhdGEpIHtcbiAgdGhpcy5ub2RlVHlwZSA9IE5vZGUuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFO1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBkb2M7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbn1cblxudmFyIG5vZGVWYWx1ZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2RhdGE7IH0sXG4gIHNldDogZnVuY3Rpb24odikge1xuICAgIHRoaXMuX2RhdGEgPSB2O1xuICAgIGlmICh0aGlzLnJvb3RlZCkgdGhpcy5vd25lckRvY3VtZW50Lm11dGF0ZVZhbHVlKHRoaXMpO1xuICB9XG59O1xuXG5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSwge1xuICBub2RlTmFtZTogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50YXJnZXQ7IH19LFxuICBub2RlVmFsdWU6IG5vZGVWYWx1ZSxcbiAgdGV4dENvbnRlbnQ6IG5vZGVWYWx1ZSxcbiAgZGF0YTogbm9kZVZhbHVlLFxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xuICBjbG9uZTogeyB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb2Nlc3NpbmdJbnN0cnVjdGlvbih0aGlzLm93bmVyRG9jdW1lbnQsIHRoaXMudGFyZ2V0LCB0aGlzLl9kYXRhKTtcbiAgfX0sXG4gIGlzRXF1YWw6IHsgdmFsdWU6IGZ1bmN0aW9uIGlzRXF1YWwobikge1xuICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0ID09PSBuLnRhcmdldCAmJiB0aGlzLl9kYXRhID09PSBuLl9kYXRhO1xuICB9fVxuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvUHJvY2Vzc2luZ0luc3RydWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGV4cG9ydGVkIE5vZGVUcmF2ZXJzYWwgKi9cbnZhciBOb2RlVHJhdmVyc2FsID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5leHRTa2lwcGluZ0NoaWxkcmVuOiBuZXh0U2tpcHBpbmdDaGlsZHJlbixcbiAgbmV4dEFuY2VzdG9yU2libGluZzogbmV4dEFuY2VzdG9yU2libGluZyxcbiAgbmV4dDogbmV4dCxcbiAgcHJldmlvdXM6IHByZXZpb3VzLFxuICBkZWVwTGFzdENoaWxkOiBkZWVwTGFzdENoaWxkXG59O1xuXG4vKipcbiAqIEBiYXNlZCBvbiBXZWJLaXQncyBOb2RlVHJhdmVyc2FsOjpuZXh0U2tpcHBpbmdDaGlsZHJlblxuICogaHR0cHM6Ly90cmFjLndlYmtpdC5vcmcvYnJvd3Nlci90cnVuay9Tb3VyY2UvV2ViQ29yZS9kb20vTm9kZVRyYXZlcnNhbC5oP3Jldj0xNzkxNDMjTDEwOVxuICovXG5mdW5jdGlvbiBuZXh0U2tpcHBpbmdDaGlsZHJlbihub2RlLCBzdGF5V2l0aGluKSB7XG4gIGlmIChub2RlID09PSBzdGF5V2l0aGluKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgfVxuICByZXR1cm4gbmV4dEFuY2VzdG9yU2libGluZyhub2RlLCBzdGF5V2l0aGluKTtcbn1cblxuLyoqXG4gKiBAYmFzZWQgb24gV2ViS2l0J3MgTm9kZVRyYXZlcnNhbDo6bmV4dEFuY2VzdG9yU2libGluZ1xuICogaHR0cHM6Ly90cmFjLndlYmtpdC5vcmcvYnJvd3Nlci90cnVuay9Tb3VyY2UvV2ViQ29yZS9kb20vTm9kZVRyYXZlcnNhbC5jcHA/cmV2PTE3OTE0MyNMOTNcbiAqL1xuZnVuY3Rpb24gbmV4dEFuY2VzdG9yU2libGluZyhub2RlLCBzdGF5V2l0aGluKSB7XG4gIGZvciAobm9kZSA9IG5vZGUucGFyZW50Tm9kZTsgbm9kZSAhPT0gbnVsbDsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgIGlmIChub2RlID09PSBzdGF5V2l0aGluKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAYmFzZWQgb24gV2ViS2l0J3MgTm9kZVRyYXZlcnNhbDo6bmV4dFxuICogaHR0cHM6Ly90cmFjLndlYmtpdC5vcmcvYnJvd3Nlci90cnVuay9Tb3VyY2UvV2ViQ29yZS9kb20vTm9kZVRyYXZlcnNhbC5oP3Jldj0xNzkxNDMjTDk5XG4gKi9cbmZ1bmN0aW9uIG5leHQobm9kZSwgc3RheVdpdGhpbikge1xuICB2YXIgbjtcbiAgbiA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgaWYgKG4gIT09IG51bGwpIHtcbiAgICByZXR1cm4gbjtcbiAgfVxuICBpZiAobm9kZSA9PT0gc3RheVdpdGhpbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG4gPSBub2RlLm5leHRTaWJsaW5nO1xuICBpZiAobiAhPT0gbnVsbCkge1xuICAgIHJldHVybiBuO1xuICB9XG4gIHJldHVybiBuZXh0QW5jZXN0b3JTaWJsaW5nKG5vZGUsIHN0YXlXaXRoaW4pO1xufVxuXG4vKipcbiAqIEBiYXNlZCBvbiBXZWJLaXQncyBOb2RlVHJhdmVyc2FsOjpkZWVwTGFzdENoaWxkXG4gKiBodHRwczovL3RyYWMud2Via2l0Lm9yZy9icm93c2VyL3RydW5rL1NvdXJjZS9XZWJDb3JlL2RvbS9Ob2RlVHJhdmVyc2FsLmNwcD9yZXY9MTc5MTQzI0wxMTZcbiAqL1xuZnVuY3Rpb24gZGVlcExhc3RDaGlsZChub2RlKSB7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBAYmFzZWQgb24gV2ViS2l0J3MgTm9kZVRyYXZlcnNhbDo6cHJldmlvdXNcbiAqIGh0dHBzOi8vdHJhYy53ZWJraXQub3JnL2Jyb3dzZXIvdHJ1bmsvU291cmNlL1dlYkNvcmUvZG9tL05vZGVUcmF2ZXJzYWwuaD9yZXY9MTc5MTQzI0wxMjFcbiAqL1xuZnVuY3Rpb24gcHJldmlvdXMobm9kZSwgc3RheVdpdGhpbikge1xuICB2YXIgcDtcbiAgcCA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICBpZiAocCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBkZWVwTGFzdENoaWxkKHApO1xuICB9XG4gIHAgPSBub2RlLnBhcmVudE5vZGU7XG4gIGlmIChwID09PSBzdGF5V2l0aGluKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL05vZGVUcmF2ZXJzYWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEV2ZW50OiByZXF1aXJlKCcuL0V2ZW50JyksXG4gIFVJRXZlbnQ6IHJlcXVpcmUoJy4vVUlFdmVudCcpLFxuICBNb3VzZUV2ZW50OiByZXF1aXJlKCcuL01vdXNlRXZlbnQnKSxcbiAgQ3VzdG9tRXZlbnQ6IHJlcXVpcmUoJy4vQ3VzdG9tRXZlbnQnKVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvZXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBVUkwgPSByZXF1aXJlKCcuL1VSTCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVSTFV0aWxzO1xuXG4vLyBUaGlzIGlzIGFuIGFic3RyYWN0IHN1cGVyY2xhc3MgZm9yIExvY2F0aW9uLCBIVE1MQW5jaG9yRWxlbWVudCBhbmRcbi8vIG90aGVyIHR5cGVzIHRoYXQgaGF2ZSB0aGUgc3RhbmRhcmQgY29tcGxlbWVudCBvZiBcIlVSTCBkZWNvbXBvc2l0aW9uXG4vLyBJREwgYXR0cmlidXRlc1wiLiAgVGhpcyBpcyBub3cgc3RhbmRhcmRpemVkIGFzIFVSTFV0aWxzLCBzZWU6XG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4vLyBTdWJjbGFzc2VzIG11c3QgZGVmaW5lIGEgZ2V0dGVyL3NldHRlciBvbiBocmVmLlxuLy8gVGhlIGdldHRlciBhbmQgc2V0dGVyIG1ldGhvZHMgcGFyc2UgYW5kIHJlYnVpbGQgdGhlIFVSTCBvbiBlYWNoXG4vLyBpbnZvY2F0aW9uOyB0aGVyZSBpcyBubyBhdHRlbXB0IHRvIGNhY2hlIHRoZSB2YWx1ZSBhbmQgYmUgbW9yZSBlZmZpY2llbnRcbmZ1bmN0aW9uIFVSTFV0aWxzKCkge31cblVSTFV0aWxzLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFVSTFV0aWxzLFxuXG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpKSByZXR1cm4gdXJsLnNjaGVtZSArIFwiOlwiO1xuICAgIGVsc2UgcmV0dXJuIFwiXCI7XG4gIH0sXG5cbiAgZ2V0IGhvc3QoKSB7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwodGhpcy5ocmVmKTtcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSAmJiB1cmwuaXNBdXRob3JpdHlCYXNlZCgpKVxuICAgICAgcmV0dXJuIHVybC5ob3N0ICsgKHVybC5wb3J0ID8gKFwiOlwiICsgdXJsLnBvcnQpIDogXCJcIik7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFwiXCI7XG4gIH0sXG5cbiAgZ2V0IGhvc3RuYW1lKCkge1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKHRoaXMuaHJlZik7XG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkgJiYgdXJsLmlzQXV0aG9yaXR5QmFzZWQoKSlcbiAgICAgIHJldHVybiB1cmwuaG9zdDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gXCJcIjtcbiAgfSxcblxuICBnZXQgcG9ydCgpIHtcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0F1dGhvcml0eUJhc2VkKCkgJiYgdXJsLnBvcnQhPT11bmRlZmluZWQpXG4gICAgICByZXR1cm4gdXJsLnBvcnQ7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFwiXCI7XG4gIH0sXG5cbiAgZ2V0IHBhdGhuYW1lKCkge1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKHRoaXMuaHJlZik7XG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkgJiYgdXJsLmlzSGllcmFyY2hpY2FsKCkpXG4gICAgICByZXR1cm4gdXJsLnBhdGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFwiXCI7XG4gIH0sXG5cbiAgZ2V0IHNlYXJjaCgpIHtcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0hpZXJhcmNoaWNhbCgpICYmIHVybC5xdWVyeSE9PXVuZGVmaW5lZClcbiAgICAgIHJldHVybiBcIj9cIiArIHVybC5xdWVyeTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gXCJcIjtcbiAgfSxcblxuICBnZXQgaGFzaCgpIHtcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIFwiI1wiICsgdXJsLmZyYWdtZW50O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBcIlwiO1xuICB9LFxuXG4gIGdldCB1c2VybmFtZSgpIHtcbiAgICB2YXIgdXJsID0gbmV3IFVSTCh0aGlzLmhyZWYpO1xuICAgIHJldHVybiB1cmwudXNlcm5hbWUgfHwgJyc7XG4gIH0sXG5cbiAgZ2V0IHBhc3N3b3JkKCkge1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKHRoaXMuaHJlZik7XG4gICAgcmV0dXJuIHVybC5wYXNzd29yZCB8fCAnJztcbiAgfSxcblxuICBnZXQgb3JpZ2luKCkge1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKHRoaXMuaHJlZik7XG4gICAgdmFyIG9yaWdpbkZvclBvcnQgPSBmdW5jdGlvbihkZWZhdWx0UG9ydCkge1xuICAgICAgdmFyIG9yaWdpbiA9IFt1cmwuc2NoZW1lLCB1cmwuaG9zdCwgK3VybC5wb3J0IHx8IGRlZmF1bHRQb3J0XTtcbiAgICAgIC8vIFhYWCBzaG91bGQgYmUgXCJ1bmljb2RlIHNlcmlhbGl6YXRpb25cIlxuICAgICAgcmV0dXJuIG9yaWdpblswXSArICc6Ly8nICsgb3JpZ2luWzFdICtcbiAgICAgICAgKG9yaWdpblsyXSA9PT0gZGVmYXVsdFBvcnQgPyAnJyA6ICgnOicgKyBvcmlnaW5bMl0pKTtcbiAgICB9O1xuICAgIHN3aXRjaCAodXJsLnNjaGVtZSkge1xuICAgIGNhc2UgJ2Z0cCc6XG4gICAgICByZXR1cm4gb3JpZ2luRm9yUG9ydCgyMSk7XG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICAgIHJldHVybiBvcmlnaW5Gb3JQb3J0KDcwKTtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgICByZXR1cm4gb3JpZ2luRm9yUG9ydCg4MCk7XG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgICByZXR1cm4gb3JpZ2luRm9yUG9ydCg0NDMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyB0aGlzIGlzIHdoYXQgY2hyb21lIGRvZXNcbiAgICAgIHJldHVybiB1cmwuc2NoZW1lICsgJzovLyc7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gIGdldCBzZWFyY2hQYXJhbXMoKSB7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwodGhpcy5ocmVmKTtcbiAgICAvLyBYWFhcbiAgfSxcbiAgKi9cblxuICBzZXQgcHJvdG9jb2wodikge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLmhyZWY7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSkge1xuICAgICAgdiA9IHYucmVwbGFjZSgvOiskLywgXCJcIik7XG4gICAgICB2ID0gdi5yZXBsYWNlKC9bXi0rXFwuYS16QS1aMC05XS9nLCBVUkwucGVyY2VudEVuY29kZSk7XG4gICAgICBpZiAodi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVybC5zY2hlbWUgPSB2O1xuICAgICAgICBvdXRwdXQgPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ocmVmID0gb3V0cHV0O1xuICB9LFxuXG4gIHNldCBob3N0KHYpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKG91dHB1dCk7XG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkgJiYgdXJsLmlzQXV0aG9yaXR5QmFzZWQoKSkge1xuICAgICAgdiA9IHYucmVwbGFjZSgvW14tK1xcLl9+ISQmJygpKiw7Oj1hLXpBLVowLTldL2csIFVSTC5wZXJjZW50RW5jb2RlKTtcbiAgICAgIGlmICh2Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXJsLmhvc3QgPSB2O1xuICAgICAgICBkZWxldGUgdXJsLnBvcnQ7XG4gICAgICAgIG91dHB1dCA9IHVybC50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmhyZWYgPSBvdXRwdXQ7XG4gIH0sXG5cbiAgc2V0IGhvc3RuYW1lKHYpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKG91dHB1dCk7XG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkgJiYgdXJsLmlzQXV0aG9yaXR5QmFzZWQoKSkge1xuICAgICAgdiA9IHYucmVwbGFjZSgvXlxcLysvLCBcIlwiKTtcbiAgICAgIHYgPSB2LnJlcGxhY2UoL1teLStcXC5ffiEkJicoKSosOzo9YS16QS1aMC05XS9nLCBVUkwucGVyY2VudEVuY29kZSk7XG4gICAgICBpZiAodi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdjtcbiAgICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcbiAgfSxcblxuICBzZXQgcG9ydCh2KSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuaHJlZjtcbiAgICB2YXIgdXJsID0gbmV3IFVSTChvdXRwdXQpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpICYmIHVybC5pc0F1dGhvcml0eUJhc2VkKCkpIHtcbiAgICAgIHYgPSAnJyArIHY7XG4gICAgICB2ID0gdi5yZXBsYWNlKC9bXjAtOV0uKiQvLCBcIlwiKTtcbiAgICAgIHYgPSB2LnJlcGxhY2UoL14wKy8sIFwiXCIpO1xuICAgICAgaWYgKHYubGVuZ3RoID09PSAwKSB2ID0gXCIwXCI7XG4gICAgICBpZiAocGFyc2VJbnQodiwgMTApIDw9IDY1NTM1KSB7XG4gICAgICAgIHVybC5wb3J0ID0gdjtcbiAgICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcbiAgfSxcblxuICBzZXQgcGF0aG5hbWUodikge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLmhyZWY7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcbiAgICBpZiAodXJsLmlzQWJzb2x1dGUoKSAmJiB1cmwuaXNIaWVyYXJjaGljYWwoKSkge1xuICAgICAgaWYgKHYuY2hhckF0KDApICE9PSBcIi9cIilcbiAgICAgICAgdiA9IFwiL1wiICsgdjtcbiAgICAgIHYgPSB2LnJlcGxhY2UoL1teLStcXC5ffiEkJicoKSosOzo9QFxcL2EtekEtWjAtOV0vZywgVVJMLnBlcmNlbnRFbmNvZGUpO1xuICAgICAgdXJsLnBhdGggPSB2O1xuICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcbiAgfSxcblxuICBzZXQgc2VhcmNoKHYpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKG91dHB1dCk7XG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkgJiYgdXJsLmlzSGllcmFyY2hpY2FsKCkpIHtcbiAgICAgIGlmICh2LmNoYXJBdCgwKSA9PT0gXCI/XCIpIHYgPSB2LnN1YnN0cmluZygxKTtcbiAgICAgIHYgPSB2LnJlcGxhY2UoL1teLStcXC5ffiEkJicoKSosOzo9QFxcLz9hLXpBLVowLTldL2csIFVSTC5wZXJjZW50RW5jb2RlKTtcbiAgICAgIHVybC5xdWVyeSA9IHY7XG4gICAgICBvdXRwdXQgPSB1cmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5ocmVmID0gb3V0cHV0O1xuICB9LFxuXG4gIHNldCBoYXNoKHYpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5ocmVmO1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKG91dHB1dCk7XG4gICAgaWYgKHVybC5pc0Fic29sdXRlKCkpIHtcbiAgICAgIGlmICh2LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHYgPSB2LnN1YnN0cmluZygxKTtcbiAgICAgIHYgPSB2LnJlcGxhY2UoL1teLStcXC5ffiEkJicoKSosOzo9QFxcLz9hLXpBLVowLTldL2csIFVSTC5wZXJjZW50RW5jb2RlKTtcbiAgICAgIHVybC5mcmFnbWVudCA9IHY7XG4gICAgICBvdXRwdXQgPSB1cmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5ocmVmID0gb3V0cHV0O1xuICB9LFxuXG4gIHNldCB1c2VybmFtZSh2KSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuaHJlZjtcbiAgICB2YXIgdXJsID0gbmV3IFVSTChvdXRwdXQpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpKSB7XG4gICAgICB2ID0gdi5yZXBsYWNlKC9bXFx4MDAtXFx4MUZcXHg3Ri1cXHVGRkZGIFwiIzw+P2BcXC9AXFxcXDpdL2csIFVSTC5wZXJjZW50RW5jb2RlKTtcbiAgICAgIHVybC51c2VybmFtZSA9IHY7XG4gICAgICBvdXRwdXQgPSB1cmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5ocmVmID0gb3V0cHV0O1xuICB9LFxuXG4gIHNldCBwYXNzd29yZCh2KSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuaHJlZjtcbiAgICB2YXIgdXJsID0gbmV3IFVSTChvdXRwdXQpO1xuICAgIGlmICh1cmwuaXNBYnNvbHV0ZSgpKSB7XG4gICAgICBpZiAodj09PScnKSB7XG4gICAgICAgIHVybC5wYXNzd29yZCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gdi5yZXBsYWNlKC9bXFx4MDAtXFx4MUZcXHg3Ri1cXHVGRkZGIFwiIzw+P2BcXC9AXFxcXF0vZywgVVJMLnBlcmNlbnRFbmNvZGUpO1xuICAgICAgICB1cmwucGFzc3dvcmQgPSB2O1xuICAgICAgfVxuICAgICAgb3V0cHV0ID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMuaHJlZiA9IG91dHB1dDtcbiAgfS8qLFxuXG4gIHNldCBzZWFyY2hQYXJhbXModikge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLmhyZWY7XG4gICAgdmFyIHVybCA9IG5ldyBVUkwob3V0cHV0KTtcbiAgICAvLyBYWFhcbiAgICB0aGlzLmhyZWYgPSBvdXRwdXQ7XG4gIH1cbiAgKi9cbn07XG5cblVSTFV0aWxzLl9pbmhlcml0ID0gZnVuY3Rpb24ocHJvdG8pIHtcbiAgLy8gY29weSBnZXR0ZXJzL3NldHRlcnMgZnJvbSBVUkxVdGlscyB0byBvLlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhVUkxVdGlscy5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgIGlmIChwPT09J2NvbnN0cnVjdG9yJyB8fCBwPT09J2hyZWYnKSB7IHJldHVybjsgfVxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihVUkxVdGlscy5wcm90b3R5cGUsIHApO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgcCwgZGVzYyk7XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvVVJMVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgYXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpO1xudmFyIHNsb3BweSA9IHJlcXVpcmUoJy4vc2xvcHB5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3BlYywgZGVmYXVsdENvbnN0cnVjdG9yLCB0YWdMaXN0LCB0YWdOYW1lVG9JbXBsKSB7XG4gIHZhciBjID0gc3BlYy5jdG9yO1xuICBpZiAoYykge1xuICAgIHZhciBwcm9wcyA9IHNwZWMucHJvcHMgfHwge307XG5cbiAgICBpZiAoc3BlYy5hdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IgKHZhciBuIGluIHNwZWMuYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgYXR0ciA9IHNwZWMuYXR0cmlidXRlc1tuXTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGF0dHIpKSBhdHRyID0ge3R5cGU6IGF0dHJ9O1xuICAgICAgICBpZiAoIWF0dHIubmFtZSkgYXR0ci5uYW1lID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBwcm9wc1tuXSA9IGF0dHJpYnV0ZXMucHJvcGVydHkoYXR0cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY29uc3RydWN0b3IgPSB7IHZhbHVlIDogYyB9O1xuICAgIGMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSgoc3BlYy5zdXBlcmNsYXNzIHx8IGRlZmF1bHRDb25zdHJ1Y3RvcikucHJvdG90eXBlLCBwcm9wcyk7XG4gICAgaWYgKHNwZWMuZXZlbnRzKSB7XG4gICAgICBhZGRFdmVudEhhbmRsZXJzKGMsIHNwZWMuZXZlbnRzKTtcbiAgICB9XG4gICAgdGFnTGlzdFtjLm5hbWVdID0gYztcbiAgfVxuICBlbHNlIHtcbiAgICBjID0gZGVmYXVsdENvbnN0cnVjdG9yO1xuICB9XG5cbiAgKHNwZWMudGFncyB8fCBzcGVjLnRhZyAmJiBbc3BlYy50YWddIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHRhZykge1xuICAgIHRhZ05hbWVUb0ltcGxbdGFnXSA9IGM7XG4gIH0pO1xuXG4gIHJldHVybiBjO1xufTtcblxuZnVuY3Rpb24gRXZlbnRIYW5kbGVyQnVpbGRlcihib2R5LCBkb2N1bWVudCwgZm9ybSwgZWxlbWVudCkge1xuICB0aGlzLmJvZHkgPSBib2R5O1xuICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gIHRoaXMuZm9ybSA9IGZvcm07XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG59XG5cbkV2ZW50SGFuZGxlckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gc2xvcHB5LkV2ZW50SGFuZGxlckJ1aWxkZXJfYnVpbGQ7XG5cbmZ1bmN0aW9uIEV2ZW50SGFuZGxlckNoYW5nZUhhbmRsZXIoZWx0LCBuYW1lLCBvbGR2YWwsIG5ld3ZhbCkge1xuICB2YXIgZG9jID0gZWx0Lm93bmVyRG9jdW1lbnQgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGZvcm0gPSBlbHQuZm9ybSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBlbHRbbmFtZV0gPSBuZXcgRXZlbnRIYW5kbGVyQnVpbGRlcihuZXd2YWwsIGRvYywgZm9ybSwgZWx0KS5idWlsZCgpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudEhhbmRsZXJzKGMsIGV2ZW50SGFuZGxlclR5cGVzKSB7XG4gIHZhciBwID0gYy5wcm90b3R5cGU7XG4gIGV2ZW50SGFuZGxlclR5cGVzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIC8vIERlZmluZSB0aGUgZXZlbnQgaGFuZGxlciByZWdpc3RyYXRpb24gSURMIGF0dHJpYnV0ZSBmb3IgdGhpcyB0eXBlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwib25cIiArIHR5cGUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRFdmVudEhhbmRsZXIodHlwZSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX3NldEV2ZW50SGFuZGxlcih0eXBlLCB2KTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBEZWZpbmUgc3BlY2lhbCBiZWhhdmlvciBmb3IgdGhlIGNvbnRlbnQgYXR0cmlidXRlIGFzIHdlbGxcbiAgICBhdHRyaWJ1dGVzLnJlZ2lzdGVyQ2hhbmdlSGFuZGxlcihjLCBcIm9uXCIgKyB0eXBlLCBFdmVudEhhbmRsZXJDaGFuZ2VIYW5kbGVyKTtcbiAgfSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2RlZmluZUVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIERvbWlubyB1c2VzIHNsb3BweS1tb2RlIGZlYXR1cmVzIChpbiBwYXJ0aWN1bGFyLCBgd2l0aGApIGZvciBhIGZld1xuICogbWlub3IgdGhpbmdzLiAgVGhpcyBmaWxlIGVuY2Fwc3VsYXRlcyBhbGwgdGhlIHNsb3BwaW5lc3M7IGV2ZXJ5XG4gKiBvdGhlciBtb2R1bGUgc2hvdWxkIGJlIHN0cmljdC4gKi9cbi8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovXG4vKiBqc2hpbnQgZXZpbDogdHJ1ZSAqL1xuLyoganNoaW50IC1XMDg1ICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2luZG93X3J1bjogZnVuY3Rpb24gX3J1bihjb2RlLCBmaWxlKSB7XG4gICAgaWYgKGZpbGUpIGNvZGUgKz0gJ1xcbi8vQCBzb3VyY2VVUkw9JyArIGZpbGU7XG4gICAgd2l0aCh0aGlzKSBldmFsKGNvZGUpO1xuICB9LFxuICBFdmVudEhhbmRsZXJCdWlsZGVyX2J1aWxkOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICB0cnkge1xuICAgICAgd2l0aCh0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IE9iamVjdC5jcmVhdGUobnVsbCkpXG4gICAgICAgIHdpdGgodGhpcy5kb2N1bWVudClcbiAgICAgICAgICB3aXRoKHRoaXMuZm9ybSlcbiAgICAgICAgICAgIHdpdGgodGhpcy5lbGVtZW50KVxuICAgICAgICAgICAgICByZXR1cm4gZXZhbChcIihmdW5jdGlvbihldmVudCl7XCIgKyB0aGlzLmJvZHkgKyBcIn0pXCIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHRocm93IGVycjsgfTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL3Nsb3BweS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogcmVxdWlyZSgnLi9DU1NTdHlsZURlY2xhcmF0aW9uJyksXG4gIENoYXJhY3RlckRhdGE6IHJlcXVpcmUoJy4vQ2hhcmFjdGVyRGF0YScpLFxuICBDb21tZW50OiByZXF1aXJlKCcuL0NvbW1lbnQnKSxcbiAgRE9NRXhjZXB0aW9uOiByZXF1aXJlKCcuL0RPTUV4Y2VwdGlvbicpLFxuICBET01JbXBsZW1lbnRhdGlvbjogcmVxdWlyZSgnLi9ET01JbXBsZW1lbnRhdGlvbicpLFxuICBET01Ub2tlbkxpc3Q6IHJlcXVpcmUoJy4vRE9NVG9rZW5MaXN0JyksXG4gIERvY3VtZW50OiByZXF1aXJlKCcuL0RvY3VtZW50JyksXG4gIERvY3VtZW50RnJhZ21lbnQ6IHJlcXVpcmUoJy4vRG9jdW1lbnRGcmFnbWVudCcpLFxuICBEb2N1bWVudFR5cGU6IHJlcXVpcmUoJy4vRG9jdW1lbnRUeXBlJyksXG4gIEVsZW1lbnQ6IHJlcXVpcmUoJy4vRWxlbWVudCcpLFxuICBIVE1MUGFyc2VyOiByZXF1aXJlKCcuL0hUTUxQYXJzZXInKSxcbiAgTm9kZTogcmVxdWlyZSgnLi9Ob2RlJyksXG4gIE5vZGVMaXN0OiByZXF1aXJlKCcuL05vZGVMaXN0JyksXG4gIE5vZGVGaWx0ZXI6IHJlcXVpcmUoJy4vTm9kZUZpbHRlcicpLFxuICBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHJlcXVpcmUoJy4vUHJvY2Vzc2luZ0luc3RydWN0aW9uJyksXG4gIFRleHQ6IHJlcXVpcmUoJy4vVGV4dCcpLFxuICBXaW5kb3c6IHJlcXVpcmUoJy4vV2luZG93Jylcbn07XG5cbnV0aWxzLm1lcmdlKGV4cG9ydHMsIHJlcXVpcmUoJy4vZXZlbnRzJykpO1xudXRpbHMubWVyZ2UoZXhwb3J0cywgcmVxdWlyZSgnLi9odG1sZWx0cycpLmVsZW1lbnRzKTtcbnV0aWxzLm1lcmdlKGV4cG9ydHMsIHJlcXVpcmUoJy4vc3ZnJykuZWxlbWVudHMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9pbXBsLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi9FbGVtZW50Jyk7XG52YXIgZGVmaW5lRWxlbWVudCA9IHJlcXVpcmUoJy4vZGVmaW5lRWxlbWVudCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIENTU1N0eWxlRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL0NTU1N0eWxlRGVjbGFyYXRpb24nKTtcblxudmFyIHN2Z0VsZW1lbnRzID0gZXhwb3J0cy5lbGVtZW50cyA9IHt9O1xudmFyIHN2Z05hbWVUb0ltcGwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihkb2MsIGxvY2FsTmFtZSwgcHJlZml4KSB7XG4gIHZhciBpbXBsID0gc3ZnTmFtZVRvSW1wbFtsb2NhbE5hbWVdIHx8IFNWR0VsZW1lbnQ7XG4gIHJldHVybiBuZXcgaW1wbChkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbn07XG5cbmZ1bmN0aW9uIGRlZmluZShzcGVjKSB7XG4gIHJldHVybiBkZWZpbmVFbGVtZW50KHNwZWMsIFNWR0VsZW1lbnQsIHN2Z0VsZW1lbnRzLCBzdmdOYW1lVG9JbXBsKTtcbn1cblxudmFyIFNWR0VsZW1lbnQgPSBkZWZpbmUoe1xuICBzdXBlcmNsYXNzOiBFbGVtZW50LFxuICBjdG9yOiBmdW5jdGlvbiBTVkdFbGVtZW50KGRvYywgbG9jYWxOYW1lLCBwcmVmaXgpIHtcbiAgICBFbGVtZW50LmNhbGwodGhpcywgZG9jLCBsb2NhbE5hbWUsIHV0aWxzLk5BTUVTUEFDRS5TVkcsIHByZWZpeCk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgc3R5bGU6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fc3R5bGUpXG4gICAgICAgIHRoaXMuX3N0eWxlID0gbmV3IENTU1N0eWxlRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgfX1cbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIGN0b3I6IGZ1bmN0aW9uIFNWR1NWR0VsZW1lbnQoZG9jLCBsb2NhbE5hbWUsIHByZWZpeCkge1xuICAgIFNWR0VsZW1lbnQuY2FsbCh0aGlzLCBkb2MsIGxvY2FsTmFtZSwgcHJlZml4KTtcbiAgfSxcbiAgdGFnOiAnc3ZnJyxcbiAgcHJvcHM6IHtcbiAgICBjcmVhdGVTVkdSZWN0OiB7IHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5jcmVhdGVFbGVtZW50KHRoaXMub3duZXJEb2N1bWVudCwgJ3JlY3QnLCBudWxsKTtcbiAgICB9IH1cbiAgfVxufSk7XG5cbmRlZmluZSh7XG4gIHRhZ3M6IFtcbiAgICAnYScsICdhbHRHbHlwaCcsICdhbHRHbHlwaERlZicsICdhbHRHbHlwaEl0ZW0nLCAnYW5pbWF0ZScsICdhbmltYXRlQ29sb3InLCAnYW5pbWF0ZU1vdGlvbicsICdhbmltYXRlVHJhbnNmb3JtJyxcbiAgICAnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2NvbG9yLXByb2ZpbGUnLCAnY3Vyc29yJywgJ2RlZnMnLCAnZGVzYycsICdlbGxpcHNlJywgJ2ZlQmxlbmQnLCAnZmVDb2xvck1hdHJpeCcsXG4gICAgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsXG4gICAgJ2ZlRmxvb2QnLCAnZmVGdW5jQScsICdmZUZ1bmNCJywgJ2ZlRnVuY0cnLCAnZmVGdW5jUicsICdmZUdhdXNzaWFuQmx1cicsICdmZUltYWdlJywgJ2ZlTWVyZ2UnLCAnZmVNZXJnZU5vZGUnLFxuICAgICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJywgJ2ZpbHRlcicsXG4gICAgJ2ZvbnQnLCAnZm9udC1mYWNlJywgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXNyYycsICdmb250LWZhY2UtdXJpJywgJ2ZvcmVpZ25PYmplY3QnLCAnZycsXG4gICAgJ2dseXBoJywgJ2dseXBoUmVmJywgJ2hrZXJuJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFya2VyJywgJ21hc2snLCAnbWV0YWRhdGEnLCAnbWlzc2luZy1nbHlwaCcsXG4gICAgJ21wYXRoJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc2NyaXB0JywgJ3NldCcsICdzdG9wJywgICdzdHlsZScsXG4gICAgJ3N3aXRjaCcsICdzeW1ib2wnLCAndGV4dCcsICd0ZXh0UGF0aCcsICd0aXRsZScsICd0cmVmJywgJ3RzcGFuJywgJ3VzZScsICd2aWV3JywgJ3ZrZXJuJ1xuICBdXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvc3ZnLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhcHAnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2FwcC5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vYXBwLmNvbXBvbmVudC5jc3MnKV1cbn0pXG5leHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvYXBwL2FwcC5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFTUFBQUFUQ0FNQUFBRDhta0MyQUFBQmtsQk1WRVZ5VkRaeVVqVjBVeldNWWpsL1dqYUVYamFEWERoNlZ6aUhYamg0VmphUlpEaDZWemlGWFRoL1hEZkp1WnVEWERoeVVqVnNUemFEWERaeVZEWi9XamJqMjhGK1dqalZ5cTU4V0RpSFhqaUJYRGFBV0RhQVdqaUJYRFY0V0RmUHdhVjRWamFMWURoeVVqYUhZRGgwVXpWK1dEWjZXRFp3VWpWOFZqZHNVRFI2VmphRlhqaDlXRGFFWGphTWJFbUJYamJiMHJkdFVEVnVVVFYvWERpdmwzZkNzWk9KWURoM1ZUVnFUelNJWHpoNFZ6aUdZa0RMdXB5TlpEaHFUalNMWmtDQ1d6V0RXemluajI1dlVEWjJWRGQrVnpadVVEYUZYRGFEWERYZDA3ZXdsM2lQYlVpS1pVQjJWemFOWXpmVnlhNlJZamg5V0RpNnBvaUxhVW1QYmtpOXFJcUhaRURRdzZXUWJVcUJXalZ2VURSNFdEaDJXRFowVmpadlVqZHBUelNKWkVCMlZqV1Ria3BvVFRaMlVqYUVYRFdZZGxLTVlqbHNUalNWZFZHaGhXV3hsM2FxajIrQldqYTFvSCtWZGxLZ2htYkJzWlBGczVQQnI1S21qRzJOYWtpamhtV1NjVktRYmtxYWZGdWFmVjJOYWttUGJVcUpaVCtOYkVxbGpHMmpoMmExbjRHVGNsT3puNEcybjRHZGZsemtXK3JYQUFBQUMzUlNUbFB1N3U3dTd1N3U3dTd1N2xONGVnd0FBQUw0U1VSQlZIZ0JwSS9uYjlzd0ZNUUpkS0JvSDBtQjRxaElDWUp0S0NxcXlIWThEQVJPWUR0N0JFbWEzUzlGVWFCNzc3M2IvN3VQVGxMMGUwL1U4WGQ4UndFaTIvOHZjbkZpS1FpQ2FqVUk4eUN2QnJsblBNQmNSY0FZQnFnUUV6cEczSEprYk9XaG4rWGhOcGxkS0dlUHRibnA3Uytkd3ZnZG4vOXJKeWRJclZseUpvenY5bnE5U21XNmd0dDB4VHNLY1J4UEFRMUx5Q2MyamJQamNxdENlcUd1RlJIVWFvWGZvcWlHVkhoRGoycW4wYThJSDF5QWpJTG9wTmVxa1F1QmpJb1NBRW93U3FuREFkeFNxSmtvWXFzQXk2c3pVQXdZNWdIY1VRTlkzbjlSSHM5aHJBTDRQSkFvdk93Sk5USkhNRHBjNDBmR1I0QVo5UTErSzhaNWwzRmdYUTdtRWVlcmIrQ2Q0WUtQQURqV3ltWGVBbkl1dUNMRVVLQ3NXZWM4WFd0OE1vS0xsY2FJcGZ2aVY4ckVocm9wdkEwZmRzWFQ1c1p3M1lnVnZNRTUzcm05UXBkS1V1WVRqZVI2SW13aS9MK2tuNU05aFZwcldOWnBOcG9kWnRkTjhsZ0lzNWZjYjlvbjNZYXRLMVRISmphaElxRjJ5cEx6Tnk3RnNpMjFwRzFUcjVzUE5QNWl0Tlp4ck5sYytqT2RZL1JBOVhYY1I5UHBnL1NabG5WRGFVeXhJdHM2Ym1kVGJSSzNKbUlxcFYrbVR0ODNEN0FqcVk5czdydnE0RGYwYzJZcFk1VFNEbXRLaW5ORXE2bTBWRXVxcHlnNU8zODFjeGxxTWR0Njdkek95K3lqUW0xSnlWNjlWVCsrTWlmN1RDbld6NXpiVlR0Wk5yazduanZuRnErNVJlZnV4V1J5YVVILzZWTGNWYU9IZ1NnOGRoUENOQnJjcUJKaUVVWVNicmF5Y2VIbVQ3dEYybHdJSVhuL1o4Z251VEQ4WjBibmNrYXFtdG5jMXk4NVo0OTZxdGRtMWZ0bFdid3UzdnZjb0p4cCtReFpscWY3cDFhZFZZTnFyYW96R25WSFkxRGlYS1BXVUhVUGRLMnFuQkR3SGhSakt1RStQVUJvRkpuOTlQSGpFV0prVzBRNG5QZVdpZGh3WmxONUxoUE5OK2lFckF5Q2FSVkVnVFFnUGE1cjdMZElaYXU4MkwrYnU0Rkd6alc5NEM3NXI3M016NitNYjNac1Ztd3JtOW5CbG9PaXU4TUs5dWdWd0RUaXAzSHY3Z3NxU1VUU2tNUU5UaVk0alVsSTU0ejlEWk5NdkRUQ1F4cGMvMDJDbVpIMEJ6WG16UGQ1WnpaUEFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vd3d3cm9vdC9pbWFnZXMvUmVtb3ZlX0J1dHRvbi5wbmdcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUY0QUFBQWJDQU1BQUFEQ21jaURBQUFCQ0ZCTVZFVk9QQ2RHTmlSQ01pQktPQ1JJT0NSRU5TSkVOQ0pBTWlCS09TUS9NQ0JETkNKTE9DVklOaVJKTmlUUHhhdEtPU1pnVURwRU5DR2xtb0tSaEcxQU1DQmZVRHAwWmxCVlJUQmdUenAwWlU1cFdrU1NobTNqMjhCVFFDcFlSQ3hRUGlnMktodGNSaTVXUWl0U1BpbE1PaVkyS1J0VFB5cGNSeTVhUlMxVVFDcGVTQzlOT2laUVBDaFNRQ203c1pkWVFpelowYmZQeDYxT1BDWlVRU3JqM2NHVWhtNTJabEJiUmk1V1FpcE1PeWhYUmpCVVB5cGtWRDJUaFc1dFhVYXlwNDZBY1Zxd3BZMkplMlN4cDQyZWtYckd2S05VUHlsdVhVZGtVVHpGdTZHZGtYaGNSaTJUaDIrVmlXNVdRU3BXUlRCclcwYUxmbVZaU0ROYVNES0tmR1IvY0ZxTGVtUmFSeklUYXc3OEFBQURsMGxFUVZSNEFiUkxPMjVETVF6elJhUmFLdnl4QWNQREcveUE3RmtDOVA3SEthVUVXanFYRGo5aStOSnMwa1NnWUdzeVo1dFRHZ1FxQUJ6OUMzL0IwWXRsVDk2KzhCd3luUk9FeUhzNjB6bTlINGhJLzZRaklBVGRnWHRuN080T0g5dkU0YlZnRUpWMG5GaWQxSHZKUUxFSGl4Z29BTXlKOUJjbDFJQkpvUGZFblBtZlVKZ1RhMVpncS9MTmUvTm1jOGJKYXMvbFpneTI5YmYvYngydzkxYXJVZUcrTWJFdjJSWGZsRnVUYWxHOU5PRDV4enpPQ0JjSWRacEVDdUIwOFYrK05BM29COE00b0Vhb09ZeWdGSXN3S0EzZmV3NVFwSHlOVkNuWFZldWdCMVVEUFo5MlZWcUxDT1pjTklqR1F2WUhOM25VK29DQjJQdmFPK2dDaVRKUitscDV2Zkg5UytlNHJqWU13MUQ0UE1JZVFFT0dlUHZqMURnaENTVDBmcUZOMk9qdWUvODNtZVFKMmtIM3VWSjFGQjNaczBMUy9VVnhibDNRVHl6bkJvL1pJTmhJdHNwaUZJWGpvbUJSdWxDU0ZqWW9GOHlKR3FKWDFZZVZOdWVSaUk3emhwNExvcWhQVURlejJYVWsxM0tENHhtNGRDV1hyRWlHRlJwbFRsTmszbFZseWN0RTM5SS9ITjdlcTQ3M1ZYa2FqemFwdjJ0TXkyS2dkaERZUXFpbDR2eXZ0QkdJRThEN2o3UUdsdFRsejIzVnhWTWV5L0l2ZFowN0QxQWNiSlVSY0UxTFJCRkNHallyWUV1b3JWM0JqUC9oWUpmY0p2eStQZ3hqQkQ1MzJDYmdpNEFld0tJYTBsTWV5aEs5WmcwVFdqdE53VUh4UVVKUVI0QUtLWHI0UmZSb0cyQkRSRTNuMS9UaVE5RDFXS1F6REsvQVo1dmFWUUV1ZVBUZWVhT1hjMDNRTkVWL0hrZC9sNlFlSnoraytGTm91V1M5RFVJeG1MZXh3WGtrZlpjQkE3eUFudE5OdFB0ZlVIVUZ2Yk9lQ2l4L3VvZy95ZXdmbjIrZnhtL2tIeSs5b01KQXZjdEhsajVLa1FRdjlKRUI4b1o5YWRDdmI0L1dYdVhkMnZmeDlZWmY4ZmpZMm52Y2ZyYkNKaVJYY0JHN0RDTDhLdG5rZTgvWnkxYnpHWWFPd0VCRTFkOHpKQ2F6NGpFZnd2SmRvQ0VYUWVzR2xFdjIzV2ZqdytWVmdaczI0VlJrMHRaSm5yNHc2Tld3aXQxN0U4SVZSR2ZscTBKbnJlRU16Q0pQckd4VTRwcE5uRk55WmRTVGZnWVQ3TVZvNlhoYklJME1DVFBvS2JseXFJYlozMGExODFLM3dVVGJZN1FXV3hUWG95bkdPWW9rUFVYUUd6cGYwc29WcllteG81cVNiQlZRVXRJRXcxSlBpVVRRS2tQU012K3dTZWs2VW5vbUdIWTZqaU05SjNCRWxMV3lnbENpNW9UU1F6NzlTTWE1VHVrL0F4cUJsMFE5MG9PMVlRcnpnVFRDblRPYlcxTFErSi9Cdnd2YnRnYWIyYlo5MjkwdXZ0T3hJQml5SUJOdGxsWnlRT2dEKzJ3NzJGeExvRDlGL3Urb2NqaUYvUUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3dyb290L2ltYWdlcy9CYWNrX2J1dHRvbi5wbmdcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUY0QUFBQWJDQU1BQUFEQ21jaURBQUFCR2xCTVZFVTJLaHRFTlNKQ01pQkdOaVJJT0NSRU5DSkFNaUEvTUNCRE5DSklOaVJKTmlSRU5DRkFNQ0RqM01GTU95Wk9PaWRNT2laUVBpaE9QQ1pQUENaU1BpbFVRQ3BXUWl0VFFDcTdzWmVVaDI2bm00UFowYmRTUUNsS09TUTJLUnRlU0M5Y1JpNWNSeTVVUVNwWVJDeFVRQ21LZkdTVGgyNmRrWGpQeDZ6RnU2S1RoVzUyYUZCVFB5cEtPQ1J0WEVaV1FpcFlRaXhQUENoUVBDaGFTRExGdTZGa1V6MjhzcGhNT2lpZGtYcWVrWHFIZW1PcG5ZVnFXMFoyWmxDSGVXTjBaazlXUmpCYVJDeGZUenFKZkdSK2NGbXhwb3lCY2x1VmlXNWJSaTVWUUNwY1JpMTljRm1SaEcxcVcwWFB4NnZPeGF1enA0OWtVVDFnVHp0alVqdGFSekYwWlU1S09TWlZSQzk5Y0ZwWFJqS0plbVRGdmFONGFWSldSVEFwNXIzYkFBQUR5VWxFUVZSNEFiU01QVzRGSVF5RWZZV1YxdEFnL2tzazlncXZ5OHY5RDVRWkJ5S2hOR2t5R21QN0d3dEp1UlJ6VHFXa2tuTzJOYVVWZ0paUE1nQmtNSmtKRzQ4TUE4SW9YcEFhVHZKeEtuL2IycUVETUQ5Ukp2eDlJZTBsVWFqZDlyaHI4N1hBT3prVWorTm8vZFdrd2Y4a29aMDRxTkVQR01vMUZKNXB6Znc0QkNoaU54MEJCRGJkT2lkQTR3OFAvOEFZWGNQZjBWSFYzb24rRjFXNkhydWJlOXJmQ0Z3MWR0V3VGUXAxdjFxVnBIUHMySXdzak03RWNwdDMwam0vU1kyb2hDcmV4ekc4VjYvREQ4aXJvanhFREVNQmVmQ2RPNkVoTWo4NkpwVCtuT29hQWtyR2tCQmcwN1dlRzc0dU5HNm43cHZrM2h2eU5YL1JPRjFMYnNNd1VEOEFFQ3dQTE1lOHFjaU9QZU56dno1WExnL3B2Zi8vYjJRUmpaY0xDc0FDSzc3VTJXQlB3blNyZHdpTnRjR3FwNTdRRXZBaEJLSlhZVWZEMlNXUnBpSE1SNkppSWYrQmRvblpOU1Vid25vSGZiM0ZoVzRBenVBMlBhUUp0ckZLeFFweGpqTW0yMUpyVTdGMlRjK0l1YzIwdE51UzdaS3MvWDIwMEZlWVRXWEVTaitlYjh2SDFURmFtekxXVjVCV09LQjZlOTk0NTczVjhJcVl2S2ZrMndFNXpSSFhmazVMbjhvWDc1MXpNVG5Ya2djMno0VFdNZXFpU3pzWWdCNzN5YXFaYU5CQTEwd2E3RnRZd3Q2ZDdQUEd1eHlucVVnS1pNdlJsMlQ4NTJIemdLMkVKbjZzSSt6VXlualh1UDlrWnNkR25ORVA2LzdNdUhaQVRYTjJLQWNvT2VJVjBHUG4rSUZZK05CeGZqTE91RVBKaGp2OFhRZVlsU3lHalhuQjZnMENJcXhONGRpeG9oMlEwL1VlY1lYZm1VTmgzdStOeEJuekw4SndJYUx5RSsvaFQzVEZzNGlFV1hCQUFFTERNdGtMVDZFWWU5SGlOZDF5UjNmeWx4NjVML2R5UzUyOEplWk56K2d6WHp3eDM5RVBmYzBqN1B2SVBNdkNjckxIcmQ2MU5sSVhVbXVWK20waGNrTjBJYktvaTB6SXF1QlR2NytuRzNtRCtwMWNFSDBWb3F4amk0aWlSM3RXNzBuUjE0cFZKVkNsVWFwOS9WZlhHQmhYRE1JdzFJQWhnWFNGc0FIci9QMUhxYVQ2Y2pTOTZwdm9TWmo3OTRMdzRVQWY3TEc4UC9ockxwT0Jhc20zT2hvQ2FyeU9GMkM4bHVabjJjSkE3bVBkdmdaNThNc082RUhBSUIrWUlWcVBVTGkvZG4ydVllNFlhQXdQOWM3b1hjeEhNdFpMb0RvME9ybVB2cGhpTDdEUDBhMjRNUldOcUlnSmdkR0hvUmQwa0dzQWZYdW1QMkF5VENtenBJUkxIU0ovb2FqallxOWlhUzgwc21pdEZFdHAxcHBTNHBHWW5od1dYbVY3RTEzZEF0T1B6MVN0Vmp0cnZTcDBudldrWFNSSmhlenhwOUkzR28xT1hDbFpQZTNLYzlxMG1FZDdlRjB3L2QyUGNtNDQ4MlV0aDFxY0xiNExudi9VM2tsbXg5RmF5emdIaGdIbkNLS1JNaXNPMTZMOUVqUVlleTVrZlgvckd3eTAwL2lrMzRlZkFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vd3d3cm9vdC9pbWFnZXMvUHVyY2hhc2VfYnV0dG9uLnBuZ1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTm9BQUFEYUNBTUFBQUQzdzZ6cEFBQUNjMUJNVkVVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQk1hWEVBQUFBU0NBQWlHUThoR2draEVRZ1pCZ0VZRHdrQUFBQUlBUUYyYTJGclkxd3NHeEE2R2dXOG1uSWhBd0xlekxpY2QwQXJDQUl3RUFMcTE4YUxnM3lsaFUzWHZLaUhlbkI4YzJnWUZBR0taUzlqWGxpWmVWcUVhRkd1akZVekFBQ1VkRHltaUdSNlpFcnczOHJleUt4Q0JnS1VqSU9lbEkxQUlBOU5NU1dHVnkzcDFieFRRREd0aldsUEt4V2JnMloxVjBhcW5KRmpUemQxYkdvdkh4czFLaHlhaFhkZ095TndYMUt5ZlYwNkNBSzJqMm5YeXJPUWFqeGFTVFJzUHlLR2NtVG16YmhkUURQMjd0RFNyM2xBTHg1Z0xSV0ZWMFJESFFjeEdBZkJyNWxYSFFYQ25wQ25lVWxLUEMyVWNsSEx1S2gzU2lqWnRwaVpaak96akZaclUwWS9IeG1XZUdsd1NUVlFDd04wWVRWbVptYmZ5Wm1NYVZQT3I1aGpVMFU3THlxMWVrYlp3WXV2akhlK2pWT3BlbHl4cEpld25HUjhmSGZHekxlWWgxT2hrb0FZQnhPOWoybHZVemZVb1hEWXNvaTluMmJKaTFkYlYxUUJLaW5PcklaeUxoUjdDQVNWVnk2ZGpIOW1JUXpNbVdaMGRHNWRNQ2laQUFEVnhKaXVxNmQzV2lpVWFWR3lsWHYwektxMm5vREhvR2pGbzRDK3FIUGd2NW5BbFhuRmVVdUlSU1c5dEt0NFBpRkxTRVpDT2pLNWFEOUpTRGxaVTBmRm5IUTFOeEpWVUVlcFdTK0xNeG1mcDRHbFp6MmxiVXkreDZhY0RnZVpTQ1ZOU2lTOW40QnNFUVBHTkFkWklSZ3pNek9wdmFlMFlqSzN0cElqQlNRU0FDaHRpRzRObVpROEVqT3dTaW9TTGlVd0RpVUtRRHFjSGdYZmVGaFJiMWk5VkN5NU1nd1BXbGRSVTFmeU5TS3JMeFduSVJWQUhERGJhVHpEU1J5Z3NwRVloSUFmVDBSVHBaWUliR2R1dGFmcVJpTHFWVHN5ZzNkVWgzQmlzYXRxNTZuSkFBQUFDWFJTVGxNUlpsVXpkeUtJQUVUeUJrTm5BQUJPVGtsRVFWUjRBZHlWU3c3RE1BaEV6ZkFwWHZUKzF5MURIZVVNWmp4R0VWazl2WVhYNTJTeEk4Wkx4Tkh4R1lNaEZtL3YzTlZWWnd3Q1BtakZsUld3dkxoM1ZMVGhpRWF5QkVUc2Y2cFhId0d5MlJvdElURW5abVJyYTY2UVBTb0NkVnFqdE5qN082aUJmTkFrdU5qbnovM2ZJWVhHS05GR2FTczBiV3VhWm5PY3NTSG90ODA5TGJpWTA3QzJ0bWd0SmpsN3JSSE56dnJIYUJudTJJN0NNUGgzWTllMzBqd0I3LytTZXl3Ym9YTzNzOW9VU0thRVRyNlRRRHNEVGdTeFFjeVJBYVdQcDY2SzVIbXU0WUFVUVVJa0tYZlZBRE9JMU4yYmNHZGNJNzN2NWo0Z0JnUFNpZzFwdHRRNllvL0NKV3N1eU04THUvZUdwQi9ucGIzK2VocDFyWStycnV1RCtId01ZQUNTeXkyUkFSQW9zMERXQ1grSjhrREpFd1h4eFRwN0xZY3cyTURSd29BQ3A4MmMwelh3WkdJbDdFWmV5Vit6OWxXUUJOV0ZYaVZpM0lvS0sxRTcvOWRqTmxvZzBJNmcxK1VXRzcwNUZrVzVLYnllVkxtYWFGanRXeWdWaHd3cWVtdU9oVjZUa1VBb21yWHZnbXoyd2E2d1p2bElEbHhRTGNYck50cWwvT1lDN0pYVlEzR2RZb1RvZVpJbGI5VFZuc0dlb2dmWWpCcmFuZHdFVFYzOE16OGJsT2h2M3F4OUZXUzNWNHV2bWMrSUZJQ29PM3YxMWgyMGhzbnBOb2t4bkpLZVpGYVJSSjVkcVkwYVVIaGFuRjNPaVcwRmE4NGsyUElSYkdRdkorUTFYbkpXYkRNTEJacHMzZDVuejZldjU3bVYzNWRLWUtjNEdpWGJsWUxndFBDNkRLblpwcDUxb29Ob3Q2cmQ0VWlEaTFpSDdQV0VCRnZDUkhuU0IzMHlLT202c1k4UlhUejVZRzE0c0hJSEdJbVdyMFhSV3ZselY5aDVSc0JqRUNtQkJCR1ZXb1YxNDdNNWt3VDk2NFMwbkg5RldVbmtKVkZHaWRqejBmVlkvcmdpbGZtUGgxRVZ2K3hHTzFzLzE1dDRWbHBad1BSVVl5R0htQmdGTnhqUnlSa09JeFA4czlkZVRzam50eWowOVplYllzVzJqbElRbnllUDZ1TjBiNCtDNzlVck0wZThJazg0N1gvTG4ySjhuNURoSFdCTytSMTVyZk9mWTh3UDZnQlExeTAzWm11cXJ6T3gwdGVDTG5GUjBncHVhV3RzemhlcG81Vyt4UWp1N3lma1pJZWNWMENxM0wyMS9RWmVzSkN0Vy9mUzV5SzRzckZXS1BjTDBNcjNiQjdwbitjRXFqWGR0dlJvSTNzeFlWVlBycEJkYjkrUVlDL01lWDlNT25iSmIvU3FzZ1dhUmpNWjcwVUxReVliRkE2QnBRU1pDdnNTNDdjazYrUTRjMTJ4eWVlRXRjTnAybjc1aGh6N05GcTJGeVV0dk9mKy9wTnBXcndrZzNtYXBFSVlmVWFKdmNwTnRhTVpvczVwRzNvL0JVSVIwNmJCR0hGQzl2b05lWkpnNlFIODlrbnFtZkp5UXB5QlREV3lQMldxa1hDWHRaV1lPazArN2QzRXFGVTQ1OVcrMllqbzJFY3hLdGQvbkpEWk5LZDJ2NzRxeWxhSlU2L0RpK1puVnpLWER0aXBSWHlONWExSFM1NDBhaG0rYVFDM2Fibzh0SnBNOFErZjFxOGp1ZXAwNCt1cUpiSHFBVnJDQVdRdEdkbENKa0lpSTdXakNWdXoyVW9iK0NXK0Y3akI3MkUvQ2xOTnQrN01ZTGZObnpXdVErSERLV2JmR2JKUFNGRTFyMnRJazhlWGg4WTh6M01PZXhpR2NaOWJDZ1BDNzNKUDg3OVZCVzdja3ZNK0FvWjlsclIzSzE4cU4wQVlyK3dJdGY2M05LZmF5bFp3aDN2SU81c2duOXViOUd3azF6ajBLNFpzUXlGRDNzVTROUDBaL0tTMW5xYkhDa09ZOUZJT3ZSeldEMnJWbkQ4SFZHT3lqNy9MTVUxVEhqQS9GdDMrMlJTZTQyNjVpaXYxWTgySTRjSDVhUnNtdmllMDNNSS92Zko0d0w0ZUpXOGYwZ1BnNnpIMHM4SDRVa05XQ0NCT3EzMm8zZ1dNQmNBR01COU9oMUp4RWswRjR1SjBRc2hFTVE4S3hnOXRwb0NiZGM3elFCbWlHUkJuWjFLUE9CT1JoaHVpamNhT0NwVW1zbGpLbm1KQUtEZGFFRlIyYmdycXRrOG1JWXplR2Qvb1U1YVFwc3Fmd3F4QStKNGhKZjZzMXdFNWgzM0p6anJhMnJvdW9aUm5WNG80cEJpbkRVWkRodWVQWCtKUmU3SHg0TmNlNUhZRXdPQW1RR2g4Y1hmMHFLVG5hTW1vY1AwVHE5bXpNeU1nY0RPN2F5V3pvNXFjcSs0S3hnK2RHaFVpdnBKS2o5ZSsxSkREUzl6K1JJbGRpK3lHam4za1VzVyttL2hSN3J1alpSekdwVnhoQ0RyR2YydnJxSFdBQVNjeUdjWTl3S20zcG1jUnN5RmJKYU1oc3l1OGZVU1hGRExrMGdmVVpnQUVIM2xZTkprMVZBU3ZzVnFMUlRyS256Vmt3L1FhTUw5aEM0Yk05RG1IN1lwaUtqVFlyS05qZ0FwdGdObVFHYS9CeVROYllBdTBJZHM4YkFDdGU0UnM0c1QzZVNFWEVQRjBibVovN21ZWkVaQ2JFU0U4L2p3UVlhVzQyUFE3dEljRjNQRGZKZUVIRFFuWU9aL1BXaGI5d1NCVEpHZTAvVWdiVzNsM1VYK21EMDB1TjJnd2ZFUmF1TzNKU0ZOMDArZWtkNUMxRUxGNlRYL015VDlpL1JDaGVnMFFzbHNBbnMxMm1kZ2o0MEhSNmVQVDU2RlB3QTZLSzl0eXdCaSswWkFTeVFvUlBRT3Y1NUlmVGlKRzk4RTBjamZrRm0zY3lSOWU4OW9hU2Rkbm9JMklKVElsN2VLeFdwOE5kNkxOa3VwTXExN2p6RjI4eHMyTGlZc2ZGYUJLbWhqZGxNUkI4bXZBdVBKbmh2d0ZJblhrS2ZIODY2S1F2U05hVmtENDdlZ2hzMHk4NW9uMENFL3hNK0RFanZHRy9ickp3REcwQmMvL0kzY0g1T1NqUy96aUNnMnhOZ09HeFQxU1crM1RST1NPWElXV0hKMy9teGNaeG5jTTJmUmJId3loRTg0TXc3YVBkWVltaW5xcjM1b0ZsSWNLdEl2Y0NvenJ6WUhkYlpraGc5NXg4RWtNWXRzZmdBYzVPOWJsSlRtWEVMakhoY3RYTThJYzR6UU8rWGRWSnVOQ0pvbUE2Y0Q2L2w1Vkk5OXF5QmFaeXdhU0hLTDJkK3ZIQ3R4VUQxMDBNakJhK2RZUXFyMDFSTjgvNzZCZ2lpWlgyVHdmZTl1YWF3eUpJWksrK0h4MjdxTmljY3diclJtd2N1OW9iYTZ1U3RGNWJKdDlzcjY5Zm5ZSWpPRWJocFNOR2VIK29SWGszSTMrREtVMkc1cEs2KzZpZlNySW9PdTNOb1JJaTk4QXg5bGFkdWFEeVYrVjRzTnNvS0FpQSs2QUVWSFVhVURGWTNVRXdQQndPOXVjWFR6S2JiUjF4aC9HVnNXMU9wZkY3KytybWpqd2E0YVViWisrcHlZdXF3VlZLemNURit2bk5CbTl3Wmdlam83UDhYTHZiZzBWRTBxdTJLWFhsRDZPdGRSdm4zL0pUWDR1UmZkb3NRSGUwdVFZL3cxWGN2cnpmbE5xajhiNlpCZUxDbFZ0UHVlME12Y3EvSXp1K0VqengvRW5WUlFTUS9SRlN1QXhobTgwNU5OaE5UVWZEbnhwRzhGYTd5dUx2d1IxaVBuTC9uMUZDaDhtVWx4V2ZuVDB4aXphWjE3WnMzWkVwYlFZRjJlUTBHZ3FsVkZuaFlNbXQ1emNkMWpOb3FmNXhnczNOMWVHZEg0RWhidWJFMHRPbThWbDVXeVJXNGZGdHY2Z0laK2FuNVBFV3hKdzFpZ01FRGdOV091YWR3ZXNkZEJEUFdHZS9zMUtkUy9WTjBHVFRyZHlzRCtmMGR2elEwSlZYeTEvUFJFbzNGenFlOHpHdHYyZ0lWc0EyY25qalY0VjgwdzNyMlFyTWlWRVVnOEJnUXFiK1h4NWoyTjd3Q2VLQWw4VVU3VzQ0ZU96SWVHS0MvZFRZclVsU3REK3JDRUZtNHhydDFwNkJ3RmFLeGtxSXBlRVIrc3o0L1UxaU1zRXovZ0NyQUtXL1U0VS80aVZzcWVDb0dvT0JRcG5tazlmMW9FMlJzTVBHaExoZFhGdUlKbzJZbFJjSThqRUl0bnJyaGd1VDJHWk90QzE1MWRwckxBN3UxVVBQWXRjWm5RWEZnV0NFTEE2VS93R2NvalZET0liRGRrN0YvNUI2WUFoaWhNUkJMOXdjSjBzT01DVnJjaGU1OThvcDl6ZUV3d0tHemU4L0YyUks2QWhhd2o1MS8vZERiSDlPMGJXNVBGM0doTEV4VDEwR042TjVKOWNCU0MydDZzYlp4V2Y3L3V3YjhqZTNRall1cW1ZVkx2SWhIdi8ydUcxS0ZRaVQrRU5oZnkvMUpDZEN0N2V6K1gzdXY2NXZNVk9TaW5zVE5MaHliUGlNTWtDUHY5K295cmg4ZlhGVncwMVlJOGhyMXc5RWVBOXFGR3l4ZnBEbFAzZkpPVHl6bkN5MlhBTkgxeFRwTmIzM1V3WkJPelBTazZNZXBMZkwwUzhEZGdkOW5aVVdBMGhGL3IybThTV3pVUGY3RU1pQ2xmTEQ3QmprcXBHM0tKVitreFNmRUMxN3ZtRVFFRSszOEFKMitNTnkyNDZjLzVUYUlnMDc1ejJGdnUvZE51QUlnQzg3L20vVDBqRUo1NCtzUFV1R0NXRDBJSEpoNllhbVlsWjc0NnVEN0QzQUpvZkdVbEoxV25WYlRXOTcxWlZmM2RSMjYzaFUvTE5xVUwrMzJqSTYvSHVOK2xVVmlua25JUThjbE1WV1pNLzJJaTBjUW4ycm9SN3VqQmxPcjJJcHlKVDJFVzlyRE5WOVFnbnY4N0lGMlVoL0M5YnJGOXBTTlgvTHZNK0pQaDI2OENlNFZybk44RTI5SEYra282VW9PblM2eTl6dDE5OFhnekxqLytIRzJYeWlIeW9oWHJ0SjE4dVpGOXFTSVFYRGNIQjlId1NVVXc3MFk2Y1BUK3BwR05BUE1yZDVFUVV5aTl4clI2SFVxblpFM3VrbVBsMW95WmFrRGp0T0NRS2dHdkpqOXladVN0UGh4cUpGSkZ2V1ZUY1BpUFVGMUJDb2hOaEowNXcwQW1KamxxeWRhT0dabmlPRXd1dDd4bnlsWExCbldBVE9JL3JYN1FQMkdsSGUwSk1lTmMzVkprMjFCYjFxZmozc0xqUjdNMjRHV1N6ckRLSjMxaHFnaW5YVXJVakhPYkVUQmxOdUx1N3NtNUFGMmRsUFNhSHlzWEVXVyt5bWhJZ1pncG9OZmpJMWt3V3hvZzVsanFUdVhTUGRvaCtzUDQ1a3hTZ1RNaXZOU1NDRXZHa0xXZE1nblVCYTJHZEtoT2FkRTJjUUdGWUVoeWZOencrMFZyTU1jd3hBL0xoemVSL2NZNXJBSklCSEc2WXRWOXdwQVNvU21kcXBQbVhTWEcwNlphTUtsbTMyWVRhWDZzdnZ3Q25GZXV6WUMzN0pod0Zxd21saEFVeTZFbkNhMWw5S29qdjlpR2g3NGNGVFNlZzRYbkhwdHNUK1hFdWMvTkdkYW9jSGxCN3NFUnM4a2s2Y09OREwvOFl4NlRsUzgzZ3I5WTFaUnJoYnN6OWRuanVLdDBNSHBOUFdLQ2hVY2QwcGh2ZGI1NU1IVHVlNHd4dFFMRC9Jd29RampGNkhkQmF3SjJxZ2UvL3A2WlJ4bmY3a0FpcW5nZ1FUSUp5SWdKRG16aURKbkZUOWRwcVJpaXc0RGo1WlNIdUFIZ2FBRGluOGEvMit6OVZSSlNheEtiaTZJaklxNXU2MDJhbm04SzRvOWtDYVlhR2tqVWVNZnJyQmVWVFVONGc4UHN2ZXlCRnc5QVFUZzFZRGV3OFZqWGt0d3paQndEQkJUUW5SbmFXS3JnU1piRG5FQk5tN2pWVEhxTWZwa09GT01Oa3Nkek9GUklCRG5hQmtUU1cvanpYRkx5b0hudGFiN2dlOStXMjBUMnhjMHB0RE1WSENWTlV0N2pkenBLMWV1UjNLTWdNVFFOL3B5WlBGa2N6Wm9Od1VJQ0hoYnM1SWJLQnc1dlhLbzZ2OXlFQlJkZlhxYWlESjlvQU14VlQ2cVR6bFF1QlgyR1lyYkpod3J4WDNvUjBUVklzbGNZNzhxaTR4Z054S3RsN0lHTGlteXBQNm95ZURrVEROT2pQa2xVbE95d1VkV29NR1hlVVo0VWhBNFg3Ly9OcGhpbDZ3ekFRL2QxS08zZndqWHZrVXNhUFIwTUlXdGg4SkxFOWxpekxrL256cjUvZkhlQjZWdG12REJrNVl5dnJ1YnhZOGxOcERHby9XdVJhRVNCWGZYWXp2a1BMb3hKeTcrM3dKVDlRMXJ4akgxcG1PYWxPVzg5KzFKQ2g4MER6MGE2VjdPSFFkT1FCZlVMYlBzc1ptVEJ2RjN5YVA1U2V0WUtESVJhVGI3Zmd0RDZ3N1EwQitYN0tUallNVXh2b1djc2F6bFM0Z2I2eDFPTjdVc2ZYbUd0NEVHWStEQmNCeHBObEpIeWdUZENLVnJOSUNab2llNjhoR1libzREeWsxdG42OVptejdEL3NvZWswRGdIbU9PdXovckpKMzhvQVdjNE9CZENKSDZIZU02VFNFQW96SVBrdEhLa3JpRFhxV2d3RzlQMStBeFdZdFFMR1lML0Y1ZHlwUFVtU3lwQmd0TjU1U002V0lLTVU1YmVLSDlBVjhRelBPaGtYWEhEL1lzeCsvWVV4OHNGUG02WUp6OTJYV01mWFFNV1FWYjlsU0NDQVQ2VkZLUjhRb2QyU1BGL0k1cUxWbjRUd1hMeXNPZGNOQVRwNE1XcVJzMFJlQ3JTckFGQlA3b1NBZktzaENibHhaQTUrU3BKelVsa05sOTdJZW5JMUk4VnI4SjFBcEpMQU1RYk9ISFF0blJTdWE1c2c1WEhLNDljTUNTaUc1TXpRUkkxUmVnbHRsNW9ITDlrM3hZTkJQMTVNZTF4UStuZHNMYWx2QVl1Nm5uNm5Gd3FaM25sSXgydnFiZk0vb0owMGxScTlvNWlQS1RYQm5jcktoOWdicFZuRVk4RXhhZnJsNG1FcGt5NE41Y1BXMk9EOXFpRnpKZUJFbUs3YkxNa2xPWGpYNzNIR3FQTVNKdjlYY0FtVlNYMVJmR3huVHF1VWozNWkxYldKR3dGUWZPVmp2MnJJSkNLWWxTdVNSemkzRXpoSUFITC9sajBteHV3bGVJYXR0aUNUMEphSm9iZjRXZWhucGN2U3Z3bDdhL2RDTm9PdlUvYnNRSHlMeHYzZ0pvWC9pQzBvRUZnTGpBQ3RrZlRBNG5ZMjRXWjlRdTdrMzRFTENqdmROQTY2Rks2VEMvUEIrVCtJOGI5OG03RnU0emdRaHVzcnlkcUFDQkJ1cnZBaU5iTUhWZ2MxYWRPbFlpR1Y2dG55SFNSWWdKNGc3NkJYdS8vL05ZcXhTSHovME1QaEFLVDFhU1RMM2l3NVlkdTJXdXRhYXp6a1lkRkx4UmZua2lzd0RxM3o2QklITUM5Rk52YjBKZzNqTUw1dHNRNHg1dWp4aXA0dnozQVkxcG90VFNGSnkxNERPc3lySDV3OG5MbGhWVWRFWFpCUC94M1NUdlMyRTYxR29oVWZpOTdCU0VwQ1M2bUVkSXdUVW1LVkpRQjZ3NVB5QTgxNUVhenZ2MWZpWkE5di9ITElFVmd4QVlXbW9SZHc1YVIxV05FR1EvZUFWVytGRThYUDN5SHRId3BCQnJZb01Kb2tqcFFhWHV3aEpjaGxBL1lZZ1EwNnl3U2pIQTE5WnRWV0J0NGtPWEdLNEtsSUVmTjIvM2Rqeld5K1poUnZkLy8vN3FtUnJTRFRRdjVnUzZ4RVNNNFJqR3F1aFdhSXBHVU1KZWVOcTY3Yk51OTFnOGRhUEUzSDRlUGcxNWUzd1ZQWmtNMmtESHRrOURMdjRNRVRoMjB3L09TdHdNVjVld1NRN05tZW11TUJkUndOUkM1WHJCcEVDMDJXUW1yb25RdUpLWXdGSkdNbHQyVmVQajluYXR2WDNSYUxlY0NoRCsvajhGWERrNEx6T2NnaTBWcWlNV01tQ2U1anpjZmNZOHdVcndIN2RmWG43N1dmTm5tZE45cUREQ1VMSkFzaWt5YWhPVVR1TUFwZDhiSFdIZTBUY0R2SXRGb3NwZkFxY2ptUGIxRVg3Y0ZsU3ZMTTJCQVZ0aEROek9VQlN5VE5Ea2VIMHRYQngrLy9SK3Y3ZDBnOW9jNmFFWXdMdDBRb0o1NXU2Z0lhb3NseThxZmNlWXRDODd5Z2JCWHl6RUVPK25oL3l6b1RmK3FST29LL1VWS25VNm9UeDF3Z21VdUVERG9nUnMxNTROckRpQmZmazEySDl2ZXFvMlJHeHBJRmNSQ3J1M1R3YkhTaEN5YU5vRmdxR1ZxaWxWYm1wZFpDcklSUmF6enpMMlBtY1oxQVovK2wvZ3Z5a2NQaVNqaTlGWnh1QTVoOVl0bWZwbjdlZFNnNDIrVldqNUw1UkRKV3FuWFNkT2xnY21kQThlMG9kQTBRKzc2WGFXb1RkVUVBVUN6VnFKSkRuMUcxam13OWErUDZLNk5yRjNvYVRwYklydTRZU0ZOTHFjUzYxdGd1dHhhakQ1ZXVCU2tkYUpsa3VpQ2Zma0xhSHExWWRadXg5cUYxVGNXYVNQSk5uUnhrblpzSTBCcWdJTGpiN1JkNkVLSnVwYjZ1SGFxMjVJNGs3aXJyb1dzUGlsNEdKQ2dBak1MRXljZnR2aXpMNit1NDNPZWFVcXp6NWdQS2VOYmU1MmkvRUo1K1FxSUJEYUdLNXZYQVFpR002TWJqUklQN3gwS2tFS1BSbEw1dndLQXVaUHQxbytCQjE4bytqMy9kdXo2L3ZMdU9JZ0ZNZ1VDTXppSmNFcGpZSW03WSsrYzR6dmRsWG42L2p2Zjc3RjJwV3dROXlWaTQrSEZ1S1h1K0w5dSt2WjVvdXNkRTloOGZaL0RhT0pLRjhYT3F5eFU3QlJPbUl5d0gwNWRta05xc2RySzFLWWtzbUpBOW1NVWlDTEhReWNGc1hEQWdFdVNiMllQQUIwRXdleklTTnZnNkZ5L3NxZWZZLzlwK1R4S09RNE8vc2txS3VodjA4L2ZlcXlvMUZlZE5ycE01Z2VOazFkbktMSFRVTXJyblJLem9MNEJGQXF6ck9qVXBhc29PWHh2ekF2dnpJTG9MOFBDUDlpTTQwS083cytrY1BOcFhkT2VxWVFzY2F3NjdBTE9HNkFLMkZTWGNLNjRSSFdRY1pTMEFiNW9WK0pGOTJhTFNaVTAyQVJkQ3NlRnlmMUFLRkdwRW1tV1prN3FwNnpHS20rMzN5UUsrT1JaaWs0ckhmUGR0aHIySHAwTGZPdmFOVjNSc2k3eTByYXNndUxLdTdFZjBnUjFBd0tKcjY4cXljY09kbFA1MkUwWFJlZ09xMzh2MUJ0NEIwUGk3OVdUUjc5aDFxUUZoTmM4NnVpLzdzbDRsbmsyb3dsWmNCMlFLeHh0a2loczQwbjFUMUh1Q01XMFlOZ3ZPMkxjL3hJenBiN1BaS2RRV2JLYkx3bHQ3Y3dxSGVtclI2Vmt3bmZDQ1JsbXdsNVBCTkxqVjMwRFV6VEUyNDFUQVNXTjhYL3NiaTFMV0J0b1pjZUU0c2krYmd3eXE1b1dMWnlSeERaWUJBODJ5Nm1uakFtNFNvYUtXNG1ndWNPY1dwak1oWmllbmJiUURpVjJCdFFTNHJzKzJVZlZnOUZrWC9aN2xwRm1GbEdVcHpta0c0WXlmMHFuVzYyMGYwN29xQU00d2RweUJzYUNxNGpQdFQ1MnFSbE8yVmVzZndZL01JWnYzMWhNaTZGbWt4aVRsT0F1TXUyUW5WYjlHdVA5ZXlaUlY2ODQyNlJBT0tUaTlMYzM2QnNGa0VGRmVHWmxvWFVxSnV0Qy82YVdFbHI2cElsT3BwNDNXUmYrc3M3Q3NSV2RDWE9zU1hNWTNPMStiYWMrQnFrSG41TEpGaSswais3S2JkZkFaeGFNTmdwb01lZkU4d1JkV3piaFFNQnZlcXFRQVJ5WDQxT2ZrTDVJakloa3hnZTJOYkRHWHZwVFMyNDU4MzB5TDIzNXBSbWF6NXRMWGt2TWljOU1nL1hQNm1pNVRkRUFEcDFMSzQrdVNpVXZtRzJQVzgwNW51OTBVSlg3UVREUGM5R3hFaTJOUlNXMWVqQjNabDkwc2hLOWh6bk9kWlM2d3JLck00YUQ1NDNPRGxrT3Vhemw1RWdJSkIvWGhWOG1rWUJ4UTdVTzBpV1ZHL2lpS1NtOWJlSWhIRTNrRkZnVkdTejFpMG14N2xrcGUxWkxhcXlMQVY1VXM4K1hnSTJkTXdJd3FnNHNOeHRzQ1hGS0lVK0ViUFZYMEJEYlVhOTdKSHRtWDNTendRZGFqTkNNMm9uSUlDME11TG51SVNQaFpsNVdLTFFuemNCVUNLOFRwc3h3emdZQnNUR3ZnMnQvN0Q1RmVkeUxmbUs5emZ4RGhvak9OekdEYmw5cGY5Mzh2dDJtWUxOWHJrdWpvbzVKN3hNSmdMRkZZa2JudkVwZDJmN1AycnRRM2VhNGNDN0o3OVl1SFkzdHE0Qm5FTy91NHl5eUVPWGtFODZESnRVWGhTZEFFUjQ1ZXExVkZoUmFIOFdjdEpaY0NXTzl5aldrNUdobHN0Zk84VFQrS0JtWlEzR3poM0hScVpOUmYrekpLVjZFQzJEM2NDb0ZGQ3BjRFB1WXRiTm9uN2JtQXltWmlKc3pvSms5b2NNM0FWcHQyYkU5TjQxcW5JWFBjZ0daSkRvV2V5aFZDTUZtOXZLeGVWblNESEhOeWQrdkVZWmpFeEFXOGYzM2hIN2xzTmE3dEpjeGE2eThhSVdtOEh1cmVxTGdyUitBMEQ4WnNJaWxONU1hcnB5UUUxWDFJSitwV0NtaXNSV3lIYUtBU2JNYVlNWitTWEJGYmpVWXhlV3hQRFVTNWhwb0R0c3hWOXZhWklQSkdBS3QwOFhLeHlrR2NXOFdKRllNdGhsWTRmNUlTYkMxeTdJQ3R6UWI5dWM4WW9zK1BwdE8vYm0rbjB3ZzJvcWI0cGVIU0dPWjI0NWkrbi9BK2JMU0trV3VTdDhRUHJnRk5hNzBiM09WS3Vha1ZJTjMyUS9heGZkbkVYMDlDQWlkVmdibDlkbUVYY0dxeTFaN3V2N2sxMmVsV08ralNVM1ZmWXRLakJOdVlpdi83Q2luWnpwUkdjaTZCWndZamd0S1NVWW93WmtyR1ZEY210amNCVS8zNlVYL0F2QmEydmFFSjBvenBuUm5kaFVwbERtWXROUm8vdXFlbVp1ZlZ3b3htVHlyd2pDbm5QY3ZOVnlzaU93ZlVLb2ZjeGZlZGJMYzUwTTZIM1hnNEhPSkE5L1ZuL2hNWGg2NlJoTVl0NWh1Tnh5VHRmMDlDNVlBeE13bTBib1gyRkQ3RmFMaUNhK1B4aDFickVpRjVnQWE0Rm1Qay8yT2V1alFnMnRZZFBiVTR1cWVHUXpDdXF2QkFTNU5nNEJ0SjdwY2xyWmZweFYyLzNCVzdQOWlzM2FxZTdTVDcrL0I4ZU43bzRyZFBwc1g1RDY0WnRzTWdDNWZBZGhpb2JBWTB2eFIrOGtzTXR2dXdDa3VRQVM5ZS9qb2VYNEpNdkVNalVVU1dnMnlsVkpvNXRXdlZCUGw0aFNUNkt0Vm9lcFZrMGRndkkrUFRJSG15Ly8wUVZDWHd0MUhqWVZ2MkowSzZ1RGluZHY2ZllYd2pmMERUSS8ydHNLeE93VVFMZzlJYkdtOWNNK0V2Y2JjYkxzTXFMcHZrdlFjYUo5ZG9hdjJXYXlDbGYvUmdGSklrY1RPUTJjMS9qaC9aVThNRjJTcUl6TTRjVjZuVTR3LzFCbW5PVG1Zbm9Hc0dMTUVaSXdMUmVnUVEyTkRvOVBTM2YvL3p0Mzk4K2Ztbms2YXV0VW55Z2YydnRBTmw3NHo5bFowZVdqRFRRQlBtQ1JuN0JLSWhBbk1ZeCtpNlE1U1JEMEJyOFVPajIrMHExYUJJclpBbGVScGdBZFM4SHorMnA0WVRHZ2VhN1FRbytFbm1qYlVCMmdoLzhLNEdjemFUbUFUL241RHpmVXJyVE4vNGExZ2c3VUN4UUpkTU9ocW1GVnJrcEllUVVZbG5TWThIOVlBZW9tZ2ljckxSQ2RIWXpXbzFjY1lqeFRIVkdOTXg0dW5TZGdaR0ozWlpPcTR2ZExKci9VNlRtTmw5c1QvK3ByM3VCeVlsZWNIM0JpSFRHVS81bk91NnIrZCs0S0RCYmgvanFtUVJwdHRJNXRwT1Y1ZWVVM3hPaDVuS1lEYmJ6ZjErby9HbjBlNnpmMnIvSmZUOTdHdlZERWFheW02MS8yUWVISEFUVzdJcEFpVGM0WEhVSlpQVFFxMW1manY4Q2E2amJScHR2NzBhK2dBNzJYTkFlLzF4Um9QcklVMGd3enhPYUROUkpOcUY2S0IxOWkwMGRua3FlczBFTktsSnFtb21jVTN1aFVLeFZDcnBXazZKK3dUQmc1c1E5L25ialpaYjM3ZTB0UC8wKysvcmptSm9KemFFbmFVdDZTVWtOdzVDVE5Xbm5tM2JPUXRUcmM2UTdPK2x6SnJhMjYyWEkzZTNRUVpEZHJlZ3o2Z2FmNmVHMktBYVRTSXpHSG1qOE5LdHRuWUx1cUx1M05IMkM3b0IxbW9ma3ZCQ09LQzU2V2x6SWJOZkJKa201M3hVZ2lMTE9UWHVOeHFNbjE4Y0JRV1IxYXRHaHV3d0RMcnBLSEFoZmtBR05wSnVZSzdEYXFZZ2VjT1FhQXgwcURFNnZRMjBFRzJBdXJ0cm42azIrRTROd0FqL0xBMVhoRFpBYU5ETlpETGE2NVlYbE1VMGF6TE5uakZZN2MxZWIxT3RKQmZuWHRncUZ2ZXU1VVZTemVmeGVIeDQ4c1ZUVnZNWlN4dkN2OXF1OWFvaGdEdk1GOXl3TlhDbzFmQmMvZGRHYk83U0phdVpVdlZNUFJvaXpKaHF1eGdhUUs5OUdzUUMwSDIyOW5jd0dpUms3WktVUDlDSWlBV2IwR2d6MG1HYU5ack1zL1VubkU0VERBbTBjWW5Rdkp5TDNUYVh0L2FMZThXQUxpdmtTS0JSVmZwTVpwall3Q2JDTTIrcVpzUWFibzRDcUhhS0lveVJtaTdSUERQcTkvZGJyZlc5aHJJWU8vcmFCc2RuTUpoUGh6cG5RcCtjN2E1OWlOeG9oclF3MWRoR2JRYXR0cHI0SElZRUdsdVI2dEJ3ZU1pR0lFN1pZeHg4aURzVjBPYTN3RmJNNnBxaUtJTFA0MU45cXFwVzVOOFl6cUQ5VGVZM1ZTTXk1TGoxblNoVTgwcVNxMG1TbWpoSkFoeCszT2NURzROKzNvL2ZzdGM4U1hhRUcvMTkwWmF4ZFpxaXNibjdGSWFzZmQybTBRekozaGRpYUxTRG50NGUrSndtcDVTRjJPb1hXeklrc1pxaG1rc0NWeXZLMWVweWJSNHZaQXI3MmIwQWNrUWh3ZFN5cXBZVnZzUHlqb0dPZ2FjM1ZUTlJraGhHdlJSR1JNYlJTYUxNaFl6bjh3R1Jud3YzOXp2OFRzQ2htTE9zZmRIWStQajRaSEthN1gvUWF5MUdFcVh4RE1uYTBRUkRFaHB0TEVheHIzQmdTTFdhMkxGLzlUeXNSZi9CMlRiQlNXUkZRZ1BobytOWFcvczd4V3orTlZxdXZLU0tZYXZSWXJBeTFlcGRiYXptZUx0NXpzMFJGTWYwYjhVRDF3UVp1M1JaRmtXUmgzSitteE4yY3BxYy9YdzBQWnBPRDZlSE41TFk0aUhwWmpySDNxMSs4TjFvaHJSVWRTVS9raDJuVjVOZlhhQmRpdDFpaFNIcnJFUm85UDZiSTVwd3V5Vk84a3FNREQvenovOTlzcC9OWnZWY2pxRXBzbDdXZGkvYVRBYW0yanYxMnFNQkxHYmt1Q2tWU3pSNXE1SkJPcEtOSHIzWGRTVXNLM0VldDdnejduVFkvTGIrT0I5dWszbGUxZ01KRE5EWWpWUDZBNDNjMW5pR0JEdnJOYUNCREJ2bzBNZW5WbkRoVmIydG1zVmlkNlMvY1M5NnVWYk95MVYxNDFwNzdqMS8vcGYvTzlyVDBHd3FSRk5GVGRQdTdGYjhUb0NBeTFDUFpxZDV4R1JKeGRMclVzU0xIQUhjcjVPTjkycCtMU3pMUElpY1RnZEs0QVduMCthMDJmanc4TVVyUUp0Qml1TnRzQSs2VGN5UWpXYkljOUFWdTJ4TXh6RGs5T29xTWlnNW5WMVp1V1Uxdm9WR2c0dERxSHptbmhoeHRmYkFTWnprQWhuKzNlTTYvcy96bDA4ZlBGaDZVRjRxTHkwdFBYMzY0R2dna1JZclZvZlJoQmo0Vlhxem5XVlhhblFzTm9FKzh5YTlhTGdJeEt1eXVhL3F3Mkk0eklkNUc3anNEcnRnY3dyOVRodlBoK2ZtWWpjU3llbGdTeWZlSXNLR0Rma0l0a1l6Wk8xeWlLb2hRNnZiMDl1SmJkZnUzelZ0SlpYcXI4MGpLSXc3ZHB4RHRSS2JmTElJSy9ZQUN2R0dCNmlHNHU3TnZ6cDUrZlRwMGdQY1hyNThjVkljdXFOVnhIVDY0dVVMZGpwRnRRS2EyV1JkdVh6bjRTU0ZCNGRwaElNdEkrN3FJakN5RzBDamhjVndQTTdRSEFJOEtUaDV2aTA5bHhibkVzbFE4T05naU5ER2FsY0tOWmdoYTErRHhaTDlLYWsyallqY21CN1l6WmNWdFJJWEJDeFRkanRlRzkwOXZsUWJMd2QrMkd4RjFkQ1lhcWhXN3Q3eTh2TDF6TzdPems0bU0vWGw4bFJXcktoams3R0huZU9DZzQ3QUNpL1dtb3FPdHNSaTJRbldxQlQ4ME4rZHJLNXdJKzhIUk5SYW1FZWYyV0ZKdUZHdzJWSjhXL2hTV294aFI5N2M4dFU2Wkt0dVJYRnZNRVBXcmx1Q0g2blhFSkhKdSt1QmgwOFNYV2xkQnBwUDlSQWRBVHBTYldGUjFuZVhDYzNGcUNqYUdGcHI2ODM1NDhKQ1Y3RjROZlBiOHlDN3YvQitYdFB5RDJOaks1VitRWEI2SEI0QTRqajhTanE2VXBIejRoTTZCcWpvT0UwUkw2MXFFbFRMaTdvczR2K0Q3SGVnaUMzdTkvZng0UXRSOFVaaVlLTTdOZ2t5b0oyalNlUC9teUhKa215RVJLNGlJZTlPNnZsQTdFNXNYSmRWbStxajJjbmh3RjJvVkdSTnpGN0xMd0x0RWN0R2lSNnJodVJ1SDU4VWlydUZ2Y3pWVExFdzlYZ3F3d1ptUlZWdGdsWHdLVDRCQnZNNGZCVTE1UkhVWEM2WGFJWHN0TEs1QUFVMnloSXBFUkQxTmUxSG1KSml4QzhBVFlCcWZmektZRGd0QmtLa0dtSUVhR08xNjlrYWZ5K2JiaTEvUklwUXN3MXNSMmJ5cFZKZVUxUlp5NmxhdVFvSDdmQ3Noc1ZBVmdjYW9QRGczblEva3FxcTlYRHpyNDRMbWFuaWk2TVh4YU5DWnZuKy9vY2xyQWJzdDhHaU12VnJReGpJRkczQ3hYbTlnR1BoR0pIY1hpL21yVkI2UlF5ZzJaZ2hIV0ZLZjdSYW5JZGgwc1BEYVl5QndaYkpqYTg2OGNrVnlLZ2E3N0xKa21zM3FoOWhUT05ObmljN2U2VXMwQlM4c3FXY3FnbzBHR0tDRXVKK09ieDJSWCtQR2czS3VSZDdSOXhlcnFiYW85dUZrNjZkNHQ3ZTBkRldZV3ArK2RwZXZwVFRjam1jRzNTc1NvQndKY1l3VmFsb3VwSUhXcE1YeVZnYlE3QzljWC90ZGY5eUdBN0lNcUhaUEE2L0FqU0lGdWZSYTlIb3ltaGk0TS9CaDhISllMQXoyTTNlcjJvOFF4cFpONjZ0QllFR1I2NWlGMy9sYUUvWFpDV3NsYlJ5V2ZHQnlzNWtxeWh5T0xBanZzZkJoYmd0ZnJQcHBTZ2hOSkJ0blhSdEZhNWYzeS9zWDE5KzNIdC9QNS9YeWlVTnl1Y1VwanY4aUdZanplUVZUY2wvVFVBc0d5RWNTcUlOenFQRXQ0ZUhLMzFBNHgyMk9DMXFRai9Rd0RhNGNubzZ2cDNZQ0E1OTF2bFJNRGgybHJtdDhmdVFGbFpyYTkyRWhqbHIrMjRpVzh5dTZhV0tEbU9xS2lRVEVNTWVueWRld2FBUnVDTCtMdEtLNnBFbU50bXl4bFRiUEg3MTZzdUZvNlBDem9zTXlCNzNUbVYwOUJyNnJhd1Fta0JvWUtOaEJTMHJsNGRIU0RXc2JKVCt0UWtTSFhkejhkM1R3NFBEdnBRZnplMFFiQjc0MHVidmYzWjZlUGp0K1BwaVlyMTVhSEk5MkR3MjFsMjd1S3pCMy9hcGZoY1ZxcDFsYngvQWtKRlFGbDRhMWpUYVhvS01yTVJPTi9aaGNXM3VRM0VJYUNocFFtcjFScmdxMnFON3ZmUHpoY0pSc2JCVG1KcGE2SDI4WE1oRE1haW0xVlFqTmhpUzBDcHlUdEVYT1pLS3NwRzI2cXdrb04yKy9VTkw5UFQwWVBaMUhjd2VIQndjZm52NW95L3ZEeVEybXNjbk80Rkdrei81cmZFTVNicWkxem8vcWNWSThoOC9aMHZsb3A0ZjF0QW84Q01Fd3hrWGZJaExGZVBPajVjakxQeEh2bmE1c09KU2pGRGR2TGU4ZFhKVS9PS0x3a21oTU4rN2pBTm82RFdvcGlpMUlBS2F3R1JEY3BZV3ZVbkc0MDRDanZacU9KYjc1czNlM3Q3SFEwT0JkTnRwKzhIQjdMT0RnMmZQVGsram93L1AzLy9pK25yaXJ4dWZqUWZYZzhGbW9GV3ZiVzh3UTFZdnh6YXR0V0JoQzdFWVNmN3JuLy9WdFpPOVVrQXZsM084U2hsQWk0eGdVNTJxL04xM2YvdVpJN1NJKzMrRW5mMTNXbVVXNzMrZVVXZW0wNGxoUms5R0ViakFNTE5hSW9XeU5CSEpLVzBIaTFiT29yeFlrQVU0dkNBcnA1N3dzcVJ5WldWWWhJUVh5UFRlVkhwVGtqU0pyVW5hMk5vMnFWcHJXMXRyWitaUHV0LzljTlIxNzFyRmZSTG9jdFVtbit5OXYzcy8rM25PQ2ZYSDFGS3dpajA3R3NrdVNNdnhlSHp4bTFzRnA3Tnc2N3lYeWNqcGQ2a0NNSG1rbENYbmYzenA3VSt2WmJHZU5jQnBtTld4dWM5SUREb0Nwem1kbk1zb0NFcXYwVmoxZXIzVktaNVhjYWxBSUJQUTZZNnZ6NTNTalVGR2dvZWpUTm9wSUFjcUpDNEw2eUZQSFVTamRlSmZEei8vYnZjbDQrbjU4emNSU3lqYWYzMmR5dWYvK05OYmI3MXk0OEZYRDh5allFRVJvc3BObjB4RlppT1JoVTUzYytFYThtMmg0M1JtZjdpNENqQW81TWR2UXlTWjE1QnJyeVBBd1hyaDVyMElsbXRJTk16cHNMNW13eTNmU0l4NUxhQWZkMVVkWHFQU3IvVnJGWDRGeHdrY3A5RmtOTFdHZTI1dURESXlScm5XMS9iQlBTU2RCMklsbTFZMThOcnd4bjgvLy95NzczY2ZXTWYzNzRORVBmdlcwOC8rNW9PblAvamlpdzl2M1BocTE1dzNBQTE1RDd6bnlIR3MwWnFOSkhheThXdW9hd3Z4V3gxblBWSCs0ZUxGOHlRaTcwS0tFTkx3R1l3aTh0T1BMdHk4V01iOEFZMC9WTjlBNGdqUHhUQWtJYlI2WnR6aTh2TGU2YXJST081UWF2MEtRVUZvR2xOeXJqWjMwQnpVUWZwVmgrWHp3Z042U1BrQU1XMGJzcklHR2ZuWDhPUUdIUGZkOTk5LzlkV0RHemUrK0JCTVpBQzc4WW1veStjTjVLdSswUjlZb3pYYnduY1ZpR085RGFkbDYxbG54SGtYY0YvZXZJbGtZeDBOTHRUdWp6NzY1NFVMWDI0V21wRmhFbjlRMFR1MkQwN1F5SFdXQWpMRnVVSkc0N0VEMHdlbXA4ZTlmb1ZDd1NrMG5DYmpzYS9YNXR4bWozbE1wYUlSSzhnR1B0dEh2aThjNnpXS1J3eFZvQ09UU091VmpZY1B2Ly91cTY5dWZIWGp4b2MzaU91ekI5Ylh0QnlYRDJSRyt2MHhxQmdqYzlwc0lwSm9Odk9wUUQ0Vkw5UUxaV2NrRXNrU0hNTzc4QkVac0dBM3Y5bU01L05Oek9yUVhPSEZBSmZoais0YTBvMTVMZS9hNzFJYXExamNqS05UVm1pSmpRTFNacXJWRUpDZW9ObERYdXYzeDRPZkQ0a1BvTkZBaTNiZjBmZFB3QXdyRy9lM2VyM3Q3WmQyY1hMRGFnMkg5ZjJ2Z1h5dVVGbDc3c2pJYU45N3BQMmpyVllrNFFSYUpoVlBsVlBPTE5CSXliTTdkKytCN3M2WC83d0FxZ3MzejY4dUNuQkFKaStOSERGUU1PSWFZVklaY3h0R2l2Zy82cTZqMDJyZTRWQWFIVjY4S0xXeTF6SUJsUzVacTlWMFVaVktyVHFzSHZ6ME16SmcwUWR0RzJKV2gxVjJyN1p5Z3RqdVAvemIvZHpmeEV4QW8xQm9sVm9sNzlkNjhGVTBtVlFHQVlrUU5NU0dtZmRrcitXQVZzL25pYXhlUmp0U2ljQ3lPM1Zuc1Y1T2RSWVhGcGRLZmo4L0k0aHdRQ0NUR3ZJTmp4aGdDRWtnb3JZWldLZUZnRFNsUFRQVjBMaHgrcGhScWZRRFRmYWFTVVhKbHRTcHpFRnpNS2lXaitzUGVqNGsyVlBvL05tK0lXcTJWdHpxZSszUjl2M3Q3VzFSREhEYU1NaVVQSSt2d21rZ3d5MGlvbkNVQTVQUVdxMEUwRktCRk5oUzVYSWhHNm5neXBaM0NzNU9xcERKY0J4K1FqQVBCNjlwRUpBK2tQWFpxSCtFU1BwR1dvWklCTG1XMS9JdXg2VVFpVCtwSkpHeGdEU1o1dHh6cHFSNURFV2JTamFUaVFIUDlwRWZXSUhUTUdPc2h4VER2ZU9UaExieDcwZTk3WVI1MTZ6WG56MXJWWUtNeHpjbjRDY3Vqc2hZOVBLejEzTFpjb3JBNHBzRlFrTThWaXFKenQxQ3AxQ09CekthSmI5ZnkydTFDcEVDMHA2WGZNQWFJVHdXbEFhNGJNU0FFTTQyNi9tVVlzb1lNdnFWNDQ1cEx3UlNLNk9waHRiZGM4bmFHTXFhSnhyOXlXc0RuekVPT0RxTlNEM2tRVkhzVVR3U1crOWg3OVQyN3U2RDNiWGR0YkFmYVBqR2dHYlh0TENvb1ZVb0RDK3M5WitkYmVWeUZKQ2trWjFDb1ZNR0dnbEpvVkFvcGpZN1M1dXJxNnM4ZVkwRlZ6NUFhQ0RETlNKL29xeFZacEd2Z1RvWDRua0hVdTNrcGFQdzJrOHlraDV5citQSWdpNGFoWXlvNWNkMERucTJUNTl0ai9YYzJwcjYxUHM2VWR3NkFhL0JOdjdkNi9WRWNZOTZOeHkySWlLSmpORHlKaCttYWlRaGpPNElwaU96ZjBkQTVoTE9mTHdRVHkzRUMrWENEaWxrQlg3cmRNcmwrT2F0VzR1TGkvUDRObVVQNU8xZFg1L01ONEpyZlM0MkVvdjVZdWhHY3M1OFhoc1d2STdwL1pkQ3lEaVo3Q2V2elowYVU1RkFxZ0ZHY0FQdXFaRWZucnQyamt3OEtJYnZIejhCTVY1NTlPamZEN2UydDV1WncySllyWlZ6amFHWkZKWCt5ci92T0JMS1dRVGtiQ0tiTGFUaUN4Q1NjcUZRWmdHWnlCVitRQ0dvNXp2Q0lnS1N2RVlCU1dncDhob01aQ09OYUJwYytDQ1ZyZHNEbkViaDhJNWpVVG8rVFY2VDBUU3E5ZVB2cjlkcXA4eGpVSkhEOGkyUUErNnBrWjkxd3NqV3hGNjROM2ZpWHhPVHd5c1BIOTVmZ2ZRL0wrN3VjZ290enl1aGtscGVJWEI1alNhR0ZzU1E4eDBodDFGQUloei8wcHFONUFybFRud0IrZFpCUkdZaC9rNG9mN1lPditVWDR1Z29JQ1BrZVk3RVB5QzFvUHF3RS9nODdrbFNDK256d1d0ZEthQkpjWEd0SDVVTnZRaU12Q1lRV3JwMkhGNnJuUnFMSGdiYWkzTEovc1Y3YWhoYVZkdzJIY1FwRjNodGVIUmlvL2RvK3o5UVNGR3REUU5OQ1JtV2M2MklBYXV2bUFNYURNNGpGWm5OempvTG5YaGhNd0MwTXRBcXlMVnlBWjdzZ1BSYW5Da2t1UTNxajZDV3VpTm8rbU9ONCtoQnlQRG5paS9tSTdTMGtNTGY5U3NCcDBTdmhhOHI1NW9RQkJxY1pwN1NSOVZxK2E2dFFmZlU5RHV0OThMVzZscFliOFp1d2ZzeGxKbkpJNFl0ZUEwUldSYy9nWXBvL1Noc3BKQWNGTElJR1VHYTBJU1ZCcTJRa1ZhdWxVMGt5b1dVaE5ZZk1sSUdXc1NBQzJoM0Z6cDVlM3hwcWJTa2hWSDV4YmNwU1pYaGtYV2RLVWJpaUs0RUFnbXZJU0N6a2lBRXlHditxbEVKTk1xRkg4Vy94cHltVTAycEQrdFpYUVBib0h0cVFJWVBIT3I5czdpMkxlckQxckJ1WldKeVpkSmd1TCs5MVRObnhEMFB6bjVDdWFia0thTTEwUEhZS0pqb29pVU5QaUdRT3puMHgzQldBR2dMQzNWbm9ZeVNuYWdrRXBVQzVMS1pGekEwSVJYcGV5QkFBV2s0NFY0L2p1RXh0Y2dzNVZpdWRXMXBRUk5YS0pVSVNId2FLVnJrWE5OaFZnY1pPZVd4NE1ENUh2bkc5MEhuSWZzQitjS2U0Si9EYStKTGF4REt0YTBKSElNeHJEenNKZUMyM2QxUGRxdFVzL3NaRGE5eERUWWJRVlFhMkJpUlNuWXIyNXBOMUF0U3ZKTkhzbVhyeURXb1hhNVNLZHd0RmxMUXlHKys4Y3VwUnJtR2lLU1NOb0UxRzEwak1BT0VoTkRzTmtHQkdLbXVLbzNlS2o2TlBPV2FodEJpNjNOdWJHZEU5VUd3MGJraENzZ25uNGVVZjAwTWp0cnJ3eTg4THg0V1JaMjRoVnlickV6MktuLzdEOGowWXZnc1JFVHA1LzNJTmZSeWlxM1p2bjRZV3JNMGJodnQxN1ZXSWx1QTltdFMrVUs5VTNCQytnRlh1VnQzTG5RV2JpMHVMYkd5SnVkTm5tU2tMNUhzeFVjMUFESlN6RFZzYWNXeXdPTFJPKzAxQXUzbmJxU3h4YnltMTlNMnZYeFg4dUR6a0hTOWhwc21ldFJFMG1td0U1REl5UlZEcGRMclpiWlIxNng2aW5pMGM0UVdDSWpGWVJyMkcyYlJJNkZSR2pHd2JnVFRFU2ZJRUpHcE9xU3lURlV0NTB6a2M2bUZ3cTFiUzhML0Y1QjFXZnhCUkxMdmcwVjhobUxYYVU4dkM0Sy82dmNhSGVOZWRNaDlOQTNNVktSY3E1bjF3VC9EYTcvOFd4amswZm1VL2dYOUo5YjM5T0tlc0ZxTmdOeGdhRmltWlBLaUIyRGhLb0pTempXdWVRUnBCcXhSR042UE1LL2wwSTFrVXhTT0tHd01yZFVDV3FYb3JIY0J2TGhFQ3NraklFWHlRRW9pZHhGZG43QTFFa08yelJiYkRWc2dvUENYbEY2djBuc0c4UmppNVVhTEZ0bnI2M01tVXpDSzdkNm9XajZtTktDSGxHOCt0UjQ2ZCs0cFhNd3lTTFdWRGFBVnNVekpBQzBjVnZMaHFyS2Zhd0ZORVR1SFlFSW93aENXYklLUWJUbjduVDhra2pWYUViZ3hseWh1T1l2TmZENFFYNEtlbDVDdm5JSnlMVk1IV21zQ0x6U2lReXptR3QyaXo1QklkdTNwdkZBeWVvRUdQSWMzNUhjWnRTd2dUVHFzUkd1bXNYUXdDRFM5UEJzZTBFTVNGNDZWbjhPQTZOeUx1SWhPUk1sZTJaaUlWSXBiOWFZb2Nnb1AxZXl3MGkrak5ZRUdMcERSKzBpRkxkaXdRTTdWYWIyV2dwUmdtWjJJdFBwc3ptYXpHZUFRWk1nMWYwbEJkUTFzVFIrSi9RZ3UrSXdDc2lFaEpDUHRkTkxGQ2ZOZXIzRWNhR0FMZVhrWDMyOGhUZXQ0akhjeWFVYmI3MUdyKzh1MVFUMGt2UkVlSTVQOUZoNUZRRzVVSmlnZzg2alpDajRjRGxmRDlMMGgxelRhNWpBeFlUU0tGMFRVTU5Db2k4eGlVY084VmtDMkFTMlJ5Mlp6Vzg0dHVGNFQxNkFaZ1JENTVmS2Jrbnd0WDZ2VkFsNk9FVkkzaWRGSTkvRHlEQ2VVNXBXdU0wWnlYY2pvNHNQTDVEVzdLZGxZcitscXlXUlFkZGl6UjgyR2RZT2Y3Y04rRTk2dmdOWm5nNzJvbnh3RjJzcldmY2lJMkJUMVVKR3dWVlovb0NtYVdQY3pPZ01LN1lSQkhtazVDUzJWNHRENWQxSXAxRFZmTnBkRnord2NxdWNEUWx5eDVDK1Y1Qm9GcjNWOXZxS3ZCYnlFTHdkOXJMRGUzeEJ4QnFPMmxHQ2NCeGM2Wkl5MVFzWVF4ajU5cnpYV1RXWjRUVVhkc2ZvM2ZSdlFROHAvNDBXd0FZNzQxdGIweURWRTVFWUZQL0NNS0tMenAwcnVKelQ2SWx5VFNqVWJJQSt6OS81RWF6WlJCbG9tdmdtTjdKU3pDVU1DQWVrc2Q2VzZoREdpSHpMaW41ZDdYVlRzTHUzMFF4Ykpjem5BK1p5TllnTm8zZUN5Smw0aTBhZUE5Q3NkUjVjVUhBeG9rSkdrT2FrenExUkJqeVZNUG9FOTgrUWU4c2NIeXI0SWUrcEZ2TU54K28zbk5qWTJWaXFWcldhekI4MEUyNkUxS214S1FrTkFZa3FQbGg4WHZqK2lwSWhrWFRzRU1yNjVFSTlqaE9CTXRMS3dvaE81Sm1rV0ZoZmhOT2kvUXA0cGRnMDRkQkFER3Z0QVI3cHVINktwRDVWc1FXbUVzVjdFRzNJcCt6RnMxOW5YRVpBbWN4cGVVMXNzN0RlQ0lkNmUzRVBLVDhINHh6bWd3Y2gxYXkrc2tOc21hT3pURXpQaWExcmsycFFTcG9YQWFUaXVPV0tnYzZleEV6NWNJeWQ4L2JVb2piVHJLV0V6dm9tTncwNGg2Mnc1czdrRzlMR01PWmV3Q0VWbmkxRkJSR3NSQ0hUUjg4Y2FVTVpZN2tRTGlzSU1qcFpzYVY0QmYyRjhZTVRrWnhwNTRPbW5KMmNDbWdsc0hvOUtIZFkvZ3p0UGdEYWdoNVIvQythcnJ4SWJlZTNjMlJkNlFOdEFwOVhiYWo2L25kZWdzWHlQWkdRcTdHZGVFek94a2VPeFlnd0dtVU85N2FORmNsa3MxN0NUSGNEYlFvSHlETFd1WGtZOGRqS0JKUUZzSlFpSjNHbTFvUnF4ZGd4L2hjbzFQdnRvenU0TVA2TlFHSTErMURSY2psQ0o3NjlwVEJyVFVCdkpadEtaZ3lxOXl3SXdPdFk4cUllVUorUG5mbzJZaFAzcWQyZWY3MUhGM2hoZTZUMDA5N2E1RE5BK3NSNnFnazVMMzFoQU93UXVOME1ERjR6cFNDS1hTQ0FlQXdFS1NheGtvSTlNUmNvWWxOZ3lBV0dwdEZvQ1c0bkNLeE1JdEZ0SFJrYldHOFdpczVHam1wWXJGb3NRZitkUW10b3NSRC84ZGl4azlEcGN2Q3lxSG50akhVOWUxOUh1bXRvU3h1NForV1ZBRHlrL3d3a3BobGdFR2M2WC9lODlFNU9QSmgrdFZPNXYzOCtJMnhxMWxtbS8waG9HR3JVOCtTS2M1bzc5Wkd3MERvWE1JaURSZDJ3cUVJSjFvSkg0Rndzd2pIM2lmckFaU3p3Vk5nU2t2VXVIUE4wMnFWak1OcnFOcnRUdGRxVkdCRjdMYzZwbGhiR0V4dC9ySVBWWG9xelJWOVZ4NjQyaG1zN2pNV042ckZicnNkZExqNVFlM0VPeUI5STg5WTlYbVpBOGcxTzJiNXlZL08rakRjTUt4TCtKanBrVTBocWVzc0pwdEJiVktESU5OM29lZDlHTjl4aGVSdGxlVGNTSlJUYmtZZ2tSbVU4MUU2MXl0bHd1T3N1RmNqUGU0WlpJKytFMDVqVW0vbGgrdWlXSVk2NEl0TFpkc2k4SEVoR25QUytnSFN1UmhpQWcvVWFvdjZJZnczWTgwRzdJNUhLWnpXYWdxZUUxVk9SZjdpRi9nMFAwZThsclQyTmYvSThIVm9ZZlBab2NyZ0N0TjlZVDlidGhMWDlvTFF3WlVWSkFlZ0tOUnR0ZGJMVGI3UWJSdFEyWSt3QXQ0cXgzRm1nNEhNK244dlVFeGxubFhBNEJpZTdMSml3dUV0YzhrUW1RTzhnSXFyMGJ3VmlFNk9jUTM4VmlZd2dOalYyVDVuay95U001elFpMzlYTU5uaDRhU2c2WmVBdXB2MXF2eHhrcHVvTnQwQnlTa1QxRmg5OWYzZnVuWittWXhwdmp4NGNSanhNUjFPeE1MNVhod3FJL2JMVldTU0sxQXVxYVZBYlV1cHZZd05odVo1K0Rpc3l5NlNnT1YzQnhEY2pxYUs1M1VOMHdPNVlLOEZJY1VQejhLaEpIOWhyTlJkemRZZ01mRGJmYlhZVGkrdkJQNUdkUUEwbjY2WmpGR2NCQi9PVXliNi9aVFNhTDBtejJxQmtheU5CeFBMbUhsRGM4M2pqNXlsdHY0WmdYd040KzVqMCt5b28yaVg5R3pLQkZDaDhLSzRIbXg1ZEJYUk1rbTBsS2R0dHRpY0cxZDNiUVp5R3hzb1Y4YW9HTHd6QlhUVlNvMGNMK0xVbGtKaU9BYWI2a0xMR2FEYTlKSTlpVmQ5c3AwNHJ0OXZwYzIyNXZzNUYvZW9hV291UTBjaHZlb2Nvc3cwMTJrT21NYXJNcXF0YXJnY1pzNEJ5U0RTTDM0MWpzSHdDR3pmNlF3d0d2YlV6ZVg2a1FtazVVaU9Id0d0QW9JdjBJU0VXOGtMYlpnVVhmRHF5N2MvdHhqcnhXN3FSd0Nua1J1NGUzN2kzazBQbGpvdXpNRnFSQ0lHRGpPSDUxVmNrRFRhUStGRjdEMllPa3JZdEV3MDlucUcxdlMvWTI3WWh3YVpReUk4ak9PS2l5ZVpXS243dzJaRGZwOUZHZHlxUG0xV3I1Rno4VDErQm5qSSsvc1crZmpEYnVDQkVhdFNOYlBZeXBSWkhYYThHRytFZURMQUJOMFVtbjB6WVlYaVNiSk4yOWZmdjI0NTBjUVBLZCtPYm0wbWE4czlsSlZGclF6TExUMlMzazBVTnlDdDZQMWFpU2x3TlNPa0YxVGRkdUlCeUxiWHNYdVNzMVdtaG9aZ1FOUDQ5eldsNFdsRkRJdnArQk5yUnVNaVZkK3JRS2JsUHI1V2RTRHVnaCs5dHJUNC9qMUNpd2poM1lkMnphRVNvaUhCOU5ibTBsbXM0bU92Ly9nL0h4R3Rac1lFTjBwSGlGeldiQ2RJYlJwZXcyMjkzSHQzY2U0MHprdld2WWo4RzFlZTNXTjdjUVhUbk02cnJPWnIyWkNhQWQ4Zk5vNk9XQURIQVM1c1Z1ZDdJOXRBNnRUUTZ0dDljUjI5U3JhVnhvTm8wd2dDRW1weUdRTWxwalRqZW0wdlBvUmhDUit2NGRYSVBta0hKQUFnMTI0TUMrU3pocTQzMGZ1WVlsV3dROUpDMUZ3MkV0NmxxMVNsNVR4QVV1M2pFVkpZRFpiUkxNWmtOQVpuZDJIdCs1U0h0b2RDb1M5azJPTFdxY3ppTFE4a0pnYWRWZm1qZVcvUDJPMEJRWWlsSFpTQzZuN2RnME01a2cva2w3bzBMYkJweVJXZlgwdUFNOXBJUC8wV3RjYlNocE1zK29WQjZWUjI5QlhZUGJCczhoK3pZK0RpN1l4d2ZnTmUvYzZPVHdCR1FFYU5UNml4aG9oYTJVYStpVEJFR0l4NWRubGlVQ280QUUyZyszZDNaMjd0NitkK2ZDbDNmNlpCZnVGZEVRVnB3NWRNZmRlbDZLQ3lpS1VIK2p2R0FMRExraCtPNjBLNTIwVTlPYmhFVFkyKzRoMnNjU3NIRjRiUHkwRjM1RG9QVFJkQnBPSjFHdXFTRDlwQ1A0SFRMa05mUmFUNTVEeW1qQXdpZDhkbXpjNFhxZmJscmJ1TCtTMkdyV0NTeXNyMWF0YTZ4QkJobzBrR0pSd2dVTHdIR1BXYkxkdTNjSGRvSFpIVUlySnB6WmN0ZVpiMmFFdUxEa1I3bWFML1VuNDZoc3JIZ0ViVFY3RWwydnZTYlZwR1RTM1U3bUF4eTZUYS9EWVNSak9ZRDgxb2cwbGgweW1Vd3E1alZJcFB6SXQwSFA5cEhSOXI4SnRHTWdjemhDOEJyQ2NlSkhyK21oa0JTUVJJWWZlbHdoMkg0eXV5UTFjaExjQnJ2MytNNkZPOStjdjNEbjVoMFdrQlZFWTdidWJPUzdrSkVTdWhHUXlia0dLYWVDNkxiTnBHZlNPcE05YVVyQ3h0NXhkOU11ZmhrS2VlellqMlQwMC9Tb2FPUnZoOU5NT3VyNzRUV3NzcGxNQU9JSlBlVC80N1VRWEhZR3VYdW1Oa3dqaE1nS3JmMTEyM3FRUWZ1dFNyL3NOWVVBZ1JUU2ZZVnNaOXRTQVd5UEgxOUVzdldQNk1MdUZMR3V6TUp2OVhvWENybTBvS0JvTlA2TVJrNnpKMTJxbVdqYWJBTlpMZGtlKy9wcVVscDJJY0dNWjd4VnBCdkJHVjFoVjJnbW9ISHAyd3hOcFdJbFd4NzdvSWQ4OHJOOW9DRS9vaDA3UUY1enpYaE5rMzlCNjQrMUtGYlo1bTBFcEphdnNuajBFNXFnQUphd25JNHZBdzIyYkpNS25idjNibCs0RGJLK2tzQnJSVU1sZ1pWb2pxWStHUG5EYVZqS3pwT1VpNXdPQWVsMng5cnUyQXhrSVczR0JqeXNOdmI3cTFlL25oRjRvL0hNK0RFNmZvQVBuTElPaFZ4YzlPaTNMcmRLWitxaklTQmRrSFVTUUFKNzRyTjltSUVNeGpKTjVUR2FuOE5vSEFGSlJ4REViYTNJOGRicUlhV2NheURqdWtVbWo0d3NIYmRoT0xlRTBYZGZIbkdHQWkvbk1RM0FOS3ViaFl4Z0ZyU00rUUhJU215UGp0TUY0RFVzWldQdVpGU1ZEcVoxRkpCQWUrZnJxMWV1ZkJ1aTF0R0JrZzBiaDkvNEdkZFJuTFpUMjFScGt3NW9Lb3BJaS95TGdRRHh4R2Y3QUozUVRpSWVEMHpUV1ZIOGd6b0t5QTBEVmpXMHlnNXdLR3ZXdFNwNURSVVhMVk5Lc3FjcDRWSjloU3hMbllXRnhkWHpIMytLVzA3SWNPdkp4OGV4YzloRmV5d1ZVcDA0b2xqUXpxL096L05Vc2xVQkRXZVBRZjNkdGJHWm9NNU1Qak1ITWFxNit2WC9BdHVWNjN0ZjJjOGNSaTV6SE4zLzdmVXJWNjVlZFNYdE90aE12MkpiaUV1ZWFBMVdTRWovZmh5dnQ1ajErQ2U5dW9uaFVScjdWQklaN0w5Nk1QUGgxd2dOYkFxd2FRVjNyQ2d0MjVpQnNWeWdKbVQxTk00YXN3TzV1QS9xMDJrM1JyVFpnclBvbEZJU0J1R2NmNzQwZjM3ZUR6UVJkWTFMdTBHMkRxL05CR2VDWnQxWWVpeXBDeUllUTFldlhQOTI3d2UvdllMamdyKyt6RTRNNGpBa1R0aGRqU1oxNlRRbUkrcHdDR1hOU3RVWUpnZmtFM3BJaHJidkpHV2JXbzhROXhwVnVGbHlkSExyL3YydERJMTk5R3d5M2c5SWF0MlZuTzlJdzhZS2dFQndVcm04Y0d2ejJubWNOY050VUdRZnYzc0pNbEtoSlUwWFVrUUt5VkxOaURMbFVTQWcrMmp1NDI2WFdnMjBvSW53Z0hibDZyZlhyKzgvZVJKc3Y3dnlXMXdmWExrK1BYMzAyOHRYcjBZUmtMcTBCNnBpc2VndFI2bXZKelJtVDFKSStodHZvWWNFMjVRRkdsbjFCamNtUjNGWHlCWUNjbGVrOFRFUEtybUFJbG0wTm9GZlhVWW9VanphMDdaVTkrKytoZFhWMCtjL3hra3oyUzY1RVpCYkZXY1o4UmhZd09sL25LdmgyVDhnZUtnQW00QzJYb1BYUUtaS0JsM1JZREFkUFhvVmtYY0ZSeUJQWHIrKzkvcmV5M3V2djRMamtERDY3ek82R1k5SjVmTHFWVUY0TFF6aHB4Wnh3TE45WkRRQ2cwMWpkd1JEVGZVa1k4T3BxKzBlNWo3WWhKYkorbnYxQ2svRFZpS24vVmpnQ2tmK1BoeGZwSE4wakkzT1lGL3FzcjBNZEtHWStnaHhqYWpWZ293bnIzRXFUc2ZaNExPayszOG1vNjdEMFdnd0dyS0FUUlg2OWpLU2lrNndBb3dBOFltQXZJejh1enp0UWNzZnhBeFNGVFMvWm9HTTlIZlBCanpiUjVhUmsyOGMySCtBS1M3RzdNYVhIbzMyQjVHSjUzZkZQSTIwaVl6WXBzSWdDNThka3BZRjI1Q1VUcU9PSWlJWDRyN1JJKzdGODNTdW4xeEdoNmNMUHJUOWlRYk4xaGNXTkJ3RVV2N1JpUDVsTHJPMDVNYStOT1FqYW9sRzFhRjNYSWVEd1dSdy9HMGNYYjJDMDZ2SU5BS0VnWXJzK2tsSFdvY3lRV0RCSUNxMlJYNUVZcDlpVUErNWIvLzQvbkhMMGZFcFY4amxjZTErdm9IV2Yyc0QwN3BlQnNNUUJYbXRDcFU4dXdZMDZ4ZWZVYjIydDAyMGJBUGZNbTQzc2NXS1MvT01EWEIwQjl1WFdSOUdQaEl5YlNnT05LNGZrTVlTQnEyOFRyaDVEVFdhMEE1YkxDNzlPK29nV2VqTk4zR1gwTTluanVFdk9BenBkdm1Wdng1d2tNdFVIaHlIaWU3Uld5MVRzazkrdVlkOGVmemxjZXZVVk1neXBZN3FTNy8vL1BQL29xN2RwNU4xK20wTXRFQmx4VTR3Sm5aOCtMTWJIejZJMjhoWjRBT1daMWxsbnptRHd6em4yYW5WdDBuN2NlVDQ0ZzhkSjAwUE9sSWVTeHFPQmg0WTVlUG1pTkpTZXZIT1A2OGRyTGx4SFp4NXgyS3hXRjFCZGZSd2REOVcrYS9qaURqZFgvVE1CeC84amdDZnZmenNaVGJWY0xpaUtzU3VHc0lQRVFsWjVSTll2OXhEdm9QN2NmVFdVQ2lrNTBOVC9qMmZ3eDZ5dGFpNEhjWVlFb1B4S2t4WlBmdlpoN0RQUkJ0NmtXVUJNME5HTnpQdk9IMkd0QjkxVFJhU2QzRlU4RjRuaXc1U1NpM1JyYVNyNStmUG4wWmY2Rjh1M1VUTHN1aUdIWFM3eDNDemxPVW84RjZ6V1BiOTRZOS9lZ3UzQ2NGQWgzZTZGNHJ1R1FMYkFZZkxFd1RaWVpRMG9CMDl0TGV2L3IvY1E3NzM4c3RIeDRFMjVaMXk4VkU5b2VFZzYzOVFzbnVRU1BqdFVIVnQ3Ui85NDZ6d21pQ3dkVFkrMCtEalM5NzUwNDVqaU1iWElTRE1ubjMzeTRzLzNMdDQ3MWFuSU9FQWpBMnBCdTJIMytiUFV5dUcrOXVJQzNDMS84dllHYjIyYlVWaC9IbFpHSXdZZy9WU0Jya0VCR2E2dzZnWDBVWEJVTnRjaUs2RlI0d3BrbThLSW9YUXZyVG9xZGhOUUdQVDR3amU5bEJtR3JLUk92U3RJYUoxSWFVaktZejBYOXAzZkROblQwblBsVjFpUXFOZnZuT3V6M1gwWFlsSVI1bVVrdk9JVjBJSnpZQkVhUFVLTGxZMmhpSExjclRXeTYxKzBrS1BsUXJScUhubVZtSFg5NUF6ZUMveVBGUWFZNm5DUXBaVW0xK2lpemc2ZVg3OGxMQk1uQngxUWZVUVZEVDJ1eS9BQnNNQ09TSHJGcDBYenF4ZS9QUDNoNWVJNlJTZmxUeDdEZXZBZURBazR4NlJIVUExc0tIWWRvU01BS2FoSFBPc1Nsd25tUWlOSEdFWTBBMWdYTEFnVFJneUVxcXhOVHZ5dDR4b245RkRjby83UU9zemZWL2R6ZG5aRmR2Sk8xeHpiT1NheDFHWDlLTEhNckx4aGJxM3R3ZW5Tbk1RQkVSWGd1MnRBdFUrdkNLMjZjSExINmNIL3pXWDQrSHdVcldkN1Q1aWV6dVNFYkl4RWRKZTB3OVFabGJzaFBUYmdZY1BYS0FNWGU1RnNyT3VtTEtwZWFSdmoycU5CUlBYOVpEbXBuMWJheDdRdkdacXE1K1Y2bjRpdEk4ZlA1MUJ0cE9UYyt5eWVueDhkSVgyMTBPMDRFRHI3dWM1bGxmcW1kb2J3U0FLUXdtT3ppeDJwNmkxdHgvZS9qN0YxYm12M3hjenNqRU5vRUcxL0pmdFBvMVZ0UlZGV3lLS3BGaVRmTEVDclN3RXBJTnVVQ3prbWRUY3dVVGkyU3ExYlVwSE8vS0FCdEVRTi9lUTNFT3QrWDZxMGNjb3RkeTZBTnZaeGRuRnA0czM3MDUrUFQ4K2YzNTBKZHhDc1A4UVREa0N6L3Y1WFlWbHlHaGt5SUpkakU0UWpLRVk0TjYrbWs3L0tONy9XWXlMNFhBd0hJeUhCME93SGFvZk1QZFRpS3doUVlmUU1zYm4rSlNMd01QT00yVWNZU21PU3lVcXQxQ3FTRENSUXJSVWVuTEQzQm51TTNwSTNwRElTQ3l3dGExQWQ1Y1JHL0x4OG5wNFpPU2M3UGpKNW00WFVGMTZvaUMwRVJVYm1Bak13TzJPQ1EybGRscWNZdTA5UmlxYW9IemNyQ29DUS9RMXIzRko5WWFhaUJkcGJ4R2dVYlZpbEdjU0xvV1lOcTJTVENXbWZlMEpnVyt2Y1pEUnVMNkhwTmh3RzdxbXZaNUdzU3BVMjczOHpjWFpyTllRbUJQbllBdGZWZXJWb050Tjh0dTNnWWYxUGtadlQxTkdCb2dPb0Z5UTRaL0RZb281OG5SYW5CWUZKSnVURFlkd2E2anRuZTNWMWY1cVgyUWJmRU5pZG5RNGQwUHNtMEJiN0pCbWk3VGpFVjVjanhjQlpwWEl3dWI3RWJKUmVsc05vQ0Z1NmlHcDFsenUreDd6Wk1xVVVJcmwrWXU5VWVQOG5NaW8yb3hxVDU1K3MxaW0vUnVDZkhtMmJGSjVyaFEwbzlHYnNSa3MxRnFBcDgxaFVVeFBhVnhkNlQ4OFBDUkRRMVZ2MC9aRHFEVkNRejA1RGtjNGk1U1BvUHVDM05zTDFoM01LV0VGWkVoS1YyWk91YktlU3BESnJZMUx0R3Q3U0NKYjRBRnZSQjcxSXlucjQ1Mk5QcU1aRC94czZjN1I4eVBrNERGK1ZIbVJEQmFJYXVlN3BKVXZzN3liS0VWNFBTU3lHalNiUnJVWlczTkFMUmVrT3h3V2c0UENRQmtQQ3FLNjB1ay9KdFYyYmpHZzFTUjNwTnlBUUNFMUk4QkR6RE95Wk1LVjBzSXJvY005eU1jdmJ5cDVjdy9wMWtEbUM0WjJoTEg3S3NHNkVSNjJBRVlmbktkRlpoZ3lEQUdONEtyVmdDWFVyeThUbW1KS2E5VUxUSkJpTHFrMm1vQmpzMlJhRTR5cXNRcVh6Zit3R1NlUFovbllpckxmYWxKS25EaFVnMGpFVnBtL294R1lZV3U3bWU5YTFKMkV2dlpkMy9nVFBtdUdYRU1sSXlGVGtTbzdVYjBSM3FwR0V4aEdnVFk3SlRvSWoreDFicWZWWnl4aG9MSVZNaGlobXhtQndYTUpzRGFHZXF4QjFDR2pLSVM2N0o3S0t5WW1VWllnSWNuUkpMSUhHZGg0VnFPeWlrdWhaZEZQUVJoVHRrVm9iWEl3azNjYUhsTFhiWG9ZLzZ1MWEzcElaQ1N2YlRWazVHa1JnWXlwcEsvM01KK0RyTjBPMnNBeHYwYlNEbDlNc29DMWxHQjJBb21WRU1yVFRaL1EzQW1ZQ0t6ZHJ2cDlUUmtKemVaR1VRb0NxMmNpeS9xVWpualRUcURXQnJCcUdUU0xuYVUyMVJXcFV5ZkpRRVVQb0xrT2x6MmYvczZSK2hETiszTGVIdC9RUTNMTU9RMFA3VllxaExDVi9lamJwRWUrNmszSGFWZG5lcFVSUnIxSnZSM0JHOGVZc01FbmxNQ1UzSlMrSDJRVDF3WFZKbzVTdlEzdjIwUm43Um1aeVRERFZvOWxOS21tMkRpWHhpMG1ZLzZBY3pmK3ZoUTY4WkxqQU1aQ24weEJhRVFHTnNkZDU3N3IrczFHTCswMW1wNXY3cWw1M2QreUw5SFdPWmNOWktTZ1lDM1IrdWxSUzQwbVlDTURLNEJBTjNzc2hjN0tTaVpZWkxPdi8yWGtERnJjTnFJNGZpNlJTeDBOQVEyQkhoWmhXQWg5QWpHSXJSd05QampMZ0x3YUFudWJxWElJNmlmWVM4L3pHUlpjOERVZnBGK3MvLzk0M1NXSHV2MlBKQ2M0a2VjMy8vY2VUeGhQVGQzZjJvZHU3ajU5U3NQQm1DOVlpZHhxNmQzdXl5NThkQWt0TTlneUZUc25INU5Mc2xHdXJ0Y1BOVklXYUdPemJhVEMyOUxFYlJTaGJ4ZTBpOFFBM3h6RUdESG9MYjRObDRDOC9wc2FDQUhSMHJYUVdXeE5YTnU1L3ZqTCt3ZDNRUHJ2S29oWWFIeGlUTTFtSXczc0RmYlc4bEVFMS9tSnRpRWNqVXd5VGJ2cElHU3JQcVRnVWtSRFNkZk9IYS8vSzhYSW1HeURyYm1LOXFzYjZWcmU5Y3czc1MvRmc4MFQ1eCswaVdpamdhWGVLRFNWNXR0Z3ZzKzFLejFrOHpqc2x5VUVhOWMvMjI1OTZ3N3oxL2YzYzR0NDBpOW9tRmlNMFc4cWlicTFuYTNYdjhFM3NIVmg3dVloSFJKY3kyVEtURHVOOUVMQm9ZRUNPQ2pieHI2ZVVWQTFBY3RpMmNhSCtEdlltR1lSZGFUc3kxSkZsZUUwQnE0WkUzYU5lclVxSnUvUGYwRTBVbWVNcXhVU0hRSFlsdkRXSWl4RDU2YlA2WUMrOU10bmtXd1l5T2djanVqZitSVHNlbDMvYXEydEEvSnp2cHZka0F3eXpjQTJsZU5SNjVkNlNoSnlaYlN6cW8xT3N3VWFScmZrWEJ1bGVRUVpYSXNxKzVicHZLWjNlUFVpZ2c5K3A0dXEwTjVyWDdMTEF0NzE3N0twa1J1TGd1d20yR0dQc0V6VHhOajZzSnNhb09YMTVyeTQ2UTltSm1sWlEvZnJibjBmNWoxc2U1cUhBYm1RSXhKc0xOckU0MUpjdUY0Ync0M1dVM3JxYk1nUDF5SEN0akdPQkl1ak1Pb3luRERoZk9iQUlua1pqYThLTHZFUE1LL1EzK1hhdjFaSXhDVDZ1UGJVSXQ4V0tOaHU0UHg0NHI1NS9YVlYrdGdYdURlQ1N0cTd4UklOK1haNzUyYjZoaElKTWxaSWdPSFFtbndWOU9vWkI4czZiajA0ZW9hanRrMUVISHFTd1JtTWtoYmhoR2NyRGNNOEh3TTBYZFBJeDd4bE90TDJYUHV2L3FZR3dqWlYyQURXdGNlbFBZV2JaYkdoTlplMTkwQXFGVTRJTjg1a1NqbjhJMnZmMWhZS0RuQU9aTWxFSTBJMlNHdnlZU0JoTWlDdnVzckEwTlRNd1FiWWRtdHQyOGV5NkVjQVpqQ0pxb2RuT0JDSVBMSjNzdVY3Z0Z4UmNBNWdQSzUrbC8wR2U2Z1Z4OGY5Y2QrZWx1WFBrMXR1RnBlWU1qajBaZFZYRUY0NFBhVml3MmNzMGxIb1ZrRTNOSU9SeUhDY3NsODZtd2N5Q0VSNklxUzZrRTNKaFFWMWxoSFM5dHV5Yi9vWVdmbnp3R0w2VEhibUkxcEpNdlVHYVpFN2FMcVdkZlc3N0FJNytjRzE0LzdVUGdMdXRQOERJZG5tT2I3a2pOYkFnelNFcS9KTStYYTVZZFhCMm9PTW5kSXcwalIxMFJscWx6R2g3TjVyNTJRTWpBOFl1THErajl0dEdUSDdFZDU0T2xlQ0NWU2xLTHpBT0p3aURCdm1XWDdnSWRkLzlwQS8vb1NBUExiUCsyZmsybWw1eHNlMUprcWVYb1o3bVZzV1Ewb2lHcVA5VFZoUWVhQTdOTzNzQUZHUm8rSi95K2FBNmp3dUM4SS9VWHh6a2dhcmNibzdPUVJKaTNvUHNGTDZLRDJ4VmtVSkR2RUFWRXdHejlPWHZrQ084VkdPV3YyUEh2SnYyczRvTldJWUJxSlFkcUhVenBmdmY5Y21qT21yZUZTa0xXc2l4eHFOZ2dkNWczNldyUHdjR2F2Y0ZCTFBPZVBIdE9zVFZ1bVFCaGlFZ212dy9JdVhkZDlESm1WNTk0dkxzamJvRk80ZWZFc2RIWm4rUFBvZWNtR3JDaVdHbjBsckRIbktqNTdMY2dXYUNhamlLLzVlNCtEM1BXVFpFVGxXb3lIMWRuM2FpOFl0YjFaRkc1OTdKZDFqWTRuMlBTU3lmRG94Q0pXOFZKL3FEM0JPWmFvM1A3NUU3TlUxZDRkMXlHbDZTSGJSRlVmQldpZFhac0FCWUpsTFUyRUxWWENlMXZlUXk1cFVuM3Bpd0pvOHlLY043U3IvUFNhMDlVNnI1S2J6T1pvZU1xSmptWm0reFlIZ0UyYzZ1TEc0TjhTUG96aTdCRlFQQ1RPbU5EL0ovTi80dHY4L3o5L0xQcVZ0MEVSVVNwejQwTTE1clRpMmx3TzUzNURQUzFwQVZWeVBvRnJtTzJyMC9qanUrenFRVzFxcWRyaHNYQzVieDhmcGMzb1R2L2VMZDByTGErVDUvdmFvdXYwR1VMemhnM2M1blluZit4TDMrT3lXREhJWWlHRVE2QmpUK1A4djNtQ09sWHB1ZGt5NGo4Z0MvU0dSNitjTXp2L085aVZYRGFzRmtGV2YxMUNWVGU2UUd0bTlEdldLVzVuUWFGc0pFbjNJeWZXdmdRaXJqUnNKT0hjL0hjZE1hcW9RalB1eHhCYlR0blBkZm9wNUFEZXRLS0N5aFZWckFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vd3d3cm9vdC9pbWFnZXMvU3BpY2VSdWJzX2N1YmUucG5nXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFOb0FBQURhQ0FNQUFBRDN3NnpwQUFBQ2MxQk1WRVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCTWFYRUFBQUFpR0FvakdSRVpDQUlQQ0FFWkVBam01dVlpRUFqdjhPYmUzZGJXMXRiZTN0L3Y3Ky9XMTgwYkVBTG01OTdpNU4zTnpzWE16TXoyOSsvbTdPaTltM1BIeGNibTMrRG41dTJscGFXRWhJUyt2cjcvLy8rWm1abVVsWkhGeHJ5dHJhMTdlM2lOaTQyMXRiV2twWndwR1FpOHZyTUFBQUJJT1NoVlNUdTJ0cTMzOCtab1hWUm1abWJYejg5MGRIUUlBUUJyYTJ0VlJEQXRJaG1lblpJUUFRQ3ZyYUlJQXdtdWoycEtQekttaW1FNUp4bFpWRXFiZ21LUGpJVkpSVHAyYzJwdmIzS0ZjMlZqVWtrdklBMXlZMW83TFNFbUlTUkRNQ1JYVkVLQmczdGtUejUvWlV1VWVWcHNVVDdpNTliMzl0OHhHUWFrbzVUejd0MFFDQXEwdGFVeUtTQmFURVBWMjk5WldWYjM4TytIYlUvejd0YjA5ZmRUUWp0VFNVTnJhMlN0cGFGQU96SllPaGc1SWd6S3pyd3hLUzEwWFVKblcwaTFsWEtNYzFYejZzMTRiVnB5WVU4NkxpdFdNQk5HS2crNGxHdVNoVzFGTnpzVkV4Rm5UVENla1l0MmJtR2lqNEFwREFORUxCcU9pbnFlZTF0WEpBcWZqWEdNZUdnOUdRTzFtNGJYenIvTjJjb2hEUUNha3BwbU5oUlpQU05JUkViaTNjNVJNU2FzbFlQUHhMWXFHQlV6TXpObk9pbjA2TC9GdTdsOFdUSEx1Nk5HSkFkaVFoOXdZR2F4cUkrRWUzazBHaFV5RGdMZXZZUm9UQ1J6UlI2UmVJRFdyMzdQcVhEcHg1R0VZVHlXYzB2RG5vSjRTRCt0ZVZMMzNhL0FqRjE4YkZDUmVHamo2OG5rMjhiZXJHclB0cEx2MnFlc2RVUGR1NTNadFhYb3pLSFJtbGpmdlpEaHhhT1NYejZ3aUZ2S3JZNXlTeXpydG5TOXA0VGsxcmJnejdpUFR6MTdTaStvZW1SMmViYk9Sem1NU2k3QVYwZmpRaC9CUXl5M1VUL1R0RzE1QUFBQUNYUlNUbE1SWmxVemR5S0lBRVR5QmtObkFBQkdWMGxFUVZSNEFkeVZRUTdEUUFnRHNZR3RwZlQvNzIyTmtrZUVZZkdCMjhpSGpjOU4rTzJJbTVnWWVrY1lhM25uMXAyZHVTTXMrS2gxcC83UXo4c1hoNVNXczllWWlRUUtNNFYzRDBpTjI2aUpPSHVvc3R1MDFrbGMzMDBEWnNlb2lXZVYyWFdvUnczbnZtMVJnenBNQ3R0YWczSmFTMVZkcTl3T09IOWJ0MnBiYXpXdGhWczdPMXV6V3Ywb3FhSmNSMklRSmozdFQwb3MvM0c2T2NvZWZzR2dNRTh6V3FrZU1DWkRXN21KMG1zRUY5ZGFXZS9ndlVBOEFyL1hPSE5WV1FJaVNXWlZKTkI5c1lRZVZPT1pJT0VoUGFOaDI5d3ltdm9XbkYyTEEvbHpic2orS1ZROWxzWUNGZjhGS25zNEphQWU5d0c5SzgwczN1OTZGVkppT0xHVThOQ1JmdExjaXF4Uk5tclgra0QycmgxSFl3QVBJZkRlOCtsc3BpSXcyL2o0Z0l3TmVQOGNhL2RxQXoyTGczQUZuZklHR1pOSFB3Znl6L09HWEFMdWY5c2NwZXlJZm5NcjRwbzgxTzhBYXFLcWRIM0gyT2dHTXNGMXhtb25VeENlRFJra2E3V0pEQ3BEK1loKzcxb2Z5Tm0xY2RVS3dTbDZkVEd5VmpoKzV2QXBORFdQUmxXZEM1Nk9NelNqRUJFOUxTOWNuZ3V1T2FjN0hFM3VSNW8zbSt5MWpiY2I4dTJVNEJ5U0o3RGU4VmxQZkQvSnUyUXluWldMSlh6UlhVR2ZFL2wyUThJUVNMSDN4Z1VyR1hYYnBkalhEbHdaVjY1dXFTMGd0RjFSbExhaEowSmQ0YXJFWlMwdjlTSkJ2eTdPcjRlcHo4Q084TllHMXhMNmdvekdZZFkyM201SURCYSt3NXBjUlRqZDM0ekFwMmVJNzJCNFFzNjgvNGR5dGYreGFnVTVrcXRJZEIzeHU5UzczbkdFMW5mdVVyWmFJckhZbFN4TEdKYTU0UUFlVy9vTFM1TTdYNkVPVWplY0NEQWlrYXVaMUV5VFpXTUllT1k1Z21kdzk2K0tRdUlmVHZBSFFYSVdEd0ErY3NhcWtLaDlvWkFaSXVXUUszS0I0WEloVzE5ajlwNU91WnlMWndpSU5HTDYrVHdhaUhZNFRwUnFDbGxBUXJyNkg5MEJSVjRCZ2ZLNUZUNEsxWmtkcEhKMjFwRnh1YUtRbWNscFFIRDJaMjVkWHYybWIzN0d4Vk12bVoxdWtzaEIrcDJEQ2hKbHFDaGtPYXpjUGVkd3ZuNGxIS0h1dGt5MlpBb0E5UzZIN3pCazMvTmNPeXRrQVhGaUJybjZSUEQxZEhielN4RVBjTEtuNGVUSlZsWEk1TjluVEhoOUFLODNxVFBET3JPY2luZi85OG9hOHZSZ2l3anQrbHZiM29ieGR0VGR4N1p0bXp1bTFBMHQyZTlSN2FncEYrQitDem15alJJREpPeDdRNlh4SHRIZVM3eDc3Sjl3QW56RG5RZkNMSlVrcmI0cElCTzFMeFN5K3R3SE02MTZYLzA2aGJ0MzdleXR0dXQ4NlNLeHhuM2FYYS9USll4OTJyWFY2d2pqdW5PT0YwdTUxYnUxVSt4d3Y4d3IxZmo1OWhINzM2aThKN3pRelU0SER1VXd6cDdNM3ZzV21GVThzdHVRYXl1N2JLeWtZZFpxN3JCWnBXcDRKR1pWL2c2OVY5YUZvVjY4dGczQ3JQUWN1SmxOcUE1Q2JudnV2NGp0RHRocmFac0F0NnNac2JIS0d3eDRsdkF3NHJFUGxWZ011MWFKamZOaDBwN3ZvcVEveXdpN0xjdkl0NnBDbmwvWjNheWtDeGRhR3Fveld1NGRtK3ltRFFmZ0ttWFBiWjFVTTNOdHBGZzVXemNmMm5VcVVtMFhPVE9jM2lhRzY1VmNLZDVPZUxnSzJZVGJMcFJSTnlWYnlxQmJHUzRyQjRkajJNZng1cWV5aHN6VCsvUithL1VpdTNBOXFKVk9kbHR1UDVFNWJRdkZXemZKeFZ4RG9NbEYzNWlUV2p5MSs0ZDlFeCtKMEIyM2w1dGh1RTNHUUhhTDlOMEpEOUV2aW1BdnF4NGhQakhwaDZmNUQ1QThGbmRIM3pITHlGY0tXYjVXNE5tQmt4VFRVV3hIT2c0ZlJHKzBPR29oaDcvZmpzZk5MVWUxVE5od0dNWDBUdFRlMlExUzk0Z3orNVFUa0hmM01lSmh4a09ZaUJwSEtkTmtaOHRGVGFhNXY1L0NNWDBWUUtpdklXT1B4TzJKcDEyMk9mc1FhR2c2Y2djaVpmQkdBN3EvQmV1OGJEWlM4eGV2TnR0QjhwcjZwNzNNbG4yWDRFSVFDTlVnNDMzRUNpMUM1SDl1NmpMWkxZUmhnQldMM0ZkaTErVmxTdlJaMkpUeTNwWFgvL3ozTzRXRWZPUVViamhqVHZNaTlxUEp6cGFXcVIwbUtXd01TTFhMUmVnV0V6V3EwRXJLbVJwU0lWRWo1Q2JpWWNMN0YzQkFTcTBXSVQvN283N3htNkM2MVhYd3BQdk1LbjRqWVJXcHJpRVJDbkpjakY0VHkyZW15N3FuWTR2T2tvU3hhT2doOXBrV3NRYXYwVUFhczBrL3BJRGM3Z2lkbHlTQllBVjdEWkxYSWw0TThKM3dJb3owbmQ2MHk5SFR6aVN6dWkxVmhPbXhrQURVZHRuRldqU2ZHQ05xZUx6Sm5jVkE2QjdUVTcvOXZJY0JzclZidDJXTzFPU0E0QmYxVDVjQ2tpNWdrSnNkMElsbC9RZzNDdjZHTnVBQjI5bUxISkFNQXlORjl5M2Nwc0dRUEJIT1NnTGZJelVtUjlSQ1BINnRrSlUxVWllRk1yR3VkUU44YUNxR0JrNEdlWmhJMHdPRmhnV0ZjeFdjMTZsRm04TWJtcWRkZkFnRGlVY1RxajlabjlpYThGVEF3eWt5VEc1M240RWhqbEtzYVpzRG1IalJqejFZV1VQVzFuNHRpWEw3QVhnM0t3dFlzOGkxWWEwbUp6V1J3czdyaU1ITHhXQ2NhMnZvdDJ6cjdVbjhUZEJDSHZJMFVPMWxEMFVNZUIrTXQyeUI4N3JJa0Z2Qjcwa3dhcjJ3VzF1NVhaTHNBMUVpTC9HbmcyL2Y2TVZXK3c1WjJVTUNEMloxbDNhMmJjZUdacFBlWEl5WHpBdzRrS1IxbDhlbldseHdyU2R2bWpzTWxFdC82Y2FaS0UxdDYxYTV0TnpCYlNUbWhDWkRZRVBHWTJiUU9VM2RXbmJpc3VoNWVHdWt0UE9sTmF2MFdVV1lHeWtJc1NOeWRLcnVzdU12N3huNUlsVU5UaXByMi80b2Q4YnFYVm56bmdUSGVGWkFFK3pnV2Qzc0NJMFZRc2kxTjNvSkNxbmxQR0tjVkVacHJmMGphZGZIZ1JlS281WFUzQ042S1FTRk5OeVZNMTd2T29RTTk0LzgrRU01YytQMG82cVFVTDdYWHRtV3dLczdFemhYNUxyWCs2WUhIZzcrZ1B6R0VVbThTQ3dyLzFKemdxdDkxb0d5a1AzOC9PTElLQ2ZJTXlhYytVTDY1VUlPUjNnN0hQV0x6eHljcit5eVQvZUg4SmVQVTB2STQwZzFkRjBZMGxYS1NtdHBld1pDeURYWmVIQ0xNNDErK1IraXZsTEkyS204VzU1c21WSStuL2huV3pIK29qcG1aWTlzL3UrQm1lZGFsSDRPU0E3SjF4VHlLYlRnOVM4SGY3NE5uQ3VTeitoNEM4dXM0N3R4MkdQL1ZpSHJxUFVFbGVveW9PdmZ3S3BmYnBPNytCZjJhY1RseDErL2ZsMi8vYUtJdk5aMzJkbnJlVGlwZURMQ2taOUp3S2sxNTJlaXVjTzVJMThYMWVrVWpmQVc1aHF6STJKWE9sMHJhOGlTU2FselVCZk5zazhPNkd3cllBb1ZyWWh5WmZxRkJjbGZ3WFBFaXNoZHIvVmROcDdrQVA3UXYxYkEvOVg3L0lZZ1lsRWh2M0ZFOHUvditocnlOMk9BOCtNOVIrbExZenBYWmh1Y1F4bWU2eUVuakpzMUZnNE94U3N4STJxVlhYWkN6cHBmb3FiTFhGKytTR092MUx4c2U0Yk1vNDdFSWthQmw4em5WMUZhak5BZlUyTm0xOXAzeUloY3ZGc1I4a1VtYy9aai9rdlcwZ0ZsajB5bzdtMG9Uc1ZsZW1YVDdqbzY3VnBUU0NoN0t6RmhyNFh3MkFqUjhPR0V4VjRJc2x0aHd4SHRqdXBBT3B5RXBjcEdjRUxnYWlFTmQyUzRRUmpBaENDRWF3UlhoRVlPRzhWbmlGbTRGVmtaWnU4T0d4YTIwUXFodytxWTZQRkU0Ny9xR2hLZTUwOGplclFXUitYUTh5SjhSWlNiZ2NtUmNSUWpIMlFIdHRzWlc2TFlLK3lwY3Ayd2t3d2tIempybjZ0SFRrNTVoSVRnSkk2NkF5SkR2Q2ZYYlE2TmFEaDdpT2JEcitBK0VRaW5GMjIyY1lac213aXM2MVVRZjFMSTdMWDZHaklIU0NPR2pnWktvOE5wd25Bb0kvdkpBTHRnZ0NIYm5ZWjVrdWptWU9DV0lTa0RSMmVnd2sxMEFXRWdCS01hL2M3VmMrRGRTcnJXTTJXQWVxWWV4Q3pjc1pGRHRpSHV3VFlodEhLTTJ6VStyZ2UzeW5mSTVMTHN0VWFFalRGT2doSWhTckRlUGNqWWMwV3dBendVT2ZCZGtiLzBBTDNvUSt1ZURLaUVVQ09Qa05EYUNXVkwxREFnUENqVVFwQk1qak5uQXhObmdUTUdtQkVDem9Oc0FJY05wZ25ZUmxkTzdQMlBZdzNKekpoYlJTR0RoR1RaSTYvUmNJRmRRcERSYTMwdmRLVFdNNHRrQitrODJubEhZRVBnQXBTVTRadzdJL0NlMUVOQ01LcFREbmo0SzkvdkllbmF6NGE5NW1mcU1Zb0dHYWVYaldGM3NRMEFrbzBCblFMV2tEZjRLekNqdjhqaTZ6VmtsbGc2Mkd1Z0xQVEtnUGNJRXgyeUJ5Y3VQNUhuR1RDdllIOGd6c0tCb3lQTU5UOUJwenA0SThJTTVIbUV2UVpzWlFkTGo0NWRJYUdoN2tTSzJrL3VIZ1NpNzBNMmdGOTVNaUYzWE5yKzJkYUQ5MkJVNTJicUNlSC9iUUhMQ0swaGlWcGxsNTBGR2lCU0d6WDUvMWtoQWRUajM1QVVFcU1kc0JVZGpCeUZhMUpJQU9MS05iSEk2cWFFWWdTZWdsUWM2QUFNVVdmQVNFR2FnNVJ0aG5zMGhnN3VaWWs5VmRMajVDYi9JZFFNYnlzR1lTQThBTEZZSjMrUU9rS2xOMDkzYjkzam5meFpLWVdrTWpUUDRXUWJuUjM4djY5ZmhZbHR4RWlMSlVIK2wwUHE2MVhFejhxYzJPekx4d0UwajlnRXVaUGdzVDFkRFhRWURSU1BqUnhodDVnN3E3bHR0U09IM0JvK1AxNm9sVlNDcTg1WlNPNVBoSXIwRk9yWnpVLzgxNUxiR0NOTmxrNTU0cENwam9rc0lKRFBHU09QVGVROGY2d09tdVlyYnlzd2h0clJZZ016N0prdW1jaXVkVitITExzb3hNdElvdmdRTEczRGxZTjN3bW5UZDBiNHhPS1lvVFdPU3J3enNRblp1ZzkxeU1hMVF5THFrc1VDMlJyTEJjR05jVVZzSXdXQkdMTG5JcVlWVTdrTytMS2FWU3MvTTVTTG5qbWtGLzFISHVNeERjWFlrWUYwSURReEJUeE04Q01pOXNwQ2M3S3JsdHZVUmRGQVI5MTEvblRJaExZT0hKSitCMVcyV005aEdCcEY4Q1I5YThzVDc2b2VzQTBNZFI1alE1bnZRdVJTeG5iaWtGaXJ6TjdDRDhBd1Q1Q2VxSS8zTGFBWEJqVXp5K01BSXlucWtmcElaOXordU5hSlE5b091dGs3RUhac2VocGJWbmZnVXRvMnM1NFpGUW0reVBlbVhIUmRxbzFjUnc3cEpYaVI0VlB2MVU1dWZVL1BwdURpamdZYnRMMnhSMkxNb2wvWEk3eXBENGNxaXl2WURsazJpd0E5YnVoek5tKzl2SGNCa01PVVBscDFGOVlTZWR3OWIvOENyK3hXVTJWMXBOSFdLY3VXSG03cVQrR0dlUGJRY29WUzlvQmlZcytCeWdtWlBrd2tOaFJnQ002bkQ4YlExOFA3ekNITE1xci9xRkhrSk1hUW9NOHlkR1l2UWZYTnR4bTF1TW1zY2Z3Nkp1SmR2b1hvZ0JkQmVRbURnZ2UwcnJKbFFaQklLT2lpMGcyRmt3U2FYRVFvOUNMVVVyQ0ZrRndrWkcvMmNDN09WOWhQZHY3UHpOTDM1bTMrTTA2V1NOWGYvSjk1SEZPSHFNZ0xWZnRENzBFYXhTTFpTMVJBay9PUlczUElnVlEycFRLYWppWWpsYVR0OTBQeFhyMDRsQ3A2Uzd4Z0x5Y0RBMGpzVGk4cDFkQjFveWlPM0hPYTduWjdqUlRsak9WSnpueGUyWDZaekJjZXI3alBsNkd1Nnc2YkJ4NDB6OHVTOFRpS2wzRVV1VHFKRk5kdDIraDdUZGVWZ1M2RXMxRzdIMnZhSHBkaEdBYW1XT0FhRVFMVmY4eVFzb00yMlFaczJkM2RaZ0srRWZqMjQ3MjRlSldBMEFKUFFPRU1LTlJxQTV4OWwxNHVGMTBQM2JQcnRwR2I3dmFDYkt4elZ2Z3NRZkZ0bjVVSlVBcWcrVHpHUHpVSnk1c0hscGZrSlk5TjA2elFNUVJOQ3R1VzJCcjZzOGVtUTBRV0FtcUFrdzRJelhoN0YvN1dIRkpxQ3JicGRITzNRVHRDbjB4SFJFWXNKQlZ3WUpOVzZYcFBGZEtnblpTZW5zUEdiVUpkR3c3SE1GMkxHR09jc1lUZ1FKWjdNSWo3aFYvd1poRDZYdTU1bG1WNVhza1lONm5BOUREc2dSS3UyN28yVjIzYnJwdVV3RkNsZWtHNFI1ZE9DSTBFZ050cmFyQVp4aFRhWk5uVW9BSTQrRVVvb2toRzRaV0d3d3ZuSkJzQ2Q3K2prcWI2cGRkM0lJUGxRMjFtczV6QnFodzFMMUdKclNqZ0duUDFtVjk2ODNlUFFDdDV3UXB1bXR3M285WUZROXEwZFlkU3Q2djFlbzJ1U2lXYlZJclFCNjZPempmbzkzRnNNaDcvOFNuN2JmVVBjQ0I0WnNnQ05DQXBZcG9nM1ZLQTVoQWN5dSt6Z1hjOHhyQUVtMFl1VTBxbWxTV2FhYlA3UEFpQ2hRYzJMMGhLNE9Xd0RDam5zVk45OXg2SkxNQTNqQlZteFV0dXVpRkFtcnJydWl1eHJVbE5JOWxDUVgxczhBVkpKZGZrYjFzM01pVGxCZUJOUVVQT1NURDY2KzhsQkVSQWZIUUtIVUZEWjByUkNqWVZHZ0lKZlBoQTBxS1JPdFJNMCtiMmZYQVBPbXNSQkRrckM3aUdnR1RNSGFvZnZibGxMZVlMNUJDWXk3a0pRekhXVWlJN2JhOWJOSFZicjlaZmlJM08ycWZuWnIxZWtaT2tGRmVvamxGdXZqR092V1NieFByZFpwdU5vamlPTTROY3gra0hxaktHWGVHNUlTd2gwQkhhUUJWcmdJUmRmMDJteG1SQ0M0WDAxclRqanQyelJiQ3dna1hnZ1kzbFBnZUpIZTNIanZmT1dpUUJCaUxMYzdJUzVLYUxnOWIxYWZ1NjNYYW85UThCMHFBelpaeitxS0hWaXZpT0ZKRHlmYVliVDlsd2cyUkkwNmhPaU92T2tXQS9vNlhRN003UkZUaEZaTlM3WDVzVWYvVXBETTBtbEhaQU5aVkhvSnVPNXJSbWJkcjJsaEVWSWpNcGlnTDJWR2pDdm5keUM1R2E1RG4yTUhBeEx3ZWFmbG5YMSsyYk9zSTRIbzhZYmtUV2RTY1N3UkhhQ0s0Tmg2aWpQODhoVWNUYUxJbTJ5UVNYZ0tJTlROV3lJdmxWWlM0ajEzVWFZa080QTdBUnh2WFppTEJRUlFPeWJEd2M2MjVydGpUZ2tnVmpEQkNzS0hpMTVKVVpLYUZ5NWp4WUpEbnk1Z0k3a0dvQUdKOTM2YXE3UHJ3UzJMWHJKQnU2RUdUSDduUjl2VUswQTJ3clhPOWY4aitpYm1USXR5VlZCcnArTS9zNVV4UWdSZEJzaVErUVNkRWR5Y2RtbXJndk95N1VnQXhzNlE2NUk1dFFIRXM0bkpGZXd0RndFMjlqKzU3ZEIwREw3MmxFeFRoZUJQTVZUWW1XTENtWUYxaUJ6OHJjQ2p4V1JCY3RyYTlYaVVCa25VRDdtbEp1dWI0ZVhzSDg5UEJ3RlY5VGxFbmRYbldvb3FEckp4dG50dnhKR0pXSlFzM1NYQUxxdHhnS0FDc3pwc2tEa1ZIUkNRNGRTQkkvZkFJTnlmTHN6bUp1Mnd5RzJQZkZmd0ZHZ2RDTDJkTEFxVERDeXR5emtGbm9EdWZsUDl6aHNLbWZnWVd3TzUwNkV2dzVmdDN0bXRYcDlYQjRPank5ZjNvaXRGcmtrY21FcGlPRThLZW43TDhmZ3NTeXc4MnN0SklrS1FIQmJWK2lRR1dKbW54UDhBV0o0ak0yWS9kTUtlVUM1M2I3SVUzb1NFZ29HcVFPTWFUY3VMT0x3dXpNcldsR3MyZ1p6WHAxVEVFeW1GVlJSWUhvRjJVZTRMUGt5bkRVZE5mbjYrbGFReWNienRWQWEzYnArdlQ4ZkhoNWVmL3B3LzhlRHRjVDBDaVBEQUZHQUxmbmtKcFlGNGlDM2tkeS9QanpzK2Q1eVNKaGlWQ1plQ1hhMGdOYndnQW42VGpuaU0vVy9ZcHBJNnFtQW9yQWRyc2V5VnFiR0JraU40NnJPTUt3aTEyUUxVRTJWRW1aNmpoRjdnV1llK1VzQ0pCUGxyaVdzTDZDN1Z1OW9rUzUvZFhWNnkvSHl4NWhDclREeTRmL2ZQcndma3ZnU0NRVDQyMldmT3NwV3k3YkpXbEVseGxRTnQzTUt0OTdYQ0JVa2dRVHZUbFFwWUJYU2piazdNSzJnNGR0MXpZWWM3b0c3VEh6b293V051bllHQ2xPZi9meHJsZG1vYU1vQUVOdUFscUdna21FVStXczVKOEx6b2pNRC9GYmdOWmVYMkhiQ2lHSjlHOTNNaDZQMzU2L1BSOEE5K0hsMDhzQjBVcEpjbXhRZnNSMkkwT0tSMnFpa21XalpwUVNaTDVVcXUvbC9ORjZ0T1lKUEJUeVVHQ2puOGhnNVp3dDN2L2JKdlBjYzY5cmUzQ0Y4dWFnNDI2YVpSbk4zZFFOUFZmMEcyVlpSV0NURDJkZzlmbG5Yc1ZGeWZoU21VeGdSSHRDdGpoOUE5cXYyaGJoZUJudXZwemUyT0RjWVhzRkdmWm9ob2pzc1hvalE4SXkrWkNpYUpCS1pKSk5LdHZjZmY3dVdmOTZON2NRb09EelNFa0p1aElEa0ZmL0o5enNmcHBJb3pCK2p3VXlNeG5YZHhLSFpSdDlnZUpRSmpEVzhwRWxKYVdMTlh6VXhiU2hXbTVBU2llaVVkc1lwSlptNGpnbFpWdG5NWlVpbEVpeTJiMGxYbTdjemZwLzdYT21KTHMzNGpQdFRPbk45TmZ6bm5PZTg2WUVweEtKbDhFZENIaG9RcnRlVTdCYmRpdlpQWUVlVHFMeU8wVG4wQll5eWtmL2NveThwQzI3emkyVUZEU1pzV1VmV21tbysrWHY3MDlQTnc2ckd4YlZ3WHl6VmJwVXlsZXJwNTZvU2xLUkliUWN0V3p5SXhkTzJaMmt1T2VyOFZzVHJ6dVJ6aEh4Z0xXYzI4Y1VVaXpDSGkxTWU0dlR5MENVbGV3ODRNTGhIYStMaGNQQjRBNDFQVVF0Q2JiZFN5R3doZVlUdytIbkkvMGYxckxQeDN4YjlHRTY0bU5qSFhQM3ZZWTVmYWNZaThVV28rT0QwWkduajk3Ly9mNWp0VnExckh5ejBHemFDSnBkdDRqTnd6czhwWWlTSlNrTW5TODBNRnhRSVdtRnhLbVdZeVR4b2hhQ2NDSEsvNzUxekhKWldMK0hvMTRDZ280SUVUWk1Jd1JGeitGRUdFMHNXQThXV3JsV3NwVHMzcDJZV0Y2TzMzMThvQjFwQnlZL1dFK2x5c1haMk92RmNqazZuaG9mVDAybU5WM1hHdzNlMEFJTlRVKy9DbThjZmp5c1dsWExJMHZDZUxjc3k2b0NEZ2NKamVFZFBOZU96NnNSRjNySTh5MlhTQTVISkFlL2hvd3B3ZWUyMXhDZEFFdTgzcDliSFZ2M3AyY1cwSWtRdXpVYXhzSkl1UERVY0pqSThDRGhPbFdmWDEzYTNIeGFuSjJkL2VQelA2NVdNVjNYTlUyWE84eDBHZVEydUFzZ1VrRFgwNU42T3EybjNmU1RWaktmdC9KWWM3bENQTDQ3Y2FtVXRFZ2Uzam5iVXFKZTMvUHk2UHhYckYveGtOUmxFTGxjRHFQZkRySUZ3Z2pvSlIxVkVqcjU4UFJFYjNYc1o2ZEhSMVllRm0rTmJHNXVValZaZ0FzY1JoTWM5c0RnN1NGZzNuNXh3RVJGa1ozZlBuOHlPUWVZeTEyODRBNDNPVE9aU1c5eXJ2RUdCeHFSRWR2UmFtajNwRkN2MXlQSitLL2RNSUdYVHdyVy8rRHkxWTJObDBDcng4blh0NTMvMTZac29KT1N1WUtIVm9qa2tEU3c2OFhZcmY3akgyN0dmaHFkMmI4UHBIWkJtTHZacDRvcUZvL2V0OTZiR3QrT0hoY1J2Z2RyY0xnZTBzenFNQmpwTlRnZkxQYXFndVArZVBYQU5KbmpNRTNIQVRiR1hVYkN1NXd4YmtLY2hBQ20zVmR6RXhNbnJWYnl4dVZ1S3JDZHZsSXpqOVJyV2piWThubGkyOXNMRm5ZaXdLSlpDMlFYL0dLY2hIcE5SVzRxOFd5Mi9IWjlVbmVaSWF2TUVBeUdtdytXVjhhV1FUZTAzeWRKUXFaSE1BeERsQlhtQ0xMSjljR0I0OWdINUI4bWF1Q2didEptajZmczJxMm8rOWZiVDEvY2lpdzdNZ0Ewd0tsYzh6UHU5M091Y29XcGhBZzhacllwblZUMCtObURkOEhkeTh1VURNdStHMDJMNUoxcHBlSUk1aU4yQ3lIcC9GYUY5T0oySXo2L3VsbDh2WjFhVDJ0K2JxcE1WUlJEVVZXRDdsMHplS0EvdXpYMGk5SWxYWkZFMFpBVldTRVpzaWdLR1VGcEJOWlQyNHZIeFNKYTRDaHRWbmxGRk5rNHMvRG95WnN2WHlwbkZkbW9HUlVaaUV3R0YxUDltdWIzQndJYVk1b0pPb1cxWmNvMVdUNXozS09qOHAyMS9jNFFkdGpzSm1IWk51TFdCQnNaZjVqSUU5cVRST1F1Mm9kcysrUGJENC9MMThjSEoxR3Y2SjZxU2gvY1lIUUFrT1BxNzEvcDYrcVN1aVN3ZVNJMnVtYWtIa2xDSkJYR05YMTljR0I3b055UGNqNHl2Ykt5a2dqdkxUMnV5YzY5aWlBWW5FR0tMQXRpeFpEeHBjaU1JVzdjenhrSHFHb1lGYVZpVnB5SzdKd1pBS3c1NlRmbDZTeGFKV0haVFp3d3YrVXRsTTVjem9heEk3anViKzlETGtZSHJsKzcxanZZMXhjSStQM2VwMVpFQXdGU0NBRkJWQUg1ZlJmcGlpUmxNaGt4QTdnTTJFaVNLQkZ6VDArUEtING5HWVppcUExOXN2ZmE5UmQzZjc3NlowMitKd3VDNEtpTTRnMDRwc29DSkxZUFdaVEI1MmU0WGFWQ2dVVmNLUThjNTR3NU5lM3RpNldJWFRvNXNVa0FMTmoydjRTYy9XOVQxeDNHZis0bVhlNzFDL2NhM3hESEVEZEp2UWpWaENqTWkxQlR2RUJWR2tWZEhkbGxRaUZoYVZmS3FOdXdLQ1ZRQWhYUWxRNjNtdE9Ya2FZV3NwM1lqbFhBanVQWVRrakp5MFNsL1VsN25uUHNtVmFiK3ozM25IdXhLcFdQbnU5NXZ1ZWNLeTdMNW5jd1A2RmFreldrbE0zdDd2Sjg2bTFyRTJUNzYyUU0zUGJoL3dRMFE3VWhGREFRRGdFd1pxUm1aUWcrRFZPUmtPaUs1Y3daNjFZK3ZUSDM4Rzd3d2QxZzhLN2RxaGthL2dzSEdBMmk4YkpUZWo1WVFXbXhFeFVCUHNmNTJ5Z1c1Mjkvc3ZYMS9KV2pmL3MxNE5nWVBOYkZhcFVHdWFmWm14cVVQUXdDRFdRZEpFTTYxckJxeWVjNHN1LzJFWWVtakFMTmhIQXUxeGtYMmZBM0VXQUdVcEpCS0hJTGRQYUg1V1Rxd2NNSGtXQWtHR3pWZFVPekdnYXBNSklUbCtWNU1hOVJKNkFlNERYK2JOY0lkeHRObEkzYjUvdFBSaitDY3ZYQUNUV1dHWHU0cEcvMnBvWkg3UUx0MC9hNmFMUVFTVVpEeE4zT2FYY0VhT05rTTAyWFpNTThRK0JKTVJUaUtXZ3VJT0VYM0N5NFAwa21DOUFzOGtBZmF3M3F1cTRZdXNIUVpRZW94V0VIMi9uOXo5T3ZISnlDbWd6a0pWUFRBYmJ1N3ZPbjUxOWQrS2dlUExUbmVSVmFNNGNVWUVEcjZtcXZvMGt5SmhnVVlaN1FFNDg0N0JaMWRCeHNKdGt3NVZvMVFKRENaVnFwcElsdUczZVpMcEpiWFhvd2VNWlZhWW5QQlEzMVFVUVBFd3dOUkZCUEFSazZIa0VDSmhveGJJaTFBSnhRakRuSjRCKy9STDFEekp6RGtTQU9kSUdGais2OFNhNjl6elZ6eUwyc0QwVHplTnJyK2NqMEoxY3Q0QmgyeXhFMHFFYTRjWmZFb0hRWWNjZVBKcG9OckZhckhkYlRDbU5GQWR6S0p3c1IzVFJKRmxaQVpoSVBEVStLdkJ1S3JrRTd6UUkwa2lFM0VTeHlEZ1lvc1RMRFdxWGZlM3IrbFQzYzZ2SmpRaWg0Skd2dWtDVERkQU1hUkt1akFhTkdwcURqa1U2R21XNXpqaU5jSEV6aEk0Z3psbjM3RDNUQURiRXl1ZGQ3OHR0N3IwNWN1ZmNLRHZUdjNYdC9LVkdlR3dQYVdOaW5xa3JZcFNvcXlVeFZRY05JVm5aY0ZKUVdBazVtbzUxc1dJV0pKUmtxUGRoQzg3Zis4aXVldmVCZzhFMkpodDc4NjJjTW90VlZrNkloRENzbkVXNElNZlZzNDVMTnNyL2pYMTZQdSs5ZVQ5K0p3ZDZUSjE5OWVYSmdBYXVaeWVqZnA0Y20zOGJMbDNORDA5SHBhSFcxRWhuVFZUWHNDNnZLcU9UUlZUTnNTakpJcDlaVTVJaWJnUTQyVUdJa0hvcHM5NWZkWDRQdHJkRG44MWNQODBoY2JFeHdnQXJSZ05iRUlXVjBTZFZlK0FtYTBxb282Rkk0NkFiVkRvNGZkTzJmY1ovbytlREtlMmVyNzExNS8vWFhGNnZWTjQ0ZS9ld2ExdFhSYWJ4em1UejBwK2lob1hQbk11ZWl5ZFhsU0dzNFBEYmlVM1dmb3FzNk1CbmdZaERRRkhnbWRJTjQwbDlrNEpIaUFRNlN2WWlPVGRCVnorSGZ2bzF2WW55SVkxMnVSZlkwZDhpR2FsNmkxYWVhRkkxQjRSQVdUQ01UWkFkYlp6ODRlWHg5YWkyOWxrZ21SS1JicnU1K2YvYkNQMisrODg3Q3dLR0JVME52bjVzZUdEbzZzTGlhV2tZdWpvUlYzU0FWTGlCS01CdWFlQ0NaNEFJWnhhdURXYUVjMkFpSFBRL2lMYi9mTXh1WURjM09ETC8vOHUvL2lJSU4yZUR2VGRhUVAxZU45WnBURFVnQ1RkWXNqWWJwQXBuVGQvcGlQbEV1bDFQRmNoeXRYQ21XdG9xVlVxVzhjZkhzNVQvendQelU1UFQwNU1DMXZ4NlBGeUpqWVZWVmZYWmg1bHBRRFlJUGhNeEhJQUhQWkZOQVdlTVRCaW82YXh6UWFQL2RwK2REM25tdjN3T3llZi9WMmNEVndVRnFodFo4bDgxd2UzNnVta3hIQkZkUUFnNC9BZTJnTS9KRnFWUXM1dk5sOUVSK0kzM3IxZ1lpRDd4QzhZZmpsM0ZZL3Rwci8zajMxS0hGMVhKd2JDdzhvcXBPcUtVSE5ZZW0yeDFCSFhkZzFmMUVCeHNDby9STU9kQk1HQUx0QzdDRi9KNVF5RFBqd2VaOGRuYTJjM2p3T1pJMTMyWExlS2FzaWFvR0ZNbkZhSlZHZ201alJxcGJsVW81bnpoMmZYY2ovVVBpK09ManpDSk9RSzh2WGIrWTNnRDByUXVYOW43NDJydEQwV1BKMGxoa2JHUkU5Y2xKNWtRUFFqUXNOcmowY0ZoUTFWUk1LVm9sT3dOUEppUmpBQ3pJWlFsWEpEaG04SG9BRnBnSmhmeUJtV0Vzdi9kS3RtYm5rQTNWaUViVkpKb2hzVXd4MlJTWmxKaHNDTi9EeXNiVTFMSHFHNW5NSDVhV2dQVlY5ZXpPNVZnc2s4a3NMaDNMVnlySnBWTTRiSG1jM2tRK0NqUmRXSUtHaEZTTm9PcDAycHdxNTVLdVdYQ2hhQnFpbE1zZ24zeXFxK1lnR3VaYllEZ3dRN1NyZ2VFcmd4TjdNZGZRZnRraDNWUk5vc201QnBvNm13dGpMU05kQnhrUE4xcGExbys5dFB2UzlhVnN0cnFTVHVmU0xidVpuZXI2MC91eHg1bnJMWlZTL3IxTDMxWExxV1dLTnVKVXNhZFI5U0JTVXNQbFZHMWdjN0tyZUZheE5zWTZaSjhtTktQdGt4S2xWTlkzc3AwbldrZS9OeENZOGN5SFpqellORTMwaU1OalNmWi96eUZGZzQwMFZKTUdTU3hjOVowTW9qN1pIbjZjVHFSS3FWSjhLbGw0dExLU3krV1NMYnZWN0hvV3NYUjJKMVpOcDFMSmFpNWVpaEROQnpaVmQ0clFISFpkVWdIUFJ1c1h6NnB1c1N2dy8zcVZJMkd3NWlMU1IrQ1NiZDdRRE03QlFqT3pnZUhoM2l2eUg1ODArNEp1N1p1YlJHdi9TY1Vta0F0a3FyU1NHdHNvSjl2ZGpXS3FWRXJGVjZmVzRvK3lLNERMTGkydFRFMGwwOW1wUlBMaWRpeVczZHpjWEkzUFJYeFV6ZWNqbGN4RFE3UFpKQmtGc3pnMEE2R28rSkZPQXJQRVNMUmdFR0NNVHlnYTBLaGF5Qk1JK0lFMk85eloyY3ZENCtiLzZoQmszR1UvcTVvNEZhak5OWmZxTWlXYkNFTmtwRzlzR2NZZlQ2d21rOG0xWEM2YlhWLzhhcWtsUFpYWXlDV1RMVDkrLy9UTzlzcmE1cU5VSkR4YUkvTTVKUkFWd3NBLzhRbTVTRzBNYkk1SUNOV2NvaTVBdGFCUmc2Tm8ySVZqRVFuem4vR0U0SkNCenNHK0NSejQ0L3BkTTRlVW55U1ZxZ0ZOcW5aR3MwcnJWMTAyNWRtTU5KM0Mva3Z4Ukp4d0xlc1FiYjBsdDU3TWwvUHhZcUs0bGx2WjN0NnVabjljZXdRVENhdkFrbEVIcTJHSm15bTVGTU9DUXdXY3R3RFV3cDJCSXN4RXN0WHlzYnVqdnkzVTdwL3g5OWZtMmdUQjhPYXNpVU9TREV1V3VrTTJFdEtRRm1LYVVyYlcvMDQyeEJpeU1aNkNhT3NBQTFlNVVpbVZ5NlZ5T3JuNzc2YzdUN2UzVjFiV0lCcHFHcUNlWlpPMytxQlROUU0wNG9hS2dMQm92T3dRRGE1amwyemRuR29kVkEzNXlLeUVhb1BrUWs0MmMwajVTVmpXTlc5N20xUU41aS9KTU5kc0xoVjhyQUFTelVtMGNDbStXdDVNSk5jd3pkWnlVNG5LY2dWcmswUWk5K1AyL2FleDdlMDc5MWNlYlQ0QkdaT1I0YXVKOXROQk5XSDZYT3RiUUFCUFJDRUFGdlVqa0YwR251UlU2eWRhSUNSVjYrMlQzOEZwOXZVemdvRnUySTE5dHJ1OXJwb1YrU2pnYklxdFB0a0VtMklUR1ZsSUpIUHJ1ZVJhZGlXN25rc1VTOFd0WW1JcXQ1dmR2cjhUeTJ4bjd0eklQWXB6K1ZoRDg2a2thZUJKR1cxeTZ0RTRhUFNVRUxzOEI5SVF6WUh0ak55dnlicDIyb3Z3TUNHbGFoTjhjUXkyNWc3SnlYYWlyNmVuU3lUa2dVYkZwdkdERFE4TkkxRVBNdWJ5cThuc2VqS1p5K2JXNHVWVXZsaHN5VmFyVDJNN21Vd01WK3pHV2p3RmYwVFFHbjNvRGJZNm1JcG04NUdQdU56SWFWWWVBMm5hUHBnTGlQYmpMTy84bHp4R1oxM3JKNXJIRCsxbUJCcGZRa0c1WC9qR09IcHYzd20zQi9tSWhHeFViT2hsU290MFNUYnBJNGhJQWRZZmo4Y2ZyYlhBVElxSmRDNWIzYmtUQTlwT0RHVDM3NjhtbHVmQ2dDS2FUd1ZabzVwaElCakpmT2g4a0poeW0yUFZNY0dvbmdQbm40S3FHOGZOUUd2RHJpWVFlaXZraDJvVEV6MUlSNmpXZkEwcHpYOFlOdExlMGNhRXRCeUJRWUtNa3BuSVJ5a2JTbHRqc28wVVVvVkNvWlFxbEVybFlqb055YlpCRk4ySllibUZmaW1Mb2pZMm9nS0wyWWh3MWcwU09JdzZFa0lNeit3QWNIRjFiT0ZKRUd2YWk4aEcyZ2owYXZjQXplTVBZREZ5dVBhK1YwRDhiNGVFWkx6YzhINVBaMXZiQVFTa3M5WXpVcTJSMVZVRHJrQmJMaFRtNWdxSVNuRmphbmNwZzMxbkprcXF6OEIySTVha1A2cE8wNG5sSTlnZ24ra1VOSExrZ043WXRyR0JpeVBBbUp3b0RDd0owa09RalIwc2JKNUF5T3RIUWlJZmdRWXdLUnBhRTRjTWRMVjcrem85YlcwNDVHZy9zQThRRFRLYlhFWWFEUjhaZDQ0dFAzZ3dWMWhlamsvQlBUS3g2Y25KNkhSc09vcUFlRGZPcnE0V0lpTVVhMVFUSjhkWThOc29HVWJkbEN5OGZpNGJFNUpzUWplREJZRmJVUzZOdlNFdk1oSm95RW9QNWhwVUF4djh2OW03YlBsaGJ4aGtaNSs3czlQZDhZSzczU290a215Z3Exc2t5ZkN6VFN3alI1NXN6YzJsc0ZSYzJkNkpYVnBZV0hoM2NpRzZFTDAyTkJTTjNveTJ4TG05RnQ3UGpReXJrd3FEdHlEWmhFcFVSWkhQZ09FRHVteVVESzJ4OFArRXVxR290ZnNoR042alFqWDM0TVRoSG1DaE5mdTJEOG8xYTNaZmIyZnZDZmVKcnE0WERuVHNiNVRzbW00Q3JwVmx1N1ZWR1lWcUI4TmJsU2ZGZkNvQlgzejh6YzJGZ1lYZmZMZUE0NE9GZ1d2UmIyN3ViSEk3UXpUbnFKTkJRQ1FZRk1DWnZ3YnRCQVBsNGRhYWtPeXFaQU0yOTlwV3J2NVo4UGpTNDhXT05vL2ZBN1Irc2RmdUhleDVXYTVHbXAxRHdrVnc3ZW5yNngzdXhGS0xEbmxFV3FTMEVaQzViQ0FqV3l0ZXlCQU5NWHI3NitKR21qSDE4ZWRYUC84ZW4rRjgvY0xsUmJ4bWYrUENWMWhrelhITkQrOFB0K3BCQTNZaStXd0txeGZJNkpOQUlSMHdGQldOZytERlR5cU9TVWdtMzNVQTdVQjNSN3UvSGJrNDN4K0NhdC8yVHZTQWltVE56aUZsWGZzUFlXZi9GT1dWNWZHZms2bkJmb0RlcDd2VDZVNURrRVo2cVJtTVVCa3RLbkdpUVNtblU1U21EUjFqSUtnaEtidktzRU50MGk1eFI0dU1zc3cwRWx1VVZHTmlEVWFkQkN1QWNWdzNMK3ZMekdoZThpZnQ1M3RQUDRTWjJyVDNQZzhRcG1xS1QzM1BQZWZjYzg5dE4rMW8yNUJKdDZlRGtGMHZnNHpEQnBqYy94TU9EVGpRNUNNUG5OdDViR0xuenNySll4UHZ2RFYzOS9yNFo4Zm1UajdEdHZURW52ODR2M0w3c3RCZ0N5WDFOekxZeXpSNmRTTFVrdU9GejVhYnlRVWhPSTRNTGEzNDR3bE5aRkVxZHUzcGpGVExLSWRVWEhzWDV3alpRK3VRWkNOa1dtdDMyZVpGUUZKVldEOGduTWlZSVpkR25udnFoZkx6eFZMeDJiNWZQdFg3MjlmZmZiZDdZVUhTTGJ5Myt5dUMydUt3YldlbWt6N3VrUUpJTGhLSnlVTXlBZE5qY0h5dDAvSUxCUE1iZk9YR0FablFTUHhiaWJncFJGcy9JTldPZDNlenkzNjRoN1FPM2Y0MXhUcklyTWdqUHNpVVJqSk1OYllFTHJMVjkyVXA3dkErV2hqYlROOU04Zm14emI5NGRuL2YvdUxaank5ZFhwd2QzU3UwWEo1OWlzYVRPWEpDaDhWaldQb3hLUG5vMFpSL01WUDBJaUxqL01aRmJxbW1IUEk0NmZIQSt1UDlwTWQwWFFydVlkMCt0bDhUV3JNc01wSGd2SkM0M2RVUUI0MjVhcEh1QU5RdHRycEtJVnN1bDhvRjZEWVh6bVEzMC9kSzEySDJ6Tkd6TnkvOTkreXNFMjF2emt2bTNmNGt0REhpeGMwYWpjenI0by8zd1JtQ3owcDNNaFIrNHpTemhlWkVpd1pvS2RnR1hKTGMxTi9XS3pEZUdoNnllam1zV3ZOUDJYSUR6YXZIQm9XbHRWYU4ybEl0UUR1d1Bsc29GSXRGeUFxRnpRWEcyQ3VGYktGNDVzeUoyeGNYRjVQRGVjaENlWlVPUXE0V2tPTnZoeXBRemhXMXlEbDg5SkgvZ0VtWmlPQjRuVUhpUVdKYWFvYzUrRzV1NzB5Wjh5Y0tDSzBiMFFSWHV3NEptUTZoRE02U1NOWDR5YmZrSTZIaldVWHpra255RVVaN1VZb1ZtR0lzajVXTDVjM1pjdkVNMVhEc2thWEdYazNyUlI1U2hlTUlvZHZ5clJBUHJoSTBsSWxvQzRORU9CR3pTWmFib1RXRW5ST3BHbVNuVklOTXFxMC9qbXJLSUg5a3EzV1c3VXBhd1RhN1dtWk5PdDhmRXBsQ205QmtrTFlkclM4QlphTlFHb1N6a0gybFVDejgvcTJMbDFUdUVab2ZEdnUrNXdNblg0SWRCZ2t5VnVmVkE2ZURCTnVoT2RLdU1HZUp3YkdOMXBvSFdveldpMllsV3lOa3hnUDc5aW5kMm9CcTVoOXI3YktyVjM5MGRNaG1OQzA0clROT25KUmdrY2pLL1FlcTFibklsblJvalp1T09peVFaSmlnOGExdzVzMlBiMTZmVlNWcm1DZ2RaZWI4TUFYajNHcUs3QWdibGFCSXJMQ3JHdkExTEF4U1J2YllJU3ZhVlgzL0pHUnVMNW9leWJCZFU1SzhuYlFKTkkzYXUreDFDbXh0VFUzeUl5bUpobXJxUEtqVGtHd2l3MGtHcWdVVzJTU3lvK1dpNkFDRHJGVEtmdlRpeFpYTHMvS1ArYjErTkNjQVArVGxNTXV3OUZqZHlUUlFRWllxWFdJRFM0bEhsQm9DNXNuYUMxU1RTVVl0UXphRFJEYnQycHI2dTNzUjdHRjNhdXpzc0ovaUNDdE5vclVuRWk3VmdrdUtJWnRaNUk5K3hORFNnVUdlQWM3UWl0bVh0bDVjK1h4MGRGU1YxV244dmZMSFNFaER4WEZuWkI1T3BDNGNJL3NOZHdtRzMweldTOFV1aE5OaGRsU3IwTGxJZVJMSURydkRtdlNJeUhxSTNQMXRvQ21xMWZhUWxvMndxWkZGbXZ1WEcxRlFpMEFIRldSRFNwTU5UUmFwaXAwVzIxRlV5NTRaR3l0amltT0ZNYzR3ZnY3SFMxUU90TlE0TGZTVTIwTEUzcEluckpPb3hqcUlpR2tSRUR6NzJ5UFVmWkJLTldUQW9oYWxpV1l3aGtXY1lNdUdiRDJkcVpITVZLWlRCdG12aXBadDFFeTNuOXBsdXhzY2JSdEFBeXpvUDNCcEpDNHlIcmpJa0ttMnhvOGMyQVFaODlubitrcURUNVdnSzJjL3ZIcng1dVhaSlp3STZhT3YybzFiWlJzVmpYT1F4S2dkSzFwSDZzVUZIei9JbjNTcHB1VTdYNUtBTGxhZmlHcElRNmttaSt3WlNXWEdNOXExcVRqU3JjSTRUKzEvcDBadzdpdzdVelhJWnZJUlBJbVBVMFF2TklOTm1YTFZJTTJQTURaa0dlWGlHNGNPVlM1VUtwVyt3ZEwrM1Nzck4rOHVMVmt0YTZPWFUxMWJ0b1owbGczSExXQmpiK0dJUUxUU2FFdlJqa2NwWnR4djBDOUVwUTZuUkRPbkFWWTlacGVOaDV6ZjE1TlN5R2F4aVl5blpoM1NyVFVMYTNhYWJVVi9PV2F2VGxDSTVwd2thQVlYUkxaU3RseDZickNpc2ZQQ0FuQUxuOTVlb1pzaU54d0NqVEFHVU01SFBPRFU1T0k3NXkvUmNQYmFhRUpIWlBQNEwraWh3OVg0RXRpdHNlYldacDcyam1aVmp6dmIwMm5uL0h0R01uaVJYcmZXeUxWcTNhbFI2WmpaaGg5SkJVYzFqS0R3NzdhaXNQRWwyTmZBVm8xc2crWFNvUXBwOGRSQ2IyVW5hQXNuUGw1WitYd1dKeUxWV0Y4UkhwOGROb0E0UzFOR0JXVDhJME9yS2VhRlFWVHNOZ21qOHBxZVhDU21xVFA2YU1lK0RoZzcwcDJtbXRBbytidnFzZjFqVnp3MXo3SUoyVEpJMWJUUzhpUGVxd0JZTHNLUWFQSDQyc1dtN1doakU3bC9aWHlLTVY2cGpDK016UHgxQlNkQy9xaTkyclNYVCtZQUV3UndldUxxN2RGZUxRSXpXTHcrT01DRllRTFJWWTdWR2lPL3lvc2g0aHpiMnp2YnlTRkhSaktCYW5UdTdYQlpQODlQZVVpbWpRM1dFNU55R3pZVGpLR0ExdWhtS0ZCTmJNRmlTN3QxTmpVeU1qSTFVMWs0bC96THJaV1Z5L2pIamRwZzUwTkpYMkNZR045UmpaK1VLRllUTFh3R2lVcTl3YUNYS1lld2N2ZTRTSG9tMWUvajZuU2RxWjZVdm1UR2hkYXlSUkc3bHo5ZGNMVnVIZjdjRFJXUFc0SURYOUE4RlJDTTY0bEFOK3UwY083ZkZsdHM4RGZQSHpwWUdUODNkWEpxZkdIbnpQWEx0MldQK0gxbmtVTXNLOWFOOW12OEZJZUNoRXVaRnQ2azZrNzhJQjFCTWNuWXhVc05NaEVOZDAwMnE1bFhGZi8wdmxRcXd5Umt6enNQMmErYXYwbnk4a1A3SVI5VnNTN285aEhhcTZnbUdNQnN4Z1BWMXZpUmhyYURiN3p3d2d2N0YrWWdXOWgxOWpXY3lDSm9RNUJSRkEvWjhaT3FCNm8vVm5mWS9PeERnZzlCUk5YOTRZdDRBb3BOZHVIcnBTRXRhWk94Qkk2UnFTcHJtbmk5SHJycVd0c3VOcE9rNWk3YmVvOXRVNU5hcmZralcwTVg4YzI2c0RUc2ZCUXdUZk1qamVrS2FkWnZIaTB1Q08yelR4Ni8rZkhsMlVXbkdtZ2haR09FaG9hR1FrTldIeFljTStKRFUwMDVJaUZXTTV1YU9HR05mbC9YaHFZM1JvSFZaU0cwMWVJZ3FXaGxXR3M5cE1jNGY5eEk3eU0yYXQvTEZwelF6Q0MxRldYQXB4VUgxaE1IeEVZeXVTYU45Qjh6aTd6ZlhjcG1Yejc2eG9XRmhZWFhQcjE1OCtMU29rdU5aWkRJTnZRWVhIeUJpQ2Z1Tk9NNytVZkVIWWg2V0tsblc1bzZzaS84akZLUnJrbllWUEFuS0JMUUNHa2RIWlFQcE5vSXh4b0RvRkhTK2hlN00xNzdYcmJnM0M2N0pTMkxUTHNjMHBYQkVVcWFDYzA4WkpCcUpRMnQ0Zjc5KzRQa0pFZUxPeFoyN243Nzlzb1hvNnIzakRyTjlCZ1pzbW4vYVdRd29wV2NDRDR4N0tJYlFNNUVDUTFxdGxDU1RGOGR2ajhhRmh6THF4MHZrc2tNb0ZvUGFHMkV0YWVWMS9QV3lDSEZKZFhFSnQyczZCOXpiTnJkR0JrdnNwbEI2cWtlMklUUzkrL3ZLSlZoSy9SVi9uNkpvRGFzSkF1eW9ZMURnaE9ZM2taeENVOXdFUjhhK1h5ZVNEUXM0NWVPMFdnOWorZUt4L1dReVNJN1FPUitRQ3FkU1hXbU9hYnY2WVJ6bkJTUzR3eXV2ek5yN2JJaDQra25IY21rMnRNcStXT1Jhb092cTVPWGRGeE1kMElLbW9PVFJTcXlQZFl1MlNpUWNLSG80R2YvczNKN2NZbk1XTllJbCtCRXBqY28wUEhJTGRKN1RUOE1XcUZYWFJnQlBaZnZlNU1FQXQ5Mm9xQTJlR2pHVXROcERVc04yYmIwZFBTTW9GbzNhR0JwMXRobHIxdlRmdFlpUHlJMHE3RkNZbHlhZ0sxbXlOQ3RMcmI3VFR1S2d3VVczRXRIbEJtUExtbWw3UVVLdG9DTVY0YklFRnhjbW9VVjBFQzBqWXVjU2tSNXBISXUxNkZsclV6QWc5V0RIMGtiV3lmV3lZMEMwRjQzTXVjaGZ5S0hWSk1yczJsdHlPNXlkWEc1LzFYbnJ6TnRzYTVXSTRQRnRtUEhJUHUwVXZubzZkczNiN0lIZFprSUEyTUU3MGVETk1sRXlKOGNqU0dURlBJU1BrMy9FZjVMY0xGdzNHdDFaNzJZcUVWd2cwdnZhMCtMYkdSZlowL1BsdlhVNmpZTmlvd1d0Qm9lVXJFQk9rNTdxNXNhNjZ4emNDZ1ZxT1kyYkZJdDhDU05UN29pOHRTT0hjVnl1YmlwbEwybXpOZ2ZIdDA3SEpDUit3L1owTTdhNEVDemRGR2k4ZmpDNUlLTGh4Rkt5c1BLcENkWmFJbXdvYm56M3M1VXFxZWRYZlpBSjVrazFVank0OWYxZC9QV3VsUGp0dG5VUnRaMiswZzJSSU1yV0d2QmFmMnFiS29oODdSVUtvZUtoVkpwVStYUHQyNTlQaHZQRHc4N3h5ZzZ3UTFWdFFvZUZoeGtObkVoRWZCNHNVNDd1TWtwWExmaU4wRnlhSk9RYVMrYXBtNkQ4d2VOa0gwQjU5L05xU2dUc0JyOWtKQUZUWU5yK2lFWkVNSVl5QloweHdST0VpNUc1K2xuK3pESFFtSGgyKzl1TFM3NUJHdTN4T0JTL3RGbzU5VUJtU0FCa203d1lJYjJFMTR5b3RKSm5hc3p1SnFETy9lQXJVczkxcnFYa2xiRTNvSkI0a2FhN0pnZWU2eDVscTJsdUtiVnM1a1IwMGlJVUhVdEIrWmNKSE9OYkpacmRmM3FrMTFQSGFLbzllREJnOHVqK01lTm9JbkxFV2tLenJBMHRGZHpHWEhFN1dYaXJ2QURDdXN1RnNXN0tKZjJjMEU5Q3cydEFVRTNFaWtkWk5LVTdMWnN2MEJwWklkOWZrM3RzMnpNRWRVTUxZMGJTVGVMeXc0MHhDUXdPUkljWk9NcVdhQmEzZTczanUwNitPdDFweDk4OSsxb0VqU0NHbXkydU53TVpCT1dlaUlsbEtLeXEwUENpVExVcWpGUXZaUEFlTFREcURLT25QeWlpb1lsWW9valZDT1ZqZlFyWkxQV2VHcjJRd0ptYU90VDBEblY3TlRhaVFTWnpYaTFPQjVZWkJ3d3h2aS9IZHYxcTlNZmZ2TGRkN2VTWk1hUXVWVEVhUVdaZlZNcW9rZi94ZG1oUjVjbmFBcHAxdjhlRmFHbm1CM0drYWhucEQ1dUxwSmM2N0NLeDRiV1F5VEl0SXh2MzY3Q3VQeGpjRjNvcC9vaFpaQnQ1dndSelRhaVFZTXV3Z1h1UC9EK29GVXpaQW5YMFhiOGwvdlBmdlBnK3dkZkxJNHVRUVlhRmdtSXBxbm1xTVFHWmtOVW0rc0duQW1hQWFRcWp4WVZPNWxXcFkrdDdpcGlCMGdTMGpYV0pWVDFJZVVIelhsSVZITm9heE90bitpSFZEYW04elhuL05zdE0vWkFjOFBBTk9zQ010aDBTRFhrWEdUOThRc1g5bi95dzRQdnJ5M09MZzg3c3IzNFNJRUVkQ2Faa1NrWFVjOVpYQkhaYjRnbVBFK1ZSaElSOEtqUUhmYkRiR1BPOGF0RUI2aTY0eWJaaE5hVFFUVkRhNkwzMkpwWWEzcEl5SmlJRm5qSWYyclFYV1V6TW9ZNzFMQStaQmJiUkYrbGVQYkJnKzh2emM0dUNVMFAzaCtRVmNFMk11M25hajRTbkY2VGN1QlFvbDNnYVFYcUNtY3VjYXFMeTVmTnpkeDgxS1ZMMExSdFk1SGhHOU9ncFlTR2F1dU03S0VkNDRwclFkTWdQaVJvR2hRTXBtaFBRT2JzVWI3elNjazJ0S1Z2MTlrLy9QRDlnN3ZLSC8xOGZub3BsL2NOaGRFSWxjMUFSWWcwNnR3VXBhKzRiWllaamVXUzA0bFRIcjFMU05iUlNrMmtzNVZoQnFrVU1zMWEwMUpybzREZ2p1bHI3ckpYYjBLbDFxaG1NVnQwWURFWlZUSXp4M3BYMXRKTVhOaDErcTgvZlBQdDdOS3NtdnI5dzNQVDB6N252SGtmQUhFWUdjUFlmdXlpc05ZWEJrZHFxaisyeGlJVVJaQU1nMFN0ZHNxUTdFUVpxSVpjWkkvYzN0YjVvZENlUmpJanEzbVd2ZTcvdlZNVFNScWM0d0l3UUZPYTVYYmhCMXhDVWpmMTd2bGIxNzdsSUhSVWFQSHA2ZWw4M2svNnVtbElqREkwdmdKcFNocVY1dHJXL2xEY3BWbzA5ZU5Nd3VjT3M5UVNrMTVVelZucHpqUlZMVlFEVGRHdHFSKzA3a2VDYk9UaEhlTldQZFpoUnBDTkpBMUZzbW5JSUNNOHFBWVpiSTNPUno2UjJ2WDI3VnVYWmtkaHkrTWM4elNNS0xRTjU0WnpqSWlmRCtXSEJHZFlBWmdqUzdxVFFwN2d1aDVmRmNTNXQ0MWtYSFBHaGFxaWxSNUlqNlJWcSt0QXRaYiticldmd2NXczJRK0pabllxdXFxYXMwalB4YmJJRTBLejRjZ2FraEdSSlJ0Z000czgwTjcwNTFzM2JpN2VuUjFldm5kdmVYcnY4TEJjU1hKMEdMaThQMHdYVXpLWHpJTVRjR2ttWGFNSVZKQUZYUFk5eVhMVFBWanUvSFpnazl5L2JXMVBwYmVrV2tZeXg0OTM3QU53dy9aK05USlpTYjkyRGlrUGFXRk5GVlpETTkyazJWcTBCazJ3bUp3STF4MDRJTFJYTnh5NWR1M1dqV3NuNXhidnpmM2wvYm4zN3k2TmtpWHpMRWxBVjQvMGt6bjkyWFZKMVk2Z2dzM3VQdmtSemJYRDg2WmRhWm1GMXRIZTNOR1Q3a2p3dFVWVm4vNExVbTI5ZVVnMVF3Slg0N045d0hLWlAyeE90ZFZxbldUajZxZGpzOWV1YVVSZ3E5ZHFrMFZxSkFlMjBmQjU2OU1yWDE1OSt4STNhK2ErL25wdTd0NnlRZ0dMVDllRjhrendNRGJTR0M4cHlWQVJMcEVsL3duTXVzaGQwcXdHcG1hT1E3a28zb05vbWVQcnRkVHdrS3kyYm5IeDFQQ1FEcDIxOWc4M1Q4U20wamhrMEVrN3ZaRFpQVDI0NmoyVWJlUitKV05rUDUvdWN1THhyMjZjLytaUFYvWnN2Y010b3JucjgvTnpjOGlIY1NJZ3l3NlBxU2ZwdVRxeGhPVC9FbHdicXRybHZPcHc2UWtqNWs1cjBweXNxVExDVG5TN1RnNWQ4YmlYT3FUOUUzTTFQS1RJWFV1TStaSGdQTU5rTStIMHVtbERZRjFNTEJMWnVJYVlmb1BQWWZyb2QrZS92SEhqeEpYejUvOTIvc1F6SjYvUDNkbDNmUUM4TCs0dUx3T1lNNjh5blhOTGFYbzZ2QXlEYnBuSXVqVnllb1ZkYlJubmFuMVVrd1hYYnNVRDBETHVLQnNIMmJ0cGt5UUI3aUVlVXFxdDhmNG1tN0Z4TVptM3dmSFowQ1lMTmoxWUpMT3hlYkRBcDhEOTdLVVBQcml5bTBzMk43N1VwL0JjMlhweWZ1N3IrU1B6Si9uKy90M1JISE40ZW5SNjJTY213RGdOeE9wbU8rTElCQmJXcndYV0ZhczJWaVFPTitzVW01N0JxZkVNcFZiVkQxU3NBdzNoYW5wSUhHU1FIcWZXM0thWEtpQnh5enBwU0d2dXd6clZKRnk4VWFPK2JYQ3c5T3dmWC94WllkZVoveng5ZHZlSkV6ZkEreE1mNmJYdHlKMDdkNzZlT1RJek0vLzEzUHYzbGtlWFIwZTVXeSt5SEREVDlGTkFBU0JRQmdhcm1TS2lVV2NsQm1nZjJnT1Fland6UkFCM3ZQWjBkKy9ENzJVSGNlMGZMbWFqbTdGQkpqeEdVb2FqZ2psTVREZnFrNERGRzVOVGxjSEI0bTlmekI2c2ZQanl1bXoyd3pmLzk4cU5yM1Q5NjI5WHJtN2JPbk5INDlqRWtaazc4L2lYZTlQTEVpK2NDMk9ZQU9uRzl5a2VZUWtPdlhTRDJaR2hXalA1STRQRGVRYlhLZ2RhZEx6V1ppVldsSHRvRHFuek5kdU13bVpvYW91MDRXd1FyRmZoYXFoaXhUUmpEZGJuT2xJWkxJMzlnZ2JXdnI2Q3h0RjFMMzN3NXBXcm4xNkQ3N1dyVjkvYTlzemo4TTBmbVpsNFoySmk1ZzVlOU80U2dQQ2Rtb1l2elBkVGgwOVpXNzlDR21Cd01aRE1XbysxeGhCT2g3NmdVUmJYV25zRXRwcWZEeG5zMTJ5eEJiSlpBY0dXVk5lcjZJZUNmSE5VTVQzNjM3VVYxempYV3hwNzVWOGZPZjNpemwxRmFnbmxjbm56bVYvLy90Ly9jUGJLMzdkOTljeFZ4bHQ3OW14OVpzdk1QTzJURTl1MmJaMDRobjdFdjFOQThVREdvK01MRGI0eldXUk16a09SVE4zaW9JMjM5S1NWUWJxREdtcisraFRvMnJjT25jbUNGcFJIWUF0c1VzYW5qOTRRbTc1SktrWkNqOE52Y0xFdXRwMGJ0L3pyK0FjLzZlc3JqbVd6c0pXS0IwLy83c1AvK3Vqc2VlNjFiVDF4UW54NzNubHZBdFZtSm82Lzg4NmV0N1pOVEF4Yzc1Zzd0WHlLUnlPcVlaOWsxT3E0bXJYTXlQMUZScURtOHRxSVJGUEFwbjRzTWh4RmJROHB1amF6eUtwSm5qTTJEWWlDdHg0d1VhMFo5ZVkwTTgvOUgyVm4xTm8ybG9iaDZ5eVUvb1p4U0xwMlEybURqSEdUQ1MxTmJGbGV1WTJkQk5hUUdGR3dyYkRicWtiS0ZxV3h6TGpZcENBd2RaY2hZMmc4Tjdsb094ZjJMOWlCWmFEL2FwOVBSeUpMWnpabTMrK2NJOGwxOEhuOEhaM2FrdnhxaEhQeHowOGVsNXQ2K2VnTmJLZW5vMTlhelJlMy8vYitIejhlZlByOCtSRjQrNml6WS9pRDNnRHRkNHlPMi9IOThlWGg1TTY3ZHg5K2UvZmg3NFQ4NWxWc2N1QmlLU2xqT0RKRFNyWlc2eVN0SzJpNWZKNEJLVnI4dSt4MFBDTFhRRk41UytDa2tjcmVIWFBKdjF6UThnWXdWdVhEdzUrdEZwNVRSei9qWW1jMG56VGwycVlSMTIxaHNOcnd5aDkvZVkwRjNkNisvK2hmM0JsMnZqL3NESWYranQvcjcvajd3MW5IbmJsRFh3WW9YT2lDbzFjZmhFa1UvZFNjVVNoVC9tb0I3NjNObFc2R2E5dVorOXZLU2VyR016VktPZXlYQ3RkcFU0T1NndTRRRjZJSisvUDYxZ2VJbGkra1NHN1ZSTE9zVzhYSFp2T29na0ZBcGVsNWxhZHZ1RzdyNU9SWnMyeWE4OTdjZlBqUDc1ZnVOeitCdHVNVFpNd3cwdjYrTHpLTW1lZDZzNkUvUHB6Y0EyNENHSzhsVUZ1SEJEbUx5QXI5ZnBRN1NWcUoweG5LbFB4R2J4OFp0S0NsUWNzSW1yQkZrOG5kQzdwLzc5N2s4TkErdEgrMWZ6My9RbHp5NE4yTHU4c0VXaWFiekNaM1VtMmNmaDgvTzk3WXFEellxejJMcnQ0aWRVZFBUeHZtZk5nTnV3MU9NUDdwcjA5cXN4bWpVZ2doQ293aCtaTUExUFU4YnhiNHZmcmtZc0pMcnBNMzJEaW5KbVZ6UmNpcWhYcFgwTktNeDNaV2NzWU11ZmhYaHlWaDQwS3RsUkE0cnJIZzY5OWtmV0p2WGRyL3hqSGk4c3Q1eE1YaS9KQ3ZoWW40N0tJR3JKM0xsb3VWRXp6ZFBHUHZ5UW5YZjc0aDVJTENGdVpWb1cySDNaQmp2cHJWcUowZDdPMTlmdnYyN1ZjUzVncGZHckFoeFhYZGw0NW51dUJkOG5aT3RrU1NzTTFRaURpTTFVK1N4Z1NaalEzb2IvYUhKRzZWY3JsVU5KT0VLeXQyM2JZdjdYUDdITldwSXFEUStNdDRiTXVGTit0RUpJWXNXdDdLYWFmSHgwY013TUFyTm81Zk1FT09yR3d1RTRhcjRaYk5XMERjNDZSRXB0cTJka2UxQTR3c244OTM1Z04vUHRRRDNVVUcwUWs2cnVkcWptY1l2Y3ZMcmNOTHpBSHE4aHNhVVhXYTdrZGswNXdrTFJzN3k5L2tENmwrS3BWWGFTdGt1cUllR28vSDV5cEFVdkdLR05lM09FbHB4eUVITGtYMlZHdU5UbDlzbkxSYUk0c2hrOGw4SnpoUzF0WHp2b3UxbWFtV3ROcURzN09EVHkvM25yTzM5ZnREZzZuRW5abXoyUXcrOTduck9jZ1lEdGJxZFNIYmhLdGZuVmFOS3FNeU5TVnBvRmxMU2pjZGgxU0h2UExDTnAxTy9TdS9QK2dwalFWUHhNcXIzcXZlSTRKSGJUdnVKVnFoNzZMMXFXNVptdVNKNzBiUlBBUU5Va1FKMXhwdVZqU2JxeW5kZEdvUGZ6dzdjRHpYNk14OUh6clQ4MHdhZDBhd3J0VWNSelA2M2Jva0RkTURJNjJuOGEwZ2QrbVNrR1ZqRDltYmYzVW9jTmwyTzhDbmtSMzd5dmV2Qm41dkFPQzFCb2hHbHQxTmVralk0Y3BhcU03c016ckRhU29qWmxVSmpraWVKYzlObG1nemFUSUZJM0JxR1BtZE5YLzZ5VE9Hdmt3cjdheW1hUjR4ZzAxU3Q3dXJ1ZkFJa2JpT2tUdVpIZlBzYVphbGJseVEyS2YvanpNMTRqS3JhYVlaWUhrSUc0bWpESzRnSVdJZ1A2cnp3VTd2cXJ2Si9oaEtoS3RNT3FTSFF0ZFpVemlKNHRWRXF5RlZTVFpXTXpqbWFHVWNGekVQWnZyZ3BkTjZZSHFhWmprYVdDRFM0aTd2NlJEeHJ1dkJ0QitOUmttYVpYR2tUc3FDTXpVazFvSXRnWU5PNE9Za3orLzVRTEw4NnMvOXIzTi9QcGo3aFhDVmpxR01GSkRXNGhUUjlXc3Arb2lEcXNUVEMxRXRaQ0lWTXZKTE5HdDc5UEE5UG95T04rUFZkYjB0VEdWSHRFdkJyOXRwODdqckJ2cFVUK3Nsam1ZSm1xU01zdGpicDZ3bGJBRndJamlpQk1MRWxtRjBqTG1JRVV2SHJpV2ZZQklVaUdQbVRFaVYrRWJBRkZKRUlTVmJLVmI1YkZIaVA4Vm1FYWRoL0o4OU55QTlub2JqZWcxdlcySzNWc01iMVhSZDB5UnprQXVYWkUzZDJHWEJYUmdZa3VXRXpSUTIwVENXckx2TVcvS0lNV2RqS3YyaVU0Z1dOdWpnQ1RPL1Y0cWdFR0JJVFpSc1ZhdVVLblI1YmZzQmNQY3hpVzk0SG0reHF6a05mRjkzdDdFbkYrRWxqMmRsSVB1akpZNmlyZXRwWklFLzVMWmlRMjZVT1lvcklWS2tWTVNHZnBXS05JMGlmWjBlaGZDSHFxcUdRQ3lna1VqRWFvNkJhTFhrY2pheTE2enhBYTM5c1EwRHBzdksvM3ZYMGdMSVRDMWlzMFp3RVV1THYyVTNZalpGNThvMExHdXdRUlB3Z0dESjFsNFFUS2ZwVkc2YWpzWDdqeElDVVZxdEpMMnZVcVhoajlMZktDZEJRYXlWU3RCaCtpOG0zNlN2b1psdHVpUm10bmowNHJDc0JYUlA0em1namJiaGdtN1J0Mnd5MTRqWlFJdUtKNEFpVTFZOVpqQlpuNWw3OE9wMGc1SjBDUXdSQ1lrUmtsNG5pMlJaa2pZbVNZUU5sMTdTUzZWU25nYnBlWkl5S3Q0L3hXLy9QaTdkWldDYzRnK3dzdFhDQ0xYVmtremlDUzdmMW9qRi9wQXRZUk02UnlzbnlRT0tWVS9XMFV3OUlqdENLU2NoSGFIbVNFZE1sRlB4clVwRThoZlVhK1VnS2JYNWZ5b2Y1SFhhYUFNNDZGb2pzUjArcVp5QTV6VHZ2K1krRTl6amJLTnlmQXd6cHZYRjRwSzZlZW9OTXlUZ1VwcFlxQ0xZb3R3NVpZMVppdkJpUmdyaGFWSStRa1IvS0pHU3RDUVlmNkM4Q2ltSmtvMjJWSUxQREdvUkJkTTdicWR3eUEwdUtwVWYzci9teGlQY25XTnBZME41bFI4ZDNjTHptbGg4bjVvaVR0K1FiUXViVkFIMEtDWkZsZ1NGZ1ZsMmNLUGo4d0JGOVNSTFNpSXBoZ1RrOTJxcnY4clNpdFNpTFNBU1N0Y3IwV1F4S3A0ZTQ1VFAzWDAyL29JcE0zNlhYSjJrYmhMeE5EcmdUOVlXWGcvWkxFcmExS2dVUHNJcEM0WkRJRWUyWDFJZHlMTWZzLyt0NjZ3bzBmbi9WNXBVS1JaVnJHb3RHa0p5eDRWU2txZ0t0N2VvSE4zR1p2RDdXN2R4OGY1UGQyZlVHeWtNQTJFZ1NROVlXWDd6Ly8rcDUvR2tpbnlLNEdVZkRtWWN0NlhwaWs4eHJxcEthOWFqM0UzeW92SlFNbGNrUmFZMGNwZHlKWWtiY1NrUk5BQnNWRG1NNzE2TUsveHhqWFNJQjZ6d1ljZ3FZcDRDU2RURWtPNDdaQ1Q0TjRqNHJ5VFRaRGlaaytXeGdOajNHVnVFUkFiSTN2SVFmWU1La2dFemNQRVZGcTJBMXZzT3FlTSs1bGg0ZWNoOGNlTUViNm8wMzVVM25JODVSQ1FMTk9FbW9pSlBTcWJUWGY2VlBkVTVjcElFWUw3blVicmpjTUpJcmp5Vk1USk1TcFRhWURVeGxxUW9VVFFPVkxUWEtNei9Zb1J2My8zc1JDU2dFM25LeTZDNGNXQ01xNFBNbmNtU1FHYkU2ZVZwQmpKVUo4cVFWTDFmeU9CaGZBTHhadGJodUMxNE12d3VmWnBJUnJYcE1kZnNHOEdDNTZ2L2NoTHJxRzdqZ3JHUGlVYUtpRDJJajExMHlIeWJZL3hpcnMyNU5LSkxzT1pjNSt5WmcrTHVlQlNvUFlFRkYwbldSNzVaYnk5aFBuMGt3NmkzZVlmOEg4MjROSGNnM2N5cGVZVlRoOFN6OWliL3JMMUROa2U3cjRnbitSZnRuYWZHTnRMMnJlWnpHaC9uMTc5N250OS8zYnFXeG9JczIvcXVVNnQ3UjF0SzJXcjllWTFxM2ZiV25NdWp0WDFmWGZVVlhyZXQ0TkQrZUlDdDdLNE44ZnkxbDdJc1JBT2JxeFRHc3hmY1FBYTBTQXZVbHVlTEVJQWlHdW1Rbm04RTlSY3RzbzRFbzFKbWZRQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3d3Jvb3QvaW1hZ2VzL0Nvb2tib29rc19jdWJlLnBuZ1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTm9BQUFEYUNBTUFBQUQzdzZ6cEFBQUNjMUJNVkVVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQk1hWEVBQUFBaUdSQVFCd0VoRndvWkNBRVpFQWdwQ0FBaEVBb2hEd0FwRUFBaENBQXdFQUZUUVRJWkFBQXhDQUJFT1NjNktob2hBQUFRQUFDOG1uSTZHUVpMT1NsQk1DSkxRQ2s1RUFOU0lRTXJHUTlZU1RGWUxBaEpRaklwSUJVNkJnRjZSeGhwUXlsS1BESllTamxMR1FNcEFBQXdHZ2hyT0J3ekFBQkRHUVU3SVFxTldDRkdJeEZDRUFKa0tRY3hJeGRpT1NWcU1RVmpNQkdtaUdFSUFRRlNLQktCVXlLdGpXbHBPaEF2R0FGN1JBNkZTaHgwT3c5SkRnRkNCZ0JrVWoyNGwzQ0xYUzZVVXpCYUlBSmxTemc2TGlKak5SbHFNUkIyT3h1ZGdWK0tjRk5KTkNHV2JUbHhSQkNXV3p5WGUxdDBPUVIrVzBGcVV6eDdSaUtDVXhkVUdBS01VUzU5T1Fad1F4aFhPeUYyZFd1MmsycFlLQUJYTWhhVldTK0lSdytYWkNwR0lnaG9XMDV2V2tKVlFDcFZMeUNIUmdhTVZCWkdLQnBxUkNDYWF5V25kRktzZWtPRVpFMmVZMEdZWHlHbWJ6Wi9hRXQwVXo1NFpFcVhsSWVzZWpSYUpoSjZSU2xwUEFpWFd3NXRKd0tMVlRwM2JtQkhNUmg1ZW5HcGJ5U1FqSCtIZld5bWJrbXlmbHQxTVFWbU13Q1paak5YT0NoSElnQ0RhMUI1Vml5RVZpeHJhbUM0alUxbFNUR0Znbk5BT3pLUll6MTBTak5WVGtHWFpFbHJZMWFxZTA2R2hIekFtVksxaVVDV2MxaGlId1JVRHdLV1hCa3lLU0lYSkRtUWhYT2ZhVkNIU0MrS2JsdTFoRE1oTkVkQ1pIK3FxSnJScm5KVWFJQ1ViMForWVVBUkdDZVptWm5ZdFg4eVRXWlNUMHdkT1Z5MmdFMG5RbCthYmtlc2xZYk9ySHpMcFd1L2oxMmFpM1lBQUFETW1XWWZJeWlmZ1dlMGpXRkVVV2NsTERSWVhXTktYbTdNd0twMGVuN1p2NGJKdHByZDBMM2V2Nkh0TGVDbkFBQUFDWFJTVGxNUlpsVXpkeUtJQUVUeUJrTm5BQUJPMjBsRVFWUjRBZHlWWFlyRFFBeUR4L0pQVFRmM1ArOHFJazBMT2NGWTFvakJ5Y3VIQWxtdlM0dWVFVGVSUXNvUklRbUxSN3RNVC9jWlFjQWJqVnhOUWViQnZrRzU0TWdsc2diTXdqVDAxbU5BaTAxb0RhczVpampaMUZvNjdIMXc2QmxqOEZ4Q2E5Uk5Oc0tGL3FCWmFUT0dyWXhvcDV4b1dvMWhJNXFyTmUrSUo1aG0wM3NaOUcvTDdLamo4WkppMDN1RldsdkxpZmJMSkc5YzNyYzFmWkRYNDc5L1Vzc290M29WQnNMUDZkUksxbkFmMlA4Uy80ekdIMUxqSGtYVk5jUWVIQU9aR3RNamxTSm5ERGkyREN1dUVyYjhCcDl4OTd3L3JSTFZUaGJ3TUxNMzdyazZqWEhjcWs0M3F6UlpaNDVVZTlrdzdLejVRTjcvc0p1ei9pQndMcUJsNG5LUDV4RlFNSzhNTG9LZ2U1N25wZkM0YnVPbkd0aW9kRWM0YmkrV3ZKRzFITWpPcDdiVUM2RnRTUi9tWmRJNWFPS01EWTRwYVNleFRLRUV1ekowTXlnRDJjT0JUTlp5SU52SCtTSEhxcExjNDY2ZjJTck9UTDZqaUt3ZGsyL0wxSXFibEJDVkp6NTIzSzdNZGxmblNsZFQ0a1RLYVZUNGN5QTdhem1RdTlZcXhLeloydzNoOURnc1Q1ckU2aFFKQ2FVQVhTbDdRbkt3UnhTam5jVWlLYk82QXEveXU1Z3J6UGJxOEpkU1Z1T0dkTk04UTRlRzRIcVhRLzlEUnRsZUhwMndNNk16bUh1clVtdlBHekx0UldvT280Wi9qS2FuM05xeUZDOTIrLzZxNzdyTnJZMTQ3QTdzS050Ynd1MTVRN3JYQjFHZWRDdHRkVmlsR2Z0aENuYkk4TC9JbC9zVXBiTzlWTW5QNDRaTXJmMTNURm1ZMWlObU85WisxbGlEMkFIK0pJcVN1eG9BYmJoR0hqZWsyV1grK094WU1HUGh3OEpNSHQvZGpYZkxwbUhzQXRoNHhIanVLVDlTbzBDbFNmYkI4MUZydVNIRGpiVmFGbnNnYitOMzBYQmdBdUR4aklCZFRQTkNxWDNpLzlyNERabXNRVXRaMEhad2dETnh2Tk12SERTcGE4L1RyMmVBTGFBTjRpQ0dHV0RyZmZuLzlodVMzZGhyWkFmOVFCKzhTeG5GcmVORmlHSWphR2xrbUN3M1FjelJkZlc0SWFHR3ZOZmIrbEU0Z3ltR1d0cHoxbGgzTVY3UFl4TmhmYzM3QkdZcHY4N1ErQTJaQThuM29CaXRLSHpMNm5QdTVtaCs3cnlKQXVFMy81Z1NBSlk3WVdtZmYwUCtvOFhxY1N6VmdYVmM0M2N6cElOa0FkSkI0K0N5QUlJS0hCNEhFTmd2c0VUcWtOa0FZaFVrZHdFRXM1UGUxNnZDdE50cTFQUWRYVDEzSHh1N3loLytxQjliL3BHb05FVmI4SC94Nk5VNVZoZkZHUEhxbnl3YW9mKzdLTGdkQzladGxPTHV6eDc2bjl3ZUsreFo5aWovSGxOY0twSWUyTzNmSlEwMUJaY3lZMVlWTEhpK0w0TGdtcTRnZEtneWVHNEZLRWF2ZnplamlLeXpXTHVjSVorblhjck5lbi84dTdrK1BXcmQvUngzckc0bjBkNUI3MWluZzhaUjR6ZFZidFRmWDJyazhhMGtwUHExa2NSdGJrNVpCMnJXNWduN1RQUVhlclR1NTRmZkVZanIrRGt1SXNKNXUvV25hazBBdks1YWlQNjE4SHNaUGRveHhkcmxESmxueU1XWWxacEI0NnFpcWJ3MGZvd3JISU0wRC83QXh1Z0g5WHVVWm1ENHhVaXprOFFhend1dE5xdGJnRTRIbisvMTNyQjJFOUNSYW10aytKMzViNGN5T0JXZkdjN1hCNXpneFJpSnZKaVhrWjZOTm50dUNoZW9pUWtueGRybERKbWxrVmNJQTYvT0dqc2ViNTIwbEhvQUxrd0ZlMnFjWmlHVjNlZ3F6cElTWjRCVnYyaFN1ZW5ROEpvYlkrc3NoTmFnQzI2TUp0VmFTOHlqY1NNSSs0alBRNEtiZU9XVk51NzR5Tm9SbUJoOVdQOFNUTkdXa1ZxTXRXdUc1TEhrTmRCcTNYTHJ6VnZQclhKNk1NSDF3R0pscFZWUXpuN3ZvLzVpOEZoTnE5R1pmWVFadXlkUWJWeTB4WXBkbGxmbWNIeUlLZkJLeXpkcHN5eFRXejBmbEo4SnJtUTRwbENqMllqUmF0Y2pKVkxYUDU1NW1vUVVhOWN6SktUQzFLaDVlQk10VmRudGh6WG41enlvamJPMUtya3YxbkdXcnpXK1lNYVdqV3BDRjluMGJjYU1xUkhPNklKNUVUVXJmWllRSjN5TjJ2Z2VUcmhIZ2dPbXRzQmp4U1htd3hJbHVsZFI5dWwwa3NYYTVSNlMwQk8xUU5PNkRlUGkxSXJGWHkralo4VXFUSzFZTGZPSlpVdFdjMklKcnA3WlNyK3QxTTFsYjZJZlVkdUdia1Ztd0ZiekgvTGVZUWxPdmhYY0Z3UUhDWTU5MTdoMm8ya3E1djdXR0kxK25kbytXUzFhNkhxR3pOS0lhclhSMWxxdGZjTnNTbzg5UE03UHlRNnBMUnFKeEpUN0diV050SEJkc1Qzc29hdTRrM1FkcGZwa3QvbkExamdBUkt1ZGVabWo4czBCRENGc0VPR1dCQmNkRXEwMnhyYm5abGJPUmpLN3VZd3A4dVlNbVR1a05yTVM4Q3ZnVWg5NVM2K3ZUY3Uzd3d5OUpjU2hEc1lYbngxeUFmQUJrVDl6ajBhM3ZHMXNuT3ZkYWVFWVpFUGFlNU5ES2lhM2FqdS9uREYrVEhBN3c3VWcyQ0dsMFkvQmhHM2tMdi9FWTlEUzJEWHRhOStlSVVGME9yeGlOc1A1eUZzQjJVNTZQV1BORk1UWGFEZEdoOHlwTmNFd0p3QW51Y3ZETkRGeFlhdnBJdkg4alNlMTlxVmc5Q0ZZcTQzRTdnckgxUFFvK0dVcnUyVGZxQ09IRE9ad1VYNys0Z3pKWTVjMGNxYXgyaDRieXEvamN6NlptdTVCQ1NmNUpjODgxcGlMbC9LWTNBWldoNVMxei9LY2dtWnRCY2toNmZuaEpwcUJoOTVFaGxFZmNFWW1haXp1MFZqZVJadmxGYmxwYVh0cWI4K1FtVU1PV2cvd25zYlVoUE1SSmlqeEZSM1M5dHpTMnJ0alp6aW9QV0hTL083bWZTM082SFVFbXE3TkJoOWxObGw2cWRscVQvVllzQ0FjcW1LKzRGd2M0VVIxd29rSEdzY1I5Y3NFMTlBNCt1azNEZGRXYmlMNnc4MDlaRHBEZG52Z0RCblRXUC95Mm5Qd3pDak4vb0xIckNXdU5haEZ5N0MvZm8rVGxYcHJhWmJYOWtXYzk3Z1c5dU8zdFd2blBaZ2xjU0UwbzExN1pybUNNT3pjdmpaODQrMUVPOTRXYUV4dnhRa25oR2VIRktMZHRHSDQwckc0NjN1dDdVcHJYRFFiRGJqY25DSGY0NkYzMnNRTXlhYnZYVEI2QXhqM0lLVjJhckJCR3R0QnovM2dxOEpUWDIrS1p3VmZjM2pFejh5bklMU2UySVVsSGROcnJ3OXRPQW90VjRZM2pxOFovdGNiZ3gySWh2SDFQRVk0QVJWUkUrSlE1ZjdER3hLN0hyeXZWa3VGaEdmNThneVpiZG1Lb0w0cXovdHhiak9jdThuLzRkYmgvVW9rTnJHK08wUCt6eFh0ZWpmdy8xMUVxcmxLRndTSlRubzZtOVM1UFVQKytQNmxJdXVKVzkzTFkyekZyVzZ5UkZvdVV6czV4WWRVWGY1dXo1RGkrc0xuSHkzL09uQ3JCZUpQekppZTBsOWVydnZhOVI3eStlbW5idUxwTGg3dmRTNjYzRnplZi9XUG5LR0lOazRPZW5PRy9QRmR3S3Vic2UvWGYrM2ZmNFVVWFZ4OVNoaGNKWTNVM3Q5RFpuWVIrZHZGTld5dVJmeHBEaFMzZ3JqODdQWXg5OFd6anFKVGNuK0cvT1B2RCtKUEFpY1BZdkV0ZEI1WlhIMU1TY3l5R3NTL3ZZY1UrVDNpRjBYbGJTcGYzRG5uc2Z1OHhOcmxMYytVSjYrWlZyeUxFak1RMzk5RC90ZWlycFQrcUlpTFAwWUcxNUk4TTIxdTkvZVFySk9VODg4a2NsSEtTdm51K3VrcEcwbXFDZUljL3NyM3p2WXNmeVVtWEg5UldQTHRHVEl0Nks3a3JpK3VRK21SQm04eVIrTDhkVXhlamlQNTM2ZnliKzRoeFZrN0tXVXR1VlFUVldHaTBWSU9BRHYxc0dhbEpzaHdQSndTYnp4UVRYSmJBVStTdnVKNllRMzVQZzBYWUNIaDRFd040Y01pSjZndFRXTlFWcHhwZURvSTRDS2dra0VKYmFwZDdvTFFCaTFsbTUxTXVQbjJIbEpBS2hPV3lsWVRFcFVHd2dDVEhIalFBZFN5Qkh1czFpOFFiem1TcElZbzk3TGtTZFVPYm9HV09xd0JvT2NuTkJpb0Z5WndOQlVubUFKQ0dhQVBDenlRSkhGR1A0VmoxUlZ5NjhJS25XUDgzdFk4ZC9rbmNZclY3VDNrcDd4bUo2NEg1Sm9KQ09lb2JXUVBwU1RTQXlkUjRqTkJMTHFTNmxrZUhJNDZUQ2ZyWllrZ1hQZllBcmdtRkl6b2h3ZzhUSG91RVZvZGdRVFBLS1RpU1FLRXEwSkJRNjBzL2xrSXViSzFBTHVrelMwRjhIZjNrSGwwWThXZFFVcEpMSEFRWXZLaVhZQ1dWZEpZWk9Tc0JRejh4SklXTW1vN1VaTVNpUnJWbzJCcTBUTjdCRGMvV1ZpOFUydGtyWUhnZ2QvRk02aUZnNXBRS0xaWmlJWGNwMWhFYVdUb1FaUldUbG1tL1A0ZWtwV3lqSWdUTi9FRjBXcnpFV1ZPME5KblZDU2RuTEw3VlBDMFE4S2tCTVE2RlB3OURxdVY0WURxOEhDRkkyNUI0REFGd3RBZGY1WEZJZ3dheEJUNDR5N0xvYTRaOTlBbWFvTkF5OVRLelRPakVqdnhxZHpjUTRwc3orZkhCZnN6MWx3Qm9ZTkpWcVVGK0JWVUxVY1ZKbGF4MEV2TFUxaFNzS1NFWmVMYUJVV1RSRzNCT1dBU01kYnMvTVNlSmxVUVhyQTdjY1RhQW4xQXprT0NWUVRORUtjNjFxaUVJbTNYaWtvdWdtTk5UeUwwQXFjc1J3TC9idTRoUHhTai9aU1ZVcFlmR1JJNzZrd0NKWHFKWWpBN1FFMmRDV21RSlhCSXFBemVTR25ybUNIM2hwME1hWFdDdTdaRTZkbmpTUGplRVA3aGZZT1IrNWtoQjRDbmpHVm5OUklkeHVRTXFlV09EUFIvckp2QmJnSXhERVRQdTlOUmVrQ2lsM0xndUwvRC8vOUxSZVhzNjVBbGNDaWlFSVR0ZUd5M3NVZXBLRE5KYi9DUTB1eFUwemhqSE12L3kyQ3VlakxDOVAwNDMwdE03L0dRekJIcDVmVmR6elhPZCtYT0lLTVJDTTFUM2s4OGJyYXdNT01oTVVtdmxEMERFdGpsbFpDU1lhSisyRkpncWRaWTZtL2M2RXRZdzNMR1EyYlRHRldZc1pha3RpTUwrR0ZDUWxYeGdvYlFpb0FHeEdOUTBmdFBlMGdxQWgrMFQxWjRLa2xlM2JyTmxwVWxUcEFLdFVrT2RRZDRsWnBGVHY5dWFkbHVRQ2xyZmVVQzk1S0h2RVo2SHVkdTdiNjdhbjhrcFd5WDAyMzM0T0RDa2d1dzVHNVZWTW1Wc3BWa1czVC8yU1J6Rms5NHlNaWFBbURPS2puRFpMSGx6Qk1QWVZWUmlVZ21MVEMvUEZwWW1lbG1QS1RHMlNSKzlYbkN2ZVRGcVFRWHVDbEtKY09CUkhBQ2djZXMyMVBNc3g0eUhBZFpYK0JOK0E5dTVQUGprdXBqTmVVdXNzVGd1U1NXQVJLaG5mQ1F4RkxwZzVSZmpFazZUa2RLUmFtQktjSlhVdVpBRytzd1oyOWhic0pEc2xmdE8rQmJRQ01ZUWlSU1l4aU85M3YxSmNaWHFXV1p2NHFWdVNXUjJQYXVWcTVNZVVpcVJQVkd6ak16R0VSbXdFUXF1aFgrWHlUQ2tKU2M3QS9mZjhoTUpxNGs4TzgxRDBrSnM4aEhTbUNhejZtVmpZYjZmZXlXUGovU0hiL0lQdGZWZnJaOXMxZW5RNXJ4a0NXMG5VN255L1o5dnQrYzIyNlgyK1hyaDNEejYwMGJTOFA0QjlnUlZZdURRK1UvcE1EV21KQUVjTm9NR252Y05qdlIwUUNkQmJOVEF4a1pLVjVCQTFvY2haM1dWVHVSWnJrc2FXMEpRU3JOMVdwdjVnNXU1cUlmYnA4WHVPeG0zM044aXYrb09UOC9qOTl6ZEtSVFdNV2VzTGRYUUVFOHVic08rcjFkNThyTjhoUnhQWGExU0x6K294VVVBeFlzZzZEdm5TT3lKeDI5NTFZem50ZXBkcXBlUngvckJiMHo0UHczdjlkcy82WVdlRjR5blo3eE16V2RUcXRvVlo3bnhVcUZWM21KbDdpMEtxYlZ0Q2lyb3FyaUR1Nyt1WkxtMGpLZVJhQVIrUTNiTGV1UW02K1d5RGl1SWhHY0JMS2h0bVlUd0VWb0FzcVRKM2VmQU96dTNsQ2VsbTlPeW1XQWFYdGFZQlRpZTdXYXhWamdtZTRIZDdvOFg1NU1rK09DTzliZGNVcFA5VkphcXFjTFBWMjc5dCtNYk4vL09BcXFLU2NKcE1vTTNaek5lTUFCVFpJcWFNR1c1ZEpwVkpFbkRvREpYR1Y3OWRaQlMzU0V2ZEgrbG5YSVRlTEJlK0N5ZUVlY3lvbEV0ajNVQUVZSHlGQUlEY0tCVEt0UHk4M21UWGxhQmxnMFBnamFuaWRFeW45ZEJGZXBzdzhmZ05iMCtsN0gxZTRLaVVna0Zrc2s4cHZvZWY3cjJzaTJmeDhGWnNtc2VrQkRQeUVkUDVONVVaVUlpZzZKdUNDUktxc3E0QUFqOC84Uk9WbW1hN2dITk1SS2tWdm5rSnZ0UWp5b09Lb2JNbTFJWkNnazNDcEl0cjNDT0ZuMi9hWVBOMllHMmw0ODdySmlvM0hsQ2VNZmEwWXF0Zk5odDlmeFhJUldpTWJqOGEydGVEd1dPMHdJaDRuRFdONE5sclhScUZZTFBTSXpPK2ovSjhnRjBSQWlIYkxNODZvMDQxUlE4TkFMaXVJQ2lDcmJhVTVXT2FLRm1qeVIvLzkxU0VoR2xlUW0wVVIrcmRrUVZCczJ4RGJJNkxRelBmZUo3S2FjcVF2UlhEeGV0eGpJeklhbnZmNngvZjVzWjFmUXA2NnU5M285SWJLMWRSOGxIczhsRW9kQ0luZFlEZGpyK1hLK0RCMlFsYXJWYWorYi9nTm82ZG1NN0NpU1VQaTNVa0ZIWUQwMUMrZlJlUm9uMjFKV3hnUEE1Y0RJazNRYnRGdldJZStzMk82c3lHQm1TUkpGYVR5RWJJQ2lTbXhEMGt5clozd2JaTWdVMDQ2V2lKQW1IY3RvTnhwbW8rRjQzaUo0djdON21POGZ1WHF2SUFqUnhMMzdGRnRidWR6RFJDS1cwd09ER1VIYk1Cd25sYXFXcW1ZMXlhbWZWTW9sS3Fvb2t4UjRzeFV4TFhLZk9LZ0RmYUFjajE3Smo5VTAvQ2lEak9paFpscmNETzYzckVPdWR5OGlqYVRKa254ZEZaRWZoOXM2MkZaMDFDTEcxMDNiQjlmU1F2L2NDQVFEMmNEcWdxeGhtbWJEOU5qeWFtZW5sOGZ6UFVIWVMwUVQwUzBDZzJ6UlJDd3E1SHBLMEZZYTdiQ3RPTlVTd2sxVnVWa1dzajJlcFdjcU9TMUxIZDlHRHVHeTNFeWtiQUhoSkRSSjhDSElqTkFSYktnemt1ejJPZVJtWTJLYUUwVU9YN0lvMXV0aWZUZ2VhbU44YmdKeFFhL3Jzdi9HOXB2QjByS0tSanR3NDBRVzcxaHNSZWJBWVZkdUVDREhtM3BQZDRjOUlRR2xvMXZmckdTN3A4R2ZXaVJtR29yVERzTzI0ZXp2ZStaT3FsVHRjNSt5Zjh3cXBCdWxSRUtTZVk3UXlFSGtVSTR5ZGhJZlhaSXV5MmtPWk9DaUZuYWpOTEdtK01LZUdseGNiNkpTNFdPNUx2WkJKdU1ZRWhvQ2FMMzZGRndZaS96NXdrS0c5L2Fkek4wdHNMbUxpM2JqQ21RbWF1b3M1UVdCRlJoR2dNSE42M1E2Ym1IbHlHL3U3Mm1hN3JwN3NUemVnUkVhUnNOeFdvYmp2aXVaUndNdW00Vlc0a3dGMkdvZ3EzTkpJS0NnZ2hacG5oSWpwQU00VUZXU1YxSUpEVDJuK045N2FnaUw1Z0d5Q0wxRUdWNFhyMEUySGcrMGNROTJIR2VhTm9YdkI4eXlMcGdWdEtxbGpBQTBOK2cyMmxjUWphSjZkdFpnRjR5MWpZRFlFTUUwNDQyMUIxL2QvMm9JSlR2dUlDcjBIamxLeTFCYVRtaTBGYVhxbXRYQlFPUkFwMUoraGxMMDE0RUdPQ0tEV2lLdzhBQXZaWEVOZEN2Vm9DR1psWHFOV0ZOOGNWLzJaaSthTEtvd0krVkhqc2dHZGRpcW9QZDllMm43Z1cvZjNNeXRMcnVZV014YXRqeFRpK2NHckUxdWRLRFpmdW5LVTZ5TEN3WXN4OE80YlhyZThtTU44ZG9PT25oRGVhM25GclJ5Tlg5V2FqaXRrTFdmUGdWZzFYUzE0V0JRUGovQlNJWGNJVW9vUUNJMm9Ld0JSUkJ5cTA4dG1VMFN0NnpTR0lpV1p0SW90OHdoWVZrcTByWWtJdW9TM0ZnZjE4ZnVVQjluN05mTHBXMEg5azFHMHhuckdnekNXZk53djZSSE5NTzVhaUJJc1ZMRGdLQlcxMktCV1FWYWF1Y3M5ZDRMNXE5cnRYa1FtTDFZTk5FVHRLWS96ZWc3cG1JWS8zaXFQRDFXRkZQUFJ4OXFBLy9vdXMrUkRLSWtTU1JORWpWSkpEQWdMOUh2aWl5U1E2V0tSRmJGSkl1bVpkQUVaTGV0UTlJREtBOHFTQ045ZkxXd0pYTC9vSk5wamtiZ2dtbzNSNFZZWEpoM2pXSklaRlpRTFhtNldUbzdTOUZuVmlvMWloZHYyOTJ1WlMwV3pQTUNvTzN1cEZJcGtHTkl1RHI3Z0FtSk5zelh6N21NN3o5WGpHZkZOc0NPajQrZkM1Rjd1WVByNjEwOVU4NnFHTDJsU2pwTEFZc21rOGtzQ3V5M0ZvM0lJT0gyQTRuR05SRURvRWlpQVc4dDJoZlhJWEdmNExjNXVkL251UDRxaDlTUjZVY2ZSeXV3akN0UXBvK0VyR2gwRjlaaXdwVFNEeTN6Nis5UFQ0bkFMTFV2M2w1WURHUy9MUlpXNEFTdG9McWJVdUJOZzRhd2xsZlZPOU4reHgwUHlrMjdjYXlBRFlkRGFLbm8vUzN0V2hOMjNZd1BxVERYUG9GVThPYkpTWklyYzBtY2Nka3lQSmc5d1pVa21IbjBFOEJwNHR0c0I5NFk4a3Zya0xqL0o0VGNoMnFRclM5dFgwLzkwWElFc0xudEgya1l3dTdGVWIzaXBBalJKdk5RYVlVdDgvVGZmMEhzZmtncEY5Mmk5UmszUGw4dW9HbGd0b3pxanNOK1poT0dsMkZRVHJVV2RpZDVOTGpPQk8ybnp3eVVNRFFVUUNxZE8vR0Jua2drZXZ1WlRIbHB2V0tMWlhBK1RXWVJ3QUlQbVBDVE8vbFV6dUpIVnBUMmVHaEsyVlNtNUk5eWh5QlF2amlIWEFjbmtpRkZGTjlHcWtjc2YvV1BCR0VRalNPZ216NW4xdVZrTXJlTUZ2dkorV0gzdTFVY25pbnRJbHRjV2hiSTFySTV6cjdUdlNoZXNDNURkTkcyalYrbTVYSUgwK09mRFNNRUw2ejlyUEZjZWFyc2E5cGhMSmZvNVh1QlpYV0xFMVprZjFzczVzc21ISG55a3RBUUhMSUhJa3RKUmR3a1NWSEd0MFprdDYxRGJ0QjRTdjNYWE5PR1hDUEs5Ylo5Vk1qRkMzYncrRjQ4bDR2a0VyL2U3QnNoUTRTc2RleThlM2p3M2NPRGh3ZUg1Z3NEc2hEWjU4Ky9mVjVNakVhcHhONnlDMUxZb3FiTGlvcURjVEtmU0pRWWZiRFFqVXlwSEw5NDhYeC9Semc0MUVFR3NCQmdZY2p3ZkVoSms4Z0k3UlBRc2xsQ2sxRWdHTkJFREc2YkRlNjNyRU51ME9ySSt1VnpRQkVaNnE4M1dnUlRxUWVqMnNla0VJa2R4UFNibzNlbno0K1ZzS1U0eCtiWGp3NFBjckdFL2k2L2F6cWhCZDBXRUE1MEM5WTJqeSt0dDlZNkxxbGhocmtiemVzSHVaN3hkMFdCR1o4OVV5aEpYajA2M1htWGgyYXA4RlgzV2ZnVHJQdFBxOGlLeFV6emhISUpnY0dMSEVmMlhBMEhmWkNKUUpQVHNnVEppTzZXZGNqTmFvRElOU0dVallPNGxxUE1BNEFCemNaMnJhVjMxTW1NbHA1K2VIcjJ5QVRXOTkrZjdqNk1DLyt5L1Y4NllEUFlmTEo4WlUwbVJoZHBwbGd5TGw5ZExyNzkxcUtjZVRsSGgxa3FrZE15MnIzWWZ0akdUS1FGcnNhTDQvZVA4Tjk4TGNSaXU2emJianMvc1BsOE1nRlkwUUFhOWo4OEZsKytiTDQ4L3dSQ1ZKQVJYWktESVVXWlZGdkxkdHNjRWx3bzUrZHZmTEloZ3BKKzVnN0lFTkh6NWMyY0JheTJlQjM4bDdGemZVcnIzdi85NDNaeVloTWowUlRkcklZSnk1MWxnQ3hZWWRGQTZlS1NVbFJJRklzQmhFelFoWWxjUkJST3NwR0xadzluSzBKMkhUSkhqOXVDaUxPTnpqVFQ4L3YxZ1pPTCtkbmtTV2FuKzA4Njd5L1k2WG5RT09lejBPbDBZb1lYbi92N3UxenBOMmdwbmdLZDMycXpnV3pqOXB0L1BsbzBLT0EzNUZRcitEQXVyK2tOVzJGeDlNczNiK2Z0YmMrbFI4UHluZ0dEWEI2UlR0T29qbDYzeGNMeG9ZWWo1S0FjSVhWWGx6cmN4TXhNZ2gyeGlsUTAzWDM0WVBEV2hTOHUvdVB1clllM3J2YTFxd3F4azQ1QWRydWgxdk1VVHIwZjhrUS9lUWd1Z01FZXovLzNjZDFaVEZJZ3V6UXlmbGU1c2I1WTJYaTZNYWhUU0F4S3lzb3doRXcxdkQ1cUg5OS9GRm0wS3BoMTNNOTkvOTI3TDQrU3JHaFEyUS96RnZQYWkrL3VqSnVDeGtRMVUwd2syRWtOZzFZeE9VMDVUZTRjM0E3elUzNkdZZVREOFJ1RzBZeDl6WXZLUytxbWthVm5uejY4ZSt2QkE3Z0svaHE4MkgzMThpRG9DQmx4SUdvSjNIWnhpSkFCN3hRZDhrUitJMkFQZ1RWUCtsa0VaT2ZCZHViQm03ODlIbDlhTXV4RWhuVTZuZnE2UVkrVnpJYnFvZEtuRTBhWGQwa1hXVnpVcm45NC8vN0RLNXpTYnJIUjNNQndzaGlMQlRqbC9KMTVwZFdkcVZVVCtXWWlGYVluR1RXbFZtamwvR29vNUhDRUtQeE5Wa2Erc2JtOXQ1MGV0U3ZsUVJPNDREWTZPTHZ4OE9xRkI0OGZnZ1B0REozc3dxM0w2RzhBdkF6QzNqN01XZkFiMmhyc1ZCMlN4Q1BRSG80L2ZBeUhnV3krdjdPcjUwd1BkczBiLy96eHpkdjlKYnRyTnV1MXY5ajZNaGxleDhjN3ZEalFZeFhGTlV3VVMvMkx6T1RtcS9lL2d1M3pWMXUrZ01mYU1YckFKc0ptZ1cvb0pqYUc5V3l0bm02eXNTYiszL2ZCYVFsVzdoQW5CeGZGcUxWYW0vTEZ5dHpjTm11Mit5Z3Q1WGZrYUpaRk4xZjJRM2g1OExoVi9RZjcvblNMVkpTN2wyZXVYaDFFaVVTV2tYVzg3eUxaYUdDbjZaQkFnejE2K0JBZWV6ei9kK2d5bWg1Q05uQldJcHQ1dVArMzhlV0RZaVpUcjFiZjFaTmtuREt1QmM5Zm1vNEpYdmNxUDV2MWI3ejg5NjhmM3YvNjYvdHZFckdvcDZDTlZET0pjSmlkb2hGMXcvME9VejJaWVZNczYyUFpSQ0tMR0IvUVV2SW56Qk90UWt2cG5jSDFkeXRKTzIzeG1mVnFoVzJING1rZnl1OWlwTDkvNCs3RGgwZzBkT2xiLzV1MDcwSGlOekl0RTkya1ZVb3dqV0RYUEUySFBKRkJFWXpnbXYvNy92eThEbDI2VFNiUlBQekg0L0hhUVl0c2F6VEY1bEhBVU4zUDM1d3Rvam5sZU9jd2t6MSs5Zjc5KzEvLy9VMHpDcktHMzVoT2hCT3BWSmcxV3h3TVpmVXYxek1wTm1aa2ZiNVliRkxhSGFub251b01oRXh1RWV4ZjNsNUoyMU1reFV5TXltYmRjZkJ1aTBtdVVBL3JBQWV5V3lDN2RXdnc2bDNBSWRWbXlBclUyMHUyOGI0L3RlYXMzNHYvSCttUWJhRVgwUWkwL2YxV3BzRUdpTW9tdWZEMndmemIyc0VCeU9xalRaL1B4eHJaaEp2dmxCckZXRGxkVHExbDlYeDQ2OE92di80ckdZMktRcUd4dzdIaEZCdUcyV2xCNEd3SzYxUXlrNHFaeVE5aXZkNGdvdEdnRHNPVlZrOGIxOS9ldHFPbEl3YjFYcmNleFdtSGNlUk1PZTJBU3JaSTJPN2V2ZEIzOWNIZFd6TXR1a0d3NGRmaXlQSk5GdTAvRWJYOVpCcjU0eG15WFVaT3ZOWnkycVA0QUpFUHo4cGtVbGxFdVJpcDFrRldyeWVhUG9GbFRXN003WlE2YUJhYklDdVh0MWFTdGRyeDgxbzRHbzBHU3Y2ZEhjNW5aTzFsakNCaDJpSndWcFhObXlab1pwL1p6TG9YNVpNNlhTVVNVVXRrSVpQWC90MXRJNUtMVGRscFo5WVlsS3RzTnF1RE54bk85Z3hnUWhnRzI4YlRDM2ZKWUR5SWVuSVhEWnVzY0ZBRFlGaHp5SnoxKzFMengyZlpMWHNFTWhTUi9UdnpnOUt6NTZEWnlLVHE2V21kYm1lalZvY2RKSnB3R2o1NW12V0ZITm1WYWpwUkZtTUxtZlRoOGZQbnJ3L3l6V0l6Sm5BN3RoMm5CWnBWR1ZNaVN4dHBEc1hVbVVrMnpXYUJOb3MrdlVUOVpMSVNpV3RrS2hsRFllVjJDN0dzTDVWSXN5NnZONmlYZ00ydjE4c3dzZzZvVk9yaC91ekc5eHQzYnczT1lBV0F6d2daSEhmaElpU2NvYUhlaXljUENqb3A5Qi9USVdFWWlvblBDSnJpYkNjOEpwMkdNREs0RWRuOERZMGxjeTJxZ2R1eWZIVDA3ckNjajZVUEQxS1oxODkvQmxvK2xVOFZ3K1poenNuVEZqZVNCNjNYN21zb0JoVGNlcElzMVFKTm16VURNdlcwSWE2V3dTOWFSbTRTUEI0aEhHNEdoRERyeEtvdVV5SGRjdkx6UFNxVkNteGFGSlArNzc5L05EZ3ljMkVRZ0wydEJvQzJocDdXQnlQdkczakVRUi9SSWJHdWtaRGRHSHhFVXUzT25mbUtyRk1xSlFLOXJLZGpmMyt6aWp4RFBCYWJUYVBQQ3pLZktaeElwSXFKV0dvcmVWQnNIangvL2J4MmtJL2x4WHkrbVVxbmtXSkJTOURwSW1pQ0gyL1JiOHl3QVl0Z0VXaTNyR3RBb29DUUxOWEVaN05yN0pRdnh5VU9VbUtwSktiTWVrcE9hYlNLZnVQM09xa0NhSEFjMkRheUd4dVA3bDM3SzZKeVp1WXEvQWMwZ0VFOEp5MzdSRUJvY1h4RWh5U3FQLzRLdUExbzR4WFpOYzAxaUJhR3l0UDl2K3c5cTlWcTFXUzFYa3o0V05vTnYrV0NLSUhsZEtvWkxoYUwrZWJoeno4L3IrVkZNUkFOUkdOaUxKRUkweVlZRFFmN2VLMnFSNlYxamJJOHgzRjhUdDl4VmlZMXdJYTlabFlRWTd6RGxLdzNZNklGLzgyR2xaakUxTEwxWmVQNnVGSURPT0JwSi9zMzRMbU5lNVZCWk5uTTFjc3pmU2lRZmQwWGV5RXFrcjRHc3M5T01ENHlReEs0OFkxMlNNSnJVbW04RTNMTWd6Y3ZYNzVkTkZmcnlXUWRVcGJQWjNhN01RTEs2V1RtOERDWlNDZlRtV0swZVB6OFh6OGZvSVFFU3FXb0tQckVHSjBMOFNZbkpnczZLTGNOZFBVb21FV093ZGE2RTVJcmtUMWVKY2Q1YURFcVJnWE9YRDFvaW1iUlloYnBHR3VjcE9RU05jdE8ySC9hWHQvUXkrQTJyRHNvbEsxeU12TzBwZnVNbkJ3TjlJRU5Uc1ByWTFzMnVjQkYwaEVyOWNiNC9KMzkvZmxCb01YanV2MlhiOENXTldmeVJwL1JuVnZsTFRrUFNnVE4ydzhPMHVsRU0xbE5ac1RvWVkya0dpbVBRTU5iRkFXbmcxdmxWL0VWTkRFS0NVS3dGVndxaGMxRzBUSGFFbkkwZUNIcUVXTlJNVUVDV1F4NHpWamQ4SWs4b2JSZDE1dHNjbXYweFF1c2hBWnNnd3FWb2IvRkJyakxzQmtDMW9jeGF3aDh3Q0pzZjFnaGY5L1hnTFkrdnptK0JyWTcrK054VFYra1V2bjdteDkvZlAvK0I2Y3hSNlowaEZTdWxNdlJ0TnVjUmlBaTJaSVlGUVBpY2UzNTYxb3hUOWdDQVFIbHdvSXhDcS9Wa0Z3ZkFoclo5TG9najZQbzlVaE1NWThIYTBNaDRPRUNZck9lUWUwUmhaTFQ0YVFCUnoxUk0vRkgxZXBSZFlyalNnR3g0WFRxRjlWcTB0OElXLy9UeXlnZ3ZkQTN1aS9pS0xBOVE1SkhvNTMwc0ZQdWg1d2ZtOS9jSEcvNWJURGVWOUhkZmZ6MlI3RDlUOFFQWm5TSDA4bnpPU2R2Y1F0c0tsVk1GMVBGVENJV0tKUnJxUDBIYmJSQ3crbXhXRXlyVkNoRTRVc3V4NW9KbVU1eUZoSXkwTEJJeUZNK3dlUDM4d0ZQeVpOQ0NSTHhhWWdXWG0vQldzb3psTWx1TDljTzArVkFvMUVJN093VUVPUXVyWUxVU2NBOTdlK3ZFSDBEUllTb3BVZzM1QkdKeDFObXlOOXliWDV6ZmUrbitmOXpaL3ZPL3VDZkk1WDlseTlmZm5qNTV2YXdiQkh6RXNYeFhNako1M2kzMlc0eGh4UEVjeG14VUVpaXJhSDB0OUVjZmdkODZ3RFpvdHdCNHpnR2ZWOTkvcjl1WWtNQzJxVnBZMVBnclEwUGFuNGlneElVRXdTUk50TXV0MkJ4NjZHQ3NXRkUrWEk0VUlEdE5BcUZVc0NsL3FLZGJtMjdQRVBrVlp3R2tKUWo5UThQZUR0Rmh6engydmpTNXZ6bUM4Q1JtSHgwb1gvK255Z2l0OWVHRFJLRmxTRnNlaTYwcXVlSFVkU255b2xpQmhOenVPQThQRHgrWFFNYTZpTmN3UUVyaEZSektrMHV0REZvMzUyZFdsbFhoMVFtVTBpQWR0YnRpNjV5bm9BbmNIRFF6TE14VVd3cENVVEJ5eTB5alZWZk9WazlTcWRhYUkzV2wzR3dMNjREbXc0WHNhZGtpcHpCbWNmSXhSR1EvVC9GLzVUblF6NWFHdC84YWZQRjNPYm01dmIrL3VQQlc0Lyt4LzZkUGFVVzc0bVVBQ3VEblZnZWVyU1JEVnJvY0RwSnZKWXFOWktIVzY5cjhGbUFsQkc1SDd1S24rSnl0SmN0cC9BV25TNk5SRHY1cUhVSWt2MyszajFEMXVmMndBcGlNWjhYV0o5Wk1BcytJVWdqZzNrR014YWJMaDhlcDJNbFVMVWR4M3NmWEkwYjJ1bEdESVNWeXkxaEM0Mk5WSDdvL3FjOUg3SnQvVXZqUzhEYWV6RjNCMnlva3c4dWZLR0pHQWdhUmpxWVJLWFFUdDcrNnUwY25oaHdmTHhTYk1KWEpkTnk3WFU5SDRDVmVBNWtqSmJ4T3p6bVZETlJiSmI4dGgydHhyNTFkTCtHRFJ5TEtubm9CTTE3c0dUalovTUJjNHhNS1RSYXZOdEZobU0vejJZT2ExdnBRT1BFWnpzRlBoakJRVmkvN3VrR2dTTmtPcWpvVUV4Snp3WVdYbWRPTzhzbUJSSm9XY0tHa0p6Yit3bHNmNXNmak9ONERHdGJSeGVzQjYvNDBuZnZYcjk2OWZtSGYzODRmdlZxSlowUzg5R0N2bG83RUFIbTRaR01sRlZyMDFvNVMweE1wYWFFaGhXTmQ3amVYdldPUG4vOTZ2TlhIK1lzcTd3dlBKcUIxMklwYUxNK3dZMHR4aDJrNVRhYnd4Sk8xcXZMVTY0ZFdLT0JWOEVpMThvNkpSVXd0ZEZnL2ZjaTkzcEhob0FHTEhJR2RZb09lU0tNNjdMWnBhVjFzTTNOemIzWTNQN3U3YmlzWjZDTFdGdGhQVCtmemh3ZFY0K09qdVpXWHIzNlptVmxlYUVwUmdNTlhiS1lMNVg0d2lySXRBcjBJcXZKekNhS1V4Yi9Ea0V6RkROd0lKd0l3bVMxT2xyaVZ1blVHdHRNcERNSDFVd0dLb1RGSGNURktXeCtkemhkMzZxbXpmQlhpNjdBY3pLMGp6TVJna2JJeUFVNCtLMTc2T0lRL0hVVDlzZFAwRzFkQkF4ZnV1d3pzQ0VpOStaZ2U5dmIyeHZhQVdLcWRqU3FuaVV6bWFPajQvdEhSOG10cmVWd2VYbmxSUnJicDlWQUY3aEdBK0tVRnNvazB0SkJlOHVqWlpyejc5aXNLdFZpQXFLUHlNZnkrVVRyY29aQ0FvMXN4UndLc0hBaTdNdFozREE1ZnRCZFRpYXJoNWdwRzRVZC9MQy93VEZvOTVlNjRyK1h5SXFPOE0zb2NLSTBkSWFBRWJTUHpaREVhOFNVMldkcno4Ykh3RWJRbGpmQk5tN0FFSUUzU3k3TUVzbnE4ZXRYUDVOUWZKRk9KZzlYN24rK2trN0VMRmI4Q2EzVkJvOUI4SHEydlRDMmRmLyttSmx6N0dDMWhLZ2FibUliS2dsa2ZvN21vekVlcVlqVmdBMWpsUW16TUk5N05ZZVprMUZZSFc0b2Z2V0VVQ29nRnNIR1FNYnRJWGN4U0N2RVpTZlhQWjF1QnNXazB0djM2VTFjbjk0OFRZZnNhTGx0MWdXMkpmanRoRzM1eGZibVVxUUZaZFZhdGZpMlZudGRxeDBkdmJqOTd0MzlWOTk4ZzlLd2hZVmE4R2lKd0NXUlNCYUhSNCtxOVlXdCs2OWVMazg0MjJSbkdUb0dFMUZDbzN3QkF6VEhjQjVJQ3o1Zm1NV01EV1dWRnZnbkZJVll0b1pNUWFlUmhWeFVBSmx0aHpUSmM1ZUlmUUZYZ1cwVzMwR0c2MTRFMThqSmFXK0w3Q002Wkh0YlZTcXoyUW5Bd1crYlFOdmFtbHVIelZxMVdveTJSRmF6VWtrb0NabVVPYjIxdlBWdUM4UElpNk13V2pDL2FOT2lNVXVtN2RWakxBbUhLKzlXdnZycXErMSt5b1pVbFdrZE9ROUdSZytwb1o1QVZIQllRekVXRzQ0WkRoc0ZHZ1p1T1lQYXE3TDVLVG5qY0dMMHdRV1Jzb0dXTHo5N3FRdDJ0cDFzSk0zSTk0b09aTjNka1pPeWY0b09lZkpZM0dIbGJOYjRiRzFpYkd5TStHMWxibXQ1R1d6WmFhc2FXRVFOdGRMMU91VFMxZ0xUbWhremgrbHZ6UVVIbzlEaUpxWGgwZHB4SFZwQ3JWb3Rzd3ViNjE1R3E3cDBmbEhQb0lWN2lCRzhxTWRoRTlJQlhxQWhHb1hMcUpDMDJ4MnlxbUJhaG5uQ0VIbGswWTgwUTU3NVFTaHAzY054WGdNVmRMYS8wdHRmR2VtdFZDcVJ2M2J2ZG5kclRseUc2Mk02Sk1qSWE5YWw5R2JYMWlZbTRMYzIyOHJXSHRDQ0Jpc0RvOGhCWVRxVGp3V2l4QUhFWWhuUlBKVVNuQkNudE5QR1pBMVdCZHJyV2lxS3lhU0FpT3c2Wi9HNTlaaFJDbnlCTDNuZ05vOTFNZDBzN1hBbU9vaXRGcTFhY0R2bERGb24vZzVvdDRwRmw5SVpYTVQ4NDJjY0ZLWEdpY2tBNktSeDNYQy9ydmRDWldSb3FQdkc3a2pmamFGNGR4OGgrODFySDNuR2VQdVIzc096cmxudjJzVGEwcmRMWTJON3FKUExjMXR6eSt2ZTJheVNJWENVZzJJc21UeUdKS3o5QUN2d3hhSVlFUE1wTm9zL1FSa1Q2WFQxc0ZxcnZUNnVOd09lUXFtQk9pS1I4QUw4Z21ZT044QjdxMURFeXpGUSszY1lQd29qbjdPWVRGZ1FaSmZPWUlFaG5jTmVOVUtHMUpMeHgwckpTUlpMVkQwOU1naDgvYjBWbk5maS9xMmgzVi9pdlpFYm4reGlFQUhCYjJ4L2ZEOWtpKzJMeVZtWEs3dTJaSitZK3BiRUpISGM4dkxjK3JQc21wSkN0UGo5MEJUREdSOXhDT2ZnQ3c2YWpPNVE2TXlvQ3RacGp4QkxwVE5Ka200SHNXakFVc0N3N0ZkcGVUYzhrN1B3RkJJV0FSYmlXVkxiclEwSEFzL0pjM0tRUVc5Vjk5enNhdlVacWx5cmpocE5jbndzcUxscWdpdERVSFpHTHZRL3JZenNqdlRldUhKalpHVG95cFdoZUYvZkNkUWZWOGpXZFJLUW4zWk1LbDBJeVFtd1RZMk5MZXd0ekFFT2JCTlppSTM0REVISERDZGpBUS9JRmxIYnY4VXVnOG9uWW1QbUZRb0hiL0VoZWRLSXlvU0lnSVdQSERzS0swOFdjeUZueVRtSUVzZjR2Y0ZTeVV3N25TNm5Qd1N5a0g0MTlFU3JWV1B2SVRMV2dESlRLeWJDS0M0bXAxT09aQVdaVnFJQ0dzci8wNzdkM2ZqUTdzVWI4ZTVmUHJrU0g0bTMzLzZaMDNSSXVBeGZOMjkrWmhnMmViTVRVeE1UUUNOd2U4aTNsYm1GOVRYN2tzdXZaWFlRbFdzSnVzUTVueTI1SFA0cGtHSGZzb2lDOEtSbndPb291TTB4TnBXc1ZjTXhVUWp3Zk1OaFZlM3dDRHN6T1V5aldqdXpYbW16Y2xoY2pFNFhGZ21yM0VFMGNxMUMxbmtlOHFCRTBybFdQY2dMUHFNUG5uYlR2cXhoUUtGV3cyM1hOSk9RblB2KzEyNzN5RkJrQkUrdi9HWDN5dTZORTVlZGVwYjkzd2pkdVk3UHprOVBXbHhlNHdUWXB0cHNRQ053YTFOajJVVXJpVWwrbEMzSWwvYlhqWnl5V0l5VkdnMW5pUmNLc2tzOUNyOWoxVUtiMmN4QkJndFBPcFVTSFZhYnl1OFJhQjlab1hPY0RPVkFZOTVSMkp6MVREMER1V3R0MktiQWtRYWxKYTBETDZtMmswTEhqZ3FDWjNXVkZreHVIRWhXMURJMXpyb2xCc01reWtqM1VGK2srMHFrMG5manlpOVhobmJKbThjWStkRm5qTGNWTGNoMTE3N3VPSGZ1K3FJVFlxZTV6YmF3Z0ZFWmFPL21GbkJlYVZmNllaUXJIRkp1ejlsZCt2SkJNeHJnQ3dXT0wzR1M4eElKVW9uakxiRlVNWTh0bkl5TkVNVlZqZ0I2c2c5ZUU1eFB1aTU5TVNGNnVCMVh2UWkyWlBwd2JqTTd5U0NidEZvcFhFUFk5SmxNRkJwRGpsOWQxVk1tTjIyMHoxSnF0V0tnVXowNWlSSTU4dWZJeU83UWplNDQySGE3NCtTQjNKYytVaUhiYkVSaWdGMy9HdmZmbnBNYVRDNFgyTmh2VVV3SUcvTHRhR1ZsWVgxcWZjeEx1aW5sWFgzMDFaN2RhVW9lNUFNSVBBK0tPZ2QxVWFMU1d0Rmt6VUFUOHpIeXZlbFhxUnFCR0lJTDhvREZROTNzMk1DZkx6Z3M2WHI5c0I0dWppYVQ5NzlaNzljb1dsN3JnYXlyQ0NaVDBXaU81NkVKeWhtOTIrM3p6VDZaVmlza2ttbkRNSWFzZTVHUjNsMWszQzd4MmlkWE1QMEM3bU1Wc2wxR0NGd0hJYnQrN1d1cEFYNXptWitad2JZdzFjNjNkeGp6MSsxTGRpL25SM0pROHkvSHpIcTZYb3lLaE0zaThWQkFHeURLTDZWUHBhQlJpYWxtRTRLVlVhSXFSSDFSR3NPdnhjTlRaL3JaSEYvdzIxeVpBeUtHc2VrMGE2KytxODdabFl4Q2VxMExkU1ErdHoyMzVqT0h5OGsweTFPNW9CdHluMVNOKzE4bEdzeU5aQ3ErTjlJSHI5M1EvUExKZjN6eUgyZmFDOXNwTStUSlUvZy93NjNGeEc5ZlR3OTdZYytNRTkraUNaQU9SeEp1QzJ3VDltZDZjdUszdjdKazByT1pmSlFvV0hqVHZHeWdFMFZDaHRneTRlUUNjbVNzaWFteEpCZ2twYWlIZ0xrdHVWVXE0dlB3VmoralF0VFZzY0VkSnV1c2tFNGtmSmorVGVyT216Y3ZxZmMrWDdtOVZjYjRuMG1KT1Y2ZncyMVN1S0ZFaXZxaTZjZVFCYnRYdWFDcjlFYjZoblp2RFBXMXgvcU9qNTFsLzc2S1hodzRkNjFUZXEzalhJZGE3M1M1YUs4WmJDUXFDVnlyVXRweEw2UGViOVhzdmFYMXprd1IzUXN1Sy9HcjhvR2VzeXBrREFaQll6RVZLQkdaQ2lKY3dTTlg4QkFrK2RWY2pvZmdGK1I1RXRFMkpWWTNiRzRZeUpLSmNzS0hxaEgxdWRXWExzWEw1YWx5dVp5dXAxTm1EN3dtbDYvSzVSb05LWkdTT0prZjRiajJkQnlwUkVZaWtRaHhHV1NmMDM4dm05Z1BGenBsSkNoUlRLUnl6dWxVZXMyQW15cVRqTnZiSko2Yit4YmVWUHFwL2MyZ1BGaE5pU0xtRWtoNFBJWE5ZMERHb0locmlsaEx5UmdHQVJVelkwaUx1Z09EY0VjeHVWVUhoaWRISStSS0U3UTJXNGIxQlowNVQwNllQUnNmVFUvWkY1WVBEdy9UVTNMSG1oT0RGMFhoN0VNRHRNNDR2SGF2dGROVXlOaC9iMlJ5SkJMLy9hYkJqK3FRN1grRTQ4ZS9YSVhUcnJmdTVlK2Noa1FQMTVtUmNWTUxDNXNMbUNxM2tIRDJyTmZzV2xUT0tpazdFVVFRalFXdXdNdDZzRk1wR0VvcmN4MFV4VktoNUJSRVVRQmFnNXdGVWd3eEhDRXVrbmtFNWl5bkU4bkRKS2F5dy9wb2pPWWRPUXZYME0rdS83UzV2cjZWaEhuMVhOQ3NSeHpBTkhHTkJoSUNRZXNuaXhyeURYQ1ZleU1SemZXVE8rdE8vM2RxT3ZEMW56LytwZmRyOG9zSzE2WG56bjJ0cGhxYzA2VjBFY2VOTFl5Umlabk1YY3RyNkExNkJ3YmxJa1pkVkVjTWhSeFJHSHRrV29OQlg4NllMVUNqUlRNaDQwTTJHOE9RbFlIY2pERWdnd3Nkak4vS3NXbWtFNWJaK21HeTdMTTRReDRlUXo1T1pMYm5YcUNBSktiMERoTnRuaVNUaUV3YjEwU0ExaG5CZWcyL2tXS0NXb0xoZjBSNjdud0hjZHIvejc5VDg4Ti8vdmdEYm1HL0Ryck9hN0t2cGRNT09jazVMK2x4TGJhRnZTMHNPa3RlbDFlcGxZNktVRU40WWh3emdMMERIN0hoN2xLeEdDZ1ZBbGpGZkdTRVhuV1EyY3BLMEVCMjZWTnBpTUpncUZva095alFvSTZrN1JhZWQySWlzL29wUnVrMTB1YXBSTm5vK0wrRW5kOXZHMVVXeDkrNzd0aDM3bnBvM0hrWWwxblprYWFUVGh4UGEyOFMvTU9KUklKcVM2VlJWeWJVWmUyQ3F5Mk5LQ1FWZ3F4M0MzUnBjYkVFckZTSkRWUm9wZDE5d2RwVkxZUldTYlZJK3hacC82VDluSmxhdkpCd1ptd2pRSlUvK1o0NTU1NXp6MjNZQzVGOVJDdVhXMWhsbjlHMmJNQ3VYWXQ2UHI4VE5zNU9HS2I1ck9mLzg3K241cXV2dnYzMk8yZCtYbVNyK3NwVUFXd0NKemxPMkRhKzNMNVBMYkRCQTllYXZVUHZvd3ZYc0Z0YW9leGdMeXpvdmZSUDlzb0lJVlRWcU1aS0N4S3BaSXVRblVzdkx1cDhyZW10bnZQYWhjSkRnYnZETE5xUVRaMXVQSDVJeHEvbDJhZ3BkOW9sdXYwV2ZSYkgyZHBhQ215MUZZc0dIZjQ0ZTIwTHlVeGxpa1BpY01mMklaTnl2NFpzZnhJeUg0LzBWZEwwQS9yYnUwMmNjcTFBR3JpN2NYZDcrLzc5dmZ2YnkrMzJaNFVLaThyTmtjeTJ5RzdSak9FRVd5KzkvRDVsYXAxMlFSN05TbUYyc3loVGhZNURmMkVtczdqb0ZtRE83NFlOQ3RFZDJONXVoK1ZCcDFuS0l1NXFrWUFUTnByTnNOeFl6amREMTNWbVNHZEZaczF0WlgvNktYRlJYdGQ0TVdSdkdMQVpjaVRzeHpEeVUydElSSlhKd3M4L2V1L2JKemNGREsvMGRUS3B0TCt3NjJZUnJoNm5PQXcyblBMVmRyN2RwT3AzaWtTR0ltVG9aamhic3kvZjJ5R2pnVVpPb0hlMzZhMWFsRnNHSzNvaHMvUG8rZnBmR2Jxb1gvMmtobkozV2w1WXVWaHlWMmdiZVVXbVNNcWxibk85VW1oTHBWTm1mY0pjcjlNbnIxMjZjQk1rWk9PekY0RXBBNGVFYkpyWGp2NDlOVW11RzYvaGtjL3IrSFNRcmJSS0tWUDN2YjduQ2h2UkJPSFdZTnQ3Y0o5SXlRUG5TVmVaTkMxMUZuQ0dQWHVIY1JHNnF6U3FsZ3RzZVljck9aay9zVEREbkRIbVhrRlJPbG0zQ3JjS1pMUGFjb0g5cXJMcmV1UjZDZlRkOG9EWk5vNDVaTXNWNmppY1FjbXNnSzBYYUlXSVA5SVYrVEFBekZDd21XWWNSbzZLa0QrZVgyTVkvdk92bmp6NXMyM2prWHJlTnZ5cVR2cEtCUjVOZkdFclNLUmNpM1c3ajFNU0taZG9FYzRJRndiY3VhV2RXMWR2WFgvN2g5TlBhVmVlcHZES0IyZlRodTMwTDNxTzQ3anNLOWJyYjlBRHE3OE9INXMxamN0aGxvd1gwQkVNWklwNTBLeUVibU81czVRdHUzT1Z3RFFVUHhKbDJFczNlMkJKSDJ2ZWljQ01sSkZTU29raXlTTlBIVTYzNmFFLzlkMUhUOTc3MEZjRUVkc21kOXNwcFRtdFpqTXo1cFliOVRVeVhGekdiZC9lbzVmM1dmNzM3YkttdGN3WGkrM2NMdXVqK3RQeDVIQi9mSEF3WnNQejNodWR3SExzZjkyK0VCVDdiY0RxaGV1Q2R1dU5uZHJ3ajZ4VXVsNjJHemc1MEFLdmk0S056bVdhSnVVc1k5bVZ2bkZ5SmtHbnpscm85YUlBMlFzMDhtc1VlNlpiTWw3OHhoZy92WWFNVHpub1g3MzI1RytYL0huUTVJVjJHc0l6cW1wN0h0R2tEWnF3aVUvZUJ1N0JScnZUbmd2T2lrK3V4amIzZUdmbjRRL2ozNDRuKytQeDEvZmV2RXJIK0sxT01QdkNDKy8wZ2ptQ3g2MUM0WHJoeFVhdDhGYWh0TTZpQzhVOGo1OEpxK3ZpS090aWdERk1YcWxrKzRNK1hQU0d6WVhlTlhuU2VuMUhXZHBTT2xaTjNxSXdjdVRFdVB6TFdMU1R4cWtQbm56UTEvaWpIUjhRdGF0YVV3OG83YUJiV0c0VlhvM2dNT0JZZHoycWQ5cnQzU2tZVGRpTDc5OHIzRG1ZUEQwOVlVam1jYlNkQ0Z6aFpmNEs3dG1RdXFaZVJ6RDJ3dlAwWlV0ZHVzMGVGYWlWMHp5emxpTnNXWnFzSFNsZEt4VzNOOHFJNFk2OUM0QXRTQTJ1TlhRcURpTGd5ZmRtS1hYa21abzRyNkd0T3YvQmV5LzVUcHkwcXlCS2Z1T1VvY0l4ZzJ4M3ZRa2J5cTJoRzNEQ0ZpMU5tc1MzRll3QndIQm5aK2Y3Q1pKTlJEVElhbTlLbHFzdHYvUHIzekRWWHlQbVk1VVNSeGdHQTFjNnpoSTd6ZWowSG1nakVhNUM0NENKTFFSVUdkWTRWcEdUdElBVk5XUVlid2pHbllJT05JbnRSKzlseTlOMkFsUHpIMzk4U21zaHd4bnhRNHczbjhkVktTZnJydTgyV1ZKQ3R4YXh5WnB5NzFHck1qZTNLWko1d0RVWkpUbVk3RThPeC92anI5ay9xNzFadzRaWHZnbmZmYmZTdkZKcE5HVGtwOVRJdjBLWHpyVmsrOGZTaWNYL1VNOGdXeERBUmxnWmRQSUR5S284eHBidDlXa2RMQVFSV01RV2szRVJJVS9FZHN4ZU51UmlxZWMrL3FXSTVZTkQrS2hXdFlETmExd3lsZEtPdDlRdGg2MTJqQWJjMzZWTnViZmQ1cURHTGhzQ3NweHFGbDUvQ05sNGYzK2Y3VzNXbURYZ1Bsa2Zmck41Y2JZVWxtZzYwdDFxTkVvMEprdVZySWtxSmc2WldBU05PVDd0d0FhY0syZ2pYNHFKSUN0Z3RpTlVUa1FtV1BvWldhUWFTZm00ZVVpR0JqSC9MemZteWRLK3JncVZyekVvUWJTckttV2FPS1c3S3lrT3N1c2JhMS9LeWtSeTNHY2RuTkpiS2NKV2JwVHU0STFNL3h6UTAyTjJTVmJRUSttdjdvWmhsem1aU29NdzBXQ0lNcXlFZlJPaXRDa3BqM0NSVHB2a1A0VHJqOXlCa09HaWtXUkxkc3hrUlM4RlhFd21SdkRIamoyWEhkdU5HNWQ4TGZGZStUQ0phVjJkaDh3WHRwUnBCZGtRdHFiVU9lRGRKUXRzdi8zZys3Mk5mRHZmMmhXWDlGYktUeWZqdzhPREIxK3dLMUNybGE2SWhlc3Jrby9YdTI2cDVJWU1YNVRLdzNMb091bkZkQ0l4a3lSUlVUaGdhVm1zMmQ0SVoreFh6MXFNcWJtOXBVREFudDBpV0hRbERkQVNaa0ppeE0rZnl4YTA1ODRyQlpnaUpzTEZFeWNmSWhyU0NaeWh2ZERkcFl5TDJhSVVoMjU3LzE1dWRkcGxqd2Z1N094NFRGb2IvL2Q5dXNwTWdnamJNSG9VaFk3cEJCQkxjc0JvNkdZVk9obmFaM0o3QnBQWmRKUlRqak1hdVNQSElvVXY5WWdlbGpOMVJVdnh2M1B6RXMzU29NWHp1Y2YvM1Q3eEw5dzQ1YWZFODhnWmtXZ3FvY0JTd3FZaFRLWVNwdVZKRm9CTmJBUEhqTmkrdjgyeXExM1paWDIvTVJsUFFQc2g2cHZnZWNNclpPWGNLZzF1YWdBQ1RiUXQ0cFlxYnRhbWc1WFR0alVEa2JTTndZdnB6S3J0RkwxUmxsUENkazVEeGgwN0kzQmNvQ1dFTEpIT3NPeVgrN2h6MmZGYzlhbnppVVFDblUyVDV3d2U4OFF2YktoUVRKNitrNWtUd0JtQlBEWnpqZGdweWQ2eGJudDNPM1RCbWl1YkR5YUgvenM4bkh6OUZxSmRIU0RaTU14Nk9ka3ZwUmJsa2dJSDZZZnVLRzA0c2p3MFRPR1NMRENseXhoQ3hzSHUyQmQ1RXpZRWd3dFRrTTBJV3lZancyWFlNV3ZJcVVPZVY0bDB4SllrSi9LMDRabU9RTm5jZG9wbi9veEtKcExGYkZTZ3dnWWNlQkpOSkF1MFc2MU9zLzEwSWpaK1RFNjczQUJNMEFEalhzMEpIMVpFZUhlazBoTHVPWlIraHJKTWRwVXRQZ1dQaDh3TFJsbkNJa3hjR0l1clNMQ0l6NVR6Wm1sKzBJdVp4V2RmL09oNXlPbnBqRE1DWmdxYm9jNFk1RGR0RXlNZHZ5clNVY29tU1FrbldSMWt5NlZXNHhrYmFXNTdnL1V5UGRoMkIyQVdrQWNzSUNHamZUQ2dtZFVWTkxsa2d5a1dUK0tFalR4RURlS2dqRytUdXdYUFlzSEZxaVJnNDhhMnBtQVlTTGdoSm1RemFKYUlsbUJvTWowdXhIWDBQQ1JPaTJabURNZHFXOWsrYnEwYzJMZ2x0RWltbzdCTkpaeHNPV3kwOE1rTjJMQ29GcUJQK1EvWWx2ZjJEeVlUY3RxQTBjNGhHekdiM1c0eEFJeXZMY1dCQUJUcFUxbVczNmZsd1NsN3l4SXl1UzMrRTRwaGpvN0ljbHBQQThqVVlySU16Z2paZEw0Z2NmUzViTWpFQ0ZLSnRNQUptZllsZkhGcCtXZjBVenh4Nmt4SzhmaXFoUkEyZEh1SWNCU3A0cFMwaFBZMkxzODE4bzlPVHc3K1VLc1I0dW5iTTNBQldzNVpaWXNNazRBQlhUSG9iMG45TmJ2a25CTkhCVXk0UkM4VXd4TUJFamo1NEgwYUZBMFRJNkNDdFpnNWtaSEZyOWh4ZmNqcGdjcU1zQ1VFejB4R2RVUDhaMnJsV3hBU1dhUTRUYktkbGRGVHR0Z25YNDJxT0pZbWorcXRadlBGTHg2L01peGRyZ3lHQTlpNjNUNWZQUWNhTG9oQlIrbk1LUWIybEo2L0VNVDFrSkE1cUFVYXJpaFFqaFd6UlIreFhPaUZacENCQlJjMkxUU1BpSkRUYlhxdTlBbllJSk1BYk9MZmtFR0hhRHg0R3VYd1J5MHpUZnpKWmhDR0xRSitWQXBNMldSN2VKbnB6TWJsSzB6Z0RibmQ0Y2pOT25GOGlOa0V6b0RzNXRJQ3gySS90QzJ3d0hNRXkvNC9ZV2YzRWxlVzllSHIyS2ZPeDZrdXB4VjdzS3FkTUUyYnF0RTI2b2dGM2RQTkJFeFNGaFBvSVFuSXRMVHZFR09nY3hQb1dGUmRWRVdxWUppSklESDBqSGd4a0JRVmpBZ3BWQ1FYU29hMEljemZOTTl2cno2MEY2KzZ6c2M1TVFicnlXK3R0ZmRlWjUrdHdKUThBTExOa1lsTFpKbU15SVRsT1RDcmZNQjJUaDFTQWNtUFJleE12L0trMUVvSFBseldsaWprSUkzamlXdTg1SkxyOXdiSHg1VW5POFkyWTJ3TXZ1ZStucTErZDVYQk02YTFSd2lyUzViWnpTVkJTNDlRV2h5Z2RNYXFIU1FPY1dYcFBDS1p3Qkkwa0tKZU5uVlcxRUlMTFpPUkwrb3hxQjFPRWl2N25GcUh2Q0E0T2JEdzJHSWZnMGxRMEhFUldCUi8zRGc4YlAxNWRmbGVMcFBPWGlWVHlpbHhTMnZBbVVUejRNRmNlWFpxcWpwT05YeGtwSmVtS3cyV29jbUFpMW5EWXV6eGdMWERtcFVCLzJPTWRreGZvZThocnQ3UVQ4eHhJUmlxYTNhUFVia1QvbWdsMXZQcWtDakdqbGVpdkl0YWxMT1dNaTh3UUQrcmJMOXV0MTZzUG56NDVIdDFsNitPTTB5WitkeUVtMU0yZWZETi84R0dWOUtUcmc1VHBScDBLVkM2R1pwenJJaStqZzhFY2hXejJKMXM5ckdseFJNWk1mNTU3NE1ySXhaTGk5NHZGa295S3lCb08yTStwRktxUWluR2ZOc2lKQVBReU1MRjdlM1h6ZFovV3F0M2VlSC94a2ZxRDFWblovL1FvU0NrZUNQaVlKdjdadTQyYUZORDlJQnhTVDc3R0V1UWpGQ0xKRG5BaWZtRHloZnc2RytMUTFtK2F4VEZBQU5QMFMyaXlMQmlOcGNCK2kwckpvcXh4NTZScGJ4ejM4dWVGcG5IM2ljMmRtSk5pWVNUMUFzM0lLdTAyKzNXNnExckxBVHovVWVSMzN1NU9tNlZQTEZSOHZyN2d3ZmYxQjFiYVFvYjRuTVBUUzFNRlJlcURFK3lkNnBaSnZRSVNBWVNhelZwZjh5b3pkaE1NU3lXb1Jkd0Rvd20yckRVOEJwZEdOdWlhcWVOc2srZ0tmZUlqRGE3VDJ4SnRBSElwZStLeUE0UEQ1dXR4VFYrKzltOVI2TzVuTmMzbUsxK3dmTmh5aVppVStXRUV2cGNwekJiZ0F5MjhXcEpCaDRST0RTMElOamlkMFVPSXdNc08rSmFNckdCWmovVkFnd2o1WXVzeC9LSHBJcERMeFU3TkMrd3RWUkFPT2U5N092OVRqTW5taHdpdHVSb3AwdS82djYzVzZrMEQ5dnI4NXZ0dGFmUDNremt2OHdGWGlaOWgrRXBOWThaaExQeE4wK3M1am9JVjVvVlhLbFVjR3cvQThLU2JNUVk1enNqYVZPTUF5UkhKcDlSKzI1MCtDSFdQdzJYaGlWaENKVlJXcmtLaHp5MURvbW8ydGRTb0huQ1lwZHBxTjRMRnRhWGEyOXZkdy9iaDgxMWlwVnYzengvOVNyMUtoM0VLU2FCanczTmZsM3V6QW1NdmE1bk9uaGxEZUcrQUtmd1JRRXJjVnN3dUFWeEZSMmRPb3NvWnVsZVlHWnlHcE5NcXZWblVFZ2ZuNTZTeUtLUWkwc2lNWnFKN3F4M2F1d1hhKzhGZ0dFUmJNS1NNMkl1Mmo1dThEWURnZFpzYm01WGRwL3ZQMy8rNWcxekFOd00yWGcwTzFYK2JWa09PVU8vcXo1WFY4RFZPMlVoelFvTXZQdmNteTFVZ2ROcG9aZ2RBQ2d0ZzAxTVRqSzF6TEhJNUVTS0VqQVVZSEVxRHNVbXRGeEtYOE1iSVR1ckRwa3NiQ2N5L2VNb2tCUENaV3pBWGFtODdyNnVWTkRzL1hiMzdmNyt3ZGJXMWs4L3ZYbjJxdWZvNkdqYUc4aU9GLzZxYkFJWithUXU2ZW96YzJWNHpEREJUYUljYkM2dmtEK0dwWll5bEVRVFdlS0pXQXlWMGlMWkE3SkliSHkwa0R2UUFrcmlmRFZNbVd6bjFDRXh5UGluMHN2R0VQbGUzV0s5K1hZRnNNcGhwYm5TN2I3YlA5amZPamlBN2VsUFQ5K2twbUhMNUllVktKVXB4WVlSYzJUS0drUi9LZHd2aTh1T0pQSVE3bzQxWkpGS0hqS3hZVWtwUVlyQnhZcE91QjVFcVF4UXFvWkRHVUlaQ3hFMm5rS2RYb2RNVkF2andNank0akhCck85L1JXVHRsc2kySVR2WTNkMDlPTmpiM1dQdHE2Y1hCZGVmSHY3MzcwbVVuYzlGcHdQSGhLMGpJc2hrdW9NT05zaXFkd2JwY2NCMUlzUmNSekdPWFZlVGJDYkZ5QjRLZjVoUUtWS2crV0dnY0JNY0VSZ0Vja2d4blA1T0RaWlNmMThtS2tyaUFoemdIRVVmdGlYWmVxdk5jOU9kZy8yRDNaY3ZkOSsrZmJ1M3QzZmwycE1QUDg3MUhFMzNSenpUaEEzaFpCMjJtVHBXZ3diZDJEQzdrRmdXU1BlZ1FPWmlMRTdJRWs5VTVwZ1dtVU5FSVdCNndpalN6bTNBR2MzQ0RGam1rR3lucnc5SmpqUXVpbHF3amNJbE1qMkkrcXpWUkxQTmRxczEzMzF2WkMvZjdSd2ZIemR1M3IzMjVOT0ZSeE1wcXMvK2NGWk9lVnR3WDNWZ201bXIvK3RtdllOVGlzNWNzc3lsTkZYOEkxcUJoR2FRSlJiTEI5VmhnS2VuL3dneVpaQ1F0c2dIQ1pLMDBDTHpSUzdBNFkraU83VVBtVGlrb1dudFI3eHhOTy95Q0tUNWpWWWJ6ZG90eUNxVjNmMER3SFoyZG81MzJxMC90WDVZZnZqay9yZGpveGN1QkY1OE9UdGVobzJxZnUxMllYS3kwT0gxb3pwc0ZtZG1NQTROL0k3KzR3bFBqS3pEcXNaWjlXVHpSY0J3Um53eGtHUitxRndpVThDRnNaTXQ5cEFzUEQxRGFwZG1RZ3VOVEE1cFpkb3Y2WjkvMkd4THRGWjd2YkdwNU9qSTNyOWNxM1FQVzYwWFB5emZlaks1ZEc4MEYzNFF4SU04emFRVitLcGNMZzU2L1gxakhTWXh5eWtsbkJ3Ukt5Mk1PS1plNkJJeTE1Q1pPMkpxVDQ0QXd4dUZoZ25JNzlGRnVza2xrenlpcDJjWURLZjFJZUZLbVVQS0dTbUo2MURSR0Z0cVFkWnNFMmdySzVVZGVhUFEzcjJ2ZEY4MzI2dXJ5emRaMS9QK1A1anJjUEZpMEpjZVZ1dGRMaGQ4OTk4K1VLdkxma1MzVXVtK2ttTnhCQ2F5aDRDdytKZGhpMUtJcDc0aVlISkc2dzBERUVqU0tNaklpVUFMQTlISitDdUJRU2VNTStaRDRyWlJnR3JnVWFiVEl4cU93UnZMOHlJN2JMWGJLL01WQXMxRTI5bnNxais1L21KNW1VSEFrMCtaRi9Cb2RDS1hpLzBSaGdMbHY1VmlyY0kzZlgyNVUrZDlqL3FQbmRwVWNZakc3TEp6d3BNZEQ5R0pUTjBPTmpvQUFqTXk5WTNVbm9uTjh5d1BpT3BMWFN6V01FNm45eUZ4U0ZNdEgrcmtVM29FTEk4M2pqYWFkRUNrV1hObGJiUDVjbi9mUkhzdnNnb09pVC9ldWlVMnFnRmpFeE01engrOE9qVTdXOVJublo3ZVdLdDFJTHZaZWRpcEZSblhHQkdPZmhJdGFhVmQxZ2ZzU04xZzY2a0RGVGt5UHlEU0VyWWdnczJSNFpDeXM5YUhCRTNCRmdYOGwrVFNWZ3BuR3h4YmJLOFRhU1NROVpXMVZuUDM0QVJaMTZXVzFlVzdvREZ0Q3JTaTJEUVVHSitxK21wM2U1NDltK3pVT2ovV0gzWnVkdTZCRXhzTm9obWJDUWFadFdlU3pQSUg4YWJCZnF4bUxCWmFyUHhvNXAwSU40R1JJYzllMjBjV3FTbDBZV1pzTnhvd01UempzckkydjZuK2xjamU3WFMzbWM1VklkWmFMeG8va1ArTnJlaDBVOEJWcDNyZEVPdmlzN0hhVjdCMWVKK3hkQ251UzlnZ1N6amgwczYzSjJDdVhNVWZsVU5nQThDWFV3TGxpd3l0RWpKTEl4K2NPeCtTOGtpVVZvalMvN0NuaHArQTFDSXhncmEydUxiK2JsK0JKckxtTnNiNHBua29OaFlCZnJLRVIwcTJzZEY4THM3MERsZkg2QUN5Qi9uYTdacXplc21Id1UvUW9oTWxVNkZSYmpLdUhxR3g0NDJZRThnSEpFNXhSRkVnTXFGaHVvUHN2UG1Rb0V1MXZHWlR5Q0ZCRzczU2FzeXJMUlBaM3VMS083WFZRanR1ZG5GR1lxMHBYMzJ4c1h6MzJxZEwzeTZSU0lxc2xVanRQTWo0dzhNUk91Q1Rmc0dobFd1M1M1ZDRmVEd4S0hGSUQ4Rmk4MFV6bC9UWlBKblRTbDRwTDR3RmFxMmNia3cxcy9OL1Q0MXlQMXhSQ05xTnhmbEdDNnBHbzlIYStPZGk0M2hMS1VTaWJYWVpBMkJOZHRDWGliWlA1SkRmM2pQWjBoSHBlbVRFcFhJdkx0d3VBMVlyMU1hb0JGZ1NrZGtsRnBoYzExeFJmV0YyeU1pT2ZLNE1hSEk5bnlNZ0VRQktNKzI4VWh0b2dhMjJmdlo3MllGRHkwT0dhdEhvWncwam16ZXlqZU90TFFKdFZ3MGFrckhUaUxPM1FiKzd6S0k3UzB1YVYvb0lOSzJNZkNId0J3WXlMc0ZOTWFNU3NNTGtaUy9qMEg0aGkwV21CSDhoUlppQkpMVjBVckRCaFdqQVNDVTFaMXhFWmc3cFJPTk8zV08yczllSDFNWUVIMnV6ZjcySVdHQ3R6RGMyVmhaL3M3ZHhmT0RJMUtJWkY5N0lzYjZPYW8zbFJSSUpiS0FaVzI1aTRrSTBtTXRrL0doMFZ0Mys4bVI1c2hmZk95a2JaTVNaOHVnSEgxMi9makVRa1FlYkNjYXQwQUpmc3BIejFheGg4SGltR0JrR3M5ZWNrbVZtLzk4NlpFcmZFd0QyUDhMTzRMVnRLNDdqNXk0emFyb1VpVkxKeGRuem9ScUdoWUFna0VOaGtKTzZnMis3emRCRHRBeDZiOGpKRXRscEZ6TUxoTkROTGd3ZkNoMVc2YlhncFBTUDJ1Zjducngyby9XK1Q1TGRKS1g1NVB2OXZmZjBITDhTeUZGUTFkTWExempxYk1yMHZtNVhiMVp2TmlLN3ZmeExVSmZ6K2ZWbGN6MXZYdkpsOVl1eitJOUQwTVpVbTkzL09UbGFERHhOcEVhblQzOEFEZjFLbjZsT1VVT1RCUU1OdzBpZ04waFNQL1RUNGRjMmh6aW1KTHNsSGhkSTlmaGNJYk9lNldPeWorYm1HbnM3MWlIdDRJQnIrN1FrenVwNk5wWHFzNnl1VERacmwwdVJyU0ZySUpPS2w1ZGNtK3ZtVDloK3lYNVNJc05uWS9ZVGhpMDRDb0pnNEhIajhQRDBoTVVmb1RIU1lacllYQlFGcHVUMXZPRWdDQ0x0MEJ3RlBXdWJ4ZW9DQ1FWOFdnMXhtUVFITXBkRzJQWUFnMjdISEJJdThmT1hSbUdXMVJsa2RWMW5XVllaazdYbGFzbGQ5WHI5bnJIYWNqV1FOWTE5Tm9mc0JkdktnUmIrSE9Za01oZlo4eUJJRW0vLzRmSFYxY25USDNYemVhek9jRXNHRjFta0crUWZIaEpmME1iK3VIL1JEOWh0RnpxaDZZSTMwSWtHRWhWZGg4WnpLL3RLRFlIYitiNXNTNzgvU3FzTU5EU3paTWFZdGxyaDJZcWJhdENLUmtRRWNUNXY1a0pUc1UyelRCdmxpVzJjWTF0d2ZoUWNCMkliN0Q4NmZYWjZJcmlUVTQxZjk3b29xc1R1QThaL2dqTk1rbEdDYlZFT216WnV2c01uN2p2WEJDWUFMbEI2R3FWN3pqdDlYTko0emVrb1ByOE8yZXNKUHVyQU1nNVVsWDdWbXVWU2NWeHpWLzMrVmZQYnZKRUFBKzY2YVVDVHYrempkVUVpZlFLWmcwVWt1VDZYY1UvT3I5aTNHWDJuOFV0WVNQZGxLb0pCQWhpZUljanlQcjZ4MjFMZ1BZQU1RR3dDcmx0MWxHTWlSR0xyNUhXTGRaOTlwZWJUK3pXaWVDdW1GcXdLTWhOWHBTT3puczArVEFvaGlhdlFJM2tzSnFySjdBelh3bEFkQ1VSS0pMWkZsdTNSK1NrN1oxMWRIVFBqRUJ1eW5ZUU1BeXpka2tWalJiS1BjZkhqaEo4MmVKcUhNSlk1TlBIUVQxcXlqMnp5akZNVXUrZVFnTldPcXpxcnlyS3F5aHVSVVdlcjllYjk1TU4wV2hTRkhMTnNDdWFrbUV5bXVGYkZiQVB5dXo4ZVJ6bUdXVElZQ1dVdzRKMVY2TnZ2OGNvNXhyUmVVYlNPQlowaVYyeXdYUmp0QkR6d1ZHbE8vRWhZK3RXVERtMmJVWm9uVDRSbTI0NTFTUG5WQWhiSGxSSFp6YnZsemZMMWlrcHIxNXZiaVZVaHZ3Q2JLSnJGaENlektic0IybjVrSEZvMjRCS01rNkpnQWR2NU9iOW9CWlBRTkEvdWVYZTJTVXhwQ05Qa1dkaVhWSEw5cEtkK1hxYWhEa21qMnhZWDhYR1JJV0hzWG9kc3NTc0RMRFpsYXFyeTNldWx0RnBoMjJhR1BSMmNQT01LR1E4YTFkV1BIQnhxYTJFU0dhbk9SSVp0RWRmaGNQQ0UzN1k2dXVmSTlMWXIyM2tzK053aWlJVG5UUE1oQTgrS0RVWDhSQk0vUy9TZlVrT2lkZU9hMVpmM0dBZmUwa01XRzQ1eVVWYm01clVFR01kbWMvdHFPcHM1T0dIaEhjMmFObFZuU2lDMUV6UnNrYW9OaWEzVEltSFg5Q05xVFVXR1l5b3lKREt3T1BQSXoyRVRWMmdiTW9keG1JenMycFhuMERqc2NLQmpyMk9qMEtEemRyNlczVk9yMnRpWUE4aGttU05iaXV4dHU3a0ZZWUp6U0hDNDFlaktDYkxRM0xkRklHSDdsNkkwWFNTRGg0L1U0OU10N2cwZG1MZ2NHRi9oUjc1c0N5MlUzNlhTeEhJT0RqZHgzUFlpQUcwVHFkVXNtZkxGMTdKcG9IdTB5bG1XbXExbElsdXEwdW9abW9pdGsyemJvaEhJK0lEOWJPV2FEOXNXTG8veWxEOEZuSXZSTi9kY2pTRzRPUDRoODFNZmlVMlp0S2FaQzh0MkVCcy91YnZueUVUMWxldENSTWY0Z0lYZGJPVC8xeUdOTWFYSW5HWHZsbDJwdFpzNmcyd0ttVm9CVGVIRTg1a3o3WkJ2Q3Q5OGZCT01KU05vblh6Z0JnSURTMXBZc0pSRDdQNG5zcDRaMTh3QnFUVDlJQmxZSUdWUURncExYR3JkUmlrNzM1ZHRSZThoTUdjWnZhTWFaR3VLNlJiZmhNRlZpSk1PRFNQcFJWcDJrMVllT1ZVeXpyWThpT1RnMk5lV3NPejVYaEpNRkN4a2xxaklJV0Fma2R4amlQdGd3WWRyaHpJdU5vK0RQV3NjUE1MNlNFWWdhYTdXZHIrV2pXTmxlZE5acGlFTnN2SnRxMW1sYkpOcUFWbzJtMGJSWmhvSUQ0M1lmQkxwdzVQbWJoaFcvVHhXMVZTU0tmMUlQdWtRbHkrdUxWbElnd2RFUWNreW1XYjB5QkVtZCtsSkh2ek4yaFdnTmd6RFFOSTJvMnNpTHY5LzdUTHBpS2JaRjlNU0d5eFpVb3d2T2pTVHdyeHVCTFllME9UL0dLZE4zSnFWbDY5WmVvcXVtdFVwUkpTRmc1OUJHWW1RRnNzWXZlYlJacTZCbzhIN3lSbnlOZDZGREJCN0hnUjhSMVNHV2NDQVN3cmk5SWF3d29BRk1KOHM0R3NaZklmMDlXRnN6SmdFeHJkYUx5cExLVmxBYzV0Yi9OWHBvcDllcHg3ZEpkWk83Nmtwc2NTV0c2Y1VPTXRkdTVUbFNSZnNkV2U1YlBBcmZmNFhDMm4xUElMc2RKd3dISlJjUnQ4aG16dG1lVGxnazVyU3kvN2JGT2twVytVTHdTSFVRTGU1RmJhNXZqc2lGT3N2S0orTEN1bDlxYUNZaHNxZ3NyRzAwS3h6U3lLaEN3bGtIMzl3T2VnQ0Eyc0ZLR0tkS0NYdWRjU3VucDBoWDZPaVFRaVFZUm9jdHo2cVRiWlpOTEl2eTEvV3orQ20wNUVtaHNDQjljNlF0ZXNKaHpmN0J3K1dKNlduNlowelpMdE82aFNmeWpyb3dCS256RlUyYWpsRFRsLy9jT2pGTDVGTlB1cTgrbnBlalpIRm54VnkzcUUxb0RoY2pxMEtPZGU1R21OTGFNeGFZV3YvdlY2TFRjODdQazJwbnR5aFJSbVpuN2RIQzBSei9ucHU2b1FKL0FOc2oraytCeUh2dDJrZFk3dXVvR2lLaTF5OWkrM3hKTFNmN3Nmb0NvQVlCR0ZVNU9yK0V4OCtwN0FoK2grUWtmazlRMmFVNUM0clZSMlRUK3hFa01LOUxTU1dpWGIvRlFsTVdyY1pjbHgrbnJwczB2elFDUHVaaUR0VkF6eTdmKzN3QTM1VmRoTndzZ0lzQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3dyb290L2ltYWdlcy9CYWtpbmdQbGFua3NfY3ViZS5wbmdcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU5vQUFBRGFDQU1BQUFEM3c2enBBQUFDYzFCTVZFVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJNYVhFQUFBQWhGd2NRQndJYUVBZ1pCd0VoRVFrWkRRTWpGeEVJQ0FpRVVpb0FBQUNNV3pKYU9oNDZLaHB6UkNFeEVBRzhtbkprUlNsM1NpZ0dDQUZyU1NsN1NpQmpRaUFQRVFwbk94aDRVaXJPemNRekl4ZzBJQkRGbkdsVE9pRTdLUkU2RVFIRmtWb1JDQWhyUkNIRnhyeFNOQmVFVENON1dqZS9oRTVLTWhlN2syUEdsR1JFTWlFcklRK1dZem9wRHdHeWUwTk1LQkpLT2lFTUFRQjdmSFNVV2pLTlV5dTFpbHFFV2pWMlVqUzlqbHBaUWlMTXpNeGFNaGk4aTFGRE1oaVljMG5HeU1YTW1XWnFUakZuT3lLa2UwNm5pV1JCS2hiWDFzMUNHQVIyUkJpSll6azZIQWUxaEU0aUNnQ2JmVnl2ZFRvNkdRRzRlMHFycktlUmRGVyt2cmFHWWtHdGptbDhZMGV0aEZHR2EwNWJTVE5FSUFtMHRxcVFZekV3R3diRmpGS1paak9mZ21HVGFVTy9sU2V1ZkV5K2pocUlpSDlwVXp2WTJkZFdRaW5RcG5PMmxXNlNiRHNxR2dkU1FqQmpNeGVsYzBYRG4wT2lham0vbERiQ25UZWJlbEdMYkVLK2lRZXBoRjU0VnhDZmEwUEdvVXlNV0NaQklCQ1VsSXE5aXhDbHBwbTFoQTJtY3dhdWMwU2djem0rakNST1RreTl2Syt6aVNPNGwzQVpJQ0p3WEVRb0xTK3RleGw2WWdwaFlWb1BHaDl4Y214ZVF4bXppUm9hS1RoZFJRMXBSeEdyZEFnek16TmNIaDlOSFJZaklSNnpld20zdDdXdmZBbzBPRFdHYVFwSFBEUnNiR095amo5TU9raUpPVEoxRWh1U2N3dUhHaUtaSlM4dktoZ3ZRVVY4ZkcyUGFDS1ptWm5WcTN5Z09DK1llZ2U4bWt0eEtoeUloWE9aWndtZGR4OXdYelpvT2xGd1J6U2lqamRuT3p5bWlBaGtoVVFvUWlKelFFbTFycGlhZGlsMWFFTmNha1Y3aG1KWFZTbC9ja0xUdG9nUlVUamRBQUFBQ1hSU1RsTVJabFV6ZHlLSUFFVHlCa05uQUFCTnlVbEVRVlI0QWR5VlhRN0RNQWlEd3crTVRiMy9lZWRZWGFTcEp3RGpXQkh0eXljL1pMMXVMWGhHSENJR0ZVTUNJaFlPZHhFV1pqTUNnQWNOWEFVcGphTjlBekxDZ1l0a3BTcml3b0ZiajZnVzJZaFdLamxIN3B1TnJZV3BmQzRNUEdORUxSYlJTdk9RalhCcS9kQWt1Um5EbGdLMExRTWFWMlBZZ0dac3pjcjlDWVpwZTA5UnZtMFI1WGs5Zm1JMHZhZXp0YlZieTM4bXVITjVwN1dONXZmbjk1ZlFNc2lSWFFlaDZEaW1jRXMxcmNHYlp3dlovNzRlOTNKVTVPZTM5TUF4T0lsVFBnMm0vWE1jZGRGSzhnajNaYkxINlI1ZnQvMUtNc2UyTHVzSUkzY1o3bWtaa2JIWFd0Zjd1blpvRlAyRUxrTnF3Y1NXN3YzYXkyMjdpV0JEU05RcUllc2ZOc3k5U2dCK3drTmJVYUJwQXA0MVM1Z0xpR21wZDhjeHMzMW1SbEZHWksxeVhWZWhyVjFTM2Z3U1RtUkdibmMxWVdmcFRWNVIxNnBtTkxXT0dnbEpQUE5JTDVNZ3NSWitReTM4Sk10bU5hSWFmazVzRXI1R0hzcHhlSkhJQzYrQUNrNEIyRkV0a3FDUkdvNWt5SnJTY2R6OXJrMHBrRVNvbzBaQ2txUjhVZ0QrRytjQlN0OEREdU0ydklTVGlEU1pmblpZZEEyZTB5SDVxc05sS2dMV2RCcVJqNmxtRW9jdWpTU0IwM3hOUnRSSVNQYmFBWmMweDBVamIxUjRpWFdFU05LZVhIM0ZZaTBtZ3p2YmlKRGhSY2VyUENhemtqUzgyV05USnJ6QjdvbjVPbXV2VlR1SjBLTkNXdmt0Rmdrb2FTR0RpM1VJZ3JyQTAvemlhaVhhUVZ2anV4Qy9aQll4alJLZy9jS3dWd2ZFR3FGOEdBV1orditva05aejdWWFh1Yzh5YTUwYWwxL1hxRU4vVm92Mm84V1R2dUpWRk5pNzZwN2MrbERVakxPdXFJbjZ3QitQK1dCNXk5N3NIYjNtOWZEZFN6cnlxUS9qbE5nM2wvUlpJZFY2a1k2L0d4SVF1TGNQbno3blRUTGdUZVYxMXVCc0xzbmJqQjh0MGwzTi9laFMvNUhWV0tQVzkxSjN2VC9WWkVyL0xiOVhTUE5TN0p5SGlMMU9leDVJTThKQUsyWnZZanNqdWVHeEMrb3UzQjM4V1pCVVI2RndaNW0vbmQrbmx6Z2JMRVRwUDlGMGdoamtVU0Y5ay9Lb3EwMTdDYzFVeVZrYUJqcXFUL0xTbEptaG9iU3plWGwvOEhLVEhjQWFNaUZFQ01TeU9kbHNnS2s5S3FTMG9qYWFHUVNRMVhHZjlVQ1pwVlNOb2RRZ0NUazRUSXdEOFpDQ09ibmdLY1F0QjQ0a0VXQlpEaDNsbUV1bzhkTGdaWWJmejVBdnc4U2NjcjdyYnNwK3dBSWRuRGxiek5STXVYT3c0WFpQOFRENWVQRHZ6eCtGSTRrTzI3cUdsdlNJSnJ5VENFWkI5UjJ6V244OVF5WUFuRDVJb05zcStXY08vSlJ2UEYvMFdKNG1admJ4UGtrTk9FdDVnSllRS0NESTFSeEdSM0tFc0QwcXBKWGw1Snd4a0IrdlRZYUxZeFBXNXF2VEpkd2NTWjJBYytBT2l0TWQxM3pHa3RmRW5ZOXkxY21Tc21NSUc4bjNxSkRXSXprTk54a1FzMlJZcG8xTmV3eVpPUDNkVEVpZHR5UTlDVW1tN096RGxzRkJsSlBxKzgyMDVkOTV0SnJzL3hWU2plcFcwcG4zdzRyVS8rWERpbkVsVjRGZ2pFWWpJaVRudmdJa2N3aFNFcVMySUNPeVZramNBM0dLU2VlQ3Y0dCtpS2ZWL0IxckgyNW9OMXV1cG1oczJ2cDkwUE5lVmp0L2tMc1RsbG1JMEd3dnk2SE9hYjE1Y0tXbllYL0JZekgyZWo3c2pQRTBUV0pwYVFGb1BuM2FONkRKNGhXd3Z3Z1hmZmxlUTRwVUNXR2JFc0dZWTVCZlRObHBmWVZsampaZHpIMUZETjcyRjZYTGk3cy95czRJeVMzd0hDU0dvY0dKUkU5RzNYRE9UNWhvWFpKVzZmZVkwVk15R294TjBoUmFOUTJoRFJpKzFKQkF0OVY5b1ZvSStUTDlxS2RXWjZINDVxNThISVc3TFZFQ1V6WUZuNVZxcGFUM1BuanFGeitrdEV0VUJvY0lSeDlyK2ZGbFN1L0JpR25xY1hqMmFiMitHQW1iMVhKcmV5ZkxEcS9rOCtQcGJ2SzNXanNoUjVEc2hUV3JaUkQwdllhY3JBbGo2cWtYdU1XYjg0ZDNmSk1yRFc1ZTFCTjhydXFiMGliNW1oVzZxMC9taHhSd1NVZVpEV09BTDdYblhvSERNNXhiNGp1K3I5R3lwejk1Y0U2bTFKbW9HRGdrSWlOdjQ5WkxkeVpsa3d1b0Qrd0o3RnNOeWF3QjJOSytyUjl5NjhwUmtFd3ZxamYzV0E5b1N0L1Z2N1M2ZVZCODArSEhWcDdUOThCTzNIakxXQ3E5VmtqbVA5VzcxaVJyMVpWK2RjWjUrdUpnWXJMbk9VSjBVM2dpUjUxclhLOGRGU0lMZlVRMnJ1c2ZOU1Qyc0hXYzJMZ0VtMERqWmxBNTJRUTBia3lrcUpXTHRRc2dsV3VOVHA0QnBuSUV2czNDT0Y2RGlPd2t1Q1JWZXJFd25xNVFTelVhVTRvRHNaak1qRkMwYkxOWHIrSEs5dFRyUE1kL0ZpSTU5VUJJdnRlUTgrSUQ3Ri82dnJDcHlab2ZPWThBZ0JOYXVGdStDZ0NlNGFBMm5ablVvNWhGT1Zncm85MlJldVpnaytIbjJoRXYzNWh6R2p3QWFQNWx5UTlBKzNtUDdTcTFXRm45THZicVEySjBlcFdia3pxME9IaEw0ZksvTmFUSXlOcGUvOXFLWjQ1dzlPREpYNStaa0FmQnJPVjJpc2xacWZabWdxeGEyRDc4VUFtRmtvVTFvYTJnSmpLUmxucjhTRUo2cTVtMjdBdVBZekxpMkVodUJvSnN5cUh6L0NWbDJNakNUZHNxV3g2QzRsc05LZUl2dEQzMmRyMVpxNmZXTGxLNHRRTzB3dVNaUWlscjV6czFjV1BXL0trMmEwZmRLc3ZRM2lKSnlGenZyenV4OTN1U3lORFVxMUtoNHZTRTFpbWJXa01UTlFXVW5IcW5hSVEwV1d2Z1RYRzlOYmUxSmY3ZmFzaDlLbGtWNFM1RUdKb29wQ0VvbVJZWjBSRE01SFE4YUlqblRVZlltK0pabHJ5b2xaRGNudGsrWEtyVmd4aTY1TVdCNjlockx3NGF4dENhMHJsVE1vaGs3U3hkOEgvSSt6eXdhUHM1bWk4Witmb2RVcXRkd2VQbWQ1a2xNaktKOEhiSkNGaENkNnMxR3BobnJMWHR6VkFVRWlZU1lSQlpSQnJ4bzB6eHdQRHEvT0JLU05YcUFXV1VoSVEyeHU0SFlsMlhtVFhNbjBvM3cxcVE5aGRLWUYyRjFyZnZrRnE0QXFwMTB0eW5EMEE3bFZwcTl4TFczRVVISkJMcXpLUG56VmgyRmpPQVk1b0M3dUtFaEUrSVN0OSt6SDR2VzlzNW9hbTRvWldUSjNmVVErWUEwVjl2OTN4b3ZCd29odXpTU3ZBQklFaGI1ZkhYNzVDN0RGYlBkZnprMTRIV0RuLzRxMlZSTzUwVDljSUtPVUt0UnRncTBNOUMwVzBCYWd5OERDTWhHVktsQkkybHpQY1VNaVBpcURYZW1xUHpFRWljbStlY2JGaThPQXgvbm5lbE9ESkxiVzNQaHdEQ1B5WExEckNna2Yrb0lYOTlHRnpWdWNCak81YzZGYkxRZ05vbDM2Rjl3ZFB0SkdOejhTWDQxUGFSQUY3OFVIaExLQnRyNzFRS1ZUS2ZTSjJTMGlaeUN0YmtzcTlzZ3g2d0pwT1ZyTTVZcFVocDFETFBYUzZqMUg5MG1WR1NtekFRUkwrcFllQVFlNmo4K0crdmtLcTloMDhjRDYzWDFVa3B4aXV6TWdZMWtrYk02K3BhNmxvSjM2S3ZUYjYyNVpEd2VSRGd5QUkrTWxERmVGWGpoVThQdysvM2QyUnU3TEZUMmtlNUQ4ei80d013UDZXK0o4SHhxbGI5NkJzMk85cHE3OVNjREVoZnY4QzdnQ25WQzdkWGs2MldtejV6L1BYMW1YNksvWWpTbWJnMXJlcVFFQXRvYnNqaUlMVkdJWVFFOVJCZklPdUdCKzA0Sk5OOUdzSDFnY1NqRVF1anJ1R05UenN6bnQ2djM3OW12djNjYm43VDZuV3dWczVZV0VJY1cyZmFTbjhCTWNCSTZqdXQxUzJjUXI2MjU1QytXUCtkU3hNMnNXUTRHZGw0YWJ1L1B3OG9yNTluWWZLdmN4dzgyNExkYUU4a3BINHRKNXRHU2JxMnVjMzhuaFM3NFNSZXNuY2MwdmR1YWJQUXV4eFd4RGVlSTJwaEp0WjRUUVlKY0VOak9Va0xrTjBETEgyMFBpcGZiUXc0c3VLcCtHakpXK2wxdTlmbXZlT1F6T0tRbUJWWjVTQmF4djdtakcxMkxMbHA5QmpnNmgrUXhiVlFaN2VySFFSaFhLSkJLa1hhdWhwUWRNM0J1d2pKdW1ZQi8xaS9WS0dOdjdicFVxenZJbzJwbnI1TG8yNTFBbHhUa2dId0xlMDZsQWVQZzc2WjRtU1BRdEtsWXNzaFBmc1RabVU0NEczSkZvbDlxeVlkU1RRWm5IUlpHQVRvUlpSK3ZPS0VIelo0WC9qZUgvaC9Yck8zcGhnYnJ1aUdRM0pGUURaMEZYSm5WZW1ObFFNN3RJTHhTQlhoSURCMCtxZ2V1a2ZIS2tHcUFtNWRYRnpXbWw1eWljL3hWUVRKbDdZZGgxUzdJR0NNQ3QzRHpobkhSM1J6b1ZaejVua0R6T09XSWVsb1IvbTJKb2F6elJUMmNUWkV3VDBLei9Gb1J0VG9tdUwvSEpJN2pQZFNuQnMvQ2lYdXY4VElOaXlnTVMwemdJNUZXZllOekpWemVPejZiblRqcUlRdkZhWU5CazBVdTJmSUNOWTU3eFdCQ01iTUY5WmNLMFVzM2VjL3ZvdWkwMEhPQUVVbFZyM3ArTlhGQytkVXhZa1pkYUp0eXlHbDdBK2ZWcXliTnc2RForSUw5VThHdUN1NG9iTzErQVU2Rk9DcVJZQUVhY3NrR0QvYStWNGg4SnZrQlkrVWU4Z2QwTmEyNkpqazkxRU1LUWRRSExOSUpmSGpLQ2J5QVdCSUJGeVZ2d1BzYWhrZ2JrcDArRVBqdVc2MFRQTW0rZll1Y1loczc0dkxwcDdjbXVaQ1A0cVV3OVFQY2trUGw4V1FRd3JkZm54VFgyU0U4QXliTWc2cEthanNoZzRXYjFTRGZmbmZOMDIvMm9mODJVaWwwUGJrcVlSeWJCS3AyRURSQ1pyS3NRNEFwa2JMUU1xeUVmZkdQOHluRGhxU2R0UE1TVWF5MTBlZVJHL1RjTVo2RUZONVMwazNlZzY2bERiWnFYY3YxaTFiTjRpaGRhZVN6Uzhhb0RmNklXbFdZZ0RmTFJxalB4dEc1MDIyUjk1Q25hRU5MOTduV3Z2bFBpUUJ4TW53eEJqcTBsUGpPbWt2TXhNTnRhUWpnYUpFOUlzeFo3OUFyY0VzME1IbUZHVWpvaVM3dDFlWlBuam92WEtOZW5XNkRzTTRpZDlBYkpKNHFVckxwTkduWU9wYmQwcGFjeUgyYUlIYmtITTB2TXFlTnlDM3owK2JmcWJ4dS85bCs3Ulhudzl2bWhVZVpkSTFOa2x3M2VGQlByd3pFeWpIbVVGTlJDTllSZW9PTnpXT0F2Y3JFejRXRjRCZHZKY2J6TE1RakJ1dEFmaVVzYVE2U3p3RWNEL1RMZVJRc0owZWpkR09xV2NMMGFMRmdOY3NNd1M4ZUdwLzJvY2tnUEN4ZnJXckRpczg4Zk44UE5jQ01sM3VQbVZYWDRWMzA1cDNhN0ZPZU5YT21sNGxnZzIzTVlBeTF4Z0tCTUMxMkF5ZzR6UjVWODNuN0JMY3JCU0tVZlhWcWhiTUQrRk9PZ3dOQWVHTzV2Mm4yVk9MdlFRNzR0OWpKZVpWKytNK3BKM2FyZTB3bGFtZisvc0g5NXJHQlZ5RlpxVkREaEQ1V3JzeTJzbVVKL2R1bGtSMTJKSjdmSlhJODdwSjNCTHJhVnhBUHdOSUd4OW1yeE9sc0xkdWIrWmdFaVpieDZaZTFnaHRsa2kwQ2ZjZUF2RE5VdE90L1lXUVorampaWmZtcVJ2UFMwMHZPbDcrL1pQOTIzMUk0blZ1VlVULys0YmNoLzBVUlpwZDFHUXlYRjBQZXlZeitRV1Y2WUJKNWI3dGFpVDg5VzY5eGJVRDJGVHlXelRQYUhUM0c5TGNicm12Y0hQMXFmdmx4TmlkR3J6d1JoenVhQ0cwRmd3ZFZJcjZ5dmlIVDd2SmRodUVvUUE4YjBJR1BjY3JjRVlaMTZNdW9EdnF4ckxCNmdIZnViaDFnd0UvLzd3VExoS3lkTkZBOWpFZlVrRE56MjN4YjVObUZKOW91dWdjWHNkTno5TnFraVdtaTZYeFU3Z2VXSS9zekZmaDl0dlM1ZzZuREhWays2L3pJZjNFK0JXRDdHZjVBdm5vcW9CeXI4QUthS2tGTUl6UUlBaFBlOXJWOE53REZ6RGZnczF0MldjRDF4MjJLeDRTTEw0alIyditZaU5TZUc0QkJtYmRNMnJTNHlZSjZjelltdWIyZDlZRmZxQXFoS1Z6d0oyOWtWTEY2dkpaKzllSHRKMmhTbm93TXZFajRHSkdhanVJQmY0WjVleXY4STNrRlpCbkc0S0N4bDNTdGUwNWdsR0ZheHgxTEZDdmFTQS84SkJWakNkYTVVckhmMDNLVWtJZ2ZiSjRPckpncTFhZE5DQURIMWVFcTNqQm8welJGemJnWnNSV1F2dVVENmtzZVQxTmg3MmpWSlN0NmEyVTZHL0dodCt3Z1hUekg1clhSRkd4SHVibExMU2xsTWg2VFBQSmg3eUxvSHByckFWR1VCZTVOc0Rid2d2ME5xUTFLdXVXQld3eEJSZ1ZGV0RYVXp3Y1dMV2daZzYxT3NYVlViM3laYnZrSVcxa3JlWkNLb3cvb1FrL01JZVZtQkd5d1dsVU8yTnI1eFczYnJrVG1iVU5hUXdITWpWR0gzY2dQL2VhaDJTclNHdjlkcTJRRTlYRlZtYnFRNlg1cUUzN0xlaXlpdHZrN0JGdy9UQWJUWENHSWE0SzN1Z1ovc2VMMkM1M2F1eXZMYmxrQ0orRWh3UmxnVGt2UnRYY04rdXg3aGdGczQzNlJacDBKSEtZeHQ5Z3NUR1B6SThTQ3dJY2JOYzg1SWtRMEhxbmppZFFXbXlMeVFqSjVucHlOTEpYNmFXNWF1UE5ha0gyd0RsS2V6MTdJV1pLTHVTckttRC80eUd6K1FRVmhDcGZaSGtQUVBOdWJLUlVoN1hXTzZ3Y0k0dEhIcEpzSUlhakMva0lWSWRUZHVXK1VBZlFmZHpMWmt5YUsrZlZpM1FIaWRHVmorR1dtVDgwYXNWV2xRNnpKcU52Qk5yUEVUa0ZqWmNGSG94M0lDZUs2M3pJOGVVNW5zZnhlMzhlZFZRNW5uc2R6NzFLM2R1UDQvSHorL0ZqMjk3NzluNi90eXI3ZGh6UDdWYzkzNzdLc2YvaDJ3NVdITWZ4T0k2ZnQ2WjN1OU5yQit4MWVXTXNKQ2pqRFFLRnhlcExnZ2s2bE9FUFU4VWU5N0lOdWVjUThnS1RsOGhqOUJ2c2s4MzNINmY2MUZXUzVVaEtLUFRwbjlWVGNZOWRtNXU4ZFNZWWs5UGpFNGJtTnFmVEp1WENEenkwbjMxMjdiTzMwZytabG4yZjdmZThGdlZ0c3FmcExHMHNxSFdSalZTS3ZtbTFXcHZaUHZPYUdLNjUvdm8rNUJ3VW10T3BQZHhRODhtcFRnZVV6LytaYVMwNlBkSDdJZmtwejEzck9IRVl6cEJhRitqQ1RPcmpUWFA2YXg1OWJpaWJ6eTdUOVYvZkZyclA2Z21FTXFhc21HWm9qYlRXcVRvcmlxSXV4bkVhN3pUN0JyZlU5RlAxM2pNMUQvYzlvQWdORFJJbkI0d0preXVRTnphbkoyZ3NGOW85SmtmTDBRYlNnY0ZRSU1tUDFCcjFZbk8zdXZtVTI4Z0g5SWRjV08rVk9xY3k3R3ZHUDJsRnhoQ3R0a3hweFZ6RytxaGo1ZldRNWdMdC9nREdCL2NoNzd0ZVlhMnE1c0MwM3Y3MFZhem1iMTgvaHhCdXBrQWFzRkp1ZEJ3MmJTSXBsVW1RbENlVXM2clZKcWUvU2ZRQm1zdGJYN1A2OFRxdlBPdjNkVDBSMjFWbGs5SmdjZEtoV3UrMm1qb3ErNjRDcWNXL0pmYlJmY2hiYW5jQ3hVRXk4L3B1aFdubWxaWUNISjF5VFA1dzlNWHBRT05NampOSmhRQUpwN3BvNGs1L0NkSHpha3d5Zm1LRlZ4WS9RZE1MYjZxbk4xbFZURWl6ckt1WnpuZ0RVVlV4ZmNQVlNNYzNHdFhxWGxNQjlmMzdrTHJUbERZWGNhclM4S1NWRzY5dE9RN3NOV2hCYVk2cXlaSlBRQ01odFM0RmcwdVNjeWsvdU1CSENDeW50TzZVUWdyaU5yblpETmV1bmd2R3FUOXJhcXRNanc1R2hpMWIxUVhUR21EQmxCYlZNWnhwWTAwYkZlZWZWUFIyUWY3eVB1VDlTeVM3UlJPN3lPWFZpR254c0RaOWRhYlZmZmZ3ZFJPRlNIS0s0cGhQTGIyUTV1QUNIaWNCclp4aWNFbUN3T2FIYnY2ZDJ3Qk5yM0xwT2pLcnE1bTNuK3F1bUZiVENtQ0hZY0s5eXFyNnVpcFdSRmd4OTh4UktBNG9ZTVNxbzJhajEyRHVzSGQraDN4NDB1TkpYUzYvcE10RnZndURPUnhXbDZzc1B6eDhiV01JQkpSMDBtM0lOamxDeWhGSVFnWXkwSE5ST0hMNnZIMlRJU1ZZb3p2WmQ2aTZxaXM2Wlp5empyN0tsUGIvcW1PK1hsWGRxdXY0MElUcWVVZFRYMEdxYWtORkt6UTNmMy8yNUoyL0liWHluVXovTFYwekU1SGg0Z2NaaHNFNGNLS1ZnUEliTGJjcDZpcERqZ05aU0FCeWtaaExEQkVUcHhRTlVZa29rN2QwaXgxTWRCSkZqQmpUZDZYS0toUXMvendwalpPK2xydVNBYWF5V3FtTFViVnJucHNkdW1vdTJFanZpcXdnT3Y4MDArNk1YOTJIblAvM2o0MEJreTdEWmREU0Q4UHJoZVJjRGlGM2tyUFh2dWwxRlVNQ3BEVGRZaHd1QlNXaWtoZ1RKK1BsRUtPUDVFZTRoSFhhZUFrV0doSDNKU3R1cXFhc2xrMjF2SGJMcWl5bmJ0bDF5N0xjN1pZTUo5N295aVhBcW9HMWU0WUc4Q2VOeWxsdC9yZjVDWWNQbnN0R3BtWGVhRXJ6UTk5ajYvMnJZMkhJMnRDNnc4TS9OQllja3BTR0pnUUhMaUlTeE5Sb0hWWnIzREY2eTRTSW5rNG5hNnoxenBsZ2hySzVGKzEwazNhV2xCTFpkbDFXWmJQc21GODJuTXNkdEhXejVxVjhyaHJOcm5pallhczlmMGVjK05YOWcvdVFtaG1Ib3d5M2dtemZELzErR0M2WEF6dkVpT1RtOFBBdElac0pHZ2NEVDRRRVJCZmRNWW8vRWxud3hzVW9DblArNkdNNkdldU8xbDZjaTIrMGUxSEdvaW5uc3YzdnR0UzVSeHBDYU1xaXJwdmRNN0FTV2dXcVE2YTIydC91NlVENzRMbHNVZ09INE9LL2YxZFluNUhhdnM4eWhFSkFFaVFjUG4ySmlYQzA2WVVueDJDRDZDajRJeWtGYjExQ3B4ZWkyS1Aza0NYYTFMdDBjRElldmZNU1QxbTV1T01Ra001TWUwUzIyTDZzeTBXeldENHUxcitqZzdZbHlQVjZpNUI5eUZXTXJhNktTbFBUMkxnZ0ZmZmIrLytXL2FBeXFuRWl3QWEveitvOXNuM1cxZGw1di9ja2wrZm05ZUZMak1xeVl3SWl3ZHFqVFRZZW96MGVqeFpGZE5aN3o1ekkvd3B2KzZTOHdOVEJQUmVGcFp0TTlzZTJhZFpOczMxVTFITFpMQllMWkVvanRabTJiWDVuY3JGdXR1c3RaYjF0eUszaHdOYnBqc09ueGV2WGRkb0h6MldyQzUyN0pHQ2Exam5yei8zVVo5MHFPNis2ODM1NDFkOGxINzdZUGhMYzBiS1JRc0pFV0RPTnhoaVc5ZU1vWXgvSG9tY1FyZWNEWHVSeWhHYkZTenY5L1k5bTI3dzBXMGdhellKTytTL3FZdmZ5c3AxSDJ3VzZ4eTBmMjFMWEw5dG14bUVEcHYvbHVOUHV6eFo5OUZ6Mi9FWGFpVWZHTnR0Zjkzb3hucnN1MjYreTFmTE01Q1YvL2ZaUDFwd3NxWkVYT2lWeDRTRkVtL293RWxMQnRUbFllcysyUDQ2Q3pKT2svTW5IR2F5NGpZTngvQUY2OGtyalJjWTJNbHRjV09NcGh0YVFnSTJER0NiZ0RJRTQ1NFhTUlVXRXVRUUVOb2FkZzNGTzlSUDAybWZZY3g5dC81K1M0ODVJc3F5Nk9lVEgvNjlQOGhkN3ZzV3RVbER4YmgrekpvRVNuZWN3ZksrWkNUSks3aFBXblRxUEFjdlRYc1M4QkVPQWRYU1FiaHNIUjJ4WFZ6clZVQkFqMzh4RFVtN2tIWmEwdjhGRnUrNCtmK2o3T0lqN0I0a0Z0SmNTck1mZmZuN05uVWhpbmFLdXlZWnArcWdRNS9PMEFDYzZCYUtMVWxBTXFxa0wrQXVNaXVOWktKN1MzQXRyalcrc3djWVlTNklhdlhjdDdPVFFacUExUVBNNmRrVURNVXlKdWlFamh3R3gzZENJQzdJQjRiWDNzbTk1amFKWWdZeTJkYjFUaTFZYktmMUF5ampyc3o3L2RrZHFBUWNOU0hTQ2FLNnQwUW1WcDBvQmJnOVA1aW1QVllySlJ0aFFqYmVLazRqcmpPbW0wWjF1L2lXOUlxWVptNzNhb2RsVDJiRE9pK1p1QnJlbldVTmNGcTBCSEFJS3VUSkROTG5DaVhDTmUzRzB0NTZIdk9YYktDaHlxQlpMQ2g1OTVzc3N5TElFb21VU3JaZTdWYm9HRHVSQ1Y1eFZTbXppckZCcHhGTUJ2alRmcTNSMXB1V0hQckVuUXg3Zml6WlduS2FpS0tFYTBIUTNheFo1Um10V3o0VEdTcnN0V2RuTjk1NWw5eHBvdXJITTJwT0ZtbTdTSlEzZ3Jzc2JEaUhhNHBieGYrTzM3RnRhaDFZeWxBdzI3T0hFSkpPK0w0UGtRRHM2d08xOHVCTVN3SW5vVXFDUi8wQW1LUHFCVHltQnNUbyt0anovR3FvWU5DblJBTzZJRFZPY2szNWhhUnF0dFFVY3U2RlZNMk4xemNyVFpGbXBnYVUxSkp2QmY5SW5JdHQyRmdMK0JVK1NJMmxuUW5pa0doUWpodGZmeTc0bHJ6alFjRytZWlE5ZzZJT0V5UHdvUW84QzZmd1kycTErRkxUN29OV1pwbGw2empHTlZLRUVKT01ZaXZTSUl4ZWtHcEJSZ0YyOHh4Wlg1U0M5aENNRTA5WmFvNnM1cUUySkV5cXJkVGx0alM1TE1CazlteHFBSmJnbWU5cHVOWFRyeUpSWTRJZ3RjR2h0L283eTR5aFhqRmVmaHlUVm5CdGoyVDlrQU9ubFFZS081aHFOTXFjZXhxc2NxL0w2OHBpQ2p0d21vR0FPajZxVS8xSmNLR0lVWjVKU0NPRHdkSlZmOWtKY016WkZNQzVNV3dNMFF3S1praEJOeFZnNTJhRXNiUW5GUmpZYkJrQmNtdXpXRGx0NzBpL0UxbUcrb1pBcHlaVnJlczRPenpTOXZvZDBxZ0dQWmxxOFE4am9wWjk1dmp5QXl3c09QclR5QXdnb1hkZjdXQXl3alN6MmNObzZGNENETXR5QmJKUkFVWnhqSWlpZW93TWdRdVVsRFdOOGtDT21iRVo4WldNWHUyaFRlOXFNcGFtcVNsZFZPUTNETkU2Mm12V2k1NUVaVzVhRDNRN1RzZ1dhUFhVdnpLMENDYndOTktxRjh5T2h2ZjVlTnNoUVZ6OGVFQXREMlVNaWJBb09tWDhJUEdoR0YzWXlDdndBdEgwUXlVT2ZyWTRmQ0luY1dCQ2ZjanJSUFdNaWNpY1lJbVJJKzNNb2x4OVZFb3BWcmhBd20zRXBJZG15V0ZQTm5xRlNVYTBNb1UyVE5iVlpOQzZVQzlDZzJIQWEvckZUWjFGSk4wSURXOXNDTGIzOXNaRTNuNGQwUHpjaDd2L1laYjZiVmswVVFTKy92dmQzUkVaS1pyZ1FrWlQ0TDF4WlBYNmllSW12cTl5TllZdVRRTnUwZVN0QUZZdXJnbTNHaXlQZmZOemxzZUQ3UjI5WkRNQVdPdFh6YUVaQ3c2SEhhWGllbG1IRVBGdk1QTTdqWWdodDJDN2JKMHU2WGFjYmtXMEN0NTBNVTBxeUloZjV4bnZadHg5UitBTVV5blpTUWg4UEJMQWpJOUZvY1VQRk9Zb2lqS0lnQWw0dmN4aVNWdWx6THRCYUJScmVoa0RiaUxhTkJWUUxGUTliSHNhLzgyWURsNGJ4dm1pZUIyQU4yK2RsS2F0cUFRemd4aEYrL1A3MFpYajZQaGcyRHJpaXh3R3cwOVB6MDlQekZ3Qk9pSlRsUzNkeW0rVms4d3YzY2IvU1A2K3FVWDM3dld3S0lWbEdib1FQZmZyK2pJRnNCeVBTN0NNeHZYdUVsQ3ViRDNQeXRjdms1a280TkN4ZW0vQmpyTm9ZTTBHSmpRRHNKb3dUZFZGTlNEbTQ4RVBScEpSdndPSHlRWFRHY2JtN28rRW5ISlRQcEhzTitqZVZSK3pENlh3cmYxekxaMm8vUDVOazRQci9DSGt6cEN0Y3hqNVdNTGNiRDZMN1RGWno0b010d0NVZnpObC9mSnpSYStQWUZjYWZiU1hSbGFWMXNLUXJ4Y1JZUWVaZVk2ZzlxdzBXTm9QWEQzWUpvL1V1bXo3MHBXYk1zblFwKytDbXpKc0dtN0x0Tml4RE1qUDFJTzB3Z2NuTWxqQ3dFR2daa3BLbjByK3EzNUdkcG9WSnpwVnMyUU5MZnZ2ZDg1MmpLOGs5R0NiTU1pSXlHWkhCUUxrR1Vnam1tSjNSZDB1b09NNWdzRUFxR0tXdWc0bEp2Zm9pNk5WTnJHL2I5eXQyZDUweGkxa1dkZ3dFM25hWmhhRGZUbUVGR25SSWdiZTdZMlA1aXorMzlaRDRkbVVqQnJpQVlacGxIWDByMzlKYVdyRldKSnhsdTBVbWNoQlJxU3RIVVRHQ2JzRHNpY1o5Z1dhRWJCODJZZ0N1WGhZNDZVZkpOakF0d2RaMTVrNjNYc09ocUhiUG5qRDMvOEpudnN2Y2JNY0xZejcyMWZzeXJHeWNuSnlvVDlUbitTZktFOTlWM2VmS2M2dkFzbWJFditPM2ZiTDJHRkU3Y0ZDVm9WbFpNelVwaTE5eEF1Tm1wbHdSZ1F6a1VJNXJHdW9jajJoRXNnZzRORmtBZzNka2VEVWhuRzdYSUEzdkQ3b2wwKzdOSGJ0amQwczFJRitwRERnWTJKYURYYjh5OXdZcXY5eXQ2K0Vmdm4zMjl2VHRTL2Z3N2VuTEV4ZUhSMWJCQlJmb3JtM2t3K3VReEtZNklJTndaWWdXYVJvQVNEREt1U3hBS0xtbVJ3Y0hYRE1oRjdBNGo2VGtVWTJLOFc4RWJBUmdVR3BoTzBhOTdDRHZ5RlpLZGszMHVrNjlqQVZpWjFBUENZM0N2M2xaZ2hLWG15ZXlGWlNMRndxTGprOVBEazlQVDQ5Y2tQMThwSjZlUERuQzEyaEdFUG03bnFrQkdIYXNMaUhUY0FLc21WTG4wVU5KUkJ4OFZOM29rQU5aMStBcCtBUXViRnhxMkNOenEyb0lHRDFFRXJiallCNldxUkdDaFVCREV4NWpPNTJhWWROMy82cVFha1NUQlZzcWhvMHArQUE4Mm9IakU5T05iQ3p2RnVqL0FRNHpZdXlZa01zcmI3ZmQ3Yk5DSXppU0ROTVJJOUxDWXZnUUJKQU5va0VtRTRBU1V1cW9CL3dBVlk0RERhUmNRamNlb3RJMU1CbHRxTFlvbGNvT1ZWUWJxbUY2NHI4YU9LWGFyMHQyM1J4VVMyY25Ma043UmhTMC8rd3lCQUZpclZQQlFVT3hsck1SdzhWdXVWYm1PaWVIVU92a1ZEMVNYcDY4L0JtWjk2UmdXUVFHc2p1ZXkxN2RSRUVtV0NNeURvYm9zYVJxSnN2SU5RNHVUcTZKYW9CejM5Q01lcWdBRVNTVFN6UWQvM3F3UUhtK1g0ZDZOcmtqbWFVb0lleWFFVlFiM2M3QTZOaTF4cmRuMjR5SnhhS1BGVnFzUENPdy9ObmYrNGp0SmZuczJxV0RpNVNlU3FJUitrb3pLSFQwKzlObmI1Ky9CZHpwMGVITGx5ZW5McWxHYkNENHNFUFN0cndsWDZIZWx4WXJ5ckxESTEwbnkrZTAyTVRwUUc5eGxIRWQwRVd6clJlakxWNlR4WkJMakVocUVWNW5OWlN1RXZXUEtNOWRhczJIQXpFYzJFNXRQakxxOVpKelpmZjJobWVxeTVLRmtncTdZUytjUmJwWUxKeDA0Zmo5bExrTDlEWkdBOThvbEhJV1hxRGFjbGpLaWV0Q0s1aWtxcm93UzVjUkdtTEZkc2N6TlZETndlbzBOT3VZdXM1bEt4cWFwb1IzY0ZPRGhTREhKSEt1bzNOb0pORi9TU3JkWWNRek5FNWtJWWR2Vm9GbWw0M1NvRjZ5b1ozNEhWS3ZOUGFNZWhla1EvdGJjZFprYnNPelJLNDYra1EwaE9pTGhNN0YzUTBCRmZjcTlJWHdLS0VRbHI5NlgxWENncFdOWlZqTENYbm5Nelhra05raTY1WkRaTElzY2RiYjFyWWdqRlpHZmFZazYyQWxodVprcUVtTmxqUHdCanZKbklSOFJPSkZKOGFIUmRHRGFyMHFuVlhEUThUQXp0WXlSYjE3WmRqRDdpOWVkZFpkQkVUeGtVa3VCWE1WUlhHVjdNaDNyYnhydVhueVNoK3laT0VUMlEwZmxDU3N3a28xME4zZVExNC9kZGhEaTlYQnROUGtqT1lkbVlnc2FwUnFacXNsVGJKK1lCRmJXNDgwMllaSWxISkZxUkhWalBhWmpJcEQyNGJiRDV6cXdLNzJCb1loa0d2RE9ncmRWVzg0NloycFBoaWFpMFdTTG5KWmljc3AvZk8rOFE0NUFWb2dnWXlSV2VhM1A4R3E3THFicGl1b2JQTWJEVEFSR2VJRzdaWm5hckp1QkR0NmUrb2U0UlV5U3krcWFwcW0wVi9mMWpSNFk3dWxad0dScEs2MWRGa0VITW9ieUlCS1pOcE1odHJRQ05Ca0NZUHl6aEVvZWxqUE1pR2Y0d1NON3BrS25PVGZRbFczenhOR1pEOGtreGZqL3V0cGZLNndwVjZaVkJhYlhzeVV4YnRKK25SM0pSa0JGa1FLckpWcUNnTExQbmYxa0VxbTI5QW1jMFJhemRBcERwRlpnSk5BaTB6b2dtVVpQUVRnTlZyR3l1VkIxbElpWmdEVWdCYk5aTkJyT0E0YUw1Und3QVVOTWFtaVR4OGF0akQrYVpLTmVEOGtCVWkzdlpkVmFkR2NIbnZlc1ZvUkVBMElpSHlCOHN4L0U3UDhSWnJHK0phVVdyYVhRYkpid0VHR3QveVJIK1dXcyt4VlhhT29sYnNjb21FRmhsTko0MkREamorOEZYSmkwMXRhS0RFbk5ZM21wc1NiL3BoT0RhQVpwVndFeVFENFZlL0JmRnpGN1JCWE1INWpVQW9tOSs1VnI3cGR4M0FDWjVBNVpQd05UVVVFTGpNSXI2bE92Z1BhTkZkUjFVcGxNV0tLMSs5WFZBdG92S0JjTElEbU4vdFQ1aytWaXVjRExaOXI1aG1rS0RDWUg0MDduc3NtMVlBR1MwVDNTQW1WOVZVSVNHTmk3clhhUzhGYUxRMkpCaW91MnhucG96OUFRRXhLRGp5NENTSUsrWVA5blpIWE13eTdCSnJ1L2NyYTJod1R0RFFzZ1hOUVJGMXpMMS9uWFBJTlh4eWZYNVl2RTZnMlBxN0U1ODN6ZDN2eHNSdkg2cnZ6SnFGZGVJNldTMk0vRnNFYnBmOW16M3NhRklJMHYrZFpJMitqbWJkV3o2VGZzUTVKVitDdzA4VXRJdU1tblhTV0pXYWlya01QQWlPMjhMTzIzaWFMQk8zWGJmcjZseTNJaDdZeXl6akVESEM5bmYzTjBmNDhFSFNQd2RXaXVybTdXK21oTXhtaXNEa2xURWptbnYrUnVpM3hKdmFPRTZYeUk2RjVMM0xwajVpQnUvUFhsVC9GaGZpQ0VkcHMyc3dYMG5oZDVDWVh6Y25GT2tzVG9BVmVvZEJJMXZNV1d6MHRmWHNQaVFHbjhmTm1EU1VzaEw5VHNjNHVMR2dJQ1J5U1RPTVFqV1pqYUVMSHg1SkR1RWU2YnRJL1phYzZFY2syaXg3c2pEWkhvLzFSRUZRZFk5Q3JUcFRDdG5HRlhDdEJ4V3FSSnVUaUc5Um5xL2tpVm80YnpEMU9jcGlRMytXU0N3VkUzdXVtdU9qSGdrenlJaWI3VCtQOEJLcE5wMCtuQmFDTjB5VGRLR3cwMHJGbEFhMnBUdFdOMjUvTHBxY1RGV1dEbW53eURCTUh5TEdNb3lYYldDa0VIcFp6SDJzbXpjc09iN2RROXpKT0hXcGlSUENkOTBDRGRMM04vZEZ5ekFNRGs3RDYwYjIxajlDY0dBN09Va1ZsK1BjVDMxMy94MS82akRWZnBNb0x3WlRqWlBMRE9IaXhubDZ1bmNkcy90MTBlcDVzTUFRK3JxRUlwRS9YTDhYMGZEeGRxaWFTUEY3WGQvZVR2QVV3Yk0zODdmZEQ3aGJvNFZtbHlHc1JHUjlkZk1WYUhSeUQvdjVIN1JCTG9GQ01uRkVXTzZFSk1uTEtzSlY1Q3o1SlUrY1FUbklZeXM2OW5jbituR1FiTndJeE5xcGlYcG1YVUxDUmJuWmorcDV5alUzankvZ1QrK2wyL3pKeHZjdFl2RnNrbHlJKzc3K0pwOFpsMEhoOThTNmVNdWE5bVRXWmo5U3J4R2tqOXJ6WVU5SkVFWWt5U1NiZXRJbHN6RUV5c0swVSt0QTZaQUZQbFdKT1FqU3RFM1pxVVpFS2RaR2FEUHo5V0hmQ1Fwb09CVTFzRXI2QzZqWURadXRoaUZlTmFrSXhldHplT2tDK1JhODJ2eGp0N0k4eXRHQWM5TERVanBRTDZuWnRhQnYydlBLZTZocnFWMjYrM1hSOW1JQ3JLbE4xWFZXdmZ5TkQzV2llOTZiQmEyRXgraFVIbEFCRjhYMFZ0YzVWZkhmRHg4NnNOZC9DdnhUWTZ2N05wVUlmN0NHekh6UmRVNHBscWxia2pnanFuNG95L095ck5sVDc5TTh6czZNaHFMOEt2OVpoK2hLQUxmQ1NvV3BvbmtNSm9hT0RCNXYzTmtlYisvdUVOaDdUOVJFczJ3WkJGMlExcDdzNWVVODlKQVhEV0FhanpjSm4ydWdnWHF4NzVhbkYvaHZXelNoY0Q0UkZhTFRkY3BaTmd5WWtacVJaTHBvZ004dFlBNGVmbUFUYURySEkrNnZQdi95dFJwTVVZd2dtWEFvRFZodFU1Q0hVZVQwaStWclJWbkJ2YzNNSFlJRGJ6NjZLUXpWak9EK29aN2RLVkRlOTkyMlZRUWtLdkszT1JHbkx4akkyUEsraTNIQlpXYTMrWUt4dVM3Mzl0MzNJUmdpTnJHT0lGVGt6R2lMZnRBak4xS01XVnEwLy92ejd2MzM1K2NQSU5NSEdXeDJKck5NSk1KdXhKR1ViY3hOdU1ndGZmYkc1czNTUkhhZ0dNZ0hSZWlPN1BqVHRZbmM4YVp5ZHplSTRmcm9hSDQ3MGYwY1dTWnI4OU5lZnNuaEdjZmpzTUF2cUlCRmd1T1daR2dyeS83SzJYT0hoTlRJUm5MS2dWaFBacHg4alB2MzRlN1NVZ0FNU2VtVzRDQ28zb0VnMitnRElVSWJ0Zy84UWRyNnZiYXpaSGY4RDlrVVJEbFlqa3VKQXRkVmc3RTRzVUVkZ3lZbUs1c1dneTBWWnF6dVpRSXNYeHgwMTQzR3B1V0JMbzR0citZY2l5MFBWRjVMeEhSekRSZGVZSys1NkEzRWNPNGxEUWw0azI3RDlrL281SXhFV1dydm5tWGtrNTkySGM1N3ZPYzk1TkpNRXlvK01GTVZwdUkzc2xwL2ZlbitIZUx5ZmoyNzkvZXRYZnNOeDF4cXUwMWdiakRYK1dNUENDV3MwMTVyTjNscVBxZGM3d2c2eG5jdi8vdWsvSGo5KzlIUjdlK25ObXpkTFM5dHZscVpmVEVQMi83eGpISzlCOXFzN01kQ2tENG43S0I5Ui9Eb0tVdFZ6cFpLbUw1cjY3bTI0UjRoU2JtREFnbk56NUhhcWpzY2srOUVDenNUU0QvLzU0WHh4dGdnWFpISVdtWjY0SDJPdkZrdHMvZm9HYUU3RjhkeWFnOVY4eC9HY3dOM3dmTi96L0hiZ3QvM0E4OXB0djkzeE8wenRUcWR6MmVsOGJyOTkrMG00dm56L3A4K25wNmZ2L3ZUSG42Y2gyNmMwRnJ0Q0lVTTZ3S2kxMkVXdmhOM1V5RDAwSVlMMGN6cFUxUlFGTXIyRjcwcVRLMUprUnFER0tFUUdVWWxHb3Bub2lCUW9DeU1yODlIWmVkQzJ4R2Q1YXBKOCtuN3MvWTFZakhwcmdGYmJjR3BPWldOam95TERjNzFLclZLNXFOUnEza1VOdE1xRjV3bmdoZGYzT3UxK3Y5MDMzNTU4ZXJUOTJ3K1g1K2NuSjhkWWQvMlBQNytZZmlGZTQ3cXVEMG5UbjRvbFFqZW5RTXlGVFFPU2NsYk9HOHhjVHRkMEF6aXU2aWFGdmh3SGhHajNzcjhCN29Hc01qNlpCYkU4V2YzSCtkblo0aXhlSTJlbmIwQUgycTEwNGY1c09oWUdwTnZ3RzB6aDVUWmNmNjNaYURhYmpTTW1yTmRwZHBwSFJ4MFpuY1BEVG1mbmN1ZGs1L0kvdHo5Y2Zqd0g3UmkyN25HM2UrZS84TnJnelNQWDlDR0hiL2FLY1RRUEczRGtOeGFSbktGVUxiMlVVNDJTbXROS3RsbFZkOWtUd0M1VjlMMVVCRm04UFZKbFA1QmF6VXlTNGtrSlZhRWNUU0NRV3lSdEtwSjBJWjJPamVPNVFqUi81K2JyVndMa2VBQTVqdXM2VHRPdE5ScE5OMmdFYmhBMG0yMHY4SU5lc3hQNDBIVTZSenRIZldIYk9mM3RoNDlDTm5SYkYzdTM5Mkx3OHBqcmFraHlPbkIvTVlyVE9MYkFhUkhLa01oQ0NqSk5tVk4wUmRmaWlsWlNxeHBYZGtXNmQ1aTBnTGl6bkdOR1Z1c2pEN0tzdlZROU1yS1F6V1FqNmNSc2dzUzJOWkVYdEZ1RjlQamZiaFg1RWQwdnIxeS9JckZZYzVqRWlNeWFYNnRjYkZRSVNxL05GNzk5VWV0N3hDTVIyWmFJSkNDL2d3dzdBUXl1WndjSEV3ZmRkM2hOeUpDUnEvdVFPQTI4bGI4UzZSOFA2MGdzeFVMVFM0cWk2NGFwTCt1YVl1SkIwelkzcGFNY1ljQWx5azl5SzYrRzZ5MzczV3I0RWNuVVdYRlNJT2ZUNmJIODFrU3NrTDkxYXl2QlR3RkJjeDBmQlhGRlJEQWlVbTdYOTEzZjlid0FDUW1hN2FDTi85cWRnSkFVSlRrODdlT3prNVB1T2gyd2lZUGpneDhPRHA1MTcreUpQSEpmODF6MjhBa1RuQ2J5U0pVVmRrR3FrR0hRNmEya2JTcDJDVHBkTTdYeTZHc3FsZEZKOFBBZGNBdFBVaG5xa2V4Q1BiTUFJMmt1d3dZQ2IrVkZTQXJwL1B2eFFuNHJPc3NQVlZscmE2N0RCWkVJUDBwUFhDTDN6YldlUHhUOG9Oazc2aDExZ3FOQWhIOEhlL3Y5aC9YMW04KzZwODhrS2JMU0JyWW5PNWFCejY3dVE0YmJiSEhhSUJ5cFFzUm5kaW1YVTdTYzBrckNaTnVhcm1xS3BXbXErV0JGRmh4M0JLQUlTcGw2a2lFeVV4UmY0ajYreURTS2tBamFiUDVXSVQrUitPczh2d24vd3l2ZkZWMUVJemNrRUpGRk5OS3BZVzZ0NHRXOHdQRTJQRlNTaVBROHBwMURRWnM3UHowK09XR2huZU81TGpGNWNMQiswTjM3bXJLdmViZFBLQ1N5MEhCYW1MaXltZkttcmVoVG9Dd2prRENwbW1YdjZvcHBxcnBwUmxiRzZIQ1IxU05pQUdWR0pwL1V3VXBsc3JlWllFTmNzbVA0N2U3NytSdmpoWW5DN0kveWdNSXZvSUhoMVJ4d25NQngrRllqUXJIQTk1eTJ6RUMxQjdtdDdYVU9keGluSDRMenk1UGowMk93Q0VaWmFuOXpjSGQ5RHpJWk1GejFma2drUk5qSXFtRnRqRHpTSWRnMGpibGNVamNOcFdVb0ptVGNMZHN5dFp5dHFhWHltRFM5QnJWV0JDSVk2d3NaY2VJay9vSVVmY2xrSXJIOHhNVE45STFiNy9NM29uZjVDZmpOWDE0MU1DbEF1SkgrcjBWSWo0c00wT3V0SGZaNmZEdHFvL3hpZU8zdzdWelFwZWI2WWYzODRPU2dTNlB2QUx6dXYrNGovQ0wrMS9RaGgxN0RaZFRHdEExd0JMcXZsR2JReFpsbHJXUm9wYVJxbGd4MFJETjFRMWRMbXBaNXNGS2dOSGt3R3NHa0ZDRW02VThTanZWVkljdENSbFNPU1hiTDM2Um5ubUJqV2lpSTF3aENWREhNMDRRazVvbnZ2S0RtZTdYQUVhLzVUcjlkNmJmRk9sdzdiM2RyM1IvV0QyU2huWGRQdXNQVnR2ZGkrTGpabGUvMndXdklJM0RqaFJoVVVtWk5MbFNyU1gwdXJwUVdsOVZGUTluTkdiWnAyRlZGTmEyazBTYzJOYlBLN2pNMktZMDZxWkhCa0QwM3lwK3ExMU9iL0kyd2tPUkkzUE1VL3l5MktFOERqZDE0THRYSUJ2VUlHY0J4S2hWdUFkMWc1Ym1zTksvaFZTcWVXQ0FMelJPOGZvZTA5dUh6OGVYSng0L2RZM1J5bUxQMzlsL0k0MzNjMS9RaFVVY1p0Rmh4bXloZnRweFI5VG1GY0V3cXE4bGxVek1Nbk5heWt4Wk9zMVZSa2xhNXZMa3lLazI2c0V0SmwyR0VmQVlnNnc0UndtbVExZFBGZWRDb1N2S3owVHdQejRqWHdpcUVtQXhOcW1HMzRmaE4xNUd5bUtRZFJ1TVJFaW56RWVFb1JsNExQcUwvSDArR0tWdkkzdXovMmV2OHIraERDaGpYcmRGWVlkaE96YlFVRnBxeFM0VTF0Mnl2eGcydGJLaWtBSnltMkxqT01xdVpzbGxla2ZOZ3lZS3lpY3VnSGlOMTVuQ25paHN6OWJFRWVadTJKQ1Z5OFdHK3NETHhiNE9BZEQzRUh6bVJlZ1N3bW9NOGVyN2I5UGozTmg5T08raEpndXNITERsc1orZmtuLzRsQU8xcnBmV09Fbko2ZXFpUS8vZEpUVGlHNzNtVXdoL3BuMFRocXJsU2Jzb3dOYkFNUXlNY3kvWVp2ck5iaWhLaWFTWmtyVEFvUitVMFlQSWVlcmlBdDFicjB2ZWlMU1Nna1dJeDhaQnFjaDZ5OUt3MDcwUWh3ektrNGhDR29WVWtHZkNkT1hBcUdIWElSYzFqclZYNkY4N25qZjZIdm5lNWMvbnA2ZExjNTQrRCt2aFVhdU1sMEFoR0dUQmMvWDVJZWlmSVNBRWhvWGNUa3MzbDRtcFZNY3ljb1ZyeFpjczhzK1VyQlpjQ21XcFJnN1ZhcG1adHJxeElnaC9zZENRU1JmWkhNQkxqeUk4aFdtSzJpSmJrbyt4dkpuNHRlVTJNbU1SaG9TR1ZEWEZqa3hHV3lEMnE1VTRRaEdWeUlFSXBFZm5wcDhjdnQ5OTgrZjdMNzc3OGJucHBhZW5OTk1aQ0UvV0g2OHAzKzhERkdDdkVSbGs3YkV4eSt1SlVVdEUwQXcwQmFka3drOHVhWlpDK2swblFXcmFaZ1V5enJMNldlVmFZNU5RTkdDR2pRWmtsTXVtQjBXQllTVUFtYkZIeFc1UWUwRjFCQXdvV2dwRkZKbVBBNlFacmJsUG9tQUtnbXAxZTArODBSZnhEKzhSRzlOR2pweTlmYnIvYzNnWnRHcllYdjdwdWw4MFlCQ1NqSUZtTmhMdTVxQ3lpKzRxWnpMVnlob1ltV21aY1VRbkxrcEpFUlhCYXRXcTJXaVZOcFRZeE9jZ1JLYUVPQWEyZXl2SkoxM0poWVRKUkxCWWZ5b2dXaS9PekNkQyt6WWY3TlpIK1A2K1FDY2N3RDNCUkloT1NjcE1DS0pEYk93TWx1ZnpMbjRUczZWT3dRR09leGlSZEQ0OE9yK2hEMG51Ui82bHBQRlpBKy9uaDFKVCtUWHhLMFhTbFZVTDdaNWFCWExaTGhxR3F5U1JaelVKRlFMTTBTMVUxNERpdUlZNno5VWlFOVFYaUpHRkpuVGFmbUFXTk8vRVF6eVY0b0NVZmVnMkg0VEp1WEZlcGVYd2RXTk4zQTUvNnBPMEc3U0FJMmdSak8yQmJNd2hJdkFhYUFPMHpobDRMTlVSazVJbytKQU02N2hnSDJhT2twbEx1bTZrcFJkR1NhZ3RwWEl5ZnFUUExocFV6RkRKM1BHbGJMVXV0Wmt4clVWVkxxdDJIY09GQmdXT0FzUEs4Snh2dmN1WkpxcHBQUkJQUUpVQVR2SzM1UkhyaTIvUWZudnRyU0Q1VkNFVnl1SFhqcjJaWUoxT05VSlBJV2x0ekVYL3NVQVkyWEd0Q3hsamEzL3Q1ank5WTJOYTU5dDArWk94UVJpaXkwTG5GR1cwbW5sTktPWVZWWm10VFowYkxNR3h0K2N3eWszRkRzVnN0VmRBQTFCbWExVGV0S3ExampoeC9VMmVET3BJcGk1cE1KaElnUFlSTXBrUnhmajRxYmFEZkU1Qms3REFXcFJxUmNNUjNQdTJSc0N4cFUxN1NSTGh3eU5vK3llMVFiTGpXSGhPTGdBRzFENXZveVBBL2g3cnUvNmtaMUpEa2E4UnRkV3B1YmtyQ0VZZXh5aGFOTXlMVFZwVXo5bXZ4cEdHMHFwYmFxcFpOUGtxNnJaVThRbExiblpRVFJPcDlxUjAzYWVhbGZveXlGMldaaWRjRWNENGFaY0ZOL1A1NUtQNE9XTVFsTTVpQTBncWlPUFlxRXBDT1I0bnM5eDMyYXoxeTl0RlhHWG02UkVOcmUxclljTnhBSWNPWEZsLzFiaC9HOEcyLzQyT2dWV2RLcTFOVGhqVVgxN1VwU3VQa21hM0ZEZHVLbnltV0hqZVNLdTdLV1JuVGJLazVWVkZ0Q3NxU2htMCtXT0ZKa3RROXpsUkoxcGxDVkZ4RmoxeThGazUvRjJYaHBaOC9iMGhmN245Wkw3eDdYSEtETkl4RzZuNnh0NkJCOW5SLyt1WFMvdlQwMHY3K1hvaUdzZGl1cmlFbHIwRkhvVVVEOVp2RjNabXBwTDJiekZremNVT2RPWk43V1owNlc3WXRKYzVrdHY1ZFZWWFRSRU5LRXBKWWliK3RNc2MxbEtEM2lFZXE1ZWcvSklyUklteFFEZmlpVVk0QzBxK2ZEeFJSWnBUeWdsa203RUx1MmdXZi9jckZoY2ZvTS9VSDlqOThuZEZyNi9ZVng1OEhaU01FbWpBb0REUFJpSW1pU3BBNGtFNlhIN3JDTWpOMWx2enVkQ05FTWRnM0NrRUVvL2xTWXlpRTBBU0R3MEtmUWg0YjhFczZ5Z3JCR2V3KzdXbHYvWlAyT2RMdnB0bGw4WkZrNmJZditmQTk1M3VPSkZ2NmQ4SEZ1b3ZwNGdUcnI5RHU3dGp0L0twNkJzU3k1MFBXYlkxYSsrUHF1SE1wSG5LcC9hS3dTaHNQYVNPYTdiTFBJeDlXZDNaUUlOYUI5RzJ0WFczYkN1RWlyUThTK1RvWG9uRlN1dHIvNk5XdUZCdm1TR2NUdHY2R0hHTWpqVzYzMFcwMGh0MFBnLy9LK2lTY2h1T3dYVGxYMmRYVlFCTHlSSnprNXViK2ZVYktEWS9sMXlITkF5ZzVaeDUzaWxiZ2VYcmlCd1dkZXRZclMxZVhaYTdLQjd1dEpCL3h4NEJFVEFUTnpWMmxsRzlIa0dsT1VEK0RUUzZyZlB0eTY2TlhHQ1Ewc3JBSGpWMkYxaDNHMC9SbVB2d2xRbGEyR2s4aWJvUWhINUExR2hsNEdTRm9WTnJpL3ZwNjUvN21Sb3hFMEo3K29QTC9YWWVVZEdSZFdSbGRJbHFnMUtRbm9yV2pNUlhXWkhQOUVtc0VEYVpaNEI3a29OSGRYRUxadnFRa3VpVk45NHMvLzR0Yk9seXIyMW9UTURZYXRvZ25xU2szT3M0RnJmSHU3eGZETEoxbjg0eUluVFFMQjZrY09vT0JLSlFOVWxSSy81TU5waGorRkRMK2lXd3BsOE9oa2xTOHU3NFQxYVNsc1MyNURpa09TWHp5b2pXK2JBV0JOK20wZ3pQUHN1bldaVk9YdEdtTHFiZ1orTmpMSkFoY0Q3blFMS0ZqdXh4R3NtOG1DU2M3ZEFGR3lsM0l3R0lWMzVmWWhXMk51UDNIUDhPaE0xMWtRMmN4WGFRU2N5Y2RPQTU3dU5LTTdnVXpHLzluTUFmTW9BblpZSUZVNklaRmNsc0RRRlNqMXBZK1k5dzhmbW52dUROdUJUMDFHeWwxcHRjZlhJU2pyNVdsclNnMU8yQVVzV2xxcUdyYmxCczRNbk1ST2ttU1ppSk5nTEhyNjA5ZXZ0cmkzcWlnOWJFUDRjTWNtU1FQTjlZcTFib2hTNTJJVmZCZldNbkdEOHVOUWlNeVFRTjhrR0tRMDhVT1F6LythRTVxOEVlMjViL0w1dXZ3ZTZQT3FIZnFGWk9lR285RnNBQmIxT1hQYlJ1OGRxNzh0bytKUUNhTXZvMVdrcEpSanAvazdGazFiTjkrdmZXcUZnMy9sL3NhKzFDQ1J0SHR2NjFxRFhGMjVnYUtMWlM5MEJLUWhjSVdOc0t1RTlkczJhTnFKL2RvZGtKbnd4L3ZwR2RYNzhwbHE5aWUvVjAyU2JrM0huVk9BMzNVOHFJakpuOEd5WklDZTNpZ25qaUtCT2hnTmxNTWtsYkpzUnZoam5aa0svcDVydktjaXN0MWs0TGJRTFUxRnRCQU9nZHFUZER3L2kxeHlHRjg4cmVUWVR5WWgyUmZIR2FwNDhRWnFVaVpZUmJ4RmJub1FFSTJaaFZaWFd1MVF5NHVFQTBMNFdPSHFCNnk5Znd6eGxuTnMyMWFsOGVucC9wb00vQm5JNWxIZEduWjJzUDlJYk55NWZuTWo4d2ducUlKWUphK2I3TXFPeGRFYXBHaW80SC80THBIdDYrMjFreUprWk1ZQ0RrSjRQNytZWTIyMk1tRzhady9ualdMS2F6cU9LTzZwcW1UVW0xWk9wVXl5eHlKekpoL0ttTS9uWTFGYkVTR1NGUVQ0Wlk4MjhjOHhtZjA1cHZUM29SSnl6L3FNWWhjK3JUcnFQdzUxOG92U3hYNDJEeVdId0JVc2JWOVZsc0NRRlVoUnVJdmlhdi9STWNtcW03ZHIycXRFdTM4N2N1ZlFDUGJUSmxKT2txcHliNHkvcEN0SVJIaStnMlcrRDNabGFBdHNQOTN3dlFPKzJkWGxkcHp2enA4K2ozL3ZkWTN2ZG5xVWVDZlRUeEcvaGs4elpKeWN6MWNSR3ZVeXJFTmFvNEF5K0pEbExQYmJEWmtySG5FdFFXcTdqT1VFalRaTUpCNlBuNjlmL2k5cUZaRkdFdklYeDQ3b1JSVVBPQ2pRUWVBSERZS1RjaWUxcHFjcDhIRmVpOWQyMHdqekpITDM1Y3R6NHdhdFRxem85V09GMjBXMzJHTkhjdHVxcEo4akx5eTNkYWlXaHREZExFUmp6WkFWSVMrWlF1WWVFcU9adXlyZ3JzMWJIMlVBMDFPUmwvLy90UGJIOFVodThqa1NEYldNU0FucVRWSnh5eGRaSEFKbVJHdFlqT3FMUVN1dm5ZQUlNSFhyK1R4WkV0K2wyMGVmM2pjNm95L0dBVnFmT1l4UVhhQ01pK290UHlBZkxUYWhmSmR2N3ArbkFzak9kaW1qUU1uanNMcEtZME9vcWFXVXgxODBrMjJxNjc5bWxSa0R4aG9YMzc2L1krbzFwV0ZuQXhEY1ViSlFsbnd4dHJ3UmJSNkZIbFNhcWhHRTZmYWlCT0pIUUUwajBCZitydnN5aU5icmQ3bW05Tmd2Tm56YkYxb3BwR2d0QlRPUitGcFhZMVVNK1RKRlJObDZTdjBzaXo0MnBpSHBDSk03S01JTzBIQnBQa3hZNGpZUHY1QnhlMmU4OVdtdzIycHRUaDFUZ2JEeHpDbEJxU0VnQm5aREZ4bUhMSytnTEJZQ0p5UmpuUmtYZnE3YkxqWWpya0JTTXZlSEg5bDJ4T01SQ212dEpCSFMrRUZndFptc2FtcHNxVENmR1dWNUtXdGNFWWxiTG5OUVNUSnFmTWZrbVp6aFJLVDAxR01INS9rUHVMNTI5dmEvSzkzdW5FcWxSYUhHUDg4Yk1nQWtsVVIxbHdtSVorYVAyVEdTUVN0eXNqNm1zK3ZsN3d2Mnp3STl2aHM5YmpqalRlL1VsWXk4ZWhrZ2ZYWHRsWEs1WU1FTkhSNjhQbG51N1I5Q0h4YlZrWmpaWnVRQThqSXpvamtoTzFvVzJZU1JLUFNoT3p6d3hydDRubytkS2kwT1ZZdkVjL1RScHBTVEJ6L3p5UmlSRE1KV1pHUmt1YXFUejFvL1VaZTQvajgrN0tsMEdBN2U3RW5vclhVdXBwMDFpMjM1NUZ4WlZSWXBUb29wSzJ0KzZDaGsxWlVtYURVZS9GSXdpY2dqV3daS0tNREtxNDUrZDBHUVViMitVSkMvOHYrNGEwa0pPNUF3VW05NFpOMUpuSklSd2hOS2hyVlBpZzFiSWFBN0RFaDcrdlhGQytiSWMzcmR0NjhhSFZPeDNzUUZTTmxSVVZ2M1NjZm13R1hzZ29OR1d0WlVuMlJvcTFSYUg2YnZiZ2t0T3pxRnVEYU1rdTYxTnRFNXNxUGQ2dTIxaGZWdHZjcjFXQmljZEl3emlRaDU2SDBnWXpCR0c5OER4Yy9pZ1laeTl3azVCUFZUdkIvL240SkdKNjdEbW5lNy9EYnZWYW50ZGtLSUN2d3lNTHprSTNxUWJSWkVBQ0docFNYSjFoc2ZNTG15NGVRd3FZaUxXS1JrYXhKQW1LeUF0bkcydXNLN2Z4d1gvcGFaWWxNL25PbWtFek1JV2FieXVLRUg0aG1aQ01HTlJ1cVBiRVI3dFRJWTB1WHZTL2JQQVJ4NWJqRno2QlBQWXdrOE1wbUQ3UVNZN2Y4ZzVtRzlUdkkxaTBMWEFtRUVpcldray9TMVZKa0kyMU5ibnFML3d0WU1xSGE5Z1VOOTk4K042cEorZ2xlS0JzcFNUVFlpV1FtNHNmakN1Nkthak1PYVdRakJFM09RM2tnOVRNT2FTNzdDQnA5N1hqekwwRnd0dGtKTEdzTW1rVTVGWlk3S3pTaVdTVGpMMkd6Q0JqaHNmSlBwWFBiZHNWZmNINnROV1RGSHhnZkJXMWZETExQTlBLVFVRMCtzek1IVHl2TkNSYzNkNC9MOWQzRnUvL3lkWGF2YldSbkdMOXZ2YnRldThFbVhVcUR1MjJjRnB5T2crVXN6aDVsb09vaytKZ1VleUxaSkRZVFoxYzQ0dUJRN0ppcFFHSVFOQ3hJcUVSUnNTK21vRkZZaE1KSXlKbGNtQ28waWdkWnU1YmQva2w5M3Ztb0NOUjZ6c2ZJbzV2OGVNNjg1ME9aYzFJOVl4djM4RWUvdjJrN05hZFdxNVNMRlB4cDVEL2tuUnIva0JLZ3BSQkhERDJYWTlLWDh5a0cxMlIwY1BqMVNXV1loc0l6WktBUTRheC84V29hVTg0aU1NclVJcWZSeDJNS3J0SzhOSEdaNHVPZkpsWmgyd3FoUmY3UU92d2RjUXhTa0Fka2Q1RHZMUnlZLzVQejdsSHI4UEN3MGVtZm45Y3FKeWUvLzlXMVV1bGc5R0MwdHVDZFhqTjBmMGgvZjJxZ3pTMXpJODkzRFNheFhjUkVwT20wUEF2WFFBWnZmTjlBQjdJUURaL2xhV1JVR0NUSFFJYmdRU01UNUszSE1HMENyc0UyNnRpU24xaUhMYmoyTVJsUmVRVmdRUUM1dDJDV1RjZXNPUHR2YlhQL3Rhc2ZOVnVOemZQems1TTNiNzc2NDEvZmxBK2dVZWRkOE5QaGtIWElZSzlSSlJmTnhJVytoY2ROS3VRMGlTRk1xbHQzNWJ5SEJqakNtZ3lKY0lXTEdEUEhWRGtXdy9lZ1EreWN4dTgzc1JqSUVvVjhkWUpHeVVBREgrTC9TcEpjQTBaQWhSSkFJU01oZHR3QkhJMlh0MDJRMVh0UGZ2alA4NkpaNmJ4NDBtZzAzQk1JY0NlLzJheVZpSzJ5TUVLakVUeHVGNytYSFd5NW5JcW1NcHF4aGZtb2xKL1RHSU4zYWl3OXErZlhnQ2FqUlJJYm1pVFpSdGNYczU1ajFHbExzM2VsYVVtVzBVMWNWK1hyK1hsYWR2MWxoS0xqQkpGTnJOQ2tKdm1zU2cweXBMbUhDQkswUkhBUkZMQ1FNTURhTnAyYTNlajE0ZzgydG0zSDJkL1ppQi8xaUsyRURVVnYxRzhYcHp6WC9NZzRiSC9JWUNxNlBQNkFHK254M2JqRVlCcXNZNEt4dEZoYkU3aktrdVNSQld3b0VuQmo5SlJKZDJFcE1qWElOWkRGNWhNcTh1Y1JlQVkyQ0IvZzI4UktwTnBxQlQ0Rk9mUUxpWm9pZ1JIYWd0M3I5SHE5VGdmMXZtMmF4WGVUTzduMnBVczNwNjYyTzdibE5qcFRuOEcxbnlMeVF4ZnNvQnZ1TndLNGFFcUo2K08zTWdqL2FYMkpUTk1rb2EwSkJFaWh5a3dpT0hBQkNtd2dVMlhBd2t0d29hWWxPelJGZGwyZFY3R1dwKzZDQ0dDcmhFVmFYVTBtazVqVVBQU1ovR0JQUkQ0WEJDWXFkSmxzQUtyamRxRDQ5dmErWTlaZVA1L3NWYXROeTNLQjF1cTRsbW5WdmVHeDE3ZGQvUDhod1lXMC9Famh1YTlUR2JaVStKWWJHZ2laWmpBMW4xZFYyT2FoN1h6NUFnMVJvaXlyUkFvbVQzSk1KTUFmWXlySTFFSkNMVHlPQkg2aHhrY29PZkhNYXJZZTNnTUpwVkFFUlRuc29wSHZUT1o2YnUvRFh2L2wwK2ZmZlBQRGQyOGR4M3o5enE0MkVVMTZIZHUxT203RnZ1cStwZjRhWUJlUElVZUNqYmNmS1FyZmlpcUd3WFZGY0kwWm1vYWFvVGxxS2xPWkJPTndqS2EwSThFMW1XbHlpSVY0QTFzVCtSZ0RtUkN4dFFKNjY1dkFJVFFxSVZ1RUd1UkRkTThoME1kY2dNSWtHd2xvaUVMYVA3dmQ3dkhaZHh2ZHM3TnUwU25iZGF2WnR0cnQ2bFRWYWx1VnFlcU5oWkdQTjFIOFAyUElZSFB5YkRhalI1Y3poc0xCUmxDYXdqZVl6ajB5SWFtNEl3VWlFME0wV1dhQ1hSY0NWMVdBVEFWWjRiY0FDclVTdWdhMFp1dHZJQnY0Rm1KQ29XblFuWjJqeEszRThYR1hrcWQrSDMxQnZkcHN0ejlVcTVhRjBxNjZiei85eExQcnd0K3lnUVlCYlYxUnhxUFpKenlqNVpRY041aEk1UXlXRVVCa3FrNE9DbzFKR3d4Y2dBd1JRU1pVbFlGYmhzRjVUVlgxK1lLSStuNnRvbEIxMzJkOGR0OENHaUM4RkpEUTZqaUVaZkx2TVFnTzhrTGo2TzlINmNUeGViZUxmQWEwcm1PV3lsWGJnbUZRMVZxMEZ0MTlmKy80SVh1TWp3UWJSMmRUNDFmV014bURLYnM1aFJ1Q3ozR0R3N2NOMktLRGpDRURTd01nUTdQY2tKZ0JNZzBORnRJa1RSTnBvZko1VVJDNUZheldKVDJxZ1huNE8ySzFtbTdOVjZWV0laV1JRK0dkOHZJclh6ZStQa29jYmIwL09hbWZuNS8zKy8yaVl6cm94aXZXaDhaaWU5SHlWUCs1LzgvL2RNaDUyY0hKRVNuc1ZKVlZNZ2FQOGxRdXc3VzVGT2ZjTUF6R05KN0RKOURSNDhjWW5Gdnl3TURJQlR3Rkw4S3BybXVzb0l1Q3ptL2VCeGFnZ0FZZXZ3QXQ4Z3lCNExNeGVvTmtiRkNRS1EzdTRkWkJhZTlXZWt2WnJMdU9iV05IaDJMUnRvRldLWmszbnE0L1dwK1plZXE2dCt0ajlLQWhEVHN2MnovRFpmbnlsZlhzZ3d6UEtwamFjSllhVnpMY1FGcGlHUVZVZ09JUUE1SWhMU0hJTUVnbkUrR3R4SFJkRjZBanNwL2RqMFRvRVF0RllFUVpTVjV0TnFmbzNabGdaNGZSUWJvV1hPamIwWjlnQ0xtb24vMzcyNFpsMjUyT1RkVytiY08ya25scDgvYk1LVFJ6K3RYWUNJU1hTNGFjbDAxa05GKzdQTE9lelQ1QW5Gekd6STJQWTEweURqUUlGVDFySERJZzVvRVpLdWNhaU1FTXNsd0IzNmU1S095S3l4RUk3VEZzamFGcEZDRUp6ZCtHNDJNczFJSHdBWlZacXAzOStjcGYvdlhGbmx1MzdacmRLUklnR3UyQitXcnY1Y3pwKy9mdm43NGFDOVpYaDV5WFRXUjRoK0VMRHkycjhCUldFclM1ejFNcEhsZmlSb2JIUGZNOGdRVFNNQ0RqZ3V2ZUhSVEVVcUZ6ZlJlZXBVUTA0cG0yU2pnRHRDUXFoSkVXMEVoRWhCd2lYUnR3ZVRvb2xmdk9QMzQ4UGo3K2NmY1h2OTdiUTNOMDdFNjlVaTZacFZKNTcrWHA2WC81T3AvWHVLMHZpcS96alNlalRCTUcyME1HRWROQ3ZqU1BnTXNzVElwRUtBaGtMMXFaTVFVanBncFlFRzI4R1pWc0pGcVQ3SUlXc3NBcWVDR2poVHJGV1EyR1FxR0RDUVJjV3Y5TFBlZWlCMm53NU55bjk4T3p5WWR6OVNZam9hdkY4OW9nMm9mMVJtNjZEa2wxT211dThuMC9UU0xUU3hQbnJoYzVTZVNBTEVGZTd1MGs1UGhoRHhhK1NCSTRCUzdhQ0ZnTTBVc1d2RHJhZVROOU9YMDlIZ0VPTEMyWm5zTEs4YmVTa0hWVGJ1VUZDS3FzQWs1Rm9QVXFyNFpacmRIS1BIdGZ2WHBEdUQrdmZyMDQrT2ZIV1ZXZDNUOEgybW1aenc2UFozbGU5dVRkR2JKRk1tNnU3U01aT2JBVnlKekl0SHpIc2F3b2Nwd2tTWnc5ZEhRdXdRcVE2T0NaNDRBSzFDRGRjWTZpSStjbGQxWFdZYnMzSHZlSkprdzRaQWEyNzRuR2hPeUI0RHpMOERoVG1jbFRUYitjTlBYSitVazJLMzQ3eWFBVFdKcWZ2ait0NzYraHBOM1ZGUitqT2JoUWd5KzN0OS9OUUFidTZxc1M5bUViSWNIeWU5bEE2OXhpREpTYStFRmsza1ZlUm42RXpvSDJrMVlDdWdmVUhYUllRTTZMbjFEQ0szSW9sbUNEWnlBREdOU1hBQlNIY0xjZjRodjdEaEt5YXhoRk5TTkNOV3h5YkgzWitYeXp5TEltSzRyWmZOWVVUVzJzbDgxOFhoVHp6Y3V2SHorZFRxK3VyOVByQysvblYvKy9mRmZCclRvSFhYazZOTEE5VXN2dlpTTWhTWGJiRmRjczB3T2FIMWxJeUNCSzl3RkhLa2ZUMEQ3QVlNYTVFMDM5SFNtODVoeUJMQnFRak5INjFXWWl3SGJKQnRmcW50R3FKNTA4OUE4WnJIaURjWjJ6Y2s2MGJQNXcrL2ZIS0NoNVlQbkI5ZC9YcG1sZGJ1WWxrbEs4TTNyY0lLRmw5N0xSMnRlSHVuRE5rcnFuSkZSZUNnVlJFZ0RPU1IyaDJVK1RCQzVwSmZoZGpsVVVlWUNib3JQN1kyaUVCakljY1FzSE1KREZRRHZyNnMyQ1kxM0pLcTloWllGdnRDWUhHTkdLQXR0RjFvRHQ3WGRQTHc2c3QxWVFYTnZXNUF4dUFZd2hhT1JDTEsweDNyNWl4RlhIeWpldGdRdlhNUHBlNmhQT1MwR0dDQkNnb0VFVS9nb3d6MHNjMzRQRFU4K2JldXIxQ3JBb2NrbFNraTRlaFJSMlNQbktOcENMdFp4VWVYUENFYk1zNTRBVHJzVXV5OU5pbnAzbTljTnYvbGcxRi9ibHBYdm9IajdmN09ZUFNjYU1CSm9ZMDlMZC9GdzJyeDBUN1ZncGhUcmZ6RXVXbVl4OEtFalJBaEE2d054UFFjQWh3Q0pKUGNpSmdzOHN5d01kNm9zK1dSbHJrWXVDWjVqRlFvYUVQQ05hTmN1THBxak9pMkhWTkVWZDFVVlZEZm4vcmFxb2hqMjZocEF2Q0E3eVZDbEsvV3daVzQ4a2I1bkVhQkMrcnZWcllaZS9wNGF5YlRXeFVYS0lhQ0JENTR0UzRJSE5EK0FQckJSUThFVWVsckRUdXV1bmdNTTUrdm5LQ3BOUmJ5VFN3eldjWS9IdVJyL2J2OFdFN01nL3J0eVNxaHJESG1Yd1lBZXR5OGVHZk1wRGZ5NGpRa3ZnZUNlRGJNdXZRN1p2RTNKWjVPN0J0cXNna0NrS2VKTVVkT2hJcUZKSXJOd0hHTEZUSUtYS29zMERrRUhvd0Nka0ZOTnhGSFp4c3NYWS9NVTEraUpISytMb3BZQ1JqU09EbzFEU1JtSFRwc0UxZ01HM1QxeUhiTitRNUxKNC9yMEJBTldFVUhDUndpTDl5d3A4N2VKRWtwUmMzb1QyV3FtSlRkWDA3SmhvV3BvTVdJQ0xkK09OT0I0VDdiWW1rQjd4VWV1eGFTeDBPa0EyQkxOQWFiZ3RDUHBrZlVpNWZ1eTZpN1VIcSs3Q1BnUU5aTnJLTnBXOVVCTzRKUVpDV01BMVlWUkt5THcxSVZOZi9BOW9MVnpyV293K0Jsa25ERGRHRzUxNGpCK1FkSTI2MFRZeFNZQStadXNOb1pKc21neUNhWXhQUEpmZHZpSjcxVmFyUUVOZUNwcU45WUFGOVNmQTBmNEJMY0FLYTdRQVpFcUpaN1o2c2dLMUNjbURyZ2xaSnh5UE51SndveE9PT25STm80am9oS3cweXdjSEFrMVB5aTJNSDlrR0pySXRxKzJEMXI1bkN1bjQ3Qm5RNEpvNlZMWTdVTW9GMm9LSmlRTmtpTVZrNGdubEFtVDRLNmhJcDFaWEJPME9xVERvaklSbmdCdkgvVzRZZGtkai9QRFhycEZuaUtBSXd1bC9UNjVIbk9yZ3h4eGFMaEYraXVwemJmbDFTSG5pM2tXQnFPM25MdGlPYlZkaFZJZDhCd0tXSUNQYUFvZzBFSXNKWndCWEE5czJjUXh3dTZUTlIvWTBUY2dZc0swVGgzRTM3UEJjZTdTdWZkSmtwQkgvU2lZZ0dxSTFGVE1kNWI5OG5VRnU5RG9NZzljeXpTK25tYXZNVWQ3NWY0Q0toVHlnR2RsTlI2cXRrQ1ZjZEpHQXQ0cUpjOVpXanRxdjV5SEhsOTM1a0JIZnJ2RnNuS0FlM3V3ZVEvRG5QbWZ6bFVoUFg1SmtnY2ZKckt3cTdZWGtidUNyU2ttTmhHVm9QS25nTzJTekY0RytvdHFQOTdJRDN4cnJ6NFB4Q3NRbjFlc2dHeHQ3dVRUbVpzcnF3ek83MHVhL3BEMnJmTXowQldzWjVKS29zc0hJeDdxcmhLdWNETFlRQm4xQlRyNURJT1BOTC90cGNubUhCM241eHRvZ0IzenphVkhIUXkzUTZ5bW5zalBWbSt1bmtvSzExd1paZHVRU0hlZjdCcE5ZL1ZEblJuZlplMzMxWVBiNlRrMGR3UlRJTFlvekU0U2xLekdLWG5OcDduTGpLMVdoOExTc01lRHoyZFV0VkFhY3phZnREVUs0NzQyYjJjNWtFMzc3VnZHUXl2anplY2dEY2tCL2ttYUd0cVFxRFUxVUdhTm40blB2RFlNZ3RDeVFTOHFwMFZsZjV3SW9FcWI4aWVtaVRCZ25YS1p6WEFnVVd1Ui8vdlAxdzZlbVQ0d3JsL0VZUFNNUm9uTlVjaUNSWkRQdWs1RytDVDUvTlU1ZlVBbjVxRktWZTdHWDdVb3g3UzJTM2lNRklUQjBRWTZrZmM0NjN0K3BXWkdpQTg3bmxzb1BJK2o1czNKRXpsbUxmaGJLeGFyb0dTR2laUGFsZG90ZnBrUklzTllDU1lhUWppTGpaT2x1OTgyUHh5L1JXTlZpamhmczZ6czF6L0cvWkdheXQ1VS9xbjh1WEp6c2JmRy83c3hnRFdFUWhzRkEyOG43UDdHRjZBNThNWGhsVGJaUHh5ejhkTjFGK0IrSk4rUXl1bnhkaGpsc211SXpNa2psaFJRalc4cjZUODIzMTRUcDlwUGxTUHJickNvaTJiUlk0UHJ6cTZKcUpSSU4xN2FsNDU4MUdDU0t2Q0xDditxdEh5bjRSa1BWQklPQVVtd0NRUTFNN2ZaSDkwbWk0VFVTdlRsRHdUV1JpOXkvWmFSc1loN1ZpeXpEbEZjTFBKRFdLbDByVEdEMmJPUUdpSi9FcG1rMlBwZjNEMW94YSs3WFk4Szk5WWprU2tmMFhqUDhFYXF0MlNqYWE3aEVXTTlvMDhjZjNheVVpUWEyQ0RQNDdHTW9CaG5RWnNObFJEaytBREdoZ0FZNm5FN1hNT0lOcnhnai81eW9MUDBBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3dyb290L2ltYWdlcy9CQlFfUGxhbmtzX2N1YmUucG5nXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJkM2JkMmY2OTE2MTVlMmQ4YzA0MWFjZmM0NjMzZDg4MC5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3d3Jvb3QvaW1hZ2VzL0Jha2luZ1BsYW5rc19IZWFkZXIucG5nXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI3MmQ3ZTNiNzgzZWU0YjBjM2RhZDIyMjY0ZGM0ZmM3MC5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3d3Jvb3QvaW1hZ2VzL0JCUVBsYW5rc19IZWFkZXIucG5nXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI1MWI3NjBiNTlhMWUxNWI2YWY3YjE1MzYzMTkwMDU0NS5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3d3Jvb3QvaW1hZ2VzL1NwaWNlUnVic19IZWFkZXIucG5nXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJ3JlZmxlY3QtbWV0YWRhdGEnO1xuaW1wb3J0ICd6b25lLmpzJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZmlyc3QnO1xuaW1wb3J0IHsgQVBQX0JBU0VfSFJFRiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBlbmFibGVQcm9kTW9kZSwgQXBwbGljYXRpb25SZWYsIE5nWm9uZSwgVmFsdWVQcm92aWRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgcGxhdGZvcm1EeW5hbWljU2VydmVyLCBQbGF0Zm9ybVN0YXRlLCBJTklUSUFMX0NPTkZJRyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLXNlcnZlcic7XG5pbXBvcnQgeyBjcmVhdGVTZXJ2ZXJSZW5kZXJlciwgUmVuZGVyUmVzdWx0IH0gZnJvbSAnYXNwbmV0LXByZXJlbmRlcmluZyc7XG5pbXBvcnQgeyBBcHBNb2R1bGUgfSBmcm9tICcuL2FwcC9hcHAuc2VydmVyLm1vZHVsZSc7XG5cbmVuYWJsZVByb2RNb2RlKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVNlcnZlclJlbmRlcmVyKHBhcmFtcyA9PiB7XG4gICAgY29uc3QgcHJvdmlkZXJzID0gW1xuICAgICAgICB7IHByb3ZpZGU6IElOSVRJQUxfQ09ORklHLCB1c2VWYWx1ZTogeyBkb2N1bWVudDogJzxhcHA+PC9hcHA+JywgdXJsOiBwYXJhbXMudXJsIH0gfSxcbiAgICAgICAgeyBwcm92aWRlOiBBUFBfQkFTRV9IUkVGLCB1c2VWYWx1ZTogcGFyYW1zLmJhc2VVcmwgfSxcbiAgICAgICAgeyBwcm92aWRlOiAnQkFTRV9VUkwnLCB1c2VWYWx1ZTogcGFyYW1zLm9yaWdpbiArIHBhcmFtcy5iYXNlVXJsIH0sXG4gICAgXTtcblxuICAgIHJldHVybiBwbGF0Zm9ybUR5bmFtaWNTZXJ2ZXIocHJvdmlkZXJzKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKS50aGVuKG1vZHVsZVJlZiA9PiB7XG4gICAgICAgIGNvbnN0IGFwcFJlZjogQXBwbGljYXRpb25SZWYgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KEFwcGxpY2F0aW9uUmVmKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KFBsYXRmb3JtU3RhdGUpO1xuICAgICAgICBjb25zdCB6b25lOiBOZ1pvbmUgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KE5nWm9uZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPFJlbmRlclJlc3VsdD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgem9uZS5vbkVycm9yLnN1YnNjcmliZSgoZXJyb3JJbmZvOiBhbnkpID0+IHJlamVjdChlcnJvckluZm8pKTtcbiAgICAgICAgICAgIGFwcFJlZi5pc1N0YWJsZS5maXJzdChpc1N0YWJsZSA9PiBpc1N0YWJsZSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlICdvblN0YWJsZScgZmlyZXMgYmVmb3JlICdvbkVycm9yJywgd2UgaGF2ZSB0byBkZWxheSBzbGlnaHRseSBiZWZvcmVcbiAgICAgICAgICAgICAgICAvLyBjb21wbGV0aW5nIHRoZSByZXF1ZXN0IGluIGNhc2UgdGhlcmUncyBhbiBlcnJvciB0byByZXBvcnRcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHN0YXRlLnJlbmRlclRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZVJlZi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYm9vdC5zZXJ2ZXIudHMiLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChDKSBNaWNyb3NvZnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG52YXIgUmVmbGVjdDtcclxuKGZ1bmN0aW9uIChSZWZsZWN0KSB7XHJcbiAgICAvLyBNZXRhZGF0YSBQcm9wb3NhbFxyXG4gICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS9cclxuICAgIChmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XHJcbiAgICAgICAgICAgIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOlxyXG4gICAgICAgICAgICAgICAgICAgIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXM7XCIpKCk7XHJcbiAgICAgICAgdmFyIGV4cG9ydGVyID0gbWFrZUV4cG9ydGVyKFJlZmxlY3QpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygcm9vdC5SZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHJvb3QuUmVmbGVjdCA9IFJlZmxlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBleHBvcnRlciA9IG1ha2VFeHBvcnRlcihyb290LlJlZmxlY3QsIGV4cG9ydGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmFjdG9yeShleHBvcnRlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUV4cG9ydGVyKHRhcmdldCwgcHJldmlvdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtrZXldICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzKVxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgICAgIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG4gICAgICAgIC8vIGZlYXR1cmUgdGVzdCBmb3IgU3ltYm9sIHN1cHBvcnRcclxuICAgICAgICB2YXIgc3VwcG9ydHNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICAgICAgdmFyIHRvUHJpbWl0aXZlU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC50b1ByaW1pdGl2ZSA6IFwiQEB0b1ByaW1pdGl2ZVwiO1xyXG4gICAgICAgIHZhciBpdGVyYXRvclN5bWJvbCA9IHN1cHBvcnRzU3ltYm9sICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wuaXRlcmF0b3IgOiBcIkBAaXRlcmF0b3JcIjtcclxuICAgICAgICB2YXIgc3VwcG9ydHNDcmVhdGUgPSB0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiOyAvLyBmZWF0dXJlIHRlc3QgZm9yIE9iamVjdC5jcmVhdGUgc3VwcG9ydFxyXG4gICAgICAgIHZhciBzdXBwb3J0c1Byb3RvID0geyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheTsgLy8gZmVhdHVyZSB0ZXN0IGZvciBfX3Byb3RvX18gc3VwcG9ydFxyXG4gICAgICAgIHZhciBkb3duTGV2ZWwgPSAhc3VwcG9ydHNDcmVhdGUgJiYgIXN1cHBvcnRzUHJvdG87XHJcbiAgICAgICAgdmFyIEhhc2hNYXAgPSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBvYmplY3QgaW4gZGljdGlvbmFyeSBtb2RlIChhLmsuYS4gXCJzbG93XCIgbW9kZSBpbiB2OClcclxuICAgICAgICAgICAgY3JlYXRlOiBzdXBwb3J0c0NyZWF0ZVxyXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeShPYmplY3QuY3JlYXRlKG51bGwpKTsgfVxyXG4gICAgICAgICAgICAgICAgOiBzdXBwb3J0c1Byb3RvXHJcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeSh7IF9fcHJvdG9fXzogbnVsbCB9KTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoe30pOyB9LFxyXG4gICAgICAgICAgICBoYXM6IGRvd25MZXZlbFxyXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGhhc093bi5jYWxsKG1hcCwga2V5KTsgfVxyXG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGtleSBpbiBtYXA7IH0sXHJcbiAgICAgICAgICAgIGdldDogZG93bkxldmVsXHJcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4gaGFzT3duLmNhbGwobWFwLCBrZXkpID8gbWFwW2tleV0gOiB1bmRlZmluZWQ7IH1cclxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBtYXBba2V5XTsgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIExvYWQgZ2xvYmFsIG9yIHNoaW0gdmVyc2lvbnMgb2YgTWFwLCBTZXQsIGFuZCBXZWFrTWFwXHJcbiAgICAgICAgdmFyIGZ1bmN0aW9uUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uKTtcclxuICAgICAgICB2YXIgdXNlUG9seWZpbGwgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudltcIlJFRkxFQ1RfTUVUQURBVEFfVVNFX01BUF9QT0xZRklMTFwiXSA9PT0gXCJ0cnVlXCI7XHJcbiAgICAgICAgdmFyIF9NYXAgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIiA/IE1hcCA6IENyZWF0ZU1hcFBvbHlmaWxsKCk7XHJcbiAgICAgICAgdmFyIF9TZXQgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIFNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmVudHJpZXMgPT09IFwiZnVuY3Rpb25cIiA/IFNldCA6IENyZWF0ZVNldFBvbHlmaWxsKCk7XHJcbiAgICAgICAgdmFyIF9XZWFrTWFwID0gIXVzZVBvbHlmaWxsICYmIHR5cGVvZiBXZWFrTWFwID09PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogQ3JlYXRlV2Vha01hcFBvbHlmaWxsKCk7XHJcbiAgICAgICAgLy8gW1tNZXRhZGF0YV1dIGludGVybmFsIHNsb3RcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHNcclxuICAgICAgICB2YXIgTWV0YWRhdGEgPSBuZXcgX1dlYWtNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBsaWVzIGEgc2V0IG9mIGRlY29yYXRvcnMgdG8gYSBwcm9wZXJ0eSBvZiBhIHRhcmdldCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIGRlY29yYXRvcnMgQW4gYXJyYXkgb2YgZGVjb3JhdG9ycy5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgdG8gZGVjb3JhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgdGhlIHRhcmdldCBrZXkuXHJcbiAgICAgICAgICogQHJlbWFya3MgRGVjb3JhdG9ycyBhcmUgYXBwbGllZCBpbiByZXZlcnNlIG9yZGVyLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgRXhhbXBsZSA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIixcclxuICAgICAgICAgKiAgICAgICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiLFxyXG4gICAgICAgICAqICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIikpKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiLFxyXG4gICAgICAgICAqICAgICAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiLFxyXG4gICAgICAgICAqICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpKSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBkZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzQXJyYXkoZGVjb3JhdG9ycykpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QoYXR0cmlidXRlcykgJiYgIUlzVW5kZWZpbmVkKGF0dHJpYnV0ZXMpICYmICFJc051bGwoYXR0cmlidXRlcykpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKElzTnVsbChhdHRyaWJ1dGVzKSlcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZVByb3BlcnR5KGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc0FycmF5KGRlY29yYXRvcnMpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNDb25zdHJ1Y3Rvcih0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZUNvbnN0cnVjdG9yKGRlY29yYXRvcnMsIHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJkZWNvcmF0ZVwiLCBkZWNvcmF0ZSk7XHJcbiAgICAgICAgLy8gNC4xLjIgUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSlcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNyZWZsZWN0Lm1ldGFkYXRhXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBkZWZhdWx0IG1ldGFkYXRhIGRlY29yYXRvciBmYWN0b3J5IHRoYXQgY2FuIGJlIHVzZWQgb24gYSBjbGFzcywgY2xhc3MgbWVtYmVyLCBvciBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IFRoZSBrZXkgZm9yIHRoZSBtZXRhZGF0YSBlbnRyeS5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFWYWx1ZSBUaGUgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBlbnRyeS5cclxuICAgICAgICAgKiBAcmV0dXJucyBBIGRlY29yYXRvciBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcmVtYXJrc1xyXG4gICAgICAgICAqIElmIGBtZXRhZGF0YUtleWAgaXMgYWxyZWFkeSBkZWZpbmVkIGZvciB0aGUgdGFyZ2V0IGFuZCB0YXJnZXQga2V5LCB0aGVcclxuICAgICAgICAgKiBtZXRhZGF0YVZhbHVlIGZvciB0aGF0IGtleSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IsIFR5cGVTY3JpcHQgb25seSlcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSwgVHlwZVNjcmlwdCBvbmx5KVxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXHJcbiAgICAgICAgICogICAgICAgICBwcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QoKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QoKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSAmJiAhSXNQcm9wZXJ0eUtleShwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJtZXRhZGF0YVwiLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lIGEgdW5pcXVlIG1ldGFkYXRhIGVudHJ5IG9uIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIEEgdmFsdWUgdGhhdCBjb250YWlucyBhdHRhY2hlZCBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBkZWNvcmF0b3IgZmFjdG9yeSBhcyBtZXRhZGF0YS1wcm9kdWNpbmcgYW5ub3RhdGlvbi5cclxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gTXlBbm5vdGF0aW9uKG9wdGlvbnMpOiBEZWNvcmF0b3Ige1xyXG4gICAgICAgICAqICAgICAgICAgcmV0dXJuICh0YXJnZXQsIGtleT8pID0+IFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCB0YXJnZXQsIGtleSk7XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZGVmaW5lTWV0YWRhdGFcIiwgZGVmaW5lTWV0YWRhdGEpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbiBoYXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBrZXkgd2FzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbjsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiaGFzTWV0YWRhdGFcIiwgaGFzTWV0YWRhdGEpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3QgaGFzIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEga2V5IHdhcyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0OyBvdGhlcndpc2UsIGBmYWxzZWAuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJoYXNPd25NZXRhZGF0YVwiLCBoYXNPd25NZXRhZGF0YSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBvcnRlcihcImdldE1ldGFkYXRhXCIsIGdldE1ldGFkYXRhKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGtleSBpZiBmb3VuZDsgb3RoZXJ3aXNlLCBgdW5kZWZpbmVkYC5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBvcnRlcihcImdldE93bk1ldGFkYXRhXCIsIGdldE93bk1ldGFkYXRhKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBrZXlzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdW5pcXVlIG1ldGFkYXRhIGtleXMuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlNZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0TWV0YWRhdGFLZXlzXCIsIGdldE1ldGFkYXRhS2V5cyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdW5pcXVlIG1ldGFkYXRhIGtleXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdW5pcXVlIG1ldGFkYXRhIGtleXMuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlPd25NZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0T3duTWV0YWRhdGFLZXlzXCIsIGdldE93bk1ldGFkYXRhS2V5cyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyB0aGUgbWV0YWRhdGEgZW50cnkgZnJvbSB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBwcm92aWRlZCBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1ldGFkYXRhIGVudHJ5IHdhcyBmb3VuZCBhbmQgZGVsZXRlZDsgb3RoZXJ3aXNlLCBmYWxzZS5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHByb3BlcnR5S2V5LCAvKkNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCFtZXRhZGF0YU1hcC5kZWxldGUobWV0YWRhdGFLZXkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAobWV0YWRhdGFNYXAuc2l6ZSA+IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gTWV0YWRhdGEuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhLmRlbGV0ZShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRNZXRhZGF0YS5zaXplID4gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBNZXRhZGF0YS5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZGVsZXRlTWV0YWRhdGFcIiwgZGVsZXRlTWV0YWRhdGEpO1xyXG4gICAgICAgIGZ1bmN0aW9uIERlY29yYXRlQ29uc3RydWN0b3IoZGVjb3JhdG9ycywgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0ZWQgPSBkZWNvcmF0b3IodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzQ29uc3RydWN0b3IoZGVjb3JhdGVkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGRlY29yYXRlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBEZWNvcmF0ZVByb3BlcnR5KGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9IGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQoZGVjb3JhdGVkKSAmJiAhSXNOdWxsKGRlY29yYXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KGRlY29yYXRlZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gZGVjb3JhdGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIENyZWF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBNZXRhZGF0YS5nZXQoTyk7XHJcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZCh0YXJnZXRNZXRhZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghQ3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRNZXRhZGF0YSA9IG5ldyBfTWFwKCk7XHJcbiAgICAgICAgICAgICAgICBNZXRhZGF0YS5zZXQoTywgdGFyZ2V0TWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IHRhcmdldE1ldGFkYXRhLmdldChQKTtcclxuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFDcmVhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhTWFwID0gbmV3IF9NYXAoKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhLnNldChQLCBtZXRhZGF0YU1hcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhTWFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAzLjEuMS4xIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnloYXNtZXRhZGF0YVxyXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcclxuICAgICAgICAgICAgdmFyIGhhc093biA9IE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xyXG4gICAgICAgICAgICBpZiAoIUlzTnVsbChwYXJlbnQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4xLjIuMSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzb3dubWV0YWRhdGFcclxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBUb0Jvb2xlYW4obWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS4zLjEgT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG1ldGFkYXRhXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xyXG4gICAgICAgICAgICB2YXIgaGFzT3duID0gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd24pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xyXG4gICAgICAgICAgICBpZiAoIUlzTnVsbChwYXJlbnQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS40LjEgT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG93bm1ldGFkYXRhXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS41LjEgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWRlZmluZW93bm1ldGFkYXRhXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCkge1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gdHJ1ZSk7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhTWFwLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS42LjEgT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW1ldGFkYXRha2V5c1xyXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5TWV0YWRhdGFLZXlzKE8sIFApIHtcclxuICAgICAgICAgICAgdmFyIG93bktleXMgPSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duS2V5cztcclxuICAgICAgICAgICAgdmFyIHBhcmVudEtleXMgPSBPcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50S2V5cy5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBvd25LZXlzO1xyXG4gICAgICAgICAgICBpZiAob3duS2V5cy5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRLZXlzO1xyXG4gICAgICAgICAgICB2YXIgc2V0ID0gbmV3IF9TZXQoKTtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvd25LZXlzXzEgPSBvd25LZXlzOyBfaSA8IG93bktleXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBvd25LZXlzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0tleSA9IHNldC5oYXMoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgcGFyZW50S2V5c18xID0gcGFyZW50S2V5czsgX2EgPCBwYXJlbnRLZXlzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gcGFyZW50S2V5c18xW19hXTtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNLZXkgPSBzZXQuaGFzKGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0tleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldC5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4xLjcuMSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5b3dubWV0YWRhdGFrZXlzXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCkge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgIHZhciBrZXlzT2JqID0gbWV0YWRhdGFNYXAua2V5cygpO1xyXG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBHZXRJdGVyYXRvcihrZXlzT2JqKTtcclxuICAgICAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5cy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IEl0ZXJhdG9yVmFsdWUobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXNba10gPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBrKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNiBFQ01BU2NyaXB0IERhdGEgVHlwMGVzIGFuZCBWYWx1ZXNcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xyXG4gICAgICAgIGZ1bmN0aW9uIFR5cGUoeCkge1xyXG4gICAgICAgICAgICBpZiAoeCA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIE51bGwgKi87XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHgpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjogcmV0dXJuIDAgLyogVW5kZWZpbmVkICovO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjogcmV0dXJuIDIgLyogQm9vbGVhbiAqLztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIDMgLyogU3RyaW5nICovO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInN5bWJvbFwiOiByZXR1cm4gNCAvKiBTeW1ib2wgKi87XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6IHJldHVybiA1IC8qIE51bWJlciAqLztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjogcmV0dXJuIHggPT09IG51bGwgPyAxIC8qIE51bGwgKi8gOiA2IC8qIE9iamVjdCAqLztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiA2IC8qIE9iamVjdCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LjEuMSBUaGUgVW5kZWZpbmVkIFR5cGVcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXVuZGVmaW5lZC10eXBlXHJcbiAgICAgICAgZnVuY3Rpb24gSXNVbmRlZmluZWQoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4geCA9PT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LjEuMiBUaGUgTnVsbCBUeXBlXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy1udWxsLXR5cGVcclxuICAgICAgICBmdW5jdGlvbiBJc051bGwoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4geCA9PT0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNi4xLjUgVGhlIFN5bWJvbCBUeXBlXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcy1zeW1ib2wtdHlwZVxyXG4gICAgICAgIGZ1bmN0aW9uIElzU3ltYm9sKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LjEuNyBUaGUgT2JqZWN0IFR5cGVcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QtdHlwZVxyXG4gICAgICAgIGZ1bmN0aW9uIElzT2JqZWN0KHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiID8geCAhPT0gbnVsbCA6IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuMSBUeXBlIENvbnZlcnNpb25cclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlLWNvbnZlcnNpb25cclxuICAgICAgICAvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxyXG4gICAgICAgIGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0LCBQcmVmZXJyZWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoVHlwZShpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBVbmRlZmluZWQgKi86IHJldHVybiBpbnB1dDtcclxuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBOdWxsICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogQm9vbGVhbiAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIFN0cmluZyAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFN5bWJvbCAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1IC8qIE51bWJlciAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBoaW50ID0gUHJlZmVycmVkVHlwZSA9PT0gMyAvKiBTdHJpbmcgKi8gPyBcInN0cmluZ1wiIDogUHJlZmVycmVkVHlwZSA9PT0gNSAvKiBOdW1iZXIgKi8gPyBcIm51bWJlclwiIDogXCJkZWZhdWx0XCI7XHJcbiAgICAgICAgICAgIHZhciBleG90aWNUb1ByaW0gPSBHZXRNZXRob2QoaW5wdXQsIHRvUHJpbWl0aXZlU3ltYm9sKTtcclxuICAgICAgICAgICAgaWYgKGV4b3RpY1RvUHJpbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIGhpbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKElzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgaGludCA9PT0gXCJkZWZhdWx0XCIgPyBcIm51bWJlclwiIDogaGludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuMS4xLjEgT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcclxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpIHtcclxuICAgICAgICAgICAgaWYgKGhpbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b1N0cmluZ18xID0gTy50b1N0cmluZztcclxuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHRvU3RyaW5nXzEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRvU3RyaW5nXzEuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVPZiA9IE8udmFsdWVPZjtcclxuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHZhbHVlT2YpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVPZiA9IE8udmFsdWVPZjtcclxuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHZhbHVlT2YpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9TdHJpbmdfMiA9IE8udG9TdHJpbmc7XHJcbiAgICAgICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh0b1N0cmluZ18yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0b1N0cmluZ18yLmNhbGwoTyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4xLjIgVG9Cb29sZWFuKGFyZ3VtZW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8yMDE2LyNzZWMtdG9ib29sZWFuXHJcbiAgICAgICAgZnVuY3Rpb24gVG9Cb29sZWFuKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIWFyZ3VtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjEuMTIgVG9TdHJpbmcoYXJndW1lbnQpXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9zdHJpbmdcclxuICAgICAgICBmdW5jdGlvbiBUb1N0cmluZyhhcmd1bWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIGFyZ3VtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjEuMTQgVG9Qcm9wZXJ0eUtleShhcmd1bWVudClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XHJcbiAgICAgICAgZnVuY3Rpb24gVG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gVG9QcmltaXRpdmUoYXJndW1lbnQsIDMgLyogU3RyaW5nICovKTtcclxuICAgICAgICAgICAgaWYgKElzU3ltYm9sKGtleSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICByZXR1cm4gVG9TdHJpbmcoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4yIFRlc3RpbmcgYW5kIENvbXBhcmlzb24gT3BlcmF0aW9uc1xyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRlc3RpbmctYW5kLWNvbXBhcmlzb24tb3BlcmF0aW9uc1xyXG4gICAgICAgIC8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNhcnJheVxyXG4gICAgICAgIGZ1bmN0aW9uIElzQXJyYXkoYXJndW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXlcclxuICAgICAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShhcmd1bWVudClcclxuICAgICAgICAgICAgICAgIDogYXJndW1lbnQgaW5zdGFuY2VvZiBPYmplY3RcclxuICAgICAgICAgICAgICAgICAgICA/IGFyZ3VtZW50IGluc3RhbmNlb2YgQXJyYXlcclxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4yLjMgSXNDYWxsYWJsZShhcmd1bWVudClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXHJcbiAgICAgICAgZnVuY3Rpb24gSXNDYWxsYWJsZShhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2QuXHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09IFwiZnVuY3Rpb25cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4yLjQgSXNDb25zdHJ1Y3Rvcihhcmd1bWVudClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXHJcbiAgICAgICAgZnVuY3Rpb24gSXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gYXMgd2UgY2Fubm90IGNoZWNrIGZvciBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZC5cclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjIuNyBJc1Byb3BlcnR5S2V5KGFyZ3VtZW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzcHJvcGVydHlrZXlcclxuICAgICAgICBmdW5jdGlvbiBJc1Byb3BlcnR5S2V5KGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoVHlwZShhcmd1bWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBTdHJpbmcgKi86IHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFN5bWJvbCAqLzogcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4zIE9wZXJhdGlvbnMgb24gT2JqZWN0c1xyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24tb2JqZWN0c1xyXG4gICAgICAgIC8vIDcuMy45IEdldE1ldGhvZChWLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxyXG4gICAgICAgIGZ1bmN0aW9uIEdldE1ldGhvZChWLCBQKSB7XHJcbiAgICAgICAgICAgIHZhciBmdW5jID0gVltQXTtcclxuICAgICAgICAgICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCB8fCBmdW5jID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKCFJc0NhbGxhYmxlKGZ1bmMpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuYztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy40IE9wZXJhdGlvbnMgb24gSXRlcmF0b3IgT2JqZWN0c1xyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24taXRlcmF0b3Itb2JqZWN0c1xyXG4gICAgICAgIGZ1bmN0aW9uIEdldEl0ZXJhdG9yKG9iaikge1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gR2V0TWV0aG9kKG9iaiwgaXRlcmF0b3JTeW1ib2wpO1xyXG4gICAgICAgICAgICBpZiAoIUlzQ2FsbGFibGUobWV0aG9kKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gZnJvbSBDYWxsXHJcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG1ldGhvZC5jYWxsKG9iaik7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QoaXRlcmF0b3IpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuNC40IEl0ZXJhdG9yVmFsdWUoaXRlclJlc3VsdClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvMjAxNi8jc2VjLWl0ZXJhdG9ydmFsdWVcclxuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuNC41IEl0ZXJhdG9yU3RlcChpdGVyYXRvcilcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pdGVyYXRvcnN0ZXBcclxuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvclN0ZXAoaXRlcmF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gZmFsc2UgOiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXRlcmF0b3JjbG9zZVxyXG4gICAgICAgIGZ1bmN0aW9uIEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBpdGVyYXRvcltcInJldHVyblwiXTtcclxuICAgICAgICAgICAgaWYgKGYpXHJcbiAgICAgICAgICAgICAgICBmLmNhbGwoaXRlcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA5LjEgT3JkaW5hcnkgT2JqZWN0IEludGVybmFsIE1ldGhvZHMgYW5kIEludGVybmFsIFNsb3RzXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnktb2JqZWN0LWludGVybmFsLW1ldGhvZHMtYW5kLWludGVybmFsLXNsb3RzXHJcbiAgICAgICAgLy8gOS4xLjEuMSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnlnZXRwcm90b3R5cGVvZlxyXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTykge1xyXG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgTyAhPT0gXCJmdW5jdGlvblwiIHx8IE8gPT09IGZ1bmN0aW9uUHJvdG90eXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3Qgc2V0IF9fcHJvdG9fXyBpbiBFUzUsIGFzIGl0J3Mgbm9uLXN0YW5kYXJkLlxyXG4gICAgICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yLiBDb21wYXRpYmxlIGltcGxlbWVudGF0aW9uc1xyXG4gICAgICAgICAgICAvLyBtdXN0IGVpdGhlciBzZXQgX19wcm90b19fIG9uIGEgc3ViY2xhc3MgY29uc3RydWN0b3IgdG8gdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIC8vIG9yIGVuc3VyZSBlYWNoIGNsYXNzIGhhcyBhIHZhbGlkIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgb24gaXRzIHByb3RvdHlwZSB0aGF0XHJcbiAgICAgICAgICAgIC8vIHBvaW50cyBiYWNrIHRvIHRoZSBjb25zdHJ1Y3Rvci5cclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgRnVuY3Rpb24uW1tQcm90b3R5cGVdXSwgdGhlbiB0aGlzIGlzIGRlZmluYXRlbHkgaW5oZXJpdGVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gaW4gRVM2IG9yIHdoZW4gdXNpbmcgX19wcm90b19fIGluIGEgY29tcGF0aWJsZSBicm93c2VyLlxyXG4gICAgICAgICAgICBpZiAocHJvdG8gIT09IGZ1bmN0aW9uUHJvdG90eXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgc3VwZXIgcHJvdG90eXBlIGlzIE9iamVjdC5wcm90b3R5cGUsIG51bGwsIG9yIHVuZGVmaW5lZCwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IE8ucHJvdG90eXBlO1xyXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlUHJvdG8gPSBwcm90b3R5cGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSk7XHJcbiAgICAgICAgICAgIGlmIChwcm90b3R5cGVQcm90byA9PSBudWxsIHx8IHByb3RvdHlwZVByb3RvID09PSBPYmplY3QucHJvdG90eXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgY29uc3RydWN0b3Igd2FzIG5vdCBhIGZ1bmN0aW9uLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3IgPSBwcm90b3R5cGVQcm90by5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvciAhPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHNvbWUga2luZCBvZiBzZWxmLXJlZmVyZW5jZSwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cclxuICAgICAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBPKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xyXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcHJldHR5IGdvb2QgZ3Vlc3MgYXQgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5haXZlIE1hcCBzaGltXHJcbiAgICAgICAgZnVuY3Rpb24gQ3JlYXRlTWFwUG9seWZpbGwoKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWNoZVNlbnRpbmVsID0ge307XHJcbiAgICAgICAgICAgIHZhciBhcnJheVNlbnRpbmVsID0gW107XHJcbiAgICAgICAgICAgIHZhciBNYXBJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNYXBJdGVyYXRvcihrZXlzLCB2YWx1ZXMsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBrZXlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3NlbGVjdG9yKHRoaXMuX2tleXNbaW5kZXhdLCB0aGlzLl92YWx1ZXNbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA+PSB0aGlzLl9rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gYXJyYXlTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdCwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXBJdGVyYXRvcjtcclxuICAgICAgICAgICAgfSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNYXAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2tleXMubGVuZ3RoOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpID49IDA7IH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyB0aGlzLl92YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fa2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIDE7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXNbaSAtIDFdID0gdGhpcy5fa2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpIC0gMV0gPSB0aGlzLl92YWx1ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5sZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB0aGlzLl9jYWNoZUtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSAtMjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRLZXkpOyB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRWYWx1ZSk7IH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRFbnRyeSk7IH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVudHJpZXMoKTsgfTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuX2ZpbmQgPSBmdW5jdGlvbiAoa2V5LCBpbnNlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVLZXkgIT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gdGhpcy5fa2V5cy5pbmRleE9mKHRoaXMuX2NhY2hlS2V5ID0ga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlSW5kZXggPCAwICYmIGluc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gdGhpcy5fa2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVJbmRleDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgICAgICAgICB9KCkpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRLZXkoa2V5LCBfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKF8sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RW50cnkoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBuYWl2ZSBTZXQgc2hpbVxyXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZVNldFBvbHlmaWxsKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNldCgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAgPSBuZXcgX01hcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldC5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuc2l6ZTsgfSxcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLnNldCh2YWx1ZSwgdmFsdWUpLCB0aGlzOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5kZWxldGUodmFsdWUpOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fbWFwLmNsZWFyKCk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAua2V5cygpOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAudmFsdWVzKCk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZVtcIkBAaXRlcmF0b3JcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleXMoKTsgfTtcclxuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlzKCk7IH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V0O1xyXG4gICAgICAgICAgICB9KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBuYWl2ZSBXZWFrTWFwIHNoaW1cclxuICAgICAgICBmdW5jdGlvbiBDcmVhdGVXZWFrTWFwUG9seWZpbGwoKSB7XHJcbiAgICAgICAgICAgIHZhciBVVUlEX1NJWkUgPSAxNjtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBIYXNoTWFwLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICB2YXIgcm9vdEtleSA9IENyZWF0ZVVuaXF1ZUtleSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IEhhc2hNYXAuaGFzKHRhYmxlLCB0aGlzLl9rZXkpIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBIYXNoTWFwLmdldCh0YWJsZSwgdGhpcy5fa2V5KSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0YWJsZVt0aGlzLl9rZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IEdldE9yQ3JlYXRlV2Vha01hcFRhYmxlKHRhcmdldCwgLypjcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBkZWxldGUgdGFibGVbdGhpcy5fa2V5XSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IG5vdCBhIHJlYWwgY2xlYXIsIGp1c3QgbWFrZXMgdGhlIHByZXZpb3VzIGRhdGEgdW5yZWFjaGFibGVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gV2Vha01hcDtcclxuICAgICAgICAgICAgfSgpKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQ3JlYXRlVW5pcXVlS2V5KCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gXCJAQFdlYWtNYXBAQFwiICsgQ3JlYXRlVVVJRCgpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKEhhc2hNYXAuaGFzKGtleXMsIGtleSkpO1xyXG4gICAgICAgICAgICAgICAga2V5c1trZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCBjcmVhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzT3duLmNhbGwodGFyZ2V0LCByb290S2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3JlYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHJvb3RLZXksIHsgdmFsdWU6IEhhc2hNYXAuY3JlYXRlKCkgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Jvb3RLZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZpbGxSYW5kb21CeXRlcyhidWZmZXIsIHNpemUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IE1hdGgucmFuZG9tKCkgKiAweGZmIHwgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gR2VuUmFuZG9tQnl0ZXMoc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXNDcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWxsUmFuZG9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSksIHNpemUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbGxSYW5kb21CeXRlcyhuZXcgQXJyYXkoc2l6ZSksIHNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENyZWF0ZVVVSUQoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IEdlblJhbmRvbUJ5dGVzKFVVSURfU0laRSk7XHJcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIHJhbmRvbSAtIFJGQyA0MTIyIMKnIDQuNFxyXG4gICAgICAgICAgICAgICAgZGF0YVs2XSA9IGRhdGFbNl0gJiAweDRmIHwgMHg0MDtcclxuICAgICAgICAgICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdICYgMHhiZiB8IDB4ODA7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IFVVSURfU0laRTsgKytvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZSA9IGRhdGFbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09PSA0IHx8IG9mZnNldCA9PT0gNiB8fCBvZmZzZXQgPT09IDgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIi1cIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZSA8IDE2KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGJ5dGUudG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVzZXMgYSBoZXVyaXN0aWMgdXNlZCBieSB2OCBhbmQgY2hha3JhIHRvIGZvcmNlIGFuIG9iamVjdCBpbnRvIGRpY3Rpb25hcnkgbW9kZS5cclxuICAgICAgICBmdW5jdGlvbiBNYWtlRGljdGlvbmFyeShvYmopIHtcclxuICAgICAgICAgICAgb2JqLl9fID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBkZWxldGUgb2JqLl9fO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KShSZWZsZWN0IHx8IChSZWZsZWN0ID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVmbGVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWZsZWN0LW1ldGFkYXRhL1JlZmxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMSkpKDEyMCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3pvbmUuanMvZGlzdC96b25lLW5vZGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZmlyc3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2ZpcnN0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmlyc3QgPSBmaXJzdF8xLmZpcnN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmlyc3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvZmlyc3QuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMSkpKDkxKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL29mLmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxKSkoOTIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2NvbmNhdE1hcC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMSkpKDM4KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tYXAuanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fbWV0YWRhdGE7XHJcbnZhciBfX2F3YWl0ZXI7XHJcbnZhciBfX2dlbmVyYXRvcjtcclxudmFyIF9fZXhwb3J0U3RhcjtcclxudmFyIF9fdmFsdWVzO1xyXG52YXIgX19yZWFkO1xyXG52YXIgX19zcHJlYWQ7XHJcbnZhciBfX2F3YWl0O1xyXG52YXIgX19hc3luY0dlbmVyYXRvcjtcclxudmFyIF9fYXN5bmNEZWxlZ2F0b3I7XHJcbnZhciBfX2FzeW5jVmFsdWVzO1xyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3Q7XHJcbnZhciBfX2ltcG9ydFN0YXI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQ7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAoZXhwb3J0cykgeyBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMpKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzLCBwcmV2aW91cykge1xyXG4gICAgICAgIGlmIChleHBvcnRzICE9PSByb290KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHYpIHsgcmV0dXJuIGV4cG9ydHNbaWRdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZCwgdikgOiB2OyB9O1xyXG4gICAgfVxyXG59KVxyXG4oZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVzdCA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2RlY29yYXRlID0gZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH07XHJcblxyXG4gICAgX19wYXJhbSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2V4cG9ydFN0YXIgPSBmdW5jdGlvbiAobSwgZXhwb3J0cykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH07XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0RlbGVnYXRvciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIGksIHA7XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKG9bbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH07IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnRTdGFyID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICAgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydERlZmF1bHQgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kcyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdCk7XHJcbiAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbSk7XHJcbiAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnRTdGFyXCIsIF9faW1wb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0RGVmYXVsdFwiLCBfX2ltcG9ydERlZmF1bHQpO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMSkpKDg4KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljL2J1bmRsZXMvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NS4yLjNcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicpLCByZXF1aXJlKCdAYW5ndWxhci9hbmltYXRpb25zJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnJvd3NlcicpKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9hbmltYXRpb25zJywgWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicsICdAYW5ndWxhci9hbmltYXRpb25zJywgJ0Bhbmd1bGFyL2FuaW1hdGlvbnMvYnJvd3NlciddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXIgPSBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyIHx8IHt9LCBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyLmFuaW1hdGlvbnMgPSB7fSksZ2xvYmFsLm5nLmNvcmUsZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlcixnbG9iYWwubmcuYW5pbWF0aW9ucyxnbG9iYWwubmcuYW5pbWF0aW9ucy5icm93c2VyKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb3JlLF9hbmd1bGFyX3BsYXRmb3JtQnJvd3NlcixfYW5ndWxhcl9hbmltYXRpb25zLF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3NlcikgeyAndXNlIHN0cmljdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NS4yLjNcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyb3dzZXJBbmltYXRpb25CdWlsZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJBbmltYXRpb25CdWlsZGVyKHJvb3RSZW5kZXJlciwgZG9jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9uZXh0QW5pbWF0aW9uSWQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlRGF0YSA9IC8qKiBAdHlwZSB7P30gKi8gKHtcbiAgICAgICAgICAgIGlkOiAnMCcsXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBzdHlsZXM6IFtdLFxuICAgICAgICAgICAgZGF0YTogeyBhbmltYXRpb246IFtdIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl9yZW5kZXJlciA9IC8qKiBAdHlwZSB7P30gKi8gKHJvb3RSZW5kZXJlci5jcmVhdGVSZW5kZXJlcihkb2MuYm9keSwgdHlwZURhdGEpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFuaW1hdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSB0aGlzLl9uZXh0QW5pbWF0aW9uSWQudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fbmV4dEFuaW1hdGlvbklkKys7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5ID0gQXJyYXkuaXNBcnJheShhbmltYXRpb24pID8gX2FuZ3VsYXJfYW5pbWF0aW9ucy5zZXF1ZW5jZShhbmltYXRpb24pIDogYW5pbWF0aW9uO1xuICAgICAgICBpc3N1ZUFuaW1hdGlvbkNvbW1hbmQodGhpcy5fcmVuZGVyZXIsIG51bGwsIGlkLCAncmVnaXN0ZXInLCBbZW50cnldKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeShpZCwgdGhpcy5fcmVuZGVyZXIpO1xuICAgIH07XG4gICAgQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEJyb3dzZXJBbmltYXRpb25CdWlsZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJGYWN0b3J5MiwgfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkRPQ1VNRU5ULF0gfSxdIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXI7XG59KF9hbmd1bGFyX2FuaW1hdGlvbnMuQW5pbWF0aW9uQnVpbGRlcikpO1xudmFyIEJyb3dzZXJBbmltYXRpb25GYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCcm93c2VyQW5pbWF0aW9uRmFjdG9yeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeShfaWQsIF9yZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5faWQgPSBfaWQ7XG4gICAgICAgIF90aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJlckFuaW1hdGlvblBsYXllcih0aGlzLl9pZCwgZWxlbWVudCwgb3B0aW9ucyB8fCB7fSwgdGhpcy5fcmVuZGVyZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEJyb3dzZXJBbmltYXRpb25GYWN0b3J5O1xufShfYW5ndWxhcl9hbmltYXRpb25zLkFuaW1hdGlvbkZhY3RvcnkpKTtcbnZhciBSZW5kZXJlckFuaW1hdGlvblBsYXllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZW5kZXJlckFuaW1hdGlvblBsYXllcihpZCwgZWxlbWVudCwgb3B0aW9ucywgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMucGFyZW50UGxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvdGFsVGltZSA9IDA7XG4gICAgICAgIHRoaXMuX2NvbW1hbmQoJ2NyZWF0ZScsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5fbGlzdGVuID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudCwgXCJAQFwiICsgdGhpcy5pZCArIFwiOlwiICsgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5fY29tbWFuZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tbWFuZFxuICAgICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzc3VlQW5pbWF0aW9uQ29tbWFuZCh0aGlzLl9yZW5kZXJlciwgdGhpcy5lbGVtZW50LCB0aGlzLmlkLCBjb21tYW5kLCBhcmdzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fbGlzdGVuKCdkb25lJywgZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZuKSB7IHRoaXMuX2xpc3Rlbignc3RhcnQnLCBmbik7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uRGVzdHJveSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmbikgeyB0aGlzLl9saXN0ZW4oJ2Rlc3Ryb3knLCBmbik7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaW5pdCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9jb21tYW5kKCdpbml0Jyk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZW5kZXJlckFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhcnRlZDsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvbW1hbmQoJ3BsYXknKTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9jb21tYW5kKCdwYXVzZScpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5fY29tbWFuZCgncmVzdGFydCcpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmZpbmlzaCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9jb21tYW5kKCdmaW5pc2gnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5kZXN0cm95ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbW1hbmQoJ2Rlc3Ryb3knKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkgeyB0aGlzLl9jb21tYW5kKCdyZXNldCcpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocCkgeyB0aGlzLl9jb21tYW5kKCdzZXRQb3NpdGlvbicsIHApOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9O1xuICAgIHJldHVybiBSZW5kZXJlckFuaW1hdGlvblBsYXllcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBpZFxuICogQHBhcmFtIHs/fSBjb21tYW5kXG4gKiBAcGFyYW0gez99IGFyZ3NcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzc3VlQW5pbWF0aW9uQ29tbWFuZChyZW5kZXJlciwgZWxlbWVudCwgaWQsIGNvbW1hbmQsIGFyZ3MpIHtcbiAgICByZXR1cm4gcmVuZGVyZXIuc2V0UHJvcGVydHkoZWxlbWVudCwgXCJAQFwiICsgaWQgKyBcIjpcIiArIGNvbW1hbmQsIGFyZ3MpO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQU5JTUFUSU9OX1BSRUZJWCA9ICdAJztcbnZhciBESVNBQkxFX0FOSU1BVElPTlNfRkxBRyA9ICdALmRpc2FibGVkJztcbnZhciBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5KGRlbGVnYXRlLCBlbmdpbmUsIF96b25lKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fY3VycmVudElkID0gMDtcbiAgICAgICAgdGhpcy5fbWljcm90YXNrSWQgPSAxO1xuICAgICAgICB0aGlzLl9hbmltYXRpb25DYWxsYmFja3NCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2RSZWN1ckRlcHRoID0gMDtcbiAgICAgICAgZW5naW5lLm9uUmVtb3ZhbENvbXBsZXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBpZiBhbiBjb21wb25lbnQgZWxlbWVudCBoYXMgYSBsZWF2ZSBhbmltYXRpb24sIGFuZCB0aGUgY29tcG9uZW50XG4gICAgICAgICAgICAvLyBhIGhvc3QgbGVhdmUgYW5pbWF0aW9uLCB0aGUgdmlldyBlbmdpbmUgd2lsbCBjYWxsIGByZW1vdmVDaGlsZGAgZm9yIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCByZW5kZXJlciBhcyB3ZWxsIGFzIGZvciB0aGUgY2hpbGQgY29tcG9uZW50IHJlbmRlcmVyLlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGFscmVhZHkgcmVtb3ZlZCB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSAmJiBkZWxlZ2F0ZS5wYXJlbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgZGVsZWdhdGUucmVtb3ZlQ2hpbGQoZWxlbWVudC5wYXJlbnROb2RlLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVSZW5kZXJlciA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdEVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChob3N0RWxlbWVudCwgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBFTVBUWV9OQU1FU1BBQ0VfSUQgPSAnJztcbiAgICAgICAgLy8gY2FjaGUgdGhlIGRlbGVnYXRlcyB0byBmaW5kIG91dCB3aGljaCBjYWNoZWQgZGVsZWdhdGUgY2FuXG4gICAgICAgIC8vIGJlIHVzZWQgYnkgd2hpY2ggY2FjaGVkIHJlbmRlcmVyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlbGVnYXRlID0gdGhpcy5kZWxlZ2F0ZS5jcmVhdGVSZW5kZXJlcihob3N0RWxlbWVudCwgdHlwZSk7XG4gICAgICAgIGlmICghaG9zdEVsZW1lbnQgfHwgIXR5cGUgfHwgIXR5cGUuZGF0YSB8fCAhdHlwZS5kYXRhWydhbmltYXRpb24nXSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlckNhY2hlLmdldChkZWxlZ2F0ZSk7XG4gICAgICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIgPSBuZXcgQmFzZUFuaW1hdGlvblJlbmRlcmVyKEVNUFRZX05BTUVTUEFDRV9JRCwgZGVsZWdhdGUsIHRoaXMuZW5naW5lKTtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNhY2hlIHRoaXMgcmVzdWx0IHdoZW4gdGhlIGJhc2UgcmVuZGVyZXIgaXMgdXNlZFxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyQ2FjaGUuc2V0KGRlbGVnYXRlLCByZW5kZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50SWQgPSB0eXBlLmlkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lc3BhY2VJZCA9IHR5cGUuaWQgKyAnLScgKyB0aGlzLl9jdXJyZW50SWQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRJZCsrO1xuICAgICAgICB0aGlzLmVuZ2luZS5yZWdpc3RlcihuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbmltYXRpb25UcmlnZ2VycyA9IC8qKiBAdHlwZSB7P30gKi8gKHR5cGUuZGF0YVsnYW5pbWF0aW9uJ10pO1xuICAgICAgICBhbmltYXRpb25UcmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZW5naW5lLnJlZ2lzdGVyVHJpZ2dlcihjb21wb25lbnRJZCwgbmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50LCB0cmlnZ2VyLm5hbWUsIHRyaWdnZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25SZW5kZXJlcih0aGlzLCBuYW1lc3BhY2VJZCwgZGVsZWdhdGUsIHRoaXMuZW5naW5lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS5iZWdpbiA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jZFJlY3VyRGVwdGgrKztcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuYmVnaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYmVnaW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLl9zY2hlZHVsZUNvdW50VGFzayA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBab25lLmN1cnJlbnQuc2NoZWR1bGVNaWNyb1Rhc2soJ2luY3JlbWVuZXQgdGhlIGFuaW1hdGlvbiBtaWNyb3Rhc2snLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbWljcm90YXNrSWQrKzsgfSk7XG4gICAgfTtcbiAgICAvKiBAaW50ZXJuYWwgKi9cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvdW50XG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEBwYXJhbSB7P30gZGF0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LnByb3RvdHlwZS5zY2hlZHVsZUxpc3RlbmVyQ2FsbGJhY2sgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvdW50XG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEBwYXJhbSB7P30gZGF0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvdW50LCBmbiwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY291bnQgPj0gMCAmJiBjb3VudCA8IHRoaXMuX21pY3JvdGFza0lkKSB7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBmbihkYXRhKTsgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbkNhbGxiYWNrc0J1ZmZlci5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRpb25DYWxsYmFja3NCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAodHVwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHR1cGxlWzBdLCBkYXRhID0gdHVwbGVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBmbihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRpb25DYWxsYmFja3NCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkNhbGxiYWNrc0J1ZmZlci5wdXNoKFtmbiwgZGF0YV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkucHJvdG90eXBlLmVuZCA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jZFJlY3VyRGVwdGgtLTtcbiAgICAgICAgLy8gdGhpcyBpcyB0byBwcmV2ZW50IGFuaW1hdGlvbnMgZnJvbSBydW5uaW5nIHR3aWNlIHdoZW4gYW4gaW5uZXJcbiAgICAgICAgLy8gY29tcG9uZW50IGRvZXMgQ0Qgd2hlbiBhIHBhcmVudCBjb21wb25lbnQgaW5zdGVkIGhhcyBpbnNlcnRlZCBpdFxuICAgICAgICBpZiAodGhpcy5fY2RSZWN1ckRlcHRoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zY2hlZHVsZUNvdW50VGFzaygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVuZ2luZS5mbHVzaChfdGhpcy5fbWljcm90YXNrSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVuZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeS5wcm90b3R5cGUud2hlblJlbmRlcmluZ0RvbmUgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW5naW5lLndoZW5SZW5kZXJpbmdEb25lKCk7IH07XG4gICAgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlckZhY3RvcnkyLCB9LFxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtUFuaW1hdGlvbkVuZ2luZSwgfSxcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBBbmltYXRpb25SZW5kZXJlckZhY3Rvcnk7XG59KCkpO1xudmFyIEJhc2VBbmltYXRpb25SZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlQW5pbWF0aW9uUmVuZGVyZXIobmFtZXNwYWNlSWQsIGRlbGVnYXRlLCBlbmdpbmUpIHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VJZCA9IG5hbWVzcGFjZUlkO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgICB0aGlzLmRlc3Ryb3lOb2RlID0gdGhpcy5kZWxlZ2F0ZS5kZXN0cm95Tm9kZSA/IGZ1bmN0aW9uIChuKSB7IHJldHVybiAoKGRlbGVnYXRlLmRlc3Ryb3lOb2RlKSkobik7IH0gOiBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZSwgXCJkYXRhXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZGF0YTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUuZGVzdHJveSh0aGlzLm5hbWVzcGFjZUlkLCB0aGlzLmRlbGVnYXRlKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5hbWUsIG5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5jcmVhdGVFbGVtZW50KG5hbWUsIG5hbWVzcGFjZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbW1lbnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUuY3JlYXRlQ29tbWVudCh2YWx1ZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlLmNyZWF0ZVRleHQodmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBuZXdDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBhcmVudCwgbmV3Q2hpbGQpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5hcHBlbmRDaGlsZChwYXJlbnQsIG5ld0NoaWxkKTtcbiAgICAgICAgdGhpcy5lbmdpbmUub25JbnNlcnQodGhpcy5uYW1lc3BhY2VJZCwgbmV3Q2hpbGQsIHBhcmVudCwgZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IG5ld0NoaWxkXG4gICAgICogQHBhcmFtIHs/fSByZWZDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gbmV3Q2hpbGRcbiAgICAgKiBAcGFyYW0gez99IHJlZkNoaWxkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFyZW50LCBuZXdDaGlsZCwgcmVmQ2hpbGQpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5pbnNlcnRCZWZvcmUocGFyZW50LCBuZXdDaGlsZCwgcmVmQ2hpbGQpO1xuICAgICAgICB0aGlzLmVuZ2luZS5vbkluc2VydCh0aGlzLm5hbWVzcGFjZUlkLCBuZXdDaGlsZCwgcGFyZW50LCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBvbGRDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBvbGRDaGlsZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBhcmVudCwgb2xkQ2hpbGQpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUub25SZW1vdmUodGhpcy5uYW1lc3BhY2VJZCwgb2xkQ2hpbGQsIHRoaXMuZGVsZWdhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3Rvck9yTm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZWxlY3RSb290RWxlbWVudCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JPck5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChzZWxlY3Rvck9yTm9kZSkgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zZWxlY3RSb290RWxlbWVudChzZWxlY3Rvck9yTm9kZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnBhcmVudE5vZGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlLnBhcmVudE5vZGUobm9kZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLm5leHRTaWJsaW5nID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5uZXh0U2libGluZyhub2RlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0QXR0cmlidXRlKGVsLCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5yZW1vdmVBdHRyaWJ1dGUoZWwsIG5hbWUsIG5hbWVzcGFjZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmFkZENsYXNzID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lKSB7IHRoaXMuZGVsZWdhdGUuYWRkQ2xhc3MoZWwsIG5hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUpIHsgdGhpcy5kZWxlZ2F0ZS5yZW1vdmVDbGFzcyhlbCwgbmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gZmxhZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2VBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuc2V0U3R5bGUgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBzdHlsZSwgdmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0U3R5bGUoZWwsIHN0eWxlLCB2YWx1ZSwgZmxhZ3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcbiAgICAgKiBAcGFyYW0gez89fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVTdHlsZSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHBhcmFtIHs/PX0gZmxhZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbCwgc3R5bGUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUucmVtb3ZlU3R5bGUoZWwsIHN0eWxlLCBmbGFncyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PSBBTklNQVRJT05fUFJFRklYICYmIG5hbWUgPT0gRElTQUJMRV9BTklNQVRJT05TX0ZMQUcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUFuaW1hdGlvbnMoZWwsICEhdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRQcm9wZXJ0eShlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLnNldFZhbHVlID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7IHRoaXMuZGVsZWdhdGUuc2V0VmFsdWUobm9kZSwgdmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCYXNlQW5pbWF0aW9uUmVuZGVyZXIucHJvdG90eXBlLmxpc3RlbiA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmxpc3Rlbih0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmFzZUFuaW1hdGlvblJlbmRlcmVyLnByb3RvdHlwZS5kaXNhYmxlQW5pbWF0aW9ucyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmVuZ2luZS5kaXNhYmxlQW5pbWF0aW9ucyhlbGVtZW50LCB2YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZUFuaW1hdGlvblJlbmRlcmVyO1xufSgpKTtcbnZhciBBbmltYXRpb25SZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5pbWF0aW9uUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uUmVuZGVyZXIoZmFjdG9yeSwgbmFtZXNwYWNlSWQsIGRlbGVnYXRlLCBlbmdpbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZXNwYWNlSWQsIGRlbGVnYXRlLCBlbmdpbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICBfdGhpcy5uYW1lc3BhY2VJZCA9IG5hbWVzcGFjZUlkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT0gQU5JTUFUSU9OX1BSRUZJWCkge1xuICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDEpID09ICcuJyAmJiBuYW1lID09IERJU0FCTEVfQU5JTUFUSU9OU19GTEFHKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlQW5pbWF0aW9ucyhlbCwgLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lLnByb2Nlc3ModGhpcy5uYW1lc3BhY2VJZCwgZWwsIG5hbWUuc3Vic3RyKDEpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFByb3BlcnR5KGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBbmltYXRpb25SZW5kZXJlci5wcm90b3R5cGUubGlzdGVuID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGV2ZW50TmFtZS5jaGFyQXQoMCkgPT0gQU5JTUFUSU9OX1BSRUZJWCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IHJlc29sdmVFbGVtZW50RnJvbVRhcmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZV8xID0gZXZlbnROYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBoYXNlID0gJyc7XG4gICAgICAgICAgICAvLyBAbGlzdGVuZXIucGhhc2UgaXMgZm9yIHRyaWdnZXIgYW5pbWF0aW9uIGNhbGxiYWNrc1xuICAgICAgICAgICAgLy8gQEBsaXN0ZW5lciBpcyBmb3IgYW5pbWF0aW9uIGJ1aWxkZXIgY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAobmFtZV8xLmNoYXJBdCgwKSAhPSBBTklNQVRJT05fUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgX2EgPSBwYXJzZVRyaWdnZXJDYWxsYmFja05hbWUobmFtZV8xKSwgbmFtZV8xID0gX2FbMF0sIHBoYXNlID0gX2FbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUubGlzdGVuKHRoaXMubmFtZXNwYWNlSWQsIGVsZW1lbnQsIG5hbWVfMSwgcGhhc2UsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvdW50SWQgPSAoLyoqIEB0eXBlIHs/fSAqLyAoZXZlbnQpKVsnX2RhdGEnXSB8fCAtMTtcbiAgICAgICAgICAgICAgICBfdGhpcy5mYWN0b3J5LnNjaGVkdWxlTGlzdGVuZXJDYWxsYmFjayhjb3VudElkLCBjYWxsYmFjaywgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubGlzdGVuKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25SZW5kZXJlcjtcbn0oQmFzZUFuaW1hdGlvblJlbmRlcmVyKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZXNvbHZlRWxlbWVudEZyb21UYXJnZXQodGFyZ2V0KSB7XG4gICAgc3dpdGNoICh0YXJnZXQpIHtcbiAgICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICBjYXNlICd3aW5kb3cnOlxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IHRyaWdnZXJOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwYXJzZVRyaWdnZXJDYWxsYmFja05hbWUodHJpZ2dlck5hbWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkb3RJbmRleCA9IHRyaWdnZXJOYW1lLmluZGV4T2YoJy4nKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmlnZ2VyID0gdHJpZ2dlck5hbWUuc3Vic3RyaW5nKDAsIGRvdEluZGV4KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaGFzZSA9IHRyaWdnZXJOYW1lLnN1YnN0cihkb3RJbmRleCArIDEpO1xuICAgIHJldHVybiBbdHJpZ2dlciwgcGhhc2VdO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmplY3RhYmxlQW5pbWF0aW9uRW5naW5lKGRyaXZlciwgbm9ybWFsaXplcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZHJpdmVyLCBub3JtYWxpemVyKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbmplY3RhYmxlQW5pbWF0aW9uRW5naW5lLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBJbmplY3RhYmxlQW5pbWF0aW9uRW5naW5lLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci5BbmltYXRpb25Ecml2ZXIsIH0sXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIEluamVjdGFibGVBbmltYXRpb25FbmdpbmU7XG59KF9hbmd1bGFyX2FuaW1hdGlvbnNfYnJvd3Nlci7JtUFuaW1hdGlvbkVuZ2luZSkpO1xuLyoqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVN1cHBvcnRlZEFuaW1hdGlvbkRyaXZlcigpIHtcbiAgICBpZiAoX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1c3VwcG9ydHNXZWJBbmltYXRpb25zKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuybVXZWJBbmltYXRpb25zRHJpdmVyKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1Tm9vcEFuaW1hdGlvbkRyaXZlcigpO1xufVxuLyoqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZURlZmF1bHRTdHlsZU5vcm1hbGl6ZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuybVXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyKCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcmVuZGVyZXJcbiAqIEBwYXJhbSB7P30gZW5naW5lXG4gKiBAcGFyYW0gez99IHpvbmVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVuZGVyZXJGYWN0b3J5KHJlbmRlcmVyLCBlbmdpbmUsIHpvbmUpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeShyZW5kZXJlciwgZW5naW5lLCB6b25lKTtcbn1cbnZhciBTSEFSRURfQU5JTUFUSU9OX1BST1ZJREVSUyA9IFtcbiAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2FuaW1hdGlvbnMuQW5pbWF0aW9uQnVpbGRlciwgdXNlQ2xhc3M6IEJyb3dzZXJBbmltYXRpb25CdWlsZGVyIH0sXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuybVBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIsIHVzZUZhY3Rvcnk6IGluc3RhbnRpYXRlRGVmYXVsdFN0eWxlTm9ybWFsaXplciB9LFxuICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1QW5pbWF0aW9uRW5naW5lLCB1c2VDbGFzczogSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZSB9LCB7XG4gICAgICAgIHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJGYWN0b3J5MixcbiAgICAgICAgdXNlRmFjdG9yeTogaW5zdGFudGlhdGVSZW5kZXJlckZhY3RvcnksXG4gICAgICAgIGRlcHM6IFtfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuybVEb21SZW5kZXJlckZhY3RvcnkyLCBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuybVBbmltYXRpb25FbmdpbmUsIF9hbmd1bGFyX2NvcmUuTmdab25lXVxuICAgIH1cbl07XG4vKipcbiAqIFNlcGFyYXRlIHByb3ZpZGVycyBmcm9tIHRoZSBhY3R1YWwgbW9kdWxlIHNvIHRoYXQgd2UgY2FuIGRvIGEgbG9jYWwgbW9kaWZpY2F0aW9uIGluIEdvb2dsZTMgdG9cbiAqIGluY2x1ZGUgdGhlbSBpbiB0aGUgQnJvd3Nlck1vZHVsZS5cbiAqL1xudmFyIEJST1dTRVJfQU5JTUFUSU9OU19QUk9WSURFUlMgPSBbXG4gICAgeyBwcm92aWRlOiBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuQW5pbWF0aW9uRHJpdmVyLCB1c2VGYWN0b3J5OiBpbnN0YW50aWF0ZVN1cHBvcnRlZEFuaW1hdGlvbkRyaXZlciB9XG5dLmNvbmNhdChTSEFSRURfQU5JTUFUSU9OX1BST1ZJREVSUyk7XG4vKipcbiAqIFNlcGFyYXRlIHByb3ZpZGVycyBmcm9tIHRoZSBhY3R1YWwgbW9kdWxlIHNvIHRoYXQgd2UgY2FuIGRvIGEgbG9jYWwgbW9kaWZpY2F0aW9uIGluIEdvb2dsZTMgdG9cbiAqIGluY2x1ZGUgdGhlbSBpbiB0aGUgQnJvd3NlclRlc3RpbmdNb2R1bGUuXG4gKi9cbnZhciBCUk9XU0VSX05PT1BfQU5JTUFUSU9OU19QUk9WSURFUlMgPSBbeyBwcm92aWRlOiBfYW5ndWxhcl9hbmltYXRpb25zX2Jyb3dzZXIuQW5pbWF0aW9uRHJpdmVyLCB1c2VDbGFzczogX2FuZ3VsYXJfYW5pbWF0aW9uc19icm93c2VyLsm1Tm9vcEFuaW1hdGlvbkRyaXZlciB9XS5jb25jYXQoU0hBUkVEX0FOSU1BVElPTl9QUk9WSURFUlMpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKi9cbnZhciBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSgpIHtcbiAgICB9XG4gICAgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkJyb3dzZXJNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IEJST1dTRVJfQU5JTUFUSU9OU19QUk9WSURFUlMsXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBCcm93c2VyQW5pbWF0aW9uc01vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBCcm93c2VyQW5pbWF0aW9uc01vZHVsZTtcbn0oKSk7XG4vKipcbiAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gKi9cbnZhciBOb29wQW5pbWF0aW9uc01vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb29wQW5pbWF0aW9uc01vZHVsZSgpIHtcbiAgICB9XG4gICAgTm9vcEFuaW1hdGlvbnNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkJyb3dzZXJNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IEJST1dTRVJfTk9PUF9BTklNQVRJT05TX1BST1ZJREVSUyxcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE5vb3BBbmltYXRpb25zTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE5vb3BBbmltYXRpb25zTW9kdWxlO1xufSgpKTtcblxuZXhwb3J0cy5Ccm93c2VyQW5pbWF0aW9uc01vZHVsZSA9IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlO1xuZXhwb3J0cy5Ob29wQW5pbWF0aW9uc01vZHVsZSA9IE5vb3BBbmltYXRpb25zTW9kdWxlO1xuZXhwb3J0cy7JtUJyb3dzZXJBbmltYXRpb25CdWlsZGVyID0gQnJvd3NlckFuaW1hdGlvbkJ1aWxkZXI7XG5leHBvcnRzLsm1QnJvd3NlckFuaW1hdGlvbkZhY3RvcnkgPSBCcm93c2VyQW5pbWF0aW9uRmFjdG9yeTtcbmV4cG9ydHMuybVBbmltYXRpb25SZW5kZXJlciA9IEFuaW1hdGlvblJlbmRlcmVyO1xuZXhwb3J0cy7JtUFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeSA9IEFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeTtcbmV4cG9ydHMuybVhID0gQmFzZUFuaW1hdGlvblJlbmRlcmVyO1xuZXhwb3J0cy7JtWYgPSBCUk9XU0VSX0FOSU1BVElPTlNfUFJPVklERVJTO1xuZXhwb3J0cy7JtWcgPSBCUk9XU0VSX05PT1BfQU5JTUFUSU9OU19QUk9WSURFUlM7XG5leHBvcnRzLsm1YiA9IEluamVjdGFibGVBbmltYXRpb25FbmdpbmU7XG5leHBvcnRzLsm1ZCA9IGluc3RhbnRpYXRlRGVmYXVsdFN0eWxlTm9ybWFsaXplcjtcbmV4cG9ydHMuybVlID0gaW5zdGFudGlhdGVSZW5kZXJlckZhY3Rvcnk7XG5leHBvcnRzLsm1YyA9IGluc3RhbnRpYXRlU3VwcG9ydGVkQW5pbWF0aW9uRHJpdmVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGxhdGZvcm0tYnJvd3Nlci1hbmltYXRpb25zLnVtZC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLWFuaW1hdGlvbnMudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKSg1KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcnhqcy9TdWJqZWN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSAuL3ZlbmRvclxuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxKSkoMzUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9idW5kbGVzL2NvbXBpbGVyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbi8vIEhBQ0s6IHRoaXMgaXMgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0YWJpbGl0eVxuLy8gVE9ETyhiZW5sZXNoKTogcmVtb3ZlIHRoaXMgaW4gdjYuXG5leHBvcnRzLnRvUHJvbWlzZSA9IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50b1Byb21pc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1Byb21pc2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci90b1Byb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIERPTUltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9ET01JbXBsZW1lbnRhdGlvbicpO1xudmFyIEhUTUxQYXJzZXIgPSByZXF1aXJlKCcuL0hUTUxQYXJzZXInKTtcbnZhciBXaW5kb3cgPSByZXF1aXJlKCcuL1dpbmRvdycpO1xuXG5leHBvcnRzLmNyZWF0ZURPTUltcGxlbWVudGF0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgRE9NSW1wbGVtZW50YXRpb24oKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlRG9jdW1lbnQgPSBmdW5jdGlvbihodG1sLCBmb3JjZSkge1xuICAvLyBQcmV2aW91cyBBUEkgY291bGRuJ3QgbGV0IHlvdSBwYXNzICcnIGFzIGEgZG9jdW1lbnQsIGFuZCB0aGF0XG4gIC8vIHlpZWxkcyBhIHNsaWdodGx5IGRpZmZlcmVudCBkb2N1bWVudCB0aGFuIGNyZWF0ZUhUTUxEb2N1bWVudCgnJylcbiAgLy8gZG9lcy4gIFRoZSBuZXcgYGZvcmNlYCBwYXJhbWV0ZXIgbGV0cyB5b3UgcGFzcyAnJyBpZiB5b3Ugd2FudCB0by5cbiAgaWYgKGh0bWwgfHwgZm9yY2UpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IEhUTUxQYXJzZXIoKTtcbiAgICBwYXJzZXIucGFyc2UoaHRtbCB8fCAnJywgdHJ1ZSk7XG4gICAgcmV0dXJuIHBhcnNlci5kb2N1bWVudCgpO1xuICB9XG4gIHJldHVybiBuZXcgRE9NSW1wbGVtZW50YXRpb24oKS5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIik7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVdpbmRvdyA9IGZ1bmN0aW9uKGh0bWwsIGFkZHJlc3MpIHtcbiAgdmFyIGRvY3VtZW50ID0gZXhwb3J0cy5jcmVhdGVEb2N1bWVudChodG1sKTtcbiAgaWYgKGFkZHJlc3MgIT09IHVuZGVmaW5lZCkgeyBkb2N1bWVudC5fYWRkcmVzcyA9IGFkZHJlc3M7IH1cbiAgcmV0dXJuIG5ldyBXaW5kb3coZG9jdW1lbnQpO1xufTtcblxuZXhwb3J0cy5pbXBsID0gcmVxdWlyZSgnLi9pbXBsJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyZWRFbGVtZW50TGlzdDtcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcblxuLy9cbi8vIFRoaXMgZmlsZSBkZWZpbmVzIG5vZGUgbGlzdCBpbXBsZW1lbnRhdGlvbiB0aGF0IGxhemlseSB0cmF2ZXJzZXNcbi8vIHRoZSBkb2N1bWVudCB0cmVlIChvciBhIHN1YnRyZWUgcm9vdGVkIGF0IGFueSBlbGVtZW50KSBhbmQgaW5jbHVkZXNcbi8vIG9ubHkgdGhvc2UgZWxlbWVudHMgZm9yIHdoaWNoIGEgc3BlY2lmaWVkIGZpbHRlciBmdW5jdGlvbiByZXR1cm5zIHRydWUuXG4vLyBJdCBpcyB1c2VkIHRvIGltcGxlbWVudCB0aGVcbi8vIHtEb2N1bWVudCxFbGVtZW50fS5nZXRFbGVtZW50c0J5e1RhZ05hbWUsQ2xhc3NOYW1lfXssTlN9IG1ldGhvZHMuXG4vL1xuXG5mdW5jdGlvbiBGaWx0ZXJlZEVsZW1lbnRMaXN0KHJvb3QsIGZpbHRlcikge1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgdGhpcy5sYXN0TW9kVGltZSA9IHJvb3QubGFzdE1vZFRpbWU7XG4gIHRoaXMuZG9uZSA9IGZhbHNlO1xuICB0aGlzLmNhY2hlID0gW107XG4gIHRoaXMudHJhdmVyc2UoKTtcbn1cblxuRmlsdGVyZWRFbGVtZW50TGlzdC5wcm90b3R5cGUgPSB7XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgdGhpcy5jaGVja2NhY2hlKCk7XG4gICAgaWYgKCF0aGlzLmRvbmUpIHRoaXMudHJhdmVyc2UoKTtcbiAgICByZXR1cm4gdGhpcy5jYWNoZS5sZW5ndGg7XG4gIH0sXG5cbiAgaXRlbTogZnVuY3Rpb24obikge1xuICAgIHRoaXMuY2hlY2tjYWNoZSgpO1xuICAgIGlmICghdGhpcy5kb25lICYmIG4gPj0gdGhpcy5jYWNoZS5sZW5ndGgpIHRoaXMudHJhdmVyc2Uobik7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVbbl07XG4gIH0sXG5cbiAgY2hlY2tjYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubGFzdE1vZFRpbWUgIT09IHRoaXMucm9vdC5sYXN0TW9kVGltZSkge1xuICAgICAgLy8gc3VidHJlZSBoYXMgY2hhbmdlZCwgc28gaW52YWxpZGF0ZSBjYWNoZVxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY2FjaGUubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmxhc3RNb2RUaW1lID0gdGhpcy5yb290Lmxhc3RNb2RUaW1lO1xuICAgIH1cbiAgfSxcblxuICAvLyBJZiBuIGlzIHNwZWNpZmllZCwgdGhlbiB0cmF2ZXJzZSB0aGUgdHJlZSB1bnRpbCB3ZSd2ZSBmb3VuZCB0aGUgbnRoXG4gIC8vIGl0ZW0gKG9yIHVudGlsIHdlJ3ZlIGZvdW5kIGFsbCBpdGVtcykuICBJZiBuIGlzIG5vdCBzcGVjaWZpZWQsXG4gIC8vIHRyYXZlcnNlIHVudGlsIHdlJ3ZlIGZvdW5kIGFsbCBpdGVtcy5cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uKG4pIHtcbiAgICAvLyBpbmNyZW1lbnQgbiBzbyB3ZSBjYW4gY29tcGFyZSB0byBsZW5ndGgsIGFuZCBzbyBpdCBpcyBuZXZlciBmYWxzeVxuICAgIGlmIChuICE9PSB1bmRlZmluZWQpIG4rKztcblxuICAgIHZhciBlbHQ7XG4gICAgd2hpbGUgKChlbHQgPSB0aGlzLm5leHQoKSkgIT09IG51bGwpIHtcbiAgICAgIHRoaXNbdGhpcy5jYWNoZS5sZW5ndGhdID0gZWx0OyAvL1hYWCBVc2UgcHJveHkgaW5zdGVhZFxuICAgICAgdGhpcy5jYWNoZS5wdXNoKGVsdCk7XG4gICAgICBpZiAobiAmJiB0aGlzLmNhY2hlLmxlbmd0aCA9PT0gbikgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG5vIG5leHQgZWxlbWVudCwgc28gd2UndmUgZm91bmQgZXZlcnl0aGluZ1xuICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gIH0sXG5cbiAgLy8gUmV0dXJuIHRoZSBuZXh0IGVsZW1lbnQgdW5kZXIgcm9vdCB0aGF0IG1hdGNoZXMgZmlsdGVyXG4gIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydCA9ICh0aGlzLmNhY2hlLmxlbmd0aCA9PT0gMCkgPyB0aGlzLnJvb3QgLy8gU3RhcnQgYXQgdGhlIHJvb3Qgb3IgYXRcbiAgICAgIDogdGhpcy5jYWNoZVt0aGlzLmNhY2hlLmxlbmd0aC0xXTsgLy8gdGhlIGxhc3QgZWxlbWVudCB3ZSBmb3VuZFxuXG4gICAgdmFyIGVsdDtcbiAgICBpZiAoc3RhcnQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSlcbiAgICAgIGVsdCA9IHN0YXJ0LmRvY3VtZW50RWxlbWVudDtcbiAgICBlbHNlXG4gICAgICBlbHQgPSBzdGFydC5uZXh0RWxlbWVudCh0aGlzLnJvb3QpO1xuXG4gICAgd2hpbGUoZWx0KSB7XG4gICAgICBpZiAodGhpcy5maWx0ZXIoZWx0KSkge1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgICAgfVxuXG4gICAgICBlbHQgPSBlbHQubmV4dEVsZW1lbnQodGhpcy5yb290KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL0ZpbHRlcmVkRWxlbWVudExpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBUcmVlV2Fsa2VyO1xuXG52YXIgTm9kZUZpbHRlciA9IHJlcXVpcmUoJy4vTm9kZUZpbHRlcicpO1xudmFyIE5vZGVUcmF2ZXJzYWwgPSByZXF1aXJlKCcuL05vZGVUcmF2ZXJzYWwnKTtcblxudmFyIG1hcENoaWxkID0ge1xuICBmaXJzdDogJ2ZpcnN0Q2hpbGQnLFxuICBsYXN0OiAnbGFzdENoaWxkJyxcbiAgbmV4dDogJ2ZpcnN0Q2hpbGQnLFxuICBwcmV2aW91czogJ2xhc3RDaGlsZCdcbn07XG5cbnZhciBtYXBTaWJsaW5nID0ge1xuICBmaXJzdDogJ25leHRTaWJsaW5nJyxcbiAgbGFzdDogJ3ByZXZpb3VzU2libGluZycsXG4gIG5leHQ6ICduZXh0U2libGluZycsXG4gIHByZXZpb3VzOiAncHJldmlvdXNTaWJsaW5nJ1xufTtcblxuLyogUHJpdmF0ZSBtZXRob2RzIGFuZCBoZWxwZXJzICovXG5cbi8qKlxuICogQHNwZWMgaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNjb25jZXB0LXRyYXZlcnNlLWNoaWxkcmVuXG4gKiBAbWV0aG9kXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqIEBwYXJhbSB7VHJlZVdhbGtlcn0gdHdcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIE9uZSBvZiAnZmlyc3QnIG9yICdsYXN0Jy5cbiAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VDaGlsZHJlbih0dywgdHlwZSkge1xuICB2YXIgY2hpbGQsIG5vZGUsIHBhcmVudCwgcmVzdWx0LCBzaWJsaW5nO1xuICBub2RlID0gdHcuY3VycmVudE5vZGVbbWFwQ2hpbGRbdHlwZV1dO1xuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIHJlc3VsdCA9IHR3LmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xuICAgIGlmIChyZXN1bHQgPT09IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCkge1xuICAgICAgdHcuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgPT09IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVApIHtcbiAgICAgIGNoaWxkID0gbm9kZVttYXBDaGlsZFt0eXBlXV07XG4gICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmcgPSBub2RlW21hcFNpYmxpbmdbdHlwZV1dO1xuICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHR3LnJvb3QgfHwgcGFyZW50ID09PSB0dy5jdXJyZW50Tm9kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2NvbmNlcHQtdHJhdmVyc2Utc2libGluZ3NcbiAqIEBtZXRob2RcbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICogQHBhcmFtIHtUcmVlV2Fsa2VyfSB0d1xuICogQHBhcmFtIHtUcmVlV2Fsa2VyfSB0eXBlIE9uZSBvZiAnbmV4dCcgb3IgJ3ByZXZpb3VzJy5cbiAqIEByZXR1cm4ge05vZGV8bnVsfVxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVNpYmxpbmdzKHR3LCB0eXBlKSB7XG4gIHZhciBub2RlLCByZXN1bHQsIHNpYmxpbmc7XG4gIG5vZGUgPSB0dy5jdXJyZW50Tm9kZTtcbiAgaWYgKG5vZGUgPT09IHR3LnJvb3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHNpYmxpbmcgPSBub2RlW21hcFNpYmxpbmdbdHlwZV1dO1xuICAgIHdoaWxlIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBub2RlID0gc2libGluZztcbiAgICAgIHJlc3VsdCA9IHR3LmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XG4gICAgICAgIHR3LmN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBzaWJsaW5nID0gbm9kZVttYXBDaGlsZFt0eXBlXV07XG4gICAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1QgfHwgc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBzaWJsaW5nID0gbm9kZVttYXBTaWJsaW5nW3R5cGVdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB0dy5yb290KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR3LmZpbHRlci5hY2NlcHROb2RlKG5vZGUpID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qIFB1YmxpYyBBUEkgKi9cblxuLyoqXG4gKiBJbXBsZW1lbnRlZCB2ZXJzaW9uOiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDE1L1dELWRvbS0yMDE1MDYxOC8jaW50ZXJmYWNlLXRyZWV3YWxrZXJcbiAqIExhdGVzdCB2ZXJzaW9uOiBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2ludGVyZmFjZS10cmVld2Fsa2VyXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge05vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aGF0VG9TaG93IFtvcHRpb25hbF1cbiAqIEBwYXJhbSB7RnVuY3Rpb258Tm9kZUZpbHRlcn0gZmlsdGVyIFtvcHRpb25hbF1cbiAqIEB0aHJvd3MgRXJyb3JcbiAqL1xuZnVuY3Rpb24gVHJlZVdhbGtlcihyb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpIHtcbiAgdmFyIHR3ID0gdGhpcywgYWN0aXZlID0gZmFsc2U7XG5cbiAgaWYgKCFyb290IHx8ICFyb290Lm5vZGVUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IE5PVF9TVVBQT1JURURfRVJSJyk7XG4gIH1cblxuICB0dy5yb290ID0gcm9vdDtcbiAgdHcud2hhdFRvU2hvdyA9IE51bWJlcih3aGF0VG9TaG93KSB8fCAwO1xuXG4gIHR3LmN1cnJlbnROb2RlID0gcm9vdDtcblxuICBpZiAodHlwZW9mIGZpbHRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpbHRlciA9IG51bGw7XG4gIH1cblxuICB0dy5maWx0ZXIgPSBPYmplY3QuY3JlYXRlKE5vZGVGaWx0ZXIucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHJldHVybiB7TnVtYmVyfSBDb25zdGFudCBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQsXG4gICAqICBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Qgb3IgTm9kZUZpbHRlci5GSUxURVJfU0tJUC5cbiAgICovXG4gIHR3LmZpbHRlci5hY2NlcHROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRE9NRXhjZXB0aW9uOiBJTlZBTElEX1NUQVRFX0VSUicpO1xuICAgIH1cblxuICAgIC8vIE1hcHMgbm9kZVR5cGUgdG8gd2hhdFRvU2hvd1xuICAgIGlmICghKCgoMSA8PCAobm9kZS5ub2RlVHlwZSAtIDEpKSAmIHR3LndoYXRUb1Nob3cpKSkge1xuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICB9XG5cbiAgICBhY3RpdmUgPSB0cnVlO1xuICAgIHJlc3VsdCA9IGZpbHRlcihub2RlKTtcbiAgICBhY3RpdmUgPSBmYWxzZTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cblRyZWVXYWxrZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUcmVlV2Fsa2VyLFxuXG4gIC8qKlxuICAgKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS10cmVld2Fsa2VyLXBhcmVudG5vZGVcbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBwYXJlbnROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIG5vZGUgIT09IHRoaXMucm9vdCkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChub2RlICE9PSBudWxsICYmIHRoaXMuZmlsdGVyLmFjY2VwdE5vZGUobm9kZSkgPT09IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCkge1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS10cmVld2Fsa2VyLWZpcnN0Y2hpbGRcbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBmaXJzdENoaWxkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ2hpbGRyZW4odGhpcywgJ2ZpcnN0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jZG9tLXRyZWV3YWxrZXItbGFzdGNoaWxkXG4gICAqIEBtZXRob2RcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgbGFzdENoaWxkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ2hpbGRyZW4odGhpcywgJ2xhc3QnKTtcbiAgfSxcblxuICAvKipcbiAgICogQHNwZWMgaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tdHJlZXdhbGtlci1wcmV2aW91c3NpYmxpbmdcbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBwcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhdmVyc2VTaWJsaW5ncyh0aGlzLCAncHJldmlvdXMnKTtcbiAgfSxcblxuICAvKipcbiAgICogQHNwZWMgaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tdHJlZXdhbGtlci1uZXh0c2libGluZ1xuICAgKiBAbWV0aG9kXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIG5leHRTaWJsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlU2libGluZ3ModGhpcywgJ25leHQnKTtcbiAgfSxcblxuICAvKipcbiAgICogQHNwZWMgaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tdHJlZXdhbGtlci1wcmV2aW91c25vZGVcbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBwcmV2aW91c05vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm9kZSwgcmVzdWx0LCBzaWJsaW5nO1xuICAgIG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIHdoaWxlIChub2RlICE9PSB0aGlzLnJvb3QpIHtcbiAgICAgIHNpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgIHdoaWxlIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBzaWJsaW5nO1xuICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xuICAgICAgICB3aGlsZSAocmVzdWx0ICE9PSBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1QgJiYgbm9kZS5sYXN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXIuYWNjZXB0Tm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQpIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy5yb290IHx8IG5vZGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICBpZiAodGhpcy5maWx0ZXIuYWNjZXB0Tm9kZShub2RlKSA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jZG9tLXRyZWV3YWxrZXItbmV4dG5vZGVcbiAgICogQGJhc2VkIG9uIFdlYktpdCdzIFRyZWVXYWxrZXI6Om5leHROb2RlXG4gICAqIGh0dHBzOi8vdHJhYy53ZWJraXQub3JnL2Jyb3dzZXIvdHJ1bmsvU291cmNlL1dlYkNvcmUvZG9tL1RyZWVXYWxrZXIuY3BwP3Jldj0xNzkxNDMjTDI1MlxuICAgKiBAbWV0aG9kXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIG5leHROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vZGUsIHJlc3VsdCwgZm9sbG93aW5nO1xuICAgIG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIHJlc3VsdCA9IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB3aGlsZSAocmVzdWx0ICE9PSBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1QgJiYgbm9kZS5maXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyLmFjY2VwdE5vZGUobm9kZSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCkge1xuICAgICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb2xsb3dpbmcgPSBOb2RlVHJhdmVyc2FsLm5leHRTa2lwcGluZ0NoaWxkcmVuKG5vZGUsIHRoaXMucm9vdCk7XG4gICAgICBpZiAoZm9sbG93aW5nICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBmb2xsb3dpbmc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB0aGlzLmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL1RyZWVXYWxrZXIuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlSXRlcmF0b3I7XG5cbnZhciBOb2RlRmlsdGVyID0gcmVxdWlyZSgnLi9Ob2RlRmlsdGVyJyk7XG52YXIgTm9kZVRyYXZlcnNhbCA9IHJlcXVpcmUoJy4vTm9kZVRyYXZlcnNhbCcpO1xuXG4vKiBQcml2YXRlIG1ldGhvZHMgYW5kIGhlbHBlcnMgKi9cblxuLyoqXG4gKiBAYmFzZWQgb24gV2ViS2l0J3MgTm9kZUl0ZXJhdG9yOjptb3ZlVG9OZXh0IGFuZCBOb2RlSXRlcmF0b3I6Om1vdmVUb1ByZXZpb3VzXG4gKiBodHRwczovL3RyYWMud2Via2l0Lm9yZy9icm93c2VyL3RydW5rL1NvdXJjZS9XZWJDb3JlL2RvbS9Ob2RlSXRlcmF0b3IuY3BwP3Jldj0xODYyNzkjTDUxXG4gKi9cbmZ1bmN0aW9uIG1vdmUobm9kZSwgc3RheVdpdGhpbiwgZGlyZWN0aW9uSXNOZXh0KSB7XG4gIGlmIChkaXJlY3Rpb25Jc05leHQpIHtcbiAgICByZXR1cm4gTm9kZVRyYXZlcnNhbC5uZXh0KG5vZGUsIHN0YXlXaXRoaW4pO1xuICB9IGVsc2Uge1xuICAgIGlmIChub2RlID09PSBzdGF5V2l0aGluKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIE5vZGVUcmF2ZXJzYWwucHJldmlvdXMobm9kZSwgbnVsbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2NvbmNlcHQtbm9kZWl0ZXJhdG9yLXRyYXZlcnNlXG4gKiBAbWV0aG9kXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqIEBwYXJhbSB7Tm9kZUl0ZXJhdG9yfSBuaVxuICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiBPbmUgb2YgJ25leHQnIG9yICdwcmV2aW91cycuXG4gKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlKG5pLCBkaXJlY3Rpb25Jc05leHQpIHtcbiAgdmFyIG5vZGUsIGJlZm9yZU5vZGU7XG4gIG5vZGUgPSBuaS5yZWZlcmVuY2VOb2RlO1xuICBiZWZvcmVOb2RlID0gbmkucG9pbnRlckJlZm9yZVJlZmVyZW5jZU5vZGU7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGJlZm9yZU5vZGUgPT09IGRpcmVjdGlvbklzTmV4dCkge1xuICAgICAgYmVmb3JlTm9kZSA9ICFiZWZvcmVOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gbW92ZShub2RlLCBuaS5yb290LCBkaXJlY3Rpb25Jc05leHQpO1xuICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBuaS5maWx0ZXIuYWNjZXB0Tm9kZShub2RlKTtcbiAgICBpZiAocmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBuaS5yZWZlcmVuY2VOb2RlID0gbm9kZTtcbiAgbmkucG9pbnRlckJlZm9yZVJlZmVyZW5jZU5vZGUgPSBiZWZvcmVOb2RlO1xuICByZXR1cm4gbm9kZTtcbn1cblxuLyogUHVibGljIEFQSSAqL1xuXG4vKipcbiAqIEltcGxlbWVudGVkIHZlcnNpb246IGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTUvV0QtZG9tLTIwMTUwNjE4LyNub2RlaXRlcmF0b3JcbiAqIExhdGVzdCB2ZXJzaW9uOiBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI25vZGVpdGVyYXRvclxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gd2hhdFRvU2hvdyBbb3B0aW9uYWxdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE5vZGVGaWx0ZXJ9IGZpbHRlciBbb3B0aW9uYWxdXG4gKiBAdGhyb3dzIEVycm9yXG4gKi9cbmZ1bmN0aW9uIE5vZGVJdGVyYXRvcihyb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpIHtcbiAgdmFyIG5pID0gdGhpcywgYWN0aXZlID0gZmFsc2U7XG5cbiAgaWYgKCFyb290IHx8ICFyb290Lm5vZGVUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IE5PVF9TVVBQT1JURURfRVJSJyk7XG4gIH1cblxuICBuaS5yb290ID0gbmkucmVmZXJlbmNlTm9kZSA9IHJvb3Q7XG4gIG5pLnBvaW50ZXJCZWZvcmVSZWZlcmVuY2VOb2RlID0gdHJ1ZTtcbiAgbmkud2hhdFRvU2hvdyA9IE51bWJlcih3aGF0VG9TaG93KSB8fCAwO1xuXG4gIGlmICh0eXBlb2YgZmlsdGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZmlsdGVyID0gbnVsbDtcbiAgfVxuXG4gIG5pLmZpbHRlciA9IE9iamVjdC5jcmVhdGUoTm9kZUZpbHRlci5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvbnN0YW50IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCxcbiAgICogIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCBvciBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQLlxuICAgKi9cbiAgbmkuZmlsdGVyLmFjY2VwdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IElOVkFMSURfU1RBVEVfRVJSJyk7XG4gICAgfVxuXG4gICAgLy8gTWFwcyBub2RlVHlwZSB0byB3aGF0VG9TaG93XG4gICAgaWYgKCEoKCgxIDw8IChub2RlLm5vZGVUeXBlIC0gMSkpICYgbmkud2hhdFRvU2hvdykpKSB7XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICB9XG5cbiAgICBpZiAoZmlsdGVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgIH1cblxuICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgcmVzdWx0ID0gZmlsdGVyKG5vZGUpO1xuICAgIGFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuTm9kZUl0ZXJhdG9yLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IE5vZGVJdGVyYXRvcixcblxuICAvKipcbiAgICogQHNwZWMgaHR0cDovL3d3dy53My5vcmcvVFIvZG9tLyNkb20tbm9kZWl0ZXJhdG9yLW5leHRub2RlXG4gICAqIEBtZXRob2RcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgbmV4dE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhdmVyc2UodGhpcywgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzcGVjIGh0dHA6Ly93d3cudzMub3JnL1RSL2RvbS8jZG9tLW5vZGVpdGVyYXRvci1wcmV2aW91c25vZGVcbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBwcmV2aW91c05vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhdmVyc2UodGhpcywgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc3BlYyBodHRwOi8vd3d3LnczLm9yZy9UUi9kb20vI2RvbS1ub2RlaXRlcmF0b3ItZGV0YWNoXG4gICAqIEBtZXRob2RcbiAgICogQHJldHVybiB2b2lkXG4gICAqL1xuICBkZXRhY2g6IGZ1bmN0aW9uKCkge1xuICAgIC8qIFwiVGhlIGRldGFjaCgpIG1ldGhvZCBtdXN0IGRvIG5vdGhpbmcuXG4gICAgICogSXRzIGZ1bmN0aW9uYWxpdHkgKGRpc2FibGluZyBhIE5vZGVJdGVyYXRvciBvYmplY3QpIHdhcyByZW1vdmVkLFxuICAgICAqIGJ1dCB0aGUgbWV0aG9kIGl0c2VsZiBpcyBwcmVzZXJ2ZWQgZm9yIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL05vZGVJdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEN1c3RvbUV2ZW50O1xuXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XG5cbmZ1bmN0aW9uIEN1c3RvbUV2ZW50KHR5cGUsIGRpY3Rpb25hcnkpIHtcbiAgLy8gSnVzdCB1c2UgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IgdG8gaW5pdGlhbGl6ZVxuICBFdmVudC5jYWxsKHRoaXMsIHR5cGUsIGRpY3Rpb25hcnkpO1xufVxuQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEN1c3RvbUV2ZW50IH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9DdXN0b21FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoganNoaW50IG5vZGU6dHJ1ZSwgbGF0ZWRlZjpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuLyohXG5QYXJzZXItTGliXG5Db3B5cmlnaHQgKGMpIDIwMDktMjAxMSBOaWNob2xhcyBDLiBaYWthcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuLyogVmVyc2lvbiB2MC4yLjUrZG9taW5vMSwgQnVpbGQgdGltZTogMzAtSmFudWFyeS0yMDE2IDA1OjEzOjAzICovXG52YXIgcGFyc2VybGliID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbihmdW5jdGlvbigpe1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBiYXNlIHRvIGluaGVyaXQgZnJvbSBmb3IgYW55IG9iamVjdFxuICogdGhhdCBuZWVkcyBldmVudCBoYW5kbGluZy5cbiAqIEBjbGFzcyBFdmVudFRhcmdldFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciB2YXJpb3VzIGV2ZW50cy5cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKiBAcHJvcGVydHkgX2xpc3RlbmVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuRXZlbnRUYXJnZXQucHJvdG90eXBlID0ge1xuXG4gICAgLy9yZXN0b3JlIGNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3I6IEV2ZW50VGFyZ2V0LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gYWRkIGEgbGlzdGVuZXIgZm9yLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBtZXRob2QgYWRkTGlzdGVuZXJcbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcjogZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpe1xuICAgICAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1t0eXBlXSl7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgYW4gZXZlbnQgYmFzZWQgb24gdGhlIHBhc3NlZC1pbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBldmVudCBBbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCBhICd0eXBlJyBhdHRyaWJ1dGVcbiAgICAgKiAgICAgIG9yIGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIGV2ZW50IG5hbWUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAbWV0aG9kIGZpcmVcbiAgICAgKi9cbiAgICBmaXJlOiBmdW5jdGlvbihldmVudCl7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICAgICAgZXZlbnQgPSB7IHR5cGU6IGV2ZW50IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudC50YXJnZXQgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQudHlwZSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBvYmplY3QgbWlzc2luZyAndHlwZScgcHJvcGVydHkuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tldmVudC50eXBlXSl7XG5cbiAgICAgICAgICAgIC8vY3JlYXRlIGEgY29weSBvZiB0aGUgYXJyYXkgYW5kIHVzZSB0aGF0IHNvIGxpc3RlbmVycyBjYW4ndCBjaGFuZVxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldmVudC50eXBlXS5jb25jYXQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbGVuPWxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIHJlbW92ZSBhIGxpc3RlbmVyIGZyb20uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBtZXRob2QgcmVtb3ZlTGlzdGVuZXJcbiAgICAgKi9cbiAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpe1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW3R5cGVdKXtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1saXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKXtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIENvbnZlbmllbnQgd2F5IHRvIHJlYWQgdGhyb3VnaCBzdHJpbmdzLlxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIudXRpbFxuICogQGNsYXNzIFN0cmluZ1JlYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byByZWFkLlxuICovXG5mdW5jdGlvbiBTdHJpbmdSZWFkZXIodGV4dCl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5wdXQgdGV4dCB3aXRoIGxpbmUgZW5kaW5ncyBub3JtYWxpemVkLlxuICAgICAqIEBwcm9wZXJ0eSBfaW5wdXRcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2lucHV0ID0gdGV4dC5yZXBsYWNlKC8oXFxyfFxcbil7MSwyfS9nLCBcIlxcblwiKTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIHJvdyBmb3IgdGhlIGNoYXJhY3RlciB0byBiZSByZWFkIG5leHQuXG4gICAgICogQHByb3BlcnR5IF9saW5lXG4gICAgICogQHR5cGUgaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9saW5lID0gMTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3RlciB0byBiZSByZWFkIG5leHQuXG4gICAgICogQHByb3BlcnR5IF9jb2xcbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NvbCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQgdG8gYmUgcmVhZCBuZXh0LlxuICAgICAqIEBwcm9wZXJ0eSBfY3Vyc29yXG4gICAgICogQHR5cGUgaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jdXJzb3IgPSAwO1xufVxuXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuXG4gICAgLy9yZXN0b3JlIGNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3I6IFN0cmluZ1JlYWRlcixcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBvc2l0aW9uIGluZm9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbHVtbiBvZiB0aGUgY2hhcmFjdGVyIHRvIGJlIHJlYWQgbmV4dC5cbiAgICAgKiBAcmV0dXJuIHtpbnR9IFRoZSBjb2x1bW4gb2YgdGhlIGNoYXJhY3RlciB0byBiZSByZWFkIG5leHQuXG4gICAgICogQG1ldGhvZCBnZXRDb2xcbiAgICAgKi9cbiAgICBnZXRDb2w6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2w7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJvdyBvZiB0aGUgY2hhcmFjdGVyIHRvIGJlIHJlYWQgbmV4dC5cbiAgICAgKiBAcmV0dXJuIHtpbnR9IFRoZSByb3cgb2YgdGhlIGNoYXJhY3RlciB0byBiZSByZWFkIG5leHQuXG4gICAgICogQG1ldGhvZCBnZXRMaW5lXG4gICAgICovXG4gICAgZ2V0TGluZTogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmUgO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHlvdSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZXJlJ3Mgbm8gbW9yZSBpbnB1dCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBtZXRob2QgZW9mXG4gICAgICovXG4gICAgZW9mOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gKHRoaXMuX2N1cnNvciA9PT0gdGhpcy5faW5wdXQubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQmFzaWMgcmVhZGluZ1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIG5leHQgY2hhcmFjdGVyIHdpdGhvdXQgYWR2YW5jaW5nIHRoZSBjdXJzb3IuXG4gICAgICogQHBhcmFtIHtpbnR9IGNvdW50IEhvdyBtYW55IGNoYXJhY3RlcnMgdG8gbG9vayBhaGVhZCAoZGVmYXVsdCBpcyAxKS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBuZXh0IGNoYXJhY3RlciBvciBudWxsIGlmIHRoZXJlIGlzIG5vIG5leHQgY2hhcmFjdGVyLlxuICAgICAqIEBtZXRob2QgcGVla1xuICAgICAqL1xuICAgIHBlZWs6IGZ1bmN0aW9uKGNvdW50KXtcbiAgICAgICAgdmFyIGMgPSBudWxsO1xuICAgICAgICBjb3VudCA9ICh0eXBlb2YgY291bnQgPT09IFwidW5kZWZpbmVkXCIgPyAxIDogY291bnQpO1xuXG4gICAgICAgIC8vaWYgd2UncmUgbm90IGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0Li4uXG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IgPCB0aGlzLl9pbnB1dC5sZW5ndGgpe1xuXG4gICAgICAgICAgICAvL2dldCBjaGFyYWN0ZXIgYW5kIGluY3JlbWVudCBjdXJzb3IgYW5kIGNvbHVtblxuICAgICAgICAgICAgYyA9IHRoaXMuX2lucHV0LmNoYXJBdCh0aGlzLl9jdXJzb3IgKyBjb3VudCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBpbnB1dCBhbmQgYWRqdXN0cyB0aGUgcm93IGFuZCBjb2x1bW5cbiAgICAgKiBhY2NvcmRpbmdseS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBuZXh0IGNoYXJhY3RlciBvciBudWxsIGlmIHRoZXJlIGlzIG5vIG5leHQgY2hhcmFjdGVyLlxuICAgICAqIEBtZXRob2QgcmVhZFxuICAgICAqL1xuICAgIHJlYWQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBjID0gbnVsbDtcblxuICAgICAgICAvL2lmIHdlJ3JlIG5vdCBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4uLlxuICAgICAgICBpZiAodGhpcy5fY3Vyc29yIDwgdGhpcy5faW5wdXQubGVuZ3RoKXtcblxuICAgICAgICAgICAgLy9pZiB0aGUgbGFzdCBjaGFyYWN0ZXIgd2FzIGEgbmV3bGluZSwgaW5jcmVtZW50IHJvdyBjb3VudFxuICAgICAgICAgICAgLy9hbmQgcmVzZXQgY29sdW1uIGNvdW50XG4gICAgICAgICAgICBpZiAodGhpcy5faW5wdXQuY2hhckF0KHRoaXMuX2N1cnNvcikgPT09IFwiXFxuXCIpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmUrKztcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2w9MTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZ2V0IGNoYXJhY3RlciBhbmQgaW5jcmVtZW50IGN1cnNvciBhbmQgY29sdW1uXG4gICAgICAgICAgICBjID0gdGhpcy5faW5wdXQuY2hhckF0KHRoaXMuX2N1cnNvcisrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBNaXNjXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBzbyBpdCBjYW4gYmUgcmV0dXJuZWQgdG8gbGF0ZXIuXG4gICAgICogQG1ldGhvZCBtYXJrXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBtYXJrOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLl9ib29rbWFyayA9IHtcbiAgICAgICAgICAgIGN1cnNvcjogdGhpcy5fY3Vyc29yLFxuICAgICAgICAgICAgbGluZTogICB0aGlzLl9saW5lLFxuICAgICAgICAgICAgY29sOiAgICB0aGlzLl9jb2xcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICh0aGlzLl9ib29rbWFyayl7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSB0aGlzLl9ib29rbWFyay5jdXJzb3I7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gdGhpcy5fYm9va21hcmsubGluZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbCA9IHRoaXMuX2Jvb2ttYXJrLmNvbDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ib29rbWFyaztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBBZHZhbmNlZCByZWFkaW5nXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB1cCB0byBhbmQgaW5jbHVkaW5nIHRoZSBnaXZlbiBzdHJpbmcuIFRocm93cyBhbiBlcnJvciBpZiB0aGF0XG4gICAgICogc3RyaW5nIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiBUaGUgc3RyaW5nIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgc3RyaW5nIHdoZW4gaXQgaXMgZm91bmQuXG4gICAgICogQHRocm93cyBFcnJvciB3aGVuIHRoZSBzdHJpbmcgcGF0dGVybiBpcyBub3QgZm91bmQuXG4gICAgICogQG1ldGhvZCByZWFkVG9cbiAgICAgKi9cbiAgICByZWFkVG86IGZ1bmN0aW9uKHBhdHRlcm4pe1xuXG4gICAgICAgIHZhciBidWZmZXIgPSBcIlwiLFxuICAgICAgICAgICAgYztcblxuICAgICAgICAvKlxuICAgICAgICAgKiBGaXJzdCwgYnVmZmVyIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBwYXR0ZXJuLlxuICAgICAgICAgKiBUaGVuLCBidWZmZXIgbXVzdCBlbmQgd2l0aCB0aGUgcGF0dGVybiBvciBlbHNlIHJlYWNoIHRoZVxuICAgICAgICAgKiBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgd2hpbGUgKGJ1ZmZlci5sZW5ndGggPCBwYXR0ZXJuLmxlbmd0aCB8fCBidWZmZXIubGFzdEluZGV4T2YocGF0dGVybikgIT09IGJ1ZmZlci5sZW5ndGggLSBwYXR0ZXJuLmxlbmd0aCl7XG4gICAgICAgICAgICBjID0gdGhpcy5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoYyl7XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHBhdHRlcm4gKyBcIlxcXCIgYXQgbGluZSBcIiArIHRoaXMuX2xpbmUgICsgXCIsIGNvbCBcIiArIHRoaXMuX2NvbCArIFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidWZmZXI7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgY2hhcmFjdGVycyB3aGlsZSBlYWNoIGNoYXJhY3RlciBjYXVzZXMgdGhlIGdpdmVuXG4gICAgICogZmlsdGVyIGZ1bmN0aW9uIHRvIHJldHVybiB0cnVlLiBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkXG4gICAgICogaW4gZWFjaCBjaGFyYWN0ZXIgYW5kIGVpdGhlciByZXR1cm5zIHRydWUgdG8gY29udGludWVcbiAgICAgKiByZWFkaW5nIG9yIGZhbHNlIHRvIHN0b3AuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyIFRoZSBmdW5jdGlvbiB0byByZWFkIG9uIGVhY2ggY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHN0cmluZyBtYWRlIHVwIG9mIGFsbCBjaGFyYWN0ZXJzIHRoYXQgcGFzc2VkIHRoZVxuICAgICAqICAgICAgZmlsdGVyIGNoZWNrLlxuICAgICAqIEBtZXRob2QgcmVhZFdoaWxlXG4gICAgICovXG4gICAgcmVhZFdoaWxlOiBmdW5jdGlvbihmaWx0ZXIpe1xuXG4gICAgICAgIHZhciBidWZmZXIgPSBcIlwiLFxuICAgICAgICAgICAgYyA9IHRoaXMucmVhZCgpO1xuXG4gICAgICAgIHdoaWxlKGMgIT09IG51bGwgJiYgZmlsdGVyKGMpKXtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjO1xuICAgICAgICAgICAgYyA9IHRoaXMucmVhZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBjaGFyYWN0ZXJzIHRoYXQgbWF0Y2ggZWl0aGVyIHRleHQgb3IgYSByZWd1bGFyIGV4cHJlc3Npb24gYW5kXG4gICAgICogcmV0dXJucyB0aG9zZSBjaGFyYWN0ZXJzLiBJZiBhIG1hdGNoIGlzIGZvdW5kLCB0aGUgcm93IGFuZCBjb2x1bW5cbiAgICAgKiBhcmUgYWRqdXN0ZWQ7IGlmIG5vIG1hdGNoIGlzIGZvdW5kLCB0aGUgcmVhZGVyJ3Mgc3RhdGUgaXMgdW5jaGFuZ2VkLlxuICAgICAqIHJlYWRpbmcgb3IgZmFsc2UgdG8gc3RvcC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IG1hdGNodGVyIElmIGEgc3RyaW5nLCB0aGVuIHRoZSBsaXRlcmFsIHN0cmluZ1xuICAgICAqICAgICAgdmFsdWUgaXMgc2VhcmNoZWQgZm9yLiBJZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhlbiBhbnkgc3RyaW5nXG4gICAgICogICAgICBtYXRjaGluZyB0aGUgcGF0dGVybiBpcyBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHN0cmluZyBtYWRlIHVwIG9mIGFsbCBjaGFyYWN0ZXJzIHRoYXQgbWF0Y2hlZCBvclxuICAgICAqICAgICAgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXG4gICAgICogQG1ldGhvZCByZWFkTWF0Y2hcbiAgICAgKi9cbiAgICByZWFkTWF0Y2g6IGZ1bmN0aW9uKG1hdGNoZXIpe1xuXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5fY3Vyc29yKSxcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcblxuICAgICAgICAvL2lmIGl0J3MgYSBzdHJpbmcsIGp1c3QgZG8gYSBzdHJhaWdodCBtYXRjaFxuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5pbmRleE9mKG1hdGNoZXIpID09PSAwKXtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmVhZENvdW50KG1hdGNoZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKXtcbiAgICAgICAgICAgIGlmIChtYXRjaGVyLnRlc3Qoc291cmNlKSl7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJlYWRDb3VudChSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBnaXZlbiBudW1iZXIgb2YgY2hhcmFjdGVycy4gSWYgdGhlIGVuZCBvZiB0aGUgaW5wdXQgaXMgcmVhY2hlZCxcbiAgICAgKiBpdCByZWFkcyBvbmx5IHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBhbmQgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHtpbnR9IGNvdW50IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHN0cmluZyBtYWRlIHVwIHRoZSByZWFkIGNoYXJhY3RlcnMuXG4gICAgICogQG1ldGhvZCByZWFkQ291bnRcbiAgICAgKi9cbiAgICByZWFkQ291bnQ6IGZ1bmN0aW9uKGNvdW50KXtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IFwiXCI7XG5cbiAgICAgICAgd2hpbGUoY291bnQtLSl7XG4gICAgICAgICAgICBidWZmZXIgKz0gdGhpcy5yZWFkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cblxufTtcbi8qKlxuICogVHlwZSB0byB1c2Ugd2hlbiBhIHN5bnRheCBlcnJvciBvY2N1cnMuXG4gKiBAY2xhc3MgU3ludGF4RXJyb3JcbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLnV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBhdCB3aGljaCB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gKiBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gYXQgd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxuICovXG5mdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlLCBsaW5lLCBjb2wpe1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbHVtbiBhdCB3aGljaCB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gICAgICogQHR5cGUgaW50XG4gICAgICogQHByb3BlcnR5IGNvbFxuICAgICAqL1xuICAgIHRoaXMuY29sID0gY29sO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpbmUgYXQgd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxuICAgICAqIEB0eXBlIGludFxuICAgICAqIEBwcm9wZXJ0eSBsaW5lXG4gICAgICovXG4gICAgdGhpcy5saW5lID0gbGluZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSB0ZXh0XG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxufVxuXG4vL2luaGVyaXQgZnJvbSBFcnJvclxuU3ludGF4RXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblN5bnRheEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bnRheEVycm9yOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbi8qKlxuICogQmFzZSB0eXBlIHRvIHJlcHJlc2VudCBhIHNpbmdsZSBzeW50YWN0aWMgdW5pdC5cbiAqIEBjbGFzcyBTeW50YXhVbml0XG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi51dGlsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IG9mIHRoZSB1bml0LlxuICogQHBhcmFtIHtpbnR9IGxpbmUgVGhlIGxpbmUgb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqL1xuZnVuY3Rpb24gU3ludGF4VW5pdCh0ZXh0LCBsaW5lLCBjb2wsIHR5cGUpe1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKiBAcHJvcGVydHkgY29sXG4gICAgICovXG4gICAgdGhpcy5jb2wgPSBjb2w7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGluZSBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gICAgICogQHR5cGUgaW50XG4gICAgICogQHByb3BlcnR5IGxpbmVcbiAgICAgKi9cbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHByb3BlcnR5IHRleHRcbiAgICAgKi9cbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2Ygc3ludGF4IHVuaXQuXG4gICAgICogQHR5cGUgaW50XG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzeW50YXggdW5pdCBiYXNlZCBzb2xlbHkgb24gdGhlIGdpdmVuIHRva2VuLlxuICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5ldyBzeW50YXggdW5pdCB3aGVuXG4gKiBpdCByZXByZXNlbnRzIGEgc2luZ2xlIHRva2VuIGluc3RlYWQgb2YgbXVsdGlwbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW4gVGhlIHRva2VuIG9iamVjdCB0byByZXByZXNlbnQuXG4gKiBAcmV0dXJuIHtwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0fSBUaGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdG9rZW4uXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGZyb21Ub2tlblxuICovXG5TeW50YXhVbml0LmZyb21Ub2tlbiA9IGZ1bmN0aW9uKHRva2VuKXtcbiAgICByZXR1cm4gbmV3IFN5bnRheFVuaXQodG9rZW4udmFsdWUsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xufTtcblxuU3ludGF4VW5pdC5wcm90b3R5cGUgPSB7XG5cbiAgICAvL3Jlc3RvcmUgY29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3RvcjogU3ludGF4VW5pdCxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAgICAgKiBAbWV0aG9kIHZhbHVlT2ZcbiAgICAgKi9cbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBHZW5lcmljIFRva2VuU3RyZWFtIHByb3ZpZGluZyBiYXNlIGZ1bmN0aW9uYWxpdHkuXG4gKiBAY2xhc3MgVG9rZW5TdHJlYW1CYXNlXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi51dGlsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1JlYWRlcn0gaW5wdXQgVGhlIHRleHQgdG8gdG9rZW5pemUgb3IgYSByZWFkZXIgZnJvbVxuICogICAgICB3aGljaCB0byByZWFkIHRoZSBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gVG9rZW5TdHJlYW1CYXNlKGlucHV0LCB0b2tlbkRhdGEpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZWFkZXIgZm9yIGVhc3kgYWNjZXNzIHRvIHRoZSB0ZXh0LlxuICAgICAqIEB0eXBlIFN0cmluZ1JlYWRlclxuICAgICAqIEBwcm9wZXJ0eSBfcmVhZGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yZWFkZXIgPSBpbnB1dCA/IG5ldyBTdHJpbmdSZWFkZXIoaW5wdXQudG9TdHJpbmcoKSkgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVG9rZW4gb2JqZWN0IGZvciB0aGUgbGFzdCBjb25zdW1lZCB0b2tlbi5cbiAgICAgKiBAdHlwZSBUb2tlblxuICAgICAqIEBwcm9wZXJ0eSBfdG9rZW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Rva2VuID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiB0b2tlbiBpbmZvcm1hdGlvbi5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBwcm9wZXJ0eSBfdG9rZW5EYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90b2tlbkRhdGEgPSB0b2tlbkRhdGE7XG5cbiAgICAvKipcbiAgICAgKiBMb29rYWhlYWQgdG9rZW4gYnVmZmVyLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByb3BlcnR5IF9sdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbHQgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIExvb2thaGVhZCB0b2tlbiBidWZmZXIgaW5kZXguXG4gICAgICogQHR5cGUgaW50XG4gICAgICogQHByb3BlcnR5IF9sdEluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9sdEluZGV4ID0gMDtcblxuICAgIHRoaXMuX2x0SW5kZXhDYWNoZSA9IFtdO1xufVxuXG4vKipcbiAqIEFjY2VwdHMgYW4gYXJyYXkgb2YgdG9rZW4gaW5mb3JtYXRpb24gYW5kIG91dHB1dHNcbiAqIGFuIGFycmF5IG9mIHRva2VuIGRhdGEgY29udGFpbmluZyBrZXktdmFsdWUgbWFwcGluZ3NcbiAqIGFuZCBtYXRjaGluZyBmdW5jdGlvbnMgdGhhdCB0aGUgVG9rZW5TdHJlYW0gbmVlZHMuXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbnMgQW4gYXJyYXkgb2YgdG9rZW4gZGVzY3JpcHRvcnMuXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgcHJvY2Vzc2VkIHRva2VuIGRhdGEuXG4gKiBAbWV0aG9kIGNyZWF0ZVRva2VuRGF0YVxuICogQHN0YXRpY1xuICovXG5Ub2tlblN0cmVhbUJhc2UuY3JlYXRlVG9rZW5EYXRhID0gZnVuY3Rpb24odG9rZW5zKXtcblxuICAgIHZhciBuYW1lTWFwICAgICA9IFtdLFxuICAgICAgICB0eXBlTWFwICAgICA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIHRva2VuRGF0YSAgICAgPSB0b2tlbnMuY29uY2F0KFtdKSxcbiAgICAgICAgaSAgICAgICAgICAgID0gMCxcbiAgICAgICAgbGVuICAgICAgICAgICAgPSB0b2tlbkRhdGEubGVuZ3RoKzE7XG5cbiAgICB0b2tlbkRhdGEuVU5LTk9XTiA9IC0xO1xuICAgIHRva2VuRGF0YS51bnNoaWZ0KHtuYW1lOlwiRU9GXCJ9KTtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICBuYW1lTWFwLnB1c2godG9rZW5EYXRhW2ldLm5hbWUpO1xuICAgICAgICB0b2tlbkRhdGFbdG9rZW5EYXRhW2ldLm5hbWVdID0gaTtcbiAgICAgICAgaWYgKHRva2VuRGF0YVtpXS50ZXh0KXtcbiAgICAgICAgICAgIHR5cGVNYXBbdG9rZW5EYXRhW2ldLnRleHRdID0gaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRva2VuRGF0YS5uYW1lID0gZnVuY3Rpb24odHQpe1xuICAgICAgICByZXR1cm4gbmFtZU1hcFt0dF07XG4gICAgfTtcblxuICAgIHRva2VuRGF0YS50eXBlID0gZnVuY3Rpb24oYyl7XG4gICAgICAgIHJldHVybiB0eXBlTWFwW2NdO1xuICAgIH07XG5cbiAgICByZXR1cm4gdG9rZW5EYXRhO1xufTtcblxuVG9rZW5TdHJlYW1CYXNlLnByb3RvdHlwZSA9IHtcblxuICAgIC8vcmVzdG9yZSBjb25zdHJ1Y3RvclxuICAgIGNvbnN0cnVjdG9yOiBUb2tlblN0cmVhbUJhc2UsXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBNYXRjaGluZyBtZXRob2RzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIGdpdmVuIHRva2VuIHR5cGUuXG4gICAgICogSWYgc28sIHRoYXQgdG9rZW4gaXMgY29uc3VtZWQ7IGlmIG5vdCwgdGhlIHRva2VuIGlzIHBsYWNlZFxuICAgICAqIGJhY2sgb250byB0aGUgdG9rZW4gc3RyZWFtLiBZb3UgY2FuIHBhc3MgaW4gYW55IG51bWJlciBvZlxuICAgICAqIHRva2VuIHR5cGVzIGFuZCB0aGlzIHdpbGwgcmV0dXJuIHRydWUgaWYgYW55IG9mIHRoZSB0b2tlblxuICAgICAqIHR5cGVzIGlzIGZvdW5kLlxuICAgICAqIEBwYXJhbSB7aW50fGludFtdfSB0b2tlblR5cGVzIEVpdGhlciBhIHNpbmdsZSB0b2tlbiB0eXBlIG9yIGFuIGFycmF5IG9mXG4gICAgICogICAgICB0b2tlbiB0eXBlcyB0aGF0IHRoZSBuZXh0IHRva2VuIG1pZ2h0IGJlLiBJZiBhbiBhcnJheSBpcyBwYXNzZWQsXG4gICAgICogICAgICBpdCdzIGFzc3VtZWQgdGhhdCB0aGUgdG9rZW4gY2FuIGJlIGFueSBvZiB0aGVzZS5cbiAgICAgKiBAcGFyYW0ge3ZhcmlhbnR9IGNoYW5uZWwgKE9wdGlvbmFsKSBUaGUgY2hhbm5lbCB0byByZWFkIGZyb20uIElmIG5vdFxuICAgICAqICAgICAgcHJvdmlkZWQsIHJlYWRzIGZyb20gdGhlIGRlZmF1bHQgKHVubmFtZWQpIGNoYW5uZWwuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdG9rZW4gdHlwZSBtYXRjaGVzLCBmYWxzZSBpZiBub3QuXG4gICAgICogQG1ldGhvZCBtYXRjaFxuICAgICAqL1xuICAgIG1hdGNoOiBmdW5jdGlvbih0b2tlblR5cGVzLCBjaGFubmVsKXtcblxuICAgICAgICAvL2Fsd2F5cyBjb252ZXJ0IHRvIGFuIGFycmF5LCBtYWtlcyB0aGluZ3MgZWFzaWVyXG4gICAgICAgIGlmICghKHRva2VuVHlwZXMgaW5zdGFuY2VvZiBBcnJheSkpe1xuICAgICAgICAgICAgdG9rZW5UeXBlcyA9IFt0b2tlblR5cGVzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0dCAgPSB0aGlzLmdldChjaGFubmVsKSxcbiAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICBsZW4gPSB0b2tlblR5cGVzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZShpIDwgbGVuKXtcbiAgICAgICAgICAgIGlmICh0dCA9PT0gdG9rZW5UeXBlc1tpKytdKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm8gbWF0Y2ggZm91bmQsIHB1dCB0aGUgdG9rZW4gYmFja1xuICAgICAgICB0aGlzLnVuZ2V0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBnaXZlbiB0b2tlbiB0eXBlLlxuICAgICAqIElmIHNvLCB0aGF0IHRva2VuIGlzIGNvbnN1bWVkOyBpZiBub3QsIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICAgKiBAcGFyYW0ge2ludHxpbnRbXX0gdG9rZW5UeXBlcyBFaXRoZXIgYSBzaW5nbGUgdG9rZW4gdHlwZSBvciBhbiBhcnJheSBvZlxuICAgICAqICAgICAgdG9rZW4gdHlwZXMgdGhhdCB0aGUgbmV4dCB0b2tlbiBzaG91bGQgYmUuIElmIGFuIGFycmF5IGlzIHBhc3NlZCxcbiAgICAgKiAgICAgIGl0J3MgYXNzdW1lZCB0aGF0IHRoZSB0b2tlbiBtdXN0IGJlIG9uZSBvZiB0aGVzZS5cbiAgICAgKiBAcGFyYW0ge3ZhcmlhbnR9IGNoYW5uZWwgKE9wdGlvbmFsKSBUaGUgY2hhbm5lbCB0byByZWFkIGZyb20uIElmIG5vdFxuICAgICAqICAgICAgcHJvdmlkZWQsIHJlYWRzIGZyb20gdGhlIGRlZmF1bHQgKHVubmFtZWQpIGNoYW5uZWwuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAbWV0aG9kIG11c3RNYXRjaFxuICAgICAqL1xuICAgIG11c3RNYXRjaDogZnVuY3Rpb24odG9rZW5UeXBlcywgY2hhbm5lbCl7XG5cbiAgICAgICAgdmFyIHRva2VuO1xuXG4gICAgICAgIC8vYWx3YXlzIGNvbnZlcnQgdG8gYW4gYXJyYXksIG1ha2VzIHRoaW5ncyBlYXNpZXJcbiAgICAgICAgaWYgKCEodG9rZW5UeXBlcyBpbnN0YW5jZW9mIEFycmF5KSl7XG4gICAgICAgICAgICB0b2tlblR5cGVzID0gW3Rva2VuVHlwZXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpe1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLkxUKDEpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiRXhwZWN0ZWQgXCIgKyB0aGlzLl90b2tlbkRhdGFbdG9rZW5UeXBlc1swXV0ubmFtZSArXG4gICAgICAgICAgICAgICAgXCIgYXQgbGluZSBcIiArIHRva2VuLnN0YXJ0TGluZSArIFwiLCBjb2wgXCIgKyB0b2tlbi5zdGFydENvbCArIFwiLlwiLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb25zdW1pbmcgbWV0aG9kc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogS2VlcHMgcmVhZGluZyBmcm9tIHRoZSB0b2tlbiBzdHJlYW0gdW50aWwgZWl0aGVyIG9uZSBvZiB0aGUgc3BlY2lmaWVkXG4gICAgICogdG9rZW4gdHlwZXMgaXMgZm91bmQgb3IgdW50aWwgdGhlIGVuZCBvZiB0aGUgaW5wdXQgaXMgcmVhY2hlZC5cbiAgICAgKiBAcGFyYW0ge2ludHxpbnRbXX0gdG9rZW5UeXBlcyBFaXRoZXIgYSBzaW5nbGUgdG9rZW4gdHlwZSBvciBhbiBhcnJheSBvZlxuICAgICAqICAgICAgdG9rZW4gdHlwZXMgdGhhdCB0aGUgbmV4dCB0b2tlbiBzaG91bGQgYmUuIElmIGFuIGFycmF5IGlzIHBhc3NlZCxcbiAgICAgKiAgICAgIGl0J3MgYXNzdW1lZCB0aGF0IHRoZSB0b2tlbiBtdXN0IGJlIG9uZSBvZiB0aGVzZS5cbiAgICAgKiBAcGFyYW0ge3ZhcmlhbnR9IGNoYW5uZWwgKE9wdGlvbmFsKSBUaGUgY2hhbm5lbCB0byByZWFkIGZyb20uIElmIG5vdFxuICAgICAqICAgICAgcHJvdmlkZWQsIHJlYWRzIGZyb20gdGhlIGRlZmF1bHQgKHVubmFtZWQpIGNoYW5uZWwuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAbWV0aG9kIGFkdmFuY2VcbiAgICAgKi9cbiAgICBhZHZhbmNlOiBmdW5jdGlvbih0b2tlblR5cGVzLCBjaGFubmVsKXtcblxuICAgICAgICB3aGlsZSh0aGlzLkxBKDApICE9PSAwICYmICF0aGlzLm1hdGNoKHRva2VuVHlwZXMsIGNoYW5uZWwpKXtcbiAgICAgICAgICAgIHRoaXMuZ2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5MQSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3VtZXMgdGhlIG5leHQgdG9rZW4gZnJvbSB0aGUgdG9rZW4gc3RyZWFtLlxuICAgICAqIEByZXR1cm4ge2ludH0gVGhlIHRva2VuIHR5cGUgb2YgdGhlIHRva2VuIHRoYXQgd2FzIGp1c3QgY29uc3VtZWQuXG4gICAgICogQG1ldGhvZCBnZXRcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKGNoYW5uZWwpe1xuXG4gICAgICAgIHZhciB0b2tlbkluZm8gICA9IHRoaXMuX3Rva2VuRGF0YSxcbiAgICAgICAgICAgIGkgICAgICAgICAgID0wLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBpbmZvO1xuXG4gICAgICAgIC8vY2hlY2sgdGhlIGxvb2thaGVhZCBidWZmZXIgZmlyc3RcbiAgICAgICAgaWYgKHRoaXMuX2x0Lmxlbmd0aCAmJiB0aGlzLl9sdEluZGV4ID49IDAgJiYgdGhpcy5fbHRJbmRleCA8IHRoaXMuX2x0Lmxlbmd0aCl7XG5cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gdGhpcy5fbHRbdGhpcy5fbHRJbmRleCsrXTtcbiAgICAgICAgICAgIGluZm8gPSB0b2tlbkluZm9bdGhpcy5fdG9rZW4udHlwZV07XG5cbiAgICAgICAgICAgIC8vb2JleSBjaGFubmVscyBsb2dpY1xuICAgICAgICAgICAgd2hpbGUoKGluZm8uY2hhbm5lbCAhPT0gdW5kZWZpbmVkICYmIGNoYW5uZWwgIT09IGluZm8uY2hhbm5lbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbHRJbmRleCA8IHRoaXMuX2x0Lmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSB0aGlzLl9sdFt0aGlzLl9sdEluZGV4KytdO1xuICAgICAgICAgICAgICAgIGluZm8gPSB0b2tlbkluZm9bdGhpcy5fdG9rZW4udHlwZV07XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2hlcmUgYmUgZHJhZ29uc1xuICAgICAgICAgICAgaWYgKChpbmZvLmNoYW5uZWwgPT09IHVuZGVmaW5lZCB8fCBjaGFubmVsID09PSBpbmZvLmNoYW5uZWwpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2x0SW5kZXggPD0gdGhpcy5fbHQubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9sdEluZGV4Q2FjaGUucHVzaChpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW4udHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2FsbCB0b2tlbiByZXRyaWV2ZXIgbWV0aG9kXG4gICAgICAgIHRva2VuID0gdGhpcy5fZ2V0VG9rZW4oKTtcblxuICAgICAgICAvL2lmIGl0IHNob3VsZCBiZSBoaWRkZW4sIGRvbid0IHNhdmUgYSB0b2tlblxuICAgICAgICBpZiAodG9rZW4udHlwZSA+IC0xICYmICF0b2tlbkluZm9bdG9rZW4udHlwZV0uaGlkZSl7XG5cbiAgICAgICAgICAgIC8vYXBwbHkgdG9rZW4gY2hhbm5lbFxuICAgICAgICAgICAgdG9rZW4uY2hhbm5lbCA9IHRva2VuSW5mb1t0b2tlbi50eXBlXS5jaGFubmVsO1xuXG4gICAgICAgICAgICAvL3NhdmUgZm9yIGxhdGVyXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdGhpcy5fbHQucHVzaCh0b2tlbik7XG5cbiAgICAgICAgICAgIC8vc2F2ZSBzcGFjZSB0aGF0IHdpbGwgYmUgbW92ZWQgKG11c3QgYmUgZG9uZSBiZWZvcmUgYXJyYXkgaXMgdHJ1bmNhdGVkKVxuICAgICAgICAgICAgdGhpcy5fbHRJbmRleENhY2hlLnB1c2godGhpcy5fbHQubGVuZ3RoIC0gdGhpcy5fbHRJbmRleCArIGkpO1xuXG4gICAgICAgICAgICAvL2tlZXAgdGhlIGJ1ZmZlciB1bmRlciA1IGl0ZW1zXG4gICAgICAgICAgICBpZiAodGhpcy5fbHQubGVuZ3RoID4gNSl7XG4gICAgICAgICAgICAgICAgdGhpcy5fbHQuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9hbHNvIGtlZXAgdGhlIHNoaWZ0IGJ1ZmZlciB1bmRlciA1IGl0ZW1zXG4gICAgICAgICAgICBpZiAodGhpcy5fbHRJbmRleENhY2hlLmxlbmd0aCA+IDUpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2x0SW5kZXhDYWNoZS5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3VwZGF0ZSBsb29rYWhlYWQgaW5kZXhcbiAgICAgICAgICAgIHRoaXMuX2x0SW5kZXggPSB0aGlzLl9sdC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKiBTa2lwIHRvIHRoZSBuZXh0IHRva2VuIGlmOlxuICAgICAgICAgKiAxLiBUaGUgdG9rZW4gdHlwZSBpcyBtYXJrZWQgYXMgaGlkZGVuLlxuICAgICAgICAgKiAyLiBUaGUgdG9rZW4gdHlwZSBoYXMgYSBjaGFubmVsIHNwZWNpZmllZCBhbmQgaXQgaXNuJ3QgdGhlIGN1cnJlbnQgY2hhbm5lbC5cbiAgICAgICAgICovXG4gICAgICAgIGluZm8gPSB0b2tlbkluZm9bdG9rZW4udHlwZV07XG4gICAgICAgIGlmIChpbmZvICYmXG4gICAgICAgICAgICAgICAgKGluZm8uaGlkZSB8fFxuICAgICAgICAgICAgICAgIChpbmZvLmNoYW5uZWwgIT09IHVuZGVmaW5lZCAmJiBjaGFubmVsICE9PSBpbmZvLmNoYW5uZWwpKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoY2hhbm5lbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3JldHVybiBqdXN0IHRoZSB0eXBlXG4gICAgICAgICAgICByZXR1cm4gdG9rZW4udHlwZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb29rcyBhaGVhZCBhIGNlcnRhaW4gbnVtYmVyIG9mIHRva2VucyBhbmQgcmV0dXJucyB0aGUgdG9rZW4gdHlwZSBhdFxuICAgICAqIHRoYXQgcG9zaXRpb24uIFRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgbG9va2FoZWFkIHBhc3QgdGhlXG4gICAgICogZW5kIG9mIGlucHV0LCBwYXN0IHRoZSBzaXplIG9mIHRoZSBsb29rYWhlYWQgYnVmZmVyLCBvciBiYWNrIHBhc3RcbiAgICAgKiB0aGUgZmlyc3QgdG9rZW4gaW4gdGhlIGxvb2thaGVhZCBidWZmZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IFRoZSBpbmRleCBvZiB0aGUgdG9rZW4gdHlwZSB0byByZXRyaWV2ZS4gMCBmb3IgdGhlXG4gICAgICogICAgICBjdXJyZW50IHRva2VuLCAxIGZvciB0aGUgbmV4dCwgLTEgZm9yIHRoZSBwcmV2aW91cywgZXRjLlxuICAgICAqIEByZXR1cm4ge2ludH0gVGhlIHRva2VuIHR5cGUgb2YgdGhlIHRva2VuIGluIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgKiBAbWV0aG9kIExBXG4gICAgICovXG4gICAgTEE6IGZ1bmN0aW9uKGluZGV4KXtcbiAgICAgICAgdmFyIHRvdGFsID0gaW5kZXgsXG4gICAgICAgICAgICB0dDtcbiAgICAgICAgaWYgKGluZGV4ID4gMCl7XG4gICAgICAgICAgICAvL1RPRE86IFN0b3JlIDUgc29tZXdoZXJlXG4gICAgICAgICAgICBpZiAoaW5kZXggPiA1KXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbXVjaCBsb29rYWhlYWQuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2dldCBhbGwgdGhvc2UgdG9rZW5zXG4gICAgICAgICAgICB3aGlsZSh0b3RhbCl7XG4gICAgICAgICAgICAgICAgdHQgPSB0aGlzLmdldCgpO1xuICAgICAgICAgICAgICAgIHRvdGFsLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vdW5nZXQgYWxsIHRob3NlIHRva2Vuc1xuICAgICAgICAgICAgd2hpbGUodG90YWwgPCBpbmRleCl7XG4gICAgICAgICAgICAgICAgdGhpcy51bmdldCgpO1xuICAgICAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCAwKXtcblxuICAgICAgICAgICAgaWYodGhpcy5fbHRbdGhpcy5fbHRJbmRleCtpbmRleF0pe1xuICAgICAgICAgICAgICAgIHR0ID0gdGhpcy5fbHRbdGhpcy5fbHRJbmRleCtpbmRleF0udHlwZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vIG11Y2ggbG9va2JlaGluZC5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR0ID0gdGhpcy5fdG9rZW4udHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0dDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb29rcyBhaGVhZCBhIGNlcnRhaW4gbnVtYmVyIG9mIHRva2VucyBhbmQgcmV0dXJucyB0aGUgdG9rZW4gYXRcbiAgICAgKiB0aGF0IHBvc2l0aW9uLiBUaGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgeW91IGxvb2thaGVhZCBwYXN0IHRoZVxuICAgICAqIGVuZCBvZiBpbnB1dCwgcGFzdCB0aGUgc2l6ZSBvZiB0aGUgbG9va2FoZWFkIGJ1ZmZlciwgb3IgYmFjayBwYXN0XG4gICAgICogdGhlIGZpcnN0IHRva2VuIGluIHRoZSBsb29rYWhlYWQgYnVmZmVyLlxuICAgICAqIEBwYXJhbSB7aW50fSBUaGUgaW5kZXggb2YgdGhlIHRva2VuIHR5cGUgdG8gcmV0cmlldmUuIDAgZm9yIHRoZVxuICAgICAqICAgICAgY3VycmVudCB0b2tlbiwgMSBmb3IgdGhlIG5leHQsIC0xIGZvciB0aGUgcHJldmlvdXMsIGV0Yy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0b2tlbiBvZiB0aGUgdG9rZW4gaW4gdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqIEBtZXRob2QgTEFcbiAgICAgKi9cbiAgICBMVDogZnVuY3Rpb24oaW5kZXgpe1xuXG4gICAgICAgIC8vbG9va2FoZWFkIGZpcnN0IHRvIHByaW1lIHRoZSB0b2tlbiBidWZmZXJcbiAgICAgICAgdGhpcy5MQShpbmRleCk7XG5cbiAgICAgICAgLy9ub3cgZmluZCB0aGUgdG9rZW4sIHN1YnRyYWN0IG9uZSBiZWNhdXNlIF9sdEluZGV4IGlzIGFscmVhZHkgYXQgdGhlIG5leHQgaW5kZXhcbiAgICAgICAgcmV0dXJuIHRoaXMuX2x0W3RoaXMuX2x0SW5kZXgraW5kZXgtMV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRva2VuIHR5cGUgZm9yIHRoZSBuZXh0IHRva2VuIGluIHRoZSBzdHJlYW0gd2l0aG91dFxuICAgICAqIGNvbnN1bWluZyBpdC5cbiAgICAgKiBAcmV0dXJuIHtpbnR9IFRoZSB0b2tlbiB0eXBlIG9mIHRoZSBuZXh0IHRva2VuIGluIHRoZSBzdHJlYW0uXG4gICAgICogQG1ldGhvZCBwZWVrXG4gICAgICovXG4gICAgcGVlazogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuTEEoMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFjdHVhbCB0b2tlbiBvYmplY3QgZm9yIHRoZSBsYXN0IGNvbnN1bWVkIHRva2VuLlxuICAgICAqIEByZXR1cm4ge1Rva2VufSBUaGUgdG9rZW4gb2JqZWN0IGZvciB0aGUgbGFzdCBjb25zdW1lZCB0b2tlbi5cbiAgICAgKiBAbWV0aG9kIHRva2VuXG4gICAgICovXG4gICAgdG9rZW46IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdG9rZW4gZm9yIHRoZSBnaXZlbiB0b2tlbiB0eXBlLlxuICAgICAqIEBwYXJhbSB7aW50fSB0b2tlblR5cGUgVGhlIHR5cGUgb2YgdG9rZW4gdG8gZ2V0IHRoZSBuYW1lIG9mLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHRva2VuIG9yIFwiVU5LTk9XTl9UT0tFTlwiIGZvciBhbnlcbiAgICAgKiAgICAgIGludmFsaWQgdG9rZW4gdHlwZS5cbiAgICAgKiBAbWV0aG9kIHRva2VuTmFtZVxuICAgICAqL1xuICAgIHRva2VuTmFtZTogZnVuY3Rpb24odG9rZW5UeXBlKXtcbiAgICAgICAgaWYgKHRva2VuVHlwZSA8IDAgfHwgdG9rZW5UeXBlID4gdGhpcy5fdG9rZW5EYXRhLmxlbmd0aCl7XG4gICAgICAgICAgICByZXR1cm4gXCJVTktOT1dOX1RPS0VOXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5EYXRhW3Rva2VuVHlwZV0ubmFtZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b2tlbiB0eXBlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gdG9rZW4gbmFtZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW5OYW1lIFRoZSBuYW1lIG9mIHRoZSB0b2tlbiB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQuXG4gICAgICogQHJldHVybiB7aW50fSBUaGUgdG9rZW4gdHlwZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIHRva2VuIG5hbWUgb3IgLTFcbiAgICAgKiAgICAgIGZvciBhbiB1bmtub3duIHRva2VuLlxuICAgICAqIEBtZXRob2QgdG9rZW5OYW1lXG4gICAgICovXG4gICAgdG9rZW5UeXBlOiBmdW5jdGlvbih0b2tlbk5hbWUpe1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5EYXRhW3Rva2VuTmFtZV0gfHwgLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgY29uc3VtZWQgdG9rZW4gdG8gdGhlIHRva2VuIHN0cmVhbS5cbiAgICAgKiBAbWV0aG9kIHVuZ2V0XG4gICAgICovXG4gICAgdW5nZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vaWYgKHRoaXMuX2x0SW5kZXggPiAtMSl7XG4gICAgICAgIGlmICh0aGlzLl9sdEluZGV4Q2FjaGUubGVuZ3RoKXtcbiAgICAgICAgICAgIHRoaXMuX2x0SW5kZXggLT0gdGhpcy5fbHRJbmRleENhY2hlLnBvcCgpOy8vLS07XG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IHRoaXMuX2x0W3RoaXMuX2x0SW5kZXggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvbyBtdWNoIGxvb2thaGVhZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cblxucGFyc2VybGliLnV0aWwgPSB7XG5fX3Byb3RvX18gICA6IG51bGwsXG5TdHJpbmdSZWFkZXI6IFN0cmluZ1JlYWRlcixcblN5bnRheEVycm9yIDogU3ludGF4RXJyb3IsXG5TeW50YXhVbml0ICA6IFN5bnRheFVuaXQsXG5FdmVudFRhcmdldCA6IEV2ZW50VGFyZ2V0LFxuVG9rZW5TdHJlYW1CYXNlIDogVG9rZW5TdHJlYW1CYXNlXG59O1xufSkoKTtcbi8qXG5QYXJzZXItTGliXG5Db3B5cmlnaHQgKGMpIDIwMDktMjAxMSBOaWNob2xhcyBDLiBaYWthcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuLyogVmVyc2lvbiB2MC4yLjUrZG9taW5vMSwgQnVpbGQgdGltZTogMzAtSmFudWFyeS0yMDE2IDA1OjEzOjAzICovXG4oZnVuY3Rpb24oKXtcbnZhciBFdmVudFRhcmdldCA9IHBhcnNlcmxpYi51dGlsLkV2ZW50VGFyZ2V0LFxuVG9rZW5TdHJlYW1CYXNlID0gcGFyc2VybGliLnV0aWwuVG9rZW5TdHJlYW1CYXNlLFxuU3RyaW5nUmVhZGVyID0gcGFyc2VybGliLnV0aWwuU3RyaW5nUmVhZGVyLCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblN5bnRheEVycm9yID0gcGFyc2VybGliLnV0aWwuU3ludGF4RXJyb3IsXG5TeW50YXhVbml0ICA9IHBhcnNlcmxpYi51dGlsLlN5bnRheFVuaXQ7XG5cbnZhciBDb2xvcnMgPSB7XG4gICAgX19wcm90b19fICAgICAgIDpudWxsLFxuICAgIGFsaWNlYmx1ZSAgICAgICA6XCIjZjBmOGZmXCIsXG4gICAgYW50aXF1ZXdoaXRlICAgIDpcIiNmYWViZDdcIixcbiAgICBhcXVhICAgICAgICAgICAgOlwiIzAwZmZmZlwiLFxuICAgIGFxdWFtYXJpbmUgICAgICA6XCIjN2ZmZmQ0XCIsXG4gICAgYXp1cmUgICAgICAgICAgIDpcIiNmMGZmZmZcIixcbiAgICBiZWlnZSAgICAgICAgICAgOlwiI2Y1ZjVkY1wiLFxuICAgIGJpc3F1ZSAgICAgICAgICA6XCIjZmZlNGM0XCIsXG4gICAgYmxhY2sgICAgICAgICAgIDpcIiMwMDAwMDBcIixcbiAgICBibGFuY2hlZGFsbW9uZCAgOlwiI2ZmZWJjZFwiLFxuICAgIGJsdWUgICAgICAgICAgICA6XCIjMDAwMGZmXCIsXG4gICAgYmx1ZXZpb2xldCAgICAgIDpcIiM4YTJiZTJcIixcbiAgICBicm93biAgICAgICAgICAgOlwiI2E1MmEyYVwiLFxuICAgIGJ1cmx5d29vZCAgICAgICA6XCIjZGViODg3XCIsXG4gICAgY2FkZXRibHVlICAgICAgIDpcIiM1ZjllYTBcIixcbiAgICBjaGFydHJldXNlICAgICAgOlwiIzdmZmYwMFwiLFxuICAgIGNob2NvbGF0ZSAgICAgICA6XCIjZDI2OTFlXCIsXG4gICAgY29yYWwgICAgICAgICAgIDpcIiNmZjdmNTBcIixcbiAgICBjb3JuZmxvd2VyYmx1ZSAgOlwiIzY0OTVlZFwiLFxuICAgIGNvcm5zaWxrICAgICAgICA6XCIjZmZmOGRjXCIsXG4gICAgY3JpbXNvbiAgICAgICAgIDpcIiNkYzE0M2NcIixcbiAgICBjeWFuICAgICAgICAgICAgOlwiIzAwZmZmZlwiLFxuICAgIGRhcmtibHVlICAgICAgICA6XCIjMDAwMDhiXCIsXG4gICAgZGFya2N5YW4gICAgICAgIDpcIiMwMDhiOGJcIixcbiAgICBkYXJrZ29sZGVucm9kICAgOlwiI2I4ODYwYlwiLFxuICAgIGRhcmtncmF5ICAgICAgICA6XCIjYTlhOWE5XCIsXG4gICAgZGFya2dyZXkgICAgICAgIDpcIiNhOWE5YTlcIixcbiAgICBkYXJrZ3JlZW4gICAgICAgOlwiIzAwNjQwMFwiLFxuICAgIGRhcmtraGFraSAgICAgICA6XCIjYmRiNzZiXCIsXG4gICAgZGFya21hZ2VudGEgICAgIDpcIiM4YjAwOGJcIixcbiAgICBkYXJrb2xpdmVncmVlbiAgOlwiIzU1NmIyZlwiLFxuICAgIGRhcmtvcmFuZ2UgICAgICA6XCIjZmY4YzAwXCIsXG4gICAgZGFya29yY2hpZCAgICAgIDpcIiM5OTMyY2NcIixcbiAgICBkYXJrcmVkICAgICAgICAgOlwiIzhiMDAwMFwiLFxuICAgIGRhcmtzYWxtb24gICAgICA6XCIjZTk5NjdhXCIsXG4gICAgZGFya3NlYWdyZWVuICAgIDpcIiM4ZmJjOGZcIixcbiAgICBkYXJrc2xhdGVibHVlICAgOlwiIzQ4M2Q4YlwiLFxuICAgIGRhcmtzbGF0ZWdyYXkgICA6XCIjMmY0ZjRmXCIsXG4gICAgZGFya3NsYXRlZ3JleSAgIDpcIiMyZjRmNGZcIixcbiAgICBkYXJrdHVycXVvaXNlICAgOlwiIzAwY2VkMVwiLFxuICAgIGRhcmt2aW9sZXQgICAgICA6XCIjOTQwMGQzXCIsXG4gICAgZGVlcHBpbmsgICAgICAgIDpcIiNmZjE0OTNcIixcbiAgICBkZWVwc2t5Ymx1ZSAgICAgOlwiIzAwYmZmZlwiLFxuICAgIGRpbWdyYXkgICAgICAgICA6XCIjNjk2OTY5XCIsXG4gICAgZGltZ3JleSAgICAgICAgIDpcIiM2OTY5NjlcIixcbiAgICBkb2RnZXJibHVlICAgICAgOlwiIzFlOTBmZlwiLFxuICAgIGZpcmVicmljayAgICAgICA6XCIjYjIyMjIyXCIsXG4gICAgZmxvcmFsd2hpdGUgICAgIDpcIiNmZmZhZjBcIixcbiAgICBmb3Jlc3RncmVlbiAgICAgOlwiIzIyOGIyMlwiLFxuICAgIGZ1Y2hzaWEgICAgICAgICA6XCIjZmYwMGZmXCIsXG4gICAgZ2FpbnNib3JvICAgICAgIDpcIiNkY2RjZGNcIixcbiAgICBnaG9zdHdoaXRlICAgICAgOlwiI2Y4ZjhmZlwiLFxuICAgIGdvbGQgICAgICAgICAgICA6XCIjZmZkNzAwXCIsXG4gICAgZ29sZGVucm9kICAgICAgIDpcIiNkYWE1MjBcIixcbiAgICBncmF5ICAgICAgICAgICAgOlwiIzgwODA4MFwiLFxuICAgIGdyZXkgICAgICAgICAgICA6XCIjODA4MDgwXCIsXG4gICAgZ3JlZW4gICAgICAgICAgIDpcIiMwMDgwMDBcIixcbiAgICBncmVlbnllbGxvdyAgICAgOlwiI2FkZmYyZlwiLFxuICAgIGhvbmV5ZGV3ICAgICAgICA6XCIjZjBmZmYwXCIsXG4gICAgaG90cGluayAgICAgICAgIDpcIiNmZjY5YjRcIixcbiAgICBpbmRpYW5yZWQgICAgICAgOlwiI2NkNWM1Y1wiLFxuICAgIGluZGlnbyAgICAgICAgICA6XCIjNGIwMDgyXCIsXG4gICAgaXZvcnkgICAgICAgICAgIDpcIiNmZmZmZjBcIixcbiAgICBraGFraSAgICAgICAgICAgOlwiI2YwZTY4Y1wiLFxuICAgIGxhdmVuZGVyICAgICAgICA6XCIjZTZlNmZhXCIsXG4gICAgbGF2ZW5kZXJibHVzaCAgIDpcIiNmZmYwZjVcIixcbiAgICBsYXduZ3JlZW4gICAgICAgOlwiIzdjZmMwMFwiLFxuICAgIGxlbW9uY2hpZmZvbiAgICA6XCIjZmZmYWNkXCIsXG4gICAgbGlnaHRibHVlICAgICAgIDpcIiNhZGQ4ZTZcIixcbiAgICBsaWdodGNvcmFsICAgICAgOlwiI2YwODA4MFwiLFxuICAgIGxpZ2h0Y3lhbiAgICAgICA6XCIjZTBmZmZmXCIsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3cgIDpcIiNmYWZhZDJcIixcbiAgICBsaWdodGdyYXkgICAgICAgOlwiI2QzZDNkM1wiLFxuICAgIGxpZ2h0Z3JleSAgICAgICA6XCIjZDNkM2QzXCIsXG4gICAgbGlnaHRncmVlbiAgICAgIDpcIiM5MGVlOTBcIixcbiAgICBsaWdodHBpbmsgICAgICAgOlwiI2ZmYjZjMVwiLFxuICAgIGxpZ2h0c2FsbW9uICAgICA6XCIjZmZhMDdhXCIsXG4gICAgbGlnaHRzZWFncmVlbiAgIDpcIiMyMGIyYWFcIixcbiAgICBsaWdodHNreWJsdWUgICAgOlwiIzg3Y2VmYVwiLFxuICAgIGxpZ2h0c2xhdGVncmF5ICA6XCIjNzc4ODk5XCIsXG4gICAgbGlnaHRzbGF0ZWdyZXkgIDpcIiM3Nzg4OTlcIixcbiAgICBsaWdodHN0ZWVsYmx1ZSAgOlwiI2IwYzRkZVwiLFxuICAgIGxpZ2h0eWVsbG93ICAgICA6XCIjZmZmZmUwXCIsXG4gICAgbGltZSAgICAgICAgICAgIDpcIiMwMGZmMDBcIixcbiAgICBsaW1lZ3JlZW4gICAgICAgOlwiIzMyY2QzMlwiLFxuICAgIGxpbmVuICAgICAgICAgICA6XCIjZmFmMGU2XCIsXG4gICAgbWFnZW50YSAgICAgICAgIDpcIiNmZjAwZmZcIixcbiAgICBtYXJvb24gICAgICAgICAgOlwiIzgwMDAwMFwiLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6XCIjNjZjZGFhXCIsXG4gICAgbWVkaXVtYmx1ZSAgICAgIDpcIiMwMDAwY2RcIixcbiAgICBtZWRpdW1vcmNoaWQgICAgOlwiI2JhNTVkM1wiLFxuICAgIG1lZGl1bXB1cnBsZSAgICA6XCIjOTM3MGQ4XCIsXG4gICAgbWVkaXVtc2VhZ3JlZW4gIDpcIiMzY2IzNzFcIixcbiAgICBtZWRpdW1zbGF0ZWJsdWUgOlwiIzdiNjhlZVwiLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuICAgOlwiIzAwZmE5YVwiLFxuICAgIG1lZGl1bXR1cnF1b2lzZSA6XCIjNDhkMWNjXCIsXG4gICAgbWVkaXVtdmlvbGV0cmVkIDpcIiNjNzE1ODVcIixcbiAgICBtaWRuaWdodGJsdWUgICAgOlwiIzE5MTk3MFwiLFxuICAgIG1pbnRjcmVhbSAgICAgICA6XCIjZjVmZmZhXCIsXG4gICAgbWlzdHlyb3NlICAgICAgIDpcIiNmZmU0ZTFcIixcbiAgICBtb2NjYXNpbiAgICAgICAgOlwiI2ZmZTRiNVwiLFxuICAgIG5hdmFqb3doaXRlICAgICA6XCIjZmZkZWFkXCIsXG4gICAgbmF2eSAgICAgICAgICAgIDpcIiMwMDAwODBcIixcbiAgICBvbGRsYWNlICAgICAgICAgOlwiI2ZkZjVlNlwiLFxuICAgIG9saXZlICAgICAgICAgICA6XCIjODA4MDAwXCIsXG4gICAgb2xpdmVkcmFiICAgICAgIDpcIiM2YjhlMjNcIixcbiAgICBvcmFuZ2UgICAgICAgICAgOlwiI2ZmYTUwMFwiLFxuICAgIG9yYW5nZXJlZCAgICAgICA6XCIjZmY0NTAwXCIsXG4gICAgb3JjaGlkICAgICAgICAgIDpcIiNkYTcwZDZcIixcbiAgICBwYWxlZ29sZGVucm9kICAgOlwiI2VlZThhYVwiLFxuICAgIHBhbGVncmVlbiAgICAgICA6XCIjOThmYjk4XCIsXG4gICAgcGFsZXR1cnF1b2lzZSAgIDpcIiNhZmVlZWVcIixcbiAgICBwYWxldmlvbGV0cmVkICAgOlwiI2Q4NzA5M1wiLFxuICAgIHBhcGF5YXdoaXAgICAgICA6XCIjZmZlZmQ1XCIsXG4gICAgcGVhY2hwdWZmICAgICAgIDpcIiNmZmRhYjlcIixcbiAgICBwZXJ1ICAgICAgICAgICAgOlwiI2NkODUzZlwiLFxuICAgIHBpbmsgICAgICAgICAgICA6XCIjZmZjMGNiXCIsXG4gICAgcGx1bSAgICAgICAgICAgIDpcIiNkZGEwZGRcIixcbiAgICBwb3dkZXJibHVlICAgICAgOlwiI2IwZTBlNlwiLFxuICAgIHB1cnBsZSAgICAgICAgICA6XCIjODAwMDgwXCIsXG4gICAgcmVkICAgICAgICAgICAgIDpcIiNmZjAwMDBcIixcbiAgICByb3N5YnJvd24gICAgICAgOlwiI2JjOGY4ZlwiLFxuICAgIHJveWFsYmx1ZSAgICAgICA6XCIjNDE2OWUxXCIsXG4gICAgc2FkZGxlYnJvd24gICAgIDpcIiM4YjQ1MTNcIixcbiAgICBzYWxtb24gICAgICAgICAgOlwiI2ZhODA3MlwiLFxuICAgIHNhbmR5YnJvd24gICAgICA6XCIjZjRhNDYwXCIsXG4gICAgc2VhZ3JlZW4gICAgICAgIDpcIiMyZThiNTdcIixcbiAgICBzZWFzaGVsbCAgICAgICAgOlwiI2ZmZjVlZVwiLFxuICAgIHNpZW5uYSAgICAgICAgICA6XCIjYTA1MjJkXCIsXG4gICAgc2lsdmVyICAgICAgICAgIDpcIiNjMGMwYzBcIixcbiAgICBza3libHVlICAgICAgICAgOlwiIzg3Y2VlYlwiLFxuICAgIHNsYXRlYmx1ZSAgICAgICA6XCIjNmE1YWNkXCIsXG4gICAgc2xhdGVncmF5ICAgICAgIDpcIiM3MDgwOTBcIixcbiAgICBzbGF0ZWdyZXkgICAgICAgOlwiIzcwODA5MFwiLFxuICAgIHNub3cgICAgICAgICAgICA6XCIjZmZmYWZhXCIsXG4gICAgc3ByaW5nZ3JlZW4gICAgIDpcIiMwMGZmN2ZcIixcbiAgICBzdGVlbGJsdWUgICAgICAgOlwiIzQ2ODJiNFwiLFxuICAgIHRhbiAgICAgICAgICAgICA6XCIjZDJiNDhjXCIsXG4gICAgdGVhbCAgICAgICAgICAgIDpcIiMwMDgwODBcIixcbiAgICB0aGlzdGxlICAgICAgICAgOlwiI2Q4YmZkOFwiLFxuICAgIHRvbWF0byAgICAgICAgICA6XCIjZmY2MzQ3XCIsXG4gICAgdHVycXVvaXNlICAgICAgIDpcIiM0MGUwZDBcIixcbiAgICB2aW9sZXQgICAgICAgICAgOlwiI2VlODJlZVwiLFxuICAgIHdoZWF0ICAgICAgICAgICA6XCIjZjVkZWIzXCIsXG4gICAgd2hpdGUgICAgICAgICAgIDpcIiNmZmZmZmZcIixcbiAgICB3aGl0ZXNtb2tlICAgICAgOlwiI2Y1ZjVmNVwiLFxuICAgIHllbGxvdyAgICAgICAgICA6XCIjZmZmZjAwXCIsXG4gICAgeWVsbG93Z3JlZW4gICAgIDpcIiM5YWNkMzJcIixcbiAgICAvLydjdXJyZW50Q29sb3InIGNvbG9yIGtleXdvcmQgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jY3VycmVudGNvbG9yXG4gICAgY3VycmVudENvbG9yICAgICAgICA6XCJUaGUgdmFsdWUgb2YgdGhlICdjb2xvcicgcHJvcGVydHkuXCIsXG4gICAgLy9DU1MyIHN5c3RlbSBjb2xvcnMgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jY3NzMi1zeXN0ZW1cbiAgICBhY3RpdmVCb3JkZXIgICAgICAgIDpcIkFjdGl2ZSB3aW5kb3cgYm9yZGVyLlwiLFxuICAgIGFjdGl2ZWNhcHRpb24gICAgICAgOlwiQWN0aXZlIHdpbmRvdyBjYXB0aW9uLlwiLFxuICAgIGFwcHdvcmtzcGFjZSAgICAgICAgOlwiQmFja2dyb3VuZCBjb2xvciBvZiBtdWx0aXBsZSBkb2N1bWVudCBpbnRlcmZhY2UuXCIsXG4gICAgYmFja2dyb3VuZCAgICAgICAgICA6XCJEZXNrdG9wIGJhY2tncm91bmQuXCIsXG4gICAgYnV0dG9uZmFjZSAgICAgICAgICA6XCJUaGUgZmFjZSBiYWNrZ3JvdW5kIGNvbG9yIGZvciAzLUQgZWxlbWVudHMgdGhhdCBhcHBlYXIgMy1EIGR1ZSB0byBvbmUgbGF5ZXIgb2Ygc3Vycm91bmRpbmcgYm9yZGVyLlwiLFxuICAgIGJ1dHRvbmhpZ2hsaWdodCAgICAgOlwiVGhlIGNvbG9yIG9mIHRoZSBib3JkZXIgZmFjaW5nIHRoZSBsaWdodCBzb3VyY2UgZm9yIDMtRCBlbGVtZW50cyB0aGF0IGFwcGVhciAzLUQgZHVlIHRvIG9uZSBsYXllciBvZiBzdXJyb3VuZGluZyBib3JkZXIuXCIsXG4gICAgYnV0dG9uc2hhZG93ICAgICAgICA6XCJUaGUgY29sb3Igb2YgdGhlIGJvcmRlciBhd2F5IGZyb20gdGhlIGxpZ2h0IHNvdXJjZSBmb3IgMy1EIGVsZW1lbnRzIHRoYXQgYXBwZWFyIDMtRCBkdWUgdG8gb25lIGxheWVyIG9mIHN1cnJvdW5kaW5nIGJvcmRlci5cIixcbiAgICBidXR0b250ZXh0ICAgICAgICAgIDpcIlRleHQgb24gcHVzaCBidXR0b25zLlwiLFxuICAgIGNhcHRpb250ZXh0ICAgICAgICAgOlwiVGV4dCBpbiBjYXB0aW9uLCBzaXplIGJveCwgYW5kIHNjcm9sbGJhciBhcnJvdyBib3guXCIsXG4gICAgZ3JheXRleHQgICAgICAgICAgICA6XCJHcmF5ZWQgKGRpc2FibGVkKSB0ZXh0LiBUaGlzIGNvbG9yIGlzIHNldCB0byAjMDAwIGlmIHRoZSBjdXJyZW50IGRpc3BsYXkgZHJpdmVyIGRvZXMgbm90IHN1cHBvcnQgYSBzb2xpZCBncmF5IGNvbG9yLlwiLFxuICAgIGdyZXl0ZXh0ICAgICAgICAgICAgOlwiR3JleWVkIChkaXNhYmxlZCkgdGV4dC4gVGhpcyBjb2xvciBpcyBzZXQgdG8gIzAwMCBpZiB0aGUgY3VycmVudCBkaXNwbGF5IGRyaXZlciBkb2VzIG5vdCBzdXBwb3J0IGEgc29saWQgZ3JleSBjb2xvci5cIixcbiAgICBoaWdobGlnaHQgICAgICAgICAgIDpcIkl0ZW0ocykgc2VsZWN0ZWQgaW4gYSBjb250cm9sLlwiLFxuICAgIGhpZ2hsaWdodHRleHQgICAgICAgOlwiVGV4dCBvZiBpdGVtKHMpIHNlbGVjdGVkIGluIGEgY29udHJvbC5cIixcbiAgICBpbmFjdGl2ZWJvcmRlciAgICAgIDpcIkluYWN0aXZlIHdpbmRvdyBib3JkZXIuXCIsXG4gICAgaW5hY3RpdmVjYXB0aW9uICAgICA6XCJJbmFjdGl2ZSB3aW5kb3cgY2FwdGlvbi5cIixcbiAgICBpbmFjdGl2ZWNhcHRpb250ZXh0IDpcIkNvbG9yIG9mIHRleHQgaW4gYW4gaW5hY3RpdmUgY2FwdGlvbi5cIixcbiAgICBpbmZvYmFja2dyb3VuZCAgICAgIDpcIkJhY2tncm91bmQgY29sb3IgZm9yIHRvb2x0aXAgY29udHJvbHMuXCIsXG4gICAgaW5mb3RleHQgICAgICAgICAgICA6XCJUZXh0IGNvbG9yIGZvciB0b29sdGlwIGNvbnRyb2xzLlwiLFxuICAgIG1lbnUgICAgICAgICAgICAgICAgOlwiTWVudSBiYWNrZ3JvdW5kLlwiLFxuICAgIG1lbnV0ZXh0ICAgICAgICAgICAgOlwiVGV4dCBpbiBtZW51cy5cIixcbiAgICBzY3JvbGxiYXIgICAgICAgICAgIDpcIlNjcm9sbCBiYXIgZ3JheSBhcmVhLlwiLFxuICAgIHRocmVlZGRhcmtzaGFkb3cgICAgOlwiVGhlIGNvbG9yIG9mIHRoZSBkYXJrZXIgKGdlbmVyYWxseSBvdXRlcikgb2YgdGhlIHR3byBib3JkZXJzIGF3YXkgZnJvbSB0aGUgbGlnaHQgc291cmNlIGZvciAzLUQgZWxlbWVudHMgdGhhdCBhcHBlYXIgMy1EIGR1ZSB0byB0d28gY29uY2VudHJpYyBsYXllcnMgb2Ygc3Vycm91bmRpbmcgYm9yZGVyLlwiLFxuICAgIHRocmVlZGZhY2UgICAgICAgICAgOlwiVGhlIGZhY2UgYmFja2dyb3VuZCBjb2xvciBmb3IgMy1EIGVsZW1lbnRzIHRoYXQgYXBwZWFyIDMtRCBkdWUgdG8gdHdvIGNvbmNlbnRyaWMgbGF5ZXJzIG9mIHN1cnJvdW5kaW5nIGJvcmRlci5cIixcbiAgICB0aHJlZWRoaWdobGlnaHQgICAgIDpcIlRoZSBjb2xvciBvZiB0aGUgbGlnaHRlciAoZ2VuZXJhbGx5IG91dGVyKSBvZiB0aGUgdHdvIGJvcmRlcnMgZmFjaW5nIHRoZSBsaWdodCBzb3VyY2UgZm9yIDMtRCBlbGVtZW50cyB0aGF0IGFwcGVhciAzLUQgZHVlIHRvIHR3byBjb25jZW50cmljIGxheWVycyBvZiBzdXJyb3VuZGluZyBib3JkZXIuXCIsXG4gICAgdGhyZWVkbGlnaHRzaGFkb3cgICA6XCJUaGUgY29sb3Igb2YgdGhlIGRhcmtlciAoZ2VuZXJhbGx5IGlubmVyKSBvZiB0aGUgdHdvIGJvcmRlcnMgZmFjaW5nIHRoZSBsaWdodCBzb3VyY2UgZm9yIDMtRCBlbGVtZW50cyB0aGF0IGFwcGVhciAzLUQgZHVlIHRvIHR3byBjb25jZW50cmljIGxheWVycyBvZiBzdXJyb3VuZGluZyBib3JkZXIuXCIsXG4gICAgdGhyZWVkc2hhZG93ICAgICAgICA6XCJUaGUgY29sb3Igb2YgdGhlIGxpZ2h0ZXIgKGdlbmVyYWxseSBpbm5lcikgb2YgdGhlIHR3byBib3JkZXJzIGF3YXkgZnJvbSB0aGUgbGlnaHQgc291cmNlIGZvciAzLUQgZWxlbWVudHMgdGhhdCBhcHBlYXIgMy1EIGR1ZSB0byB0d28gY29uY2VudHJpYyBsYXllcnMgb2Ygc3Vycm91bmRpbmcgYm9yZGVyLlwiLFxuICAgIHdpbmRvdyAgICAgICAgICAgICAgOlwiV2luZG93IGJhY2tncm91bmQuXCIsXG4gICAgd2luZG93ZnJhbWUgICAgICAgICA6XCJXaW5kb3cgZnJhbWUuXCIsXG4gICAgd2luZG93dGV4dCAgICAgICAgICA6XCJUZXh0IGluIHdpbmRvd3MuXCJcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgYSBzZWxlY3RvciBjb21iaW5hdG9yICh3aGl0ZXNwYWNlLCArLCA+KS5cbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xuICogQGNsYXNzIENvbWJpbmF0b3JcbiAqIEBleHRlbmRzIHBhcnNlcmxpYi51dGlsLlN5bnRheFVuaXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKiBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICovXG5mdW5jdGlvbiBDb21iaW5hdG9yKHRleHQsIGxpbmUsIGNvbCl7XG5cbiAgICBTeW50YXhVbml0LmNhbGwodGhpcywgdGV4dCwgbGluZSwgY29sLCBQYXJzZXIuQ09NQklOQVRPUl9UWVBFKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIG1vZGlmaWVyLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gXCJ1bmtub3duXCI7XG5cbiAgICAvL3ByZXR0eSBzaW1wbGVcbiAgICBpZiAoL15cXHMrJC8udGVzdCh0ZXh0KSl7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiZGVzY2VuZGFudFwiO1xuICAgIH0gZWxzZSBpZiAodGV4dCA9PT0gXCI+XCIpe1xuICAgICAgICB0aGlzLnR5cGUgPSBcImNoaWxkXCI7XG4gICAgfSBlbHNlIGlmICh0ZXh0ID09PSBcIitcIil7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiYWRqYWNlbnQtc2libGluZ1wiO1xuICAgIH0gZWxzZSBpZiAodGV4dCA9PT0gXCJ+XCIpe1xuICAgICAgICB0aGlzLnR5cGUgPSBcInNpYmxpbmdcIjtcbiAgICB9XG5cbn1cblxuQ29tYmluYXRvci5wcm90b3R5cGUgPSBuZXcgU3ludGF4VW5pdCgpO1xuQ29tYmluYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21iaW5hdG9yO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBtZWRpYSBmZWF0dXJlLCBzdWNoIGFzIG1heC13aWR0aDo1MDAuXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi5jc3NcbiAqIEBjbGFzcyBNZWRpYUZlYXR1cmVcbiAqIEBleHRlbmRzIHBhcnNlcmxpYi51dGlsLlN5bnRheFVuaXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTeW50YXhVbml0fSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlLlxuICogQHBhcmFtIHtTeW50YXhVbml0fSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGZlYXR1cmUgb3IgbnVsbCBpZiBub25lLlxuICovXG5mdW5jdGlvbiBNZWRpYUZlYXR1cmUobmFtZSwgdmFsdWUpe1xuXG4gICAgU3ludGF4VW5pdC5jYWxsKHRoaXMsIFwiKFwiICsgbmFtZSArICh2YWx1ZSAhPT0gbnVsbCA/IFwiOlwiICsgdmFsdWUgOiBcIlwiKSArIFwiKVwiLCBuYW1lLnN0YXJ0TGluZSwgbmFtZS5zdGFydENvbCwgUGFyc2VyLk1FRElBX0ZFQVRVUkVfVFlQRSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgbWVkaWEgZmVhdHVyZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSBuYW1lXG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIGZlYXR1cmUgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lLlxuICAgICAqIEB0eXBlIFN5bnRheFVuaXRcbiAgICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cbk1lZGlhRmVhdHVyZS5wcm90b3R5cGUgPSBuZXcgU3ludGF4VW5pdCgpO1xuTWVkaWFGZWF0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lZGlhRmVhdHVyZTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluZGl2aWR1YWwgbWVkaWEgcXVlcnkuXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi5jc3NcbiAqIEBjbGFzcyBNZWRpYVF1ZXJ5XG4gKiBAZXh0ZW5kcyBwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllciBUaGUgbW9kaWZpZXIgXCJub3RcIiBvciBcIm9ubHlcIiAob3IgbnVsbCkuXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVkaWFUeXBlIFRoZSB0eXBlIG9mIG1lZGlhIChpLmUuLCBcInByaW50XCIpLlxuICogQHBhcmFtIHtBcnJheX0gcGFydHMgQXJyYXkgb2Ygc2VsZWN0b3JzIHBhcnRzIG1ha2luZyB1cCB0aGlzIHNlbGVjdG9yLlxuICogQHBhcmFtIHtpbnR9IGxpbmUgVGhlIGxpbmUgb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqL1xuZnVuY3Rpb24gTWVkaWFRdWVyeShtb2RpZmllciwgbWVkaWFUeXBlLCBmZWF0dXJlcywgbGluZSwgY29sKXtcblxuICAgIFN5bnRheFVuaXQuY2FsbCh0aGlzLCAobW9kaWZpZXIgPyBtb2RpZmllciArIFwiIFwiOiBcIlwiKSArIChtZWRpYVR5cGUgPyBtZWRpYVR5cGUgOiBcIlwiKSArIChtZWRpYVR5cGUgJiYgZmVhdHVyZXMubGVuZ3RoID4gMCA/IFwiIGFuZCBcIiA6IFwiXCIpICsgZmVhdHVyZXMuam9pbihcIiBhbmQgXCIpLCBsaW5lLCBjb2wsIFBhcnNlci5NRURJQV9RVUVSWV9UWVBFKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZWRpYSBtb2RpZmllciAoXCJub3RcIiBvciBcIm9ubHlcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAcHJvcGVydHkgbW9kaWZpZXJcbiAgICAgKi9cbiAgICB0aGlzLm1vZGlmaWVyID0gbW9kaWZpZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWVkaWFUeXBlIChpLmUuLCBcInByaW50XCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHByb3BlcnR5IG1lZGlhVHlwZVxuICAgICAqL1xuICAgIHRoaXMubWVkaWFUeXBlID0gbWVkaWFUeXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcnRzIHRoYXQgbWFrZSB1cCB0aGUgc2VsZWN0b3IuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJvcGVydHkgZmVhdHVyZXNcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG5cbn1cblxuTWVkaWFRdWVyeS5wcm90b3R5cGUgPSBuZXcgU3ludGF4VW5pdCgpO1xuTWVkaWFRdWVyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZWRpYVF1ZXJ5O1xuXG5cbi8qKlxuICogQSBDU1MzIHBhcnNlci5cbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xuICogQGNsYXNzIFBhcnNlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAoT3B0aW9uYWwpIFZhcmlvdXMgb3B0aW9ucyBmb3IgdGhlIHBhcnNlcjpcbiAqICAgICAgc3RhckhhY2sgKHRydWV8ZmFsc2UpIHRvIGFsbG93IElFNiBzdGFyIGhhY2sgYXMgdmFsaWQsXG4gKiAgICAgIHVuZGVyc2NvcmVIYWNrICh0cnVlfGZhbHNlKSB0byBpbnRlcnByZXQgbGVhZGluZyB1bmRlcnNjb3Jlc1xuICogICAgICBhcyBJRTYtNyB0YXJnZXRpbmcgZm9yIGtub3duIHByb3BlcnRpZXMsIGllRmlsdGVycyAodHJ1ZXxmYWxzZSlcbiAqICAgICAgdG8gaW5kaWNhdGUgdGhhdCBJRSA8IDggZmlsdGVycyBzaG91bGQgYmUgYWNjZXB0ZWQgYW5kIG5vdCB0aHJvd1xuICogICAgICBzeW50YXggZXJyb3JzLlxuICovXG5mdW5jdGlvbiBQYXJzZXIob3B0aW9ucyl7XG5cbiAgICAvL2luaGVyaXQgZXZlbnQgZnVuY3Rpb25hbGl0eVxuICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLl90b2tlblN0cmVhbSA9IG51bGw7XG59XG5cbi8vU3RhdGljIGNvbnN0YW50c1xuUGFyc2VyLkRFRkFVTFRfVFlQRSA9IDA7XG5QYXJzZXIuQ09NQklOQVRPUl9UWVBFID0gMTtcblBhcnNlci5NRURJQV9GRUFUVVJFX1RZUEUgPSAyO1xuUGFyc2VyLk1FRElBX1FVRVJZX1RZUEUgPSAzO1xuUGFyc2VyLlBST1BFUlRZX05BTUVfVFlQRSA9IDQ7XG5QYXJzZXIuUFJPUEVSVFlfVkFMVUVfVFlQRSA9IDU7XG5QYXJzZXIuUFJPUEVSVFlfVkFMVUVfUEFSVF9UWVBFID0gNjtcblBhcnNlci5TRUxFQ1RPUl9UWVBFID0gNztcblBhcnNlci5TRUxFQ1RPUl9QQVJUX1RZUEUgPSA4O1xuUGFyc2VyLlNFTEVDVE9SX1NVQl9QQVJUX1RZUEUgPSA5O1xuXG5QYXJzZXIucHJvdG90eXBlID0gZnVuY3Rpb24oKXtcblxuICAgIHZhciBwcm90byA9IG5ldyBFdmVudFRhcmdldCgpLCAgLy9uZXcgcHJvdG90eXBlXG4gICAgICAgIHByb3AsXG4gICAgICAgIGFkZGl0aW9ucyA9ICB7XG4gICAgICAgICAgICBfX3Byb3RvX186IG51bGwsXG5cbiAgICAgICAgICAgIC8vcmVzdG9yZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgY29uc3RydWN0b3I6IFBhcnNlcixcblxuICAgICAgICAgICAgLy9pbnN0YW5jZSBjb25zdGFudHMgLSB5dWNrXG4gICAgICAgICAgICBERUZBVUxUX1RZUEUgOiAwLFxuICAgICAgICAgICAgQ09NQklOQVRPUl9UWVBFIDogMSxcbiAgICAgICAgICAgIE1FRElBX0ZFQVRVUkVfVFlQRSA6IDIsXG4gICAgICAgICAgICBNRURJQV9RVUVSWV9UWVBFIDogMyxcbiAgICAgICAgICAgIFBST1BFUlRZX05BTUVfVFlQRSA6IDQsXG4gICAgICAgICAgICBQUk9QRVJUWV9WQUxVRV9UWVBFIDogNSxcbiAgICAgICAgICAgIFBST1BFUlRZX1ZBTFVFX1BBUlRfVFlQRSA6IDYsXG4gICAgICAgICAgICBTRUxFQ1RPUl9UWVBFIDogNyxcbiAgICAgICAgICAgIFNFTEVDVE9SX1BBUlRfVFlQRSA6IDgsXG4gICAgICAgICAgICBTRUxFQ1RPUl9TVUJfUEFSVF9UWVBFIDogOSxcblxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gR3JhbW1hclxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBfc3R5bGVzaGVldDogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc3R5bGVzaGVldFxuICAgICAgICAgICAgICAgICAqICA6IFsgQ0hBUlNFVF9TWU0gUyogU1RSSU5HIFMqICc7JyBdP1xuICAgICAgICAgICAgICAgICAqICAgIFtTfENET3xDRENdKiBbIGltcG9ydCBbU3xDRE98Q0RDXSogXSpcbiAgICAgICAgICAgICAgICAgKiAgICBbIG5hbWVzcGFjZSBbU3xDRE98Q0RDXSogXSpcbiAgICAgICAgICAgICAgICAgKiAgICBbIFsgcnVsZXNldCB8IG1lZGlhIHwgcGFnZSB8IGZvbnRfZmFjZSB8IGtleWZyYW1lcyBdIFtTfENET3xDRENdKiBdKlxuICAgICAgICAgICAgICAgICAqICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgICAgICB0dDtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZShcInN0YXJ0c3R5bGVzaGVldFwiKTtcblxuICAgICAgICAgICAgICAgIC8vdHJ5IHRvIHJlYWQgY2hhcmFjdGVyIHNldFxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJzZXQoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3NraXBDcnVmdCgpO1xuXG4gICAgICAgICAgICAgICAgLy90cnkgdG8gcmVhZCBpbXBvcnRzIC0gbWF5IGJlIG1vcmUgdGhhbiBvbmVcbiAgICAgICAgICAgICAgICB3aGlsZSAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuSU1QT1JUX1NZTSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltcG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwQ3J1ZnQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL3RyeSB0byByZWFkIG5hbWVzcGFjZXMgLSBtYXkgYmUgbW9yZSB0aGFuIG9uZVxuICAgICAgICAgICAgICAgIHdoaWxlICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5OQU1FU1BBQ0VfU1lNKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmFtZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraXBDcnVmdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBuZXh0IHRva2VuXG4gICAgICAgICAgICAgICAgdHQgPSB0b2tlblN0cmVhbS5wZWVrKCk7XG5cbiAgICAgICAgICAgICAgICAvL3RyeSB0byByZWFkIHRoZSByZXN0XG4gICAgICAgICAgICAgICAgd2hpbGUodHQgPiBUb2tlbnMuRU9GKXtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2godHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5zLk1FRElBX1NZTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2tpcENydWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5zLlBBR0VfU1lNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraXBDcnVmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRva2Vucy5GT05UX0ZBQ0VfU1lNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb250X2ZhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2tpcENydWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5zLktFWUZSQU1FU19TWU06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleWZyYW1lcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwQ3J1ZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuVklFV1BPUlRfU1lNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3cG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwQ3J1ZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuRE9DVU1FTlRfU1lNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9za2lwQ3J1ZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuVU5LTk9XTl9TWU06ICAvL3Vua25vd24gQCBydWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zdHJpY3Qpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpcmUgZXJyb3IgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogICAgXCJVbmtub3duIEAgcnVsZTogXCIgKyB0b2tlblN0cmVhbS5MVCgwKS52YWx1ZSArIFwiLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgICAgIHRva2VuU3RyZWFtLkxUKDApLnN0YXJ0TGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgICAgICB0b2tlblN0cmVhbS5MVCgwKS5zdGFydENvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2tpcCBicmFjZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50PTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodG9rZW5TdHJlYW0uYWR2YW5jZShbVG9rZW5zLkxCUkFDRSwgVG9rZW5zLlJCUkFDRV0pID09PSBUb2tlbnMuTEJSQUNFKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrOyAgICAvL2tlZXAgdHJhY2sgb2YgbmVzdGluZyBkZXB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShjb3VudCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0uYWR2YW5jZShbVG9rZW5zLlJCUkFDRV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm90IGEgc3ludGF4IGVycm9yLCByZXRocm93IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmtub3duIEAgcnVsZS5cIiwgdG9rZW5TdHJlYW0uTFQoMCkuc3RhcnRMaW5lLCB0b2tlblN0cmVhbS5MVCgwKS5zdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuX3J1bGVzZXQoKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXJyb3IgaGFuZGxpbmcgZm9yIGtub3duIGlzc3Vlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKHR0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRva2Vucy5DSEFSU0VUX1NZTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS5MVCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhcnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkBjaGFyc2V0IG5vdCBhbGxvd2VkIGhlcmUuXCIsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5zLklNUE9SVF9TWU06XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0uTFQoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltcG9ydChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkBpbXBvcnQgbm90IGFsbG93ZWQgaGVyZS5cIiwgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbnMuTkFNRVNQQUNFX1NZTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS5MVCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmFtZXNwYWNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQG5hbWVzcGFjZSBub3QgYWxsb3dlZCBoZXJlLlwiLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5nZXQoKTsgIC8vZ2V0IHRoZSBsYXN0IHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZXhwZWN0ZWRUb2tlbih0b2tlblN0cmVhbS50b2tlbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIFN5bnRheEVycm9yICYmICF0aGlzLm9wdGlvbnMuc3RyaWN0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAgICAgIGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAgICBleC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgICAgICBleC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgICAgICBleC5jb2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0dCA9IHRva2VuU3RyZWFtLnBlZWsoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHQgIT09IFRva2Vucy5FT0Ype1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odG9rZW5TdHJlYW0udG9rZW4oKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKFwiZW5kc3R5bGVzaGVldFwiKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9jaGFyc2V0OiBmdW5jdGlvbihlbWl0KXtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDtcblxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuQ0hBUlNFVF9TWU0pKXtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuU1RSSU5HKTtcblxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSB0b2tlbi52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlNFTUlDT0xPTik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVtaXQgIT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImNoYXJzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyc2V0OmNoYXJzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9pbXBvcnQ6IGZ1bmN0aW9uKGVtaXQpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogaW1wb3J0XG4gICAgICAgICAgICAgICAgICogICA6IElNUE9SVF9TWU0gUypcbiAgICAgICAgICAgICAgICAgKiAgICBbU1RSSU5HfFVSSV0gUyogbWVkaWFfcXVlcnlfbGlzdD8gJzsnIFMqXG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdXJpLFxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFMaXN0ICAgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vcmVhZCBpbXBvcnQgc3ltYm9sXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5JTVBPUlRfU1lNKTtcbiAgICAgICAgICAgICAgICBpbXBvcnRUb2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChbVG9rZW5zLlNUUklORywgVG9rZW5zLlVSSV0pO1xuXG4gICAgICAgICAgICAgICAgLy9ncmFiIHRoZSBVUkkgdmFsdWVcbiAgICAgICAgICAgICAgICB1cmkgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlLnJlcGxhY2UoL14oPzp1cmxcXCgpP1tcIiddPyhbXlwiJ10rPylbXCInXT9cXCk/JC8sIFwiJDFcIik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgbWVkaWFMaXN0ID0gdGhpcy5fbWVkaWFfcXVlcnlfbGlzdCgpO1xuXG4gICAgICAgICAgICAgICAgLy9tdXN0IGVuZCB3aXRoIGEgc2VtaWNvbG9uXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5TRU1JQ09MT04pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW1pdCAhPT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImltcG9ydFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiAgICB1cmksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYTogIG1lZGlhTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgaW1wb3J0VG9rZW4uc3RhcnRMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiAgICBpbXBvcnRUb2tlbi5zdGFydENvbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9uYW1lc3BhY2U6IGZ1bmN0aW9uKGVtaXQpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgICogICA6IE5BTUVTUEFDRV9TWU0gUyogW25hbWVzcGFjZV9wcmVmaXggUypdPyBbU1RSSU5HfFVSSV0gUyogJzsnIFMqXG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIHVyaTtcblxuICAgICAgICAgICAgICAgIC8vcmVhZCBpbXBvcnQgc3ltYm9sXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5OQU1FU1BBQ0VfU1lNKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgLy9pdCdzIGEgbmFtZXNwYWNlIHByZWZpeCAtIG5vIF9uYW1lc3BhY2VfcHJlZml4KCkgbWV0aG9kIGJlY2F1c2UgaXQncyBqdXN0IGFuIElERU5UXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JREVOVCkpe1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChbVG9rZW5zLlNUUklORywgVG9rZW5zLlVSSV0pO1xuICAgICAgICAgICAgICAgIC8qaWYgKCF0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuU1RSSU5HKSl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuVVJJKTtcbiAgICAgICAgICAgICAgICB9Ki9cblxuICAgICAgICAgICAgICAgIC8vZ3JhYiB0aGUgVVJJIHZhbHVlXG4gICAgICAgICAgICAgICAgdXJpID0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZS5yZXBsYWNlKC8oPzp1cmxcXCgpP1tcIiddKFteXCInXSspW1wiJ11cXCk/LywgXCIkMVwiKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICAvL211c3QgZW5kIHdpdGggYSBzZW1pY29sb25cbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlNFTUlDT0xPTik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIGlmIChlbWl0ICE9PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgIFwibmFtZXNwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVyaTogICAgdXJpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiAgICBjb2xcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfbWVkaWE6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBtZWRpYVxuICAgICAgICAgICAgICAgICAqICAgOiBNRURJQV9TWU0gUyogbWVkaWFfcXVlcnlfbGlzdCBTKiAneycgUyogcnVsZXNldCogJ30nIFMqXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtICAgICA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhTGlzdDsvLyAgICAgICA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy9sb29rIGZvciBAbWVkaWFcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLk1FRElBX1NZTSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgbWVkaWFMaXN0ID0gdGhpcy5fbWVkaWFfcXVlcnlfbGlzdCgpO1xuXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5MQlJBQ0UpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAgIFwic3RhcnRtZWRpYVwiLFxuICAgICAgICAgICAgICAgICAgICBtZWRpYTogIG1lZGlhTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGNvbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuUEFHRV9TWU0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLkZPTlRfRkFDRV9TWU0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9udF9mYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuVklFV1BPUlRfU1lNKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuRE9DVU1FTlRfU1lNKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvY3VtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3J1bGVzZXQoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuUkJSQUNFKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImVuZG1lZGlhXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhOiAgbWVkaWFMaXN0LFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIC8vQ1NTMyBNZWRpYSBRdWVyaWVzXG4gICAgICAgICAgICBfbWVkaWFfcXVlcnlfbGlzdDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG1lZGlhX3F1ZXJ5X2xpc3RcbiAgICAgICAgICAgICAgICAgKiAgIDogUyogW21lZGlhX3F1ZXJ5IFsgJywnIFMqIG1lZGlhX3F1ZXJ5IF0qIF0/XG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhTGlzdCAgID0gW107XG5cblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuSURFTlQgfHwgdG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuTFBBUkVOKXtcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFMaXN0LnB1c2godGhpcy5fbWVkaWFfcXVlcnkoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkNPTU1BKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhTGlzdC5wdXNoKHRoaXMuX21lZGlhX3F1ZXJ5KCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYUxpc3Q7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogTm90ZTogXCJleHByZXNzaW9uXCIgaW4gdGhlIGdyYW1tYXIgbWFwcyB0byB0aGUgX21lZGlhX2V4cHJlc3Npb25cbiAgICAgICAgICAgICAqIG1ldGhvZC5cblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfbWVkaWFfcXVlcnk6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBtZWRpYV9xdWVyeVxuICAgICAgICAgICAgICAgICAqICAgOiBbT05MWSB8IE5PVF0/IFMqIG1lZGlhX3R5cGUgUyogWyBBTkQgUyogZXhwcmVzc2lvbiBdKlxuICAgICAgICAgICAgICAgICAqICAgfCBleHByZXNzaW9uIFsgQU5EIFMqIGV4cHJlc3Npb24gXSpcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpZGVudCAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuSURFTlQpKXtcbiAgICAgICAgICAgICAgICAgICAgaWRlbnQgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9zaW5jZSB0aGVyZSdzIG5vIGN1c3RvbSB0b2tlbnMgZm9yIHRoZXNlLCBuZWVkIHRvIG1hbnVhbGx5IGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZGVudCAhPT0gXCJvbmx5XCIgJiYgaWRlbnQgIT09IFwibm90XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0udW5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0udG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuSURFTlQpe1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdGhpcy5fbWVkaWFfdHlwZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5MUEFSRU4pe1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS5MVCgxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMuX21lZGlhX2V4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IG51bGwgJiYgZXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JREVOVCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWUudG9Mb3dlckNhc2UoKSAhPT0gXCJhbmRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLnRva2VuKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLl9tZWRpYV9leHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZWRpYVF1ZXJ5KGlkZW50LCB0eXBlLCBleHByZXNzaW9ucywgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgTWVkaWEgUXVlcmllc1xuICAgICAgICAgICAgX21lZGlhX3R5cGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBtZWRpYV90eXBlXG4gICAgICAgICAgICAgICAgICogICA6IElERU5UXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhX2ZlYXR1cmUoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm90ZTogaW4gQ1NTMyBNZWRpYSBRdWVyaWVzLCB0aGlzIGlzIGNhbGxlZCBcImV4cHJlc3Npb25cIi5cbiAgICAgICAgICAgICAqIFJlbmFtZWQgaGVyZSB0byBhdm9pZCBjb25mbGljdCB3aXRoIENTUzMgU2VsZWN0b3JzXG4gICAgICAgICAgICAgKiBkZWZpbml0aW9uIG9mIFwiZXhwcmVzc2lvblwiLiBBbHNvIG5vdGUgdGhhdCBcImV4cHJcIiBpbiB0aGVcbiAgICAgICAgICAgICAqIGdyYW1tYXIgbm93IG1hcHMgdG8gXCJleHByZXNzaW9uXCIgZnJvbSBDU1MzIHNlbGVjdG9ycy5cbiAgICAgICAgICAgICAqIEBtZXRob2QgX21lZGlhX2V4cHJlc3Npb25cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9tZWRpYV9leHByZXNzaW9uOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAqICA6ICcoJyBTKiBtZWRpYV9mZWF0dXJlIFMqIFsgJzonIFMqIGV4cHIgXT8gJyknIFMqXG4gICAgICAgICAgICAgICAgICogIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZSAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiAgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5MUEFSRU4pO1xuXG4gICAgICAgICAgICAgICAgZmVhdHVyZSA9IHRoaXMuX21lZGlhX2ZlYXR1cmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5DT0xPTikpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLkxUKDEpO1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5fZXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuUlBBUkVOKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZWRpYUZlYXR1cmUoZmVhdHVyZSwgKGV4cHJlc3Npb24gPyBuZXcgU3ludGF4VW5pdChleHByZXNzaW9uLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKSA6IG51bGwpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBNZWRpYSBRdWVyaWVzXG4gICAgICAgICAgICBfbWVkaWFfZmVhdHVyZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIG1lZGlhX2ZlYXR1cmVcbiAgICAgICAgICAgICAgICAgKiAgIDogSURFTlRcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLklERU5UKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXhVbml0LmZyb21Ub2tlbih0b2tlblN0cmVhbS50b2tlbigpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBQYWdlZCBNZWRpYVxuICAgICAgICAgICAgX3BhZ2U6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBwYWdlOlxuICAgICAgICAgICAgICAgICAqICAgIFBBR0VfU1lNIFMqIElERU5UPyBwc2V1ZG9fcGFnZT8gUypcbiAgICAgICAgICAgICAgICAgKiAgICAneycgUyogWyBkZWNsYXJhdGlvbiB8IG1hcmdpbiBdPyBbICc7JyBTKiBbIGRlY2xhcmF0aW9uIHwgbWFyZ2luIF0/IF0qICd9JyBTKlxuICAgICAgICAgICAgICAgICAqICAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBzZXVkb1BhZ2UgID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vbG9vayBmb3IgQHBhZ2VcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlBBR0VfU1lNKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKSl7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vVGhlIHZhbHVlICdhdXRvJyBtYXkgbm90IGJlIHVzZWQgYXMgYSBwYWdlIG5hbWUgYW5kIE1VU1QgYmUgdHJlYXRlZCBhcyBhIHN5bnRheCBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkZW50aWZpZXIudG9Mb3dlckNhc2UoKSA9PT0gXCJhdXRvXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLnRva2VuKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9zZWUgaWYgdGhlcmUncyBhIGNvbG9uIHVwY29taW5nXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLkNPTE9OKXtcbiAgICAgICAgICAgICAgICAgICAgcHNldWRvUGFnZSA9IHRoaXMuX3BzZXVkb19wYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJzdGFydHBhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICBwc2V1ZG86IHBzZXVkb1BhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiAgICBjb2xcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWREZWNsYXJhdGlvbnModHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAgIFwiZW5kcGFnZVwiLFxuICAgICAgICAgICAgICAgICAgICBpZDogICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgIHBzZXVkbzogcHNldWRvUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGNvbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgUGFnZWQgTWVkaWFcbiAgICAgICAgICAgIF9tYXJnaW46IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBtYXJnaW4gOlxuICAgICAgICAgICAgICAgICAqICAgIG1hcmdpbl9zeW0gUyogJ3snIGRlY2xhcmF0aW9uIFsgJzsnIFMqIGRlY2xhcmF0aW9uPyBdKiAnfScgUypcbiAgICAgICAgICAgICAgICAgKiAgICA7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luU3ltICAgPSB0aGlzLl9tYXJnaW5fc3ltKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWFyZ2luU3ltKXtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXJ0cGFnZW1hcmdpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBtYXJnaW5TeW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGNvbFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkRGVjbGFyYXRpb25zKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVuZHBhZ2VtYXJnaW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogbWFyZ2luU3ltLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiAgICBjb2xcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgUGFnZWQgTWVkaWFcbiAgICAgICAgICAgIF9tYXJnaW5fc3ltOiBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBtYXJnaW5fc3ltIDpcbiAgICAgICAgICAgICAgICAgKiAgICBUT1BMRUZUQ09STkVSX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgVE9QTEVGVF9TWU0gfFxuICAgICAgICAgICAgICAgICAqICAgIFRPUENFTlRFUl9TWU0gfFxuICAgICAgICAgICAgICAgICAqICAgIFRPUFJJR0hUX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgVE9QUklHSFRDT1JORVJfU1lNIHxcbiAgICAgICAgICAgICAgICAgKiAgICBCT1RUT01MRUZUQ09STkVSX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgQk9UVE9NTEVGVF9TWU0gfFxuICAgICAgICAgICAgICAgICAqICAgIEJPVFRPTUNFTlRFUl9TWU0gfFxuICAgICAgICAgICAgICAgICAqICAgIEJPVFRPTVJJR0hUX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgQk9UVE9NUklHSFRDT1JORVJfU1lNIHxcbiAgICAgICAgICAgICAgICAgKiAgICBMRUZUVE9QX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgTEVGVE1JRERMRV9TWU0gfFxuICAgICAgICAgICAgICAgICAqICAgIExFRlRCT1RUT01fU1lNIHxcbiAgICAgICAgICAgICAgICAgKiAgICBSSUdIVFRPUF9TWU0gfFxuICAgICAgICAgICAgICAgICAqICAgIFJJR0hUTUlERExFX1NZTSB8XG4gICAgICAgICAgICAgICAgICogICAgUklHSFRCT1RUT01fU1lNXG4gICAgICAgICAgICAgICAgICogICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW07XG5cbiAgICAgICAgICAgICAgICBpZih0b2tlblN0cmVhbS5tYXRjaChbVG9rZW5zLlRPUExFRlRDT1JORVJfU1lNLCBUb2tlbnMuVE9QTEVGVF9TWU0sXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuVE9QQ0VOVEVSX1NZTSwgVG9rZW5zLlRPUFJJR0hUX1NZTSwgVG9rZW5zLlRPUFJJR0hUQ09STkVSX1NZTSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5CT1RUT01MRUZUQ09STkVSX1NZTSwgVG9rZW5zLkJPVFRPTUxFRlRfU1lNLFxuICAgICAgICAgICAgICAgICAgICAgICAgVG9rZW5zLkJPVFRPTUNFTlRFUl9TWU0sIFRva2Vucy5CT1RUT01SSUdIVF9TWU0sXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuQk9UVE9NUklHSFRDT1JORVJfU1lNLCBUb2tlbnMuTEVGVFRPUF9TWU0sXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuTEVGVE1JRERMRV9TWU0sIFRva2Vucy5MRUZUQk9UVE9NX1NZTSwgVG9rZW5zLlJJR0hUVE9QX1NZTSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5SSUdIVE1JRERMRV9TWU0sIFRva2Vucy5SSUdIVEJPVFRPTV9TWU1dKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXhVbml0LmZyb21Ub2tlbih0b2tlblN0cmVhbS50b2tlbigpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9wc2V1ZG9fcGFnZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHBzZXVkb19wYWdlXG4gICAgICAgICAgICAgICAgICogICA6ICc6JyBJREVOVFxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW07XG5cbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLkNPTE9OKTtcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLklERU5UKTtcblxuICAgICAgICAgICAgICAgIC8vVE9ETzogQ1NTMyBQYWdlZCBNZWRpYSBzYXlzIG9ubHkgXCJsZWZ0XCIsIFwiY2VudGVyXCIsIGFuZCBcInJpZ2h0XCIgYXJlIGFsbG93ZWRcblxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2ZvbnRfZmFjZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGZvbnRfZmFjZVxuICAgICAgICAgICAgICAgICAqICAgOiBGT05UX0ZBQ0VfU1lNIFMqXG4gICAgICAgICAgICAgICAgICogICAgICd7JyBTKiBkZWNsYXJhdGlvbiBbICc7JyBTKiBkZWNsYXJhdGlvbiBdKiAnfScgUypcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sO1xuXG4gICAgICAgICAgICAgICAgLy9sb29rIGZvciBAcGFnZVxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuRk9OVF9GQUNFX1NZTSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcInN0YXJ0Zm9udGZhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgIGNvbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZERlY2xhcmF0aW9ucyh0cnVlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJlbmRmb250ZmFjZVwiLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfdmlld3BvcnQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB2aWV3cG9ydFxuICAgICAgICAgICAgICAgICAqICAgOiBWSUVXUE9SVF9TWU0gUypcbiAgICAgICAgICAgICAgICAgKiAgICAgJ3snIFMqIGRlY2xhcmF0aW9uPyBbICc7JyBTKiBkZWNsYXJhdGlvbj8gXSogJ30nIFMqXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w7XG5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5WSUVXUE9SVF9TWU0pO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcInN0YXJ0dmlld3BvcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogICAgY29sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWREZWNsYXJhdGlvbnModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJlbmR2aWV3cG9ydFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiAgICBjb2xcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9kb2N1bWVudDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICogICA6IERPQ1VNRU5UX1NZTSBTKlxuICAgICAgICAgICAgICAgICAqICAgICBfZG9jdW1lbnRfZnVuY3Rpb24gWyAnLCcgUyogX2RvY3VtZW50X2Z1bmN0aW9uIF0qIFMqXG4gICAgICAgICAgICAgICAgICogICAgICd7JyBTKiBydWxlc2V0KiAnfSdcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLkRPQ1VNRU5UX1NZTSk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xuICAgICAgICAgICAgICAgIGlmICgvXkBcXC0oW15cXC1dKylcXC0vLnRlc3QodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IFJlZ0V4cC4kMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9ucy5wdXNoKHRoaXMuX2RvY3VtZW50X2Z1bmN0aW9uKCkpO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkNPTU1BKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnMucHVzaCh0aGlzLl9kb2N1bWVudF9mdW5jdGlvbigpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLkxCUkFDRSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgXCJzdGFydGRvY3VtZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uczogZnVuY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6ICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICB0b2tlbi5zdGFydExpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbDogICAgICAgdG9rZW4uc3RhcnRDb2xcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLlBBR0VfU1lNKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5GT05UX0ZBQ0VfU1lNKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRfZmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLlZJRVdQT1JUX1NZTSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3cG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLk1FRElBX1NZTSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9ydWxlc2V0KCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlJCUkFDRSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgXCJlbmRkb2N1bWVudFwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnM6IGZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiAgICBwcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgICAgdG9rZW4uc3RhcnRMaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w6ICAgICAgIHRva2VuLnN0YXJ0Q29sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfZG9jdW1lbnRfZnVuY3Rpb246IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBkb2N1bWVudF9mdW5jdGlvblxuICAgICAgICAgICAgICAgICAqICAgOiBmdW5jdGlvbiB8IFVSSSBTKlxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5VUkkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2Z1bmN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX29wZXJhdG9yOiBmdW5jdGlvbihpbkZ1bmN0aW9uKXtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogb3BlcmF0b3IgKG91dHNpZGUgZnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgICogIDogJy8nIFMqIHwgJywnIFMqIHwgLyggZW1wdHkgKS9cbiAgICAgICAgICAgICAgICAgKiBvcGVyYXRvciAoaW5zaWRlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgICAqICA6ICcvJyBTKiB8ICcrJyBTKiB8ICcqJyBTKiB8ICctJyBTKiAvKCBlbXB0eSApL1xuICAgICAgICAgICAgICAgICAqICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gICAgICAgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuU0xBU0gsIFRva2Vucy5DT01NQV0pIHx8XG4gICAgICAgICAgICAgICAgICAgIChpbkZ1bmN0aW9uICYmIHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuUExVUywgVG9rZW5zLlNUQVIsIFRva2Vucy5NSU5VU10pKSl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gIHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA/IFByb3BlcnR5VmFsdWVQYXJ0LmZyb21Ub2tlbih0b2tlbikgOiBudWxsO1xuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfY29tYmluYXRvcjogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogY29tYmluYXRvclxuICAgICAgICAgICAgICAgICAqICA6IFBMVVMgUyogfCBHUkVBVEVSIFMqIHwgVElMREUgUyogfCBTK1xuICAgICAgICAgICAgICAgICAqICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjtcblxuICAgICAgICAgICAgICAgIGlmKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuUExVUywgVG9rZW5zLkdSRUFURVIsIFRva2Vucy5USUxERV0pKXtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBDb21iaW5hdG9yKHRva2VuLnZhbHVlLCB0b2tlbi5zdGFydExpbmUsIHRva2VuLnN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfdW5hcnlfb3BlcmF0b3I6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHVuYXJ5X29wZXJhdG9yXG4gICAgICAgICAgICAgICAgICogIDogJy0nIHwgJysnXG4gICAgICAgICAgICAgICAgICogIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuTUlOVVMsIFRva2Vucy5QTFVTXSkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfcHJvcGVydHk6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICogICA6IElERU5UIFMqXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBoYWNrICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w7XG5cbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBzdGFyIGhhY2sgLSB0aHJvd3MgZXJyb3IgaWYgbm90IGFsbG93ZWRcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuU1RBUiAmJiB0aGlzLm9wdGlvbnMuc3RhckhhY2spe1xuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xuICAgICAgICAgICAgICAgICAgICBoYWNrID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlbi5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuLnN0YXJ0Q29sO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JREVOVCkpe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuVmFsdWUgPSB0b2tlbi52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciB1bmRlcnNjb3JlIGhhY2sgLSBubyBlcnJvciBpZiBub3QgYWxsb3dlZCBiZWNhdXNlIGl0J3MgdmFsaWQgQ1NTIHN5bnRheFxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5WYWx1ZS5jaGFyQXQoMCkgPT09IFwiX1wiICYmIHRoaXMub3B0aW9ucy51bmRlcnNjb3JlSGFjayl7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYWNrID0gXCJfXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblZhbHVlID0gdG9rZW5WYWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBQcm9wZXJ0eU5hbWUodG9rZW5WYWx1ZSwgaGFjaywgKGxpbmV8fHRva2VuLnN0YXJ0TGluZSksIChjb2x8fHRva2VuLnN0YXJ0Q29sKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9BdWdtZW50ZWQgd2l0aCBDU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX3J1bGVzZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBydWxlc2V0XG4gICAgICAgICAgICAgICAgICogICA6IHNlbGVjdG9yc19ncm91cFxuICAgICAgICAgICAgICAgICAqICAgICAneycgUyogZGVjbGFyYXRpb24/IFsgJzsnIFMqIGRlY2xhcmF0aW9uPyBdKiAnfScgUypcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB0dCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzO1xuXG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIEVycm9yIFJlY292ZXJ5OiBJZiBldmVuIGEgc2luZ2xlIHNlbGVjdG9yIGZhaWxzIHRvIHBhcnNlLFxuICAgICAgICAgICAgICAgICAqIHRoZW4gdGhlIGVudGlyZSBydWxlc2V0IHNob3VsZCBiZSB0aHJvd24gYXdheS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSB0aGlzLl9zZWxlY3RvcnNfZ3JvdXAoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIFN5bnRheEVycm9yICYmICF0aGlzLm9wdGlvbnMuc3RyaWN0KXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9maXJlIGVycm9yIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogICAgICBleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAgICBleC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgICAgIGV4LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sOiAgICAgICAgZXguY29sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9za2lwIG92ZXIgZXZlcnl0aGluZyB1bnRpbCBjbG9zaW5nIGJyYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0dCA9IHRva2VuU3RyZWFtLmFkdmFuY2UoW1Rva2Vucy5SQlJBQ0VdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0dCA9PT0gVG9rZW5zLlJCUkFDRSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGEgcmlnaHQgYnJhY2UsIHRoZSBydWxlIGlzIGZpbmlzaGVkIHNvIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCByZXRocm93IHRoZSBlcnJvciBiZWNhdXNlIGl0IHdhc24ndCBoYW5kbGVkIHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbm90IGEgc3ludGF4IGVycm9yLCByZXRocm93IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vdHJpZ2dlciBwYXJzZXIgdG8gY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiBpdCBnb3QgaGVyZSwgYWxsIHNlbGVjdG9ycyBwYXJzZWRcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzKXtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJzdGFydHJ1bGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yczogIHNlbGVjdG9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgICAgIHNlbGVjdG9yc1swXS5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiAgICAgICAgc2VsZWN0b3JzWzBdLmNvbFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkRGVjbGFyYXRpb25zKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcImVuZHJ1bGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yczogIHNlbGVjdG9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgICAgIHNlbGVjdG9yc1swXS5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiAgICAgICAgc2VsZWN0b3JzWzBdLmNvbFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcnM7XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcbiAgICAgICAgICAgIF9zZWxlY3RvcnNfZ3JvdXA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHNlbGVjdG9yc19ncm91cFxuICAgICAgICAgICAgICAgICAqICAgOiBzZWxlY3RvciBbIENPTU1BIFMqIHNlbGVjdG9yIF0qXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycyAgID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yO1xuXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLl9zZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2goc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuQ09NTUEpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHRoaXMuX3NlbGVjdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLkxUKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcnMubGVuZ3RoID8gc2VsZWN0b3JzIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcbiAgICAgICAgICAgIF9zZWxlY3RvcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICogICA6IHNpbXBsZV9zZWxlY3Rvcl9zZXF1ZW5jZSBbIGNvbWJpbmF0b3Igc2ltcGxlX3NlbGVjdG9yX3NlcXVlbmNlIF0qXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgICAgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNlbGVjdG9yID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29tYmluYXRvciAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICB3cyAgICAgICAgICA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3Mgbm8gc2ltcGxlIHNlbGVjdG9yLCB0aGVuIHRoZXJlJ3Mgbm8gc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBuZXh0U2VsZWN0b3IgPSB0aGlzLl9zaW1wbGVfc2VsZWN0b3Jfc2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlbGVjdG9yID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IucHVzaChuZXh0U2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vbG9vayBmb3IgYSBjb21iaW5hdG9yXG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmF0b3IgPSB0aGlzLl9jb21iaW5hdG9yKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbWJpbmF0b3IgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IucHVzaChjb21iaW5hdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTZWxlY3RvciA9IHRoaXMuX3NpbXBsZV9zZWxlY3Rvcl9zZXF1ZW5jZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZXJlIG11c3QgYmUgYSBuZXh0IHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNlbGVjdG9yID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odG9rZW5TdHJlYW0uTFQoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbmV4dFNlbGVjdG9yIGlzIGFuIGluc3RhbmNlIG9mIFNlbGVjdG9yUGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLnB1c2gobmV4dFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIG5vdCB3aGl0ZXNwYWNlLCB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZFdoaXRlc3BhY2UoKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCB3aGl0ZXNwYWNlIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdzID0gbmV3IENvbWJpbmF0b3IodG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZSwgdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmUsIHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2wpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21iaW5hdG9yIGlzIG5vdCByZXF1aXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmF0b3IgPSB0aGlzLl9jb21iaW5hdG9yKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NlbGVjdG9yIGlzIHJlcXVpcmVkIGlmIHRoZXJlJ3MgYSBjb21iaW5hdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNlbGVjdG9yID0gdGhpcy5fc2ltcGxlX3NlbGVjdG9yX3NlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTZWxlY3RvciA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21iaW5hdG9yICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZXhwZWN0ZWRUb2tlbih0b2tlblN0cmVhbS5MVCgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21iaW5hdG9yICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLnB1c2goY29tYmluYXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvci5wdXNoKHdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLnB1c2gobmV4dFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvcihzZWxlY3Rvciwgc2VsZWN0b3JbMF0ubGluZSwgc2VsZWN0b3JbMF0uY29sKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcbiAgICAgICAgICAgIF9zaW1wbGVfc2VsZWN0b3Jfc2VxdWVuY2U6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBzaW1wbGVfc2VsZWN0b3Jfc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgKiAgIDogWyB0eXBlX3NlbGVjdG9yIHwgdW5pdmVyc2FsIF1cbiAgICAgICAgICAgICAgICAgKiAgICAgWyBIQVNIIHwgY2xhc3MgfCBhdHRyaWIgfCBwc2V1ZG8gfCBuZWdhdGlvbiBdKlxuICAgICAgICAgICAgICAgICAqICAgfCBbIEhBU0ggfCBjbGFzcyB8IGF0dHJpYiB8IHBzZXVkbyB8IG5lZ2F0aW9uIF0rXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcblxuICAgICAgICAgICAgICAgICAgICAvL3BhcnRzIG9mIGEgc2ltcGxlIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzICAgPSBbXSxcblxuICAgICAgICAgICAgICAgICAgICAvL2NvbXBsZXRlIHNlbGVjdG9yIHRleHRcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JUZXh0PSBcIlwiLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIGRpZmZlcmVudCBwYXJ0cyBhZnRlciB0aGUgZWxlbWVudCBuYW1lIHRvIHNlYXJjaCBmb3JcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cyAgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0hBU0hcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5IQVNIKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2VsZWN0b3JTdWJQYXJ0KHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWUsIFwiaWRcIiwgdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmUsIHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2wpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRyaWIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wc2V1ZG8sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZWdhdGlvblxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlbiAgICAgICAgID0gY29tcG9uZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sO1xuXG5cbiAgICAgICAgICAgICAgICAvL2dldCBzdGFydGluZyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoZSBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS5MVCgxKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0uTFQoMSkuc3RhcnRDb2w7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50TmFtZSA9IHRoaXMuX3R5cGVfc2VsZWN0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnROYW1lKXtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB0aGlzLl91bml2ZXJzYWwoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudE5hbWUgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclRleHQgKz0gZWxlbWVudE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgLy93aGl0ZXNwYWNlIG1lYW5zIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLlMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICB3aGlsZShpIDwgbGVuICYmIGNvbXBvbmVudCA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW2krK10uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQgPT09IG51bGwpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGRvbid0IGhhdmUgYSBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yVGV4dCA9PT0gXCJcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnMucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JUZXh0ICs9IGNvbXBvbmVudC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yVGV4dCAhPT0gXCJcIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2VsZWN0b3JQYXJ0KGVsZW1lbnROYW1lLCBtb2RpZmllcnMsIHNlbGVjdG9yVGV4dCwgbGluZSwgY29sKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX3R5cGVfc2VsZWN0b3I6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB0eXBlX3NlbGVjdG9yXG4gICAgICAgICAgICAgICAgICogICA6IFsgbmFtZXNwYWNlX3ByZWZpeCBdPyBlbGVtZW50X25hbWVcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBucyAgICAgICAgICA9IHRoaXMuX25hbWVzcGFjZV9wcmVmaXgoKSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB0aGlzLl9lbGVtZW50X25hbWUoKTtcblxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudE5hbWUpe1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBOZWVkIHRvIGJhY2sgb3V0IHRoZSBuYW1lc3BhY2UgdGhhdCB3YXMgcmVhZCBkdWUgdG8gYm90aFxuICAgICAgICAgICAgICAgICAgICAgKiB0eXBlX3NlbGVjdG9yIGFuZCB1bml2ZXJzYWwgcmVhZGluZyBuYW1lc3BhY2VfcHJlZml4XG4gICAgICAgICAgICAgICAgICAgICAqIGZpcnN0LiBLaW5kIG9mIGhhY2t5LCBidXQgb25seSB3YXkgSSBjYW4gZmlndXJlIG91dFxuICAgICAgICAgICAgICAgICAgICAgKiByaWdodCBub3cgaG93IHRvIG5vdCBjaGFuZ2UgdGhlIGdyYW1tYXIuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAobnMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0udW5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChucy5sZW5ndGggPiAxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS51bmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5zKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lLnRleHQgPSBucyArIGVsZW1lbnROYW1lLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50TmFtZS5jb2wgLT0gbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50TmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXG4gICAgICAgICAgICBfY2xhc3M6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBjbGFzc1xuICAgICAgICAgICAgICAgICAqICAgOiAnLicgSURFTlRcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjtcblxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuRE9UKSl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuSURFTlQpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0b3JTdWJQYXJ0KFwiLlwiICsgdG9rZW4udmFsdWUsIFwiY2xhc3NcIiwgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCAtIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX2VsZW1lbnRfbmFtZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGVsZW1lbnRfbmFtZVxuICAgICAgICAgICAgICAgICAqICAgOiBJREVOVFxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JREVOVCkpe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0b3JTdWJQYXJ0KHRva2VuLnZhbHVlLCBcImVsZW1lbnROYW1lXCIsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX25hbWVzcGFjZV9wcmVmaXg6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBuYW1lc3BhY2VfcHJlZml4XG4gICAgICAgICAgICAgICAgICogICA6IFsgSURFTlQgfCAnKicgXT8gJ3wnXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgID0gXCJcIjtcblxuICAgICAgICAgICAgICAgIC8vdmVyaWZ5IHRoYXQgdGhpcyBpcyBhIG5hbWVzcGFjZSBwcmVmaXhcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0uTEEoMSkgPT09IFRva2Vucy5QSVBFIHx8IHRva2VuU3RyZWFtLkxBKDIpID09PSBUb2tlbnMuUElQRSl7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5JREVOVCwgVG9rZW5zLlNUQVJdKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5QSVBFKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gXCJ8XCI7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID8gdmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX3VuaXZlcnNhbDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHVuaXZlcnNhbFxuICAgICAgICAgICAgICAgICAqICAgOiBbIG5hbWVzcGFjZV9wcmVmaXggXT8gJyonXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgID0gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgbnM7XG5cbiAgICAgICAgICAgICAgICBucyA9IHRoaXMuX25hbWVzcGFjZV9wcmVmaXgoKTtcbiAgICAgICAgICAgICAgICBpZihucyl7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IG5zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5TVEFSKSl7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFwiKlwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPyB2YWx1ZSA6IG51bGw7XG5cbiAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX2F0dHJpYjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGF0dHJpYlxuICAgICAgICAgICAgICAgICAqICAgOiAnWycgUyogWyBuYW1lc3BhY2VfcHJlZml4IF0/IElERU5UIFMqXG4gICAgICAgICAgICAgICAgICogICAgICAgICBbIFsgUFJFRklYTUFUQ0ggfFxuICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgIFNVRkZJWE1BVENIIHxcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICBTVUJTVFJJTkdNQVRDSCB8XG4gICAgICAgICAgICAgICAgICogICAgICAgICAgICAgJz0nIHxcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICBJTkNMVURFUyB8XG4gICAgICAgICAgICAgICAgICogICAgICAgICAgICAgREFTSE1BVENIIF0gUyogWyBJREVOVCB8IFNUUklORyBdIFMqXG4gICAgICAgICAgICAgICAgICogICAgICAgICBdPyAnXSdcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5zLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjtcblxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuTEJSQUNLRVQpKXtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5zID0gdGhpcy5fbmFtZXNwYWNlX3ByZWZpeCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChucyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBucztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuSURFTlQpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuUFJFRklYTUFUQ0gsIFRva2Vucy5TVUZGSVhNQVRDSCwgVG9rZW5zLlNVQlNUUklOR01BVENILFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5FUVVBTFMsIFRva2Vucy5JTkNMVURFUywgVG9rZW5zLkRBU0hNQVRDSF0pKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChbVG9rZW5zLklERU5ULCBUb2tlbnMuU1RSSU5HXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuUkJSQUNLRVQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0b3JTdWJQYXJ0KHZhbHVlICsgXCJdXCIsIFwiYXR0cmlidXRlXCIsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcbiAgICAgICAgICAgIF9wc2V1ZG86IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHBzZXVkb1xuICAgICAgICAgICAgICAgICAqICAgOiAnOicgJzonPyBbIElERU5UIHwgZnVuY3Rpb25hbF9wc2V1ZG8gXVxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHBzZXVkbyAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29sb25zICAgICAgPSBcIjpcIixcbiAgICAgICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5DT0xPTikpe1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuQ09MT04pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ucyArPSBcIjpcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuSURFTlQpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzZXVkbyA9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sIC0gY29sb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblN0cmVhbS5wZWVrKCkgPT09IFRva2Vucy5GVU5DVElPTil7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0uTFQoMSkuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0uTFQoMSkuc3RhcnRDb2wgLSBjb2xvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNldWRvID0gdGhpcy5fZnVuY3Rpb25hbF9wc2V1ZG8oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwc2V1ZG8pe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNldWRvID0gbmV3IFNlbGVjdG9yU3ViUGFydChjb2xvbnMgKyBwc2V1ZG8sIFwicHNldWRvXCIsIGxpbmUsIGNvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHNldWRvO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy9DU1MzIFNlbGVjdG9yc1xuICAgICAgICAgICAgX2Z1bmN0aW9uYWxfcHNldWRvOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogZnVuY3Rpb25hbF9wc2V1ZG9cbiAgICAgICAgICAgICAgICAgKiAgIDogRlVOQ1RJT04gUyogZXhwcmVzc2lvbiAnKSdcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5GVU5DVElPTikpe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX2V4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5SUEFSRU4pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBcIilcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXG4gICAgICAgICAgICBfZXhwcmVzc2lvbjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgKiAgIDogWyBbIFBMVVMgfCAnLScgfCBESU1FTlNJT04gfCBOVU1CRVIgfCBTVFJJTkcgfCBJREVOVCBdIFMqIF0rXG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5QTFVTLCBUb2tlbnMuTUlOVVMsIFRva2Vucy5ESU1FTlNJT04sXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuTlVNQkVSLCBUb2tlbnMuU1RSSU5HLCBUb2tlbnMuSURFTlQsIFRva2Vucy5MRU5HVEgsXG4gICAgICAgICAgICAgICAgICAgICAgICBUb2tlbnMuRlJFUSwgVG9rZW5zLkFOR0xFLCBUb2tlbnMuVElNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5SRVNPTFVUSU9OLCBUb2tlbnMuU0xBU0hdKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID8gdmFsdWUgOiBudWxsO1xuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvL0NTUzMgU2VsZWN0b3JzXG4gICAgICAgICAgICBfbmVnYXRpb246IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBuZWdhdGlvblxuICAgICAgICAgICAgICAgICAqICAgOiBOT1QgUyogbmVnYXRpb25fYXJnIFMqICcpJ1xuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgICAgIHN1YnBhcnQgICAgID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuTk9UKSl7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSB0aGlzLl9uZWdhdGlvbl9hcmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gYXJnO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuUlBBUkVOKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBzdWJwYXJ0ID0gbmV3IFNlbGVjdG9yU3ViUGFydCh2YWx1ZSwgXCJub3RcIiwgbGluZSwgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgc3VicGFydC5hcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VicGFydDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vQ1NTMyBTZWxlY3RvcnNcbiAgICAgICAgICAgIF9uZWdhdGlvbl9hcmc6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBuZWdhdGlvbl9hcmdcbiAgICAgICAgICAgICAgICAgKiAgIDogdHlwZV9zZWxlY3RvciB8IHVuaXZlcnNhbCB8IEhBU0ggfCBjbGFzcyB8IGF0dHJpYiB8IHBzZXVkb1xuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgICAgICAgID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHlwZV9zZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuaXZlcnNhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5IQVNIKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2VsZWN0b3JTdWJQYXJ0KHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWUsIFwiaWRcIiwgdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydExpbmUsIHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2wpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRyaWIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wc2V1ZG9cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgYXJnICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlbiAgICAgICAgID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgICAgICAgICAgcGFydDtcblxuICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS5MVCgxKS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0uTFQoMSkuc3RhcnRDb2w7XG5cbiAgICAgICAgICAgICAgICB3aGlsZShpIDwgbGVuICYmIGFyZyA9PT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnc1tpXS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9tdXN0IGJlIGEgbmVnYXRpb24gYXJnXG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZXhwZWN0ZWRUb2tlbih0b2tlblN0cmVhbS5MVCgxKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pdCdzIGFuIGVsZW1lbnQgbmFtZVxuICAgICAgICAgICAgICAgIGlmIChhcmcudHlwZSA9PT0gXCJlbGVtZW50TmFtZVwiKXtcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IG5ldyBTZWxlY3RvclBhcnQoYXJnLCBbXSwgYXJnLnRvU3RyaW5nKCksIGxpbmUsIGNvbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IG5ldyBTZWxlY3RvclBhcnQobnVsbCwgW2FyZ10sIGFyZy50b1N0cmluZygpLCBsaW5lLCBjb2wpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2RlY2xhcmF0aW9uOiBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBkZWNsYXJhdGlvblxuICAgICAgICAgICAgICAgICAqICAgOiBwcm9wZXJ0eSAnOicgUyogZXhwciBwcmlvP1xuICAgICAgICAgICAgICAgICAqICAgfCAvKCBlbXB0eSApL1xuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXhwciAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwcmlvICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWQgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSB0aGlzLl9wcm9wZXJ0eSgpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSAhPT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5DT0xPTik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuX2V4cHIoKTtcblxuICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3Mgbm8gcGFydHMgZm9yIHRoZSB2YWx1ZSwgaXQncyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4cHIgfHwgZXhwci5sZW5ndGggPT09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRva2VuU3RyZWFtLkxUKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHByaW8gPSB0aGlzLl9wcmlvKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogSWYgaGFja3Mgc2hvdWxkIGJlIGFsbG93ZWQsIHRoZW4gb25seSBjaGVjayB0aGUgcm9vdFxuICAgICAgICAgICAgICAgICAgICAgKiBwcm9wZXJ0eS4gSWYgaGFja3Mgc2hvdWxkIG5vdCBiZSBhbGxvd2VkLCB0cmVhdFxuICAgICAgICAgICAgICAgICAgICAgKiBfcHJvcGVydHkgb3IgKnByb3BlcnR5IGFzIGludmFsaWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhckhhY2sgJiYgcHJvcGVydHkuaGFjayA9PT0gXCIqXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudW5kZXJzY29yZUhhY2sgJiYgcHJvcGVydHkuaGFjayA9PT0gXCJfXCIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gcHJvcGVydHkudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgZXhwcik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkID0gZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJwcm9wZXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6ICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogICAgICBleHByLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50OiAgcHJpbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6ICAgICAgIHByb3BlcnR5LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgICAgICBwcm9wZXJ0eS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkOiAgICBpbnZhbGlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfcHJpbzogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHByaW9cbiAgICAgICAgICAgICAgICAgKiAgIDogSU1QT1JUQU5UX1NZTSBTKlxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCAgICAgID0gdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklNUE9SVEFOVF9TWU0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2V4cHI6IGZ1bmN0aW9uKGluRnVuY3Rpb24pe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogZXhwclxuICAgICAgICAgICAgICAgICAqICAgOiB0ZXJtIFsgb3BlcmF0b3IgdGVybSBdKlxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyAgICAgID0gW10sXG5cdFx0XHRcdFx0Ly92YWx1ZVBhcnRzXHQ9IFtdLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yICAgID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdGVybShpbkZ1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9IHRoaXMuX29wZXJhdG9yKGluRnVuY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3MgYW4gb3BlcmF0b3IsIGtlZXAgYnVpbGRpbmcgdXAgdGhlIHZhbHVlIHBhcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3Ipe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9wZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLyplbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3Mgbm90IGFuIG9wZXJhdG9yLCB5b3UgaGF2ZSBhIGZ1bGwgdmFsdWVcblx0XHRcdFx0XHRcdFx0dmFsdWVzLnB1c2gobmV3IFByb3BlcnR5VmFsdWUodmFsdWVQYXJ0cywgdmFsdWVQYXJ0c1swXS5saW5lLCB2YWx1ZVBhcnRzWzBdLmNvbCkpO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZVBhcnRzID0gW107XG5cdFx0XHRcdFx0XHR9Ki9cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl90ZXJtKGluRnVuY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG5cdFx0XHRcdC8vY2xlYW51cFxuICAgICAgICAgICAgICAgIC8qaWYgKHZhbHVlUGFydHMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gobmV3IFByb3BlcnR5VmFsdWUodmFsdWVQYXJ0cywgdmFsdWVQYXJ0c1swXS5saW5lLCB2YWx1ZVBhcnRzWzBdLmNvbCkpO1xuICAgICAgICAgICAgICAgIH0qL1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPiAwID8gbmV3IFByb3BlcnR5VmFsdWUodmFsdWVzLCB2YWx1ZXNbMF0ubGluZSwgdmFsdWVzWzBdLmNvbCkgOiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX3Rlcm06IGZ1bmN0aW9uKGluRnVuY3Rpb24pe1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB0ZXJtXG4gICAgICAgICAgICAgICAgICogICA6IHVuYXJ5X29wZXJhdG9yP1xuICAgICAgICAgICAgICAgICAqICAgICBbIE5VTUJFUiBTKiB8IFBFUkNFTlRBR0UgUyogfCBMRU5HVEggUyogfCBBTkdMRSBTKiB8XG4gICAgICAgICAgICAgICAgICogICAgICAgVElNRSBTKiB8IEZSRVEgUyogfCBmdW5jdGlvbiB8IGllX2Z1bmN0aW9uIF1cbiAgICAgICAgICAgICAgICAgKiAgIHwgU1RSSU5HIFMqIHwgSURFTlQgUyogfCBVUkkgUyogfCBVTklDT0RFUkFOR0UgUyogfCBoZXhjb2xvclxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHVuYXJ5ICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlbmRDaGFyICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2w7XG5cbiAgICAgICAgICAgICAgICAvL3JldHVybnMgdGhlIG9wZXJhdG9yIG9yIG51bGxcbiAgICAgICAgICAgICAgICB1bmFyeSA9IHRoaXMuX3VuYXJ5X29wZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHVuYXJ5ICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICBjb2wgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vZXhjZXB0aW9uIGZvciBJRSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLnBlZWsoKSA9PT0gVG9rZW5zLklFX0ZVTkNUSU9OICYmIHRoaXMub3B0aW9ucy5pZUZpbHRlcnMpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5faWVfZnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuYXJ5ID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vc2VlIGlmIGl0J3MgYSBzaW1wbGUgYmxvY2tcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluRnVuY3Rpb24gJiYgdG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5MUEFSRU4sIFRva2Vucy5MQlJBQ0UsIFRva2Vucy5MQlJBQ0tFVF0pKXtcblxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIGVuZENoYXIgPSB0b2tlbi5lbmRDaGFyO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlICsgdGhpcy5fZXhwcihpbkZ1bmN0aW9uKS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5hcnkgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW5TdHJlYW0udG9rZW4oKS5zdGFydENvbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLnR5cGUoZW5kQ2hhcikpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBlbmRDaGFyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgLy9zZWUgaWYgdGhlcmUncyBhIHNpbXBsZSBtYXRjaFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5TdHJlYW0ubWF0Y2goW1Rva2Vucy5OVU1CRVIsIFRva2Vucy5QRVJDRU5UQUdFLCBUb2tlbnMuTEVOR1RILFxuICAgICAgICAgICAgICAgICAgICAgICAgVG9rZW5zLkFOR0xFLCBUb2tlbnMuVElNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRva2Vucy5GUkVRLCBUb2tlbnMuU1RSSU5HLCBUb2tlbnMuSURFTlQsIFRva2Vucy5VUkksIFRva2Vucy5VTklDT0RFX1JBTkdFXSkpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuYXJ5ID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRDb2w7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vc2VlIGlmIGl0J3MgYSBjb2xvclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuX2hleGNvbG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBubyB1bmFyeSwgZ2V0IHRoZSBzdGFydCBvZiB0aGUgbmV4dCB0b2tlbiBmb3IgbGluZS9jb2wgaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuYXJ5ID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gdG9rZW5TdHJlYW0uTFQoMSkuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IHRva2VuU3RyZWFtLkxUKDEpLnN0YXJ0Q29sO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2hhcyB0byBiZSBhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGNoZWNrcyBmb3IgYWxwaGEob3BhY2l0eT0wKSBzdHlsZSBvZiBJRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9ucy4gSUVfRlVOQ1RJT04gb25seSBwcmVzZW50cyBwcm9naWQ6IHN0eWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5MQSgzKSA9PT0gVG9rZW5zLkVRVUFMUyAmJiB0aGlzLm9wdGlvbnMuaWVGaWx0ZXJzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9pZV9mdW5jdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qaWYgKHZhbHVlID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGlkZW50aWZpZXIgYXQgbGluZSBcIiArIHRva2VuU3RyZWFtLnRva2VuKCkuc3RhcnRMaW5lICsgXCIsIGNoYXJhY3RlciBcIiArICB0b2tlblN0cmVhbS50b2tlbigpLnN0YXJ0Q29sICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSovXG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5hcnkgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0b2tlbi5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gdG9rZW4uc3RhcnRDb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUHJvcGVydHlWYWx1ZVBhcnQodW5hcnkgIT09IG51bGwgPyB1bmFyeSArIHZhbHVlIDogdmFsdWUsIGxpbmUsIGNvbCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2Z1bmN0aW9uOiBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAqICAgOiBGVU5DVElPTiBTKiBleHByICcpJyBTKlxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGV4cHIgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkZVTkNUSU9OKSl7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCA9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLl9leHByKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gZXhwcjtcblxuICAgICAgICAgICAgICAgICAgICAvL1NUQVJUOiBIb3JyaWJsZSBoYWNrIGluIGNhc2UgaXQncyBhbiBJRSBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pZUZpbHRlcnMgJiYgdG9rZW5TdHJlYW0ucGVlaygpID09PSBUb2tlbnMuRVFVQUxTKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkV2hpdGVzcGFjZSgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9taWdodCBiZSBzZWNvbmQgdGltZSBpbiB0aGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5MQSgwKSA9PT0gVG9rZW5zLkNPTU1BKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5FUVVBTFMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mdW5jdGlvblRleHQgKz0gdGhpcy5fdGVybSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGx0ID0gdG9rZW5TdHJlYW0ucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGx0ICE9PSBUb2tlbnMuQ09NTUEgJiYgbHQgIT09IFRva2Vucy5TICYmIGx0ICE9PSBUb2tlbnMuUlBBUkVOKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0uZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsdCA9IHRva2VuU3RyZWFtLnBlZWsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlKHRva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuQ09NTUEsIFRva2Vucy5TXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9FTkQ6IEhvcnJpYmxlIEhhY2tcblxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuUlBBUkVOKTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvblRleHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfaWVfZnVuY3Rpb246IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAvKiAoTXkgb3duIGV4dGVuc2lvbilcbiAgICAgICAgICAgICAgICAgKiBpZV9mdW5jdGlvblxuICAgICAgICAgICAgICAgICAqICAgOiBJRV9GVU5DVElPTiBTKiBJREVOVCAnPScgdGVybSBbUyogJywnPyBJREVOVCAnPScgdGVybV0rICcpJyBTKlxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGx0O1xuXG4gICAgICAgICAgICAgICAgLy9JRSBmdW5jdGlvbiBjYW4gYmVnaW4gbGlrZSBhIHJlZ3VsYXIgZnVuY3Rpb24sIHRvb1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5tYXRjaChbVG9rZW5zLklFX0ZVTkNUSU9OLCBUb2tlbnMuRlVOQ1RJT05dKSl7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCA9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZFdoaXRlc3BhY2UoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IHRva2VuU3RyZWFtLnRva2VuKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWlnaHQgYmUgc2Vjb25kIHRpbWUgaW4gdGhlIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblN0cmVhbS5MQSgwKSA9PT0gVG9rZW5zLkNPTU1BKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLklERU5UKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuRVFVQUxTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCArPSB0b2tlblN0cmVhbS50b2tlbigpLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Z1bmN0aW9uVGV4dCArPSB0aGlzLl90ZXJtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsdCA9IHRva2VuU3RyZWFtLnBlZWsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGx0ICE9PSBUb2tlbnMuQ09NTUEgJiYgbHQgIT09IFRva2Vucy5TICYmIGx0ICE9PSBUb2tlbnMuUlBBUkVOKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRleHQgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsdCA9IHRva2VuU3RyZWFtLnBlZWsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSh0b2tlblN0cmVhbS5tYXRjaChbVG9rZW5zLkNPTU1BLCBUb2tlbnMuU10pKTtcblxuICAgICAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tYXRjaChUb2tlbnMuUlBBUkVOKTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UZXh0ICs9IFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvblRleHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfaGV4Y29sb3I6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBUaGVyZSBpcyBhIGNvbnN0cmFpbnQgb24gdGhlIGNvbG9yIHRoYXQgaXQgbXVzdFxuICAgICAgICAgICAgICAgICAqIGhhdmUgZWl0aGVyIDMgb3IgNiBoZXgtZGlnaXRzIChpLmUuLCBbMC05YS1mQS1GXSlcbiAgICAgICAgICAgICAgICAgKiBhZnRlciB0aGUgXCIjXCI7IGUuZy4sIFwiIzAwMFwiIGlzIE9LLCBidXQgXCIjYWJjZFwiIGlzIG5vdC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIGhleGNvbG9yXG4gICAgICAgICAgICAgICAgICogICA6IEhBU0ggUypcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0cmVhbSA9IHRoaXMuX3Rva2VuU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yO1xuXG4gICAgICAgICAgICAgICAgaWYodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLkhBU0gpKXtcblxuICAgICAgICAgICAgICAgICAgICAvL25lZWQgdG8gZG8gc29tZSB2YWxpZGF0aW9uIGhlcmVcblxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLyNbYS1mMC05XXszLDZ9L2kudGVzdChjb2xvcikpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiRXhwZWN0ZWQgYSBoZXggY29sb3IgYnV0IGZvdW5kICdcIiArIGNvbG9yICsgXCInIGF0IGxpbmUgXCIgKyB0b2tlbi5zdGFydExpbmUgKyBcIiwgY29sIFwiICsgdG9rZW4uc3RhcnRDb2wgKyBcIi5cIiwgdG9rZW4uc3RhcnRMaW5lLCB0b2tlbi5zdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyBBbmltYXRpb25zIG1ldGhvZHNcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgX2tleWZyYW1lczogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICoga2V5ZnJhbWVzOlxuICAgICAgICAgICAgICAgICAqICAgOiBLRVlGUkFNRVNfU1lNIFMqIGtleWZyYW1lX25hbWUgUyogJ3snIFMqIGtleWZyYW1lX3J1bGUqICd9JyB7XG4gICAgICAgICAgICAgICAgICogICA7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgICAgICB0dCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gXCJcIjtcblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuS0VZRlJBTUVTX1NZTSk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS50b2tlbigpO1xuICAgICAgICAgICAgICAgIGlmICgvXkBcXC0oW15cXC1dKylcXC0vLnRlc3QodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IFJlZ0V4cC4kMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLl9rZXlmcmFtZV9uYW1lKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuTEJSQUNFKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJzdGFydGtleWZyYW1lc1wiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIHRva2VuLnN0YXJ0TGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiAgICB0b2tlbi5zdGFydENvbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB0dCA9IHRva2VuU3RyZWFtLnBlZWsoKTtcblxuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGtleVxuICAgICAgICAgICAgICAgIHdoaWxlKHR0ID09PSBUb2tlbnMuSURFTlQgfHwgdHQgPT09IFRva2Vucy5QRVJDRU5UQUdFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleWZyYW1lX3J1bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdHQgPSB0b2tlblN0cmVhbS5wZWVrKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogICBcImVuZGtleWZyYW1lc1wiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIHRva2VuLnN0YXJ0TGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiAgICB0b2tlbi5zdGFydENvbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB0b2tlblN0cmVhbS5tdXN0TWF0Y2goVG9rZW5zLlJCUkFDRSk7XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9rZXlmcmFtZV9uYW1lOiBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBrZXlmcmFtZV9uYW1lOlxuICAgICAgICAgICAgICAgICAqICAgOiBJREVOVFxuICAgICAgICAgICAgICAgICAqICAgfCBTVFJJTkdcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbTtcblxuICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChbVG9rZW5zLklERU5ULCBUb2tlbnMuU1RSSU5HXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheFVuaXQuZnJvbVRva2VuKHRva2VuU3RyZWFtLnRva2VuKCkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2tleWZyYW1lX3J1bGU6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGtleWZyYW1lX3J1bGU6XG4gICAgICAgICAgICAgICAgICogICA6IGtleV9saXN0IFMqXG4gICAgICAgICAgICAgICAgICogICAgICd7JyBTKiBkZWNsYXJhdGlvbiBbICc7JyBTKiBkZWNsYXJhdGlvbiBdKiAnfScgUypcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIga2V5TGlzdCA9IHRoaXMuX2tleV9saXN0KCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAgIFwic3RhcnRrZXlmcmFtZXJ1bGVcIixcbiAgICAgICAgICAgICAgICAgICAga2V5czogICBrZXlMaXN0LFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGtleUxpc3RbMF0ubGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiAgICBrZXlMaXN0WzBdLmNvbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZERlY2xhcmF0aW9ucyh0cnVlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgXCJlbmRrZXlmcmFtZXJ1bGVcIixcbiAgICAgICAgICAgICAgICAgICAga2V5czogICBrZXlMaXN0LFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAgIGtleUxpc3RbMF0ubGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sOiAgICBrZXlMaXN0WzBdLmNvbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfa2V5X2xpc3Q6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGtleV9saXN0OlxuICAgICAgICAgICAgICAgICAqICAgOiBrZXkgWyBTKiAnLCcgUyoga2V5XSpcbiAgICAgICAgICAgICAgICAgKiAgIDtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAga2V5TGlzdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy9tdXN0IGJlIGxlYXN0IG9uZSBrZXlcbiAgICAgICAgICAgICAgICBrZXlMaXN0LnB1c2godGhpcy5fa2V5KCkpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIHdoaWxlKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5DT01NQSkpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBrZXlMaXN0LnB1c2godGhpcy5fa2V5KCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlMaXN0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2tleTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFRoZXJlIGlzIGEgcmVzdHJpY3Rpb24gdGhhdCBJREVOVCBjYW4gYmUgb25seSBcImZyb21cIiBvciBcInRvXCIuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBrZXlcbiAgICAgICAgICAgICAgICAgKiAgIDogUEVSQ0VOVEFHRVxuICAgICAgICAgICAgICAgICAqICAgfCBJREVOVFxuICAgICAgICAgICAgICAgICAqICAgO1xuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuU3RyZWFtID0gdGhpcy5fdG9rZW5TdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5QRVJDRU5UQUdFKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW50YXhVbml0LmZyb21Ub2tlbih0b2tlblN0cmVhbS50b2tlbigpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5JREVOVCkpe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuU3RyZWFtLnRva2VuKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC9mcm9tfHRvL2kudGVzdCh0b2tlbi52YWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bnRheFVuaXQuZnJvbVRva2VuKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLnVuZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiBpdCBnZXRzIGhlcmUsIHRoZXJlIHdhc24ndCBhIHZhbGlkIHRva2VuLCBzbyB0aW1lIHRvIGV4cGxvZGVcbiAgICAgICAgICAgICAgICB0aGlzLl91bmV4cGVjdGVkVG9rZW4odG9rZW5TdHJlYW0uTFQoMSkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gSGVscGVyIG1ldGhvZHNcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3QgcGFydCBvZiBDU1MgZ3JhbW1hciwgYnV0IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlclxuICAgICAgICAgICAgICogY29tYmluYXRpb24gb2Ygd2hpdGUgc3BhY2UgYW5kIEhUTUwtc3R5bGUgY29tbWVudHMuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICogQG1ldGhvZCBfc2tpcENydWZ0XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfc2tpcENydWZ0OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHdoaWxlKHRoaXMuX3Rva2VuU3RyZWFtLm1hdGNoKFtUb2tlbnMuUywgVG9rZW5zLkNETywgVG9rZW5zLkNEQ10pKXtcbiAgICAgICAgICAgICAgICAgICAgLy9ub29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3QgcGFydCBvZiBDU1MgZ3JhbW1hciwgYnV0IHRoaXMgcGF0dGVybiBvY2N1cnMgZnJlcXVlbnRseVxuICAgICAgICAgICAgICogaW4gdGhlIG9mZmljaWFsIENTUyBncmFtbWFyLiBTcGxpdCBvdXQgaGVyZSB0byBlbGltaW5hdGVcbiAgICAgICAgICAgICAqIGR1cGxpY2F0ZSBjb2RlLlxuICAgICAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBjaGVja1N0YXJ0IEluZGljYXRlcyBpZiB0aGUgcnVsZSBzaG91bGQgY2hlY2tcbiAgICAgICAgICAgICAqICAgICAgZm9yIHRoZSBsZWZ0IGJyYWNlIGF0IHRoZSBiZWdpbm5pbmcuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlYWRNYXJnaW5zIEluZGljYXRlcyBpZiB0aGUgcnVsZSBzaG91bGQgY2hlY2tcbiAgICAgICAgICAgICAqICAgICAgZm9yIG1hcmdpbiBwYXR0ZXJucy5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9yZWFkRGVjbGFyYXRpb25zXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcmVhZERlY2xhcmF0aW9uczogZnVuY3Rpb24oY2hlY2tTdGFydCwgcmVhZE1hcmdpbnMpe1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUmVhZHMgdGhlIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgKiBTKiAneycgUyogZGVjbGFyYXRpb24gWyAnOycgUyogZGVjbGFyYXRpb24gXSogJ30nIFMqXG4gICAgICAgICAgICAgICAgICogb3JcbiAgICAgICAgICAgICAgICAgKiBTKiAneycgUyogWyBkZWNsYXJhdGlvbiB8IG1hcmdpbiBdPyBbICc7JyBTKiBbIGRlY2xhcmF0aW9uIHwgbWFyZ2luIF0/IF0qICd9JyBTKlxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIGlzIGhvdyBpdCBpcyBkZXNjcmliZWQgaW4gQ1NTMyBQYWdlZCBNZWRpYSwgYnV0IGlzIGFjdHVhbGx5IGluY29ycmVjdC5cbiAgICAgICAgICAgICAgICAgKiBBIHNlbWljb2xvbiBpcyBvbmx5IG5lY2Vzc2FyeSBmb2xsb3dpbmcgYSBkZWNsYXJhdGlvbiBpZiB0aGVyZSdzIGFub3RoZXIgZGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICAgKiBvciBtYXJnaW4gYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgdHQ7XG5cblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tTdGFydCl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuU3RyZWFtLm11c3RNYXRjaChUb2tlbnMuTEJSQUNFKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSh0cnVlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5TRU1JQ09MT04pIHx8IChyZWFkTWFyZ2lucyAmJiB0aGlzLl9tYXJnaW4oKSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kZWNsYXJhdGlvbigpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5TRU1JQ09MT04pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoKCF0aGlzLl9tYXJnaW4oKSAmJiAhdGhpcy5fZGVjbGFyYXRpb24oKSkgfHwgIXRva2VuU3RyZWFtLm1hdGNoKFRva2Vucy5TRU1JQ09MT04pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHJlYW0ubXVzdE1hdGNoKFRva2Vucy5SQlJBQ0UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgU3ludGF4RXJyb3IgJiYgIXRoaXMub3B0aW9ucy5zdHJpY3Qpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZpcmUgZXJyb3IgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAgICAgIGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICAgIGV4Lm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogICAgICAgZXgubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6ICAgICAgICBleC5jb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NlZSBpZiB0aGVyZSdzIGFub3RoZXIgZGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHR0ID0gdG9rZW5TdHJlYW0uYWR2YW5jZShbVG9rZW5zLlNFTUlDT0xPTiwgVG9rZW5zLlJCUkFDRV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR0ID09PSBUb2tlbnMuU0VNSUNPTE9OKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3MgYSBzZW1pY29sb24sIHRoZW4gdGhlcmUgbWlnaHQgYmUgYW5vdGhlciBkZWNsYXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWREZWNsYXJhdGlvbnMoZmFsc2UsIHJlYWRNYXJnaW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHQgIT09IFRva2Vucy5SQlJBQ0Upe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBhIHJpZ2h0IGJyYWNlLCB0aGUgcnVsZSBpcyBmaW5pc2hlZCBzbyBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCByZXRocm93IHRoZSBlcnJvciBiZWNhdXNlIGl0IHdhc24ndCBoYW5kbGVkIHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbm90IGEgc3ludGF4IGVycm9yLCByZXRocm93IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbiBzb21lIGNhc2VzLCB5b3UgY2FuIGVuZCB1cCB3aXRoIHR3byB3aGl0ZSBzcGFjZSB0b2tlbnMgaW4gYVxuICAgICAgICAgICAgICogcm93LiBJbnN0ZWFkIG9mIG1ha2luZyBhIGNoYW5nZSBpbiBldmVyeSBmdW5jdGlvbiB0aGF0IGxvb2tzIGZvclxuICAgICAgICAgICAgICogd2hpdGUgc3BhY2UsIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBtYXRjaCBhcyBtdWNoIHdoaXRlIHNwYWNlXG4gICAgICAgICAgICAgKiBhcyBuZWNlc3NhcnkuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9yZWFkV2hpdGVzcGFjZVxuICAgICAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgd2hpdGUgc3BhY2UgaWYgZm91bmQsIGVtcHR5IHN0cmluZyBpZiBub3QuXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcmVhZFdoaXRlc3BhY2U6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5TdHJlYW0gPSB0aGlzLl90b2tlblN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgd3MgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW5TdHJlYW0ubWF0Y2goVG9rZW5zLlMpKXtcbiAgICAgICAgICAgICAgICAgICAgd3MgKz0gdG9rZW5TdHJlYW0udG9rZW4oKS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gd3M7XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhyb3dzIGFuIGVycm9yIHdoZW4gYW4gdW5leHBlY3RlZCB0b2tlbiBpcyBmb3VuZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBUaGUgdG9rZW4gdGhhdCB3YXMgZm91bmQuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF91bmV4cGVjdGVkVG9rZW5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdW5leHBlY3RlZFRva2VuOiBmdW5jdGlvbih0b2tlbil7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiAnXCIgKyB0b2tlbi52YWx1ZSArIFwiJyBhdCBsaW5lIFwiICsgdG9rZW4uc3RhcnRMaW5lICsgXCIsIGNvbCBcIiArIHRva2VuLnN0YXJ0Q29sICsgXCIuXCIsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIZWxwZXIgbWV0aG9kIHVzZWQgZm9yIHBhcnNpbmcgc3VicGFydHMgb2YgYSBzdHlsZSBzaGVldC5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgKiBAbWV0aG9kIF92ZXJpZnlFbmRcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF92ZXJpZnlFbmQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rva2VuU3RyZWFtLkxBKDEpICE9PSBUb2tlbnMuRU9GKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5leHBlY3RlZFRva2VuKHRoaXMuX3Rva2VuU3RyZWFtLkxUKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyBWYWxpZGF0aW9uIG1ldGhvZHNcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIF92YWxpZGF0ZVByb3BlcnR5OiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUpe1xuICAgICAgICAgICAgICAgIFZhbGlkYXRpb24udmFsaWRhdGUocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIFBhcnNpbmcgbWV0aG9kc1xuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQpe1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VuU3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKGlucHV0LCBUb2tlbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlc2hlZXQoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBhcnNlU3R5bGVTaGVldDogZnVuY3Rpb24oaW5wdXQpe1xuICAgICAgICAgICAgICAgIC8vanVzdCBwYXNzdGhyb3VnaFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGlucHV0KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBhcnNlTWVkaWFRdWVyeTogZnVuY3Rpb24oaW5wdXQpe1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VuU3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKGlucHV0LCBUb2tlbnMpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9tZWRpYV9xdWVyeSgpO1xuXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGFueXRoaW5nIG1vcmUsIHRoZW4gaXQncyBhbiBpbnZhbGlkIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgdGhpcy5fdmVyaWZ5RW5kKCk7XG5cbiAgICAgICAgICAgICAgICAvL290aGVyd2lzZSByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFyc2VzIGEgcHJvcGVydHkgdmFsdWUgKGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIHNlbWljb2xvbikuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtwYXJzZXJsaWIuY3NzLlByb3BlcnR5VmFsdWV9IFRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICAgICAqIEB0aHJvd3MgcGFyc2VybGliLnV0aWwuU3ludGF4RXJyb3IgSWYgYW4gdW5leHBlY3RlZCB0b2tlbiBpcyBmb3VuZC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgcGFyc2VyUHJvcGVydHlWYWx1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwYXJzZVByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uKGlucHV0KXtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VuU3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKGlucHV0LCBUb2tlbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZXhwcigpO1xuXG4gICAgICAgICAgICAgICAgLy9va2F5IHRvIGhhdmUgYSB0cmFpbGluZyB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3MgYW55dGhpbmcgbW9yZSwgdGhlbiBpdCdzIGFuIGludmFsaWQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICB0aGlzLl92ZXJpZnlFbmQoKTtcblxuICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBjb21wbGV0ZSBDU1MgcnVsZSwgaW5jbHVkaW5nIHNlbGVjdG9ycyBhbmRcbiAgICAgICAgICAgICAqIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHRleHQgdG8gcGFyc2VyLlxuICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFyc2UgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgbm90LlxuICAgICAgICAgICAgICogQG1ldGhvZCBwYXJzZVJ1bGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcGFyc2VSdWxlOiBmdW5jdGlvbihpbnB1dCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5TdHJlYW0gPSBuZXcgVG9rZW5TdHJlYW0oaW5wdXQsIFRva2Vucyk7XG5cbiAgICAgICAgICAgICAgICAvL3NraXAgYW55IGxlYWRpbmcgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3J1bGVzZXQoKTtcblxuICAgICAgICAgICAgICAgIC8vc2tpcCBhbnkgdHJhaWxpbmcgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGFueXRoaW5nIG1vcmUsIHRoZW4gaXQncyBhbiBpbnZhbGlkIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgdGhpcy5fdmVyaWZ5RW5kKCk7XG5cbiAgICAgICAgICAgICAgICAvL290aGVyd2lzZSByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFyc2VzIGEgc2luZ2xlIENTUyBzZWxlY3RvciAobm8gY29tbWEpXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHRleHQgdG8gcGFyc2UgYXMgYSBDU1Mgc2VsZWN0b3IuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtTZWxlY3Rvcn0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VsZWN0b3IuXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHBhcnNlcmxpYi51dGlsLlN5bnRheEVycm9yIElmIGFuIHVuZXhwZWN0ZWQgdG9rZW4gaXMgZm91bmQuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHBhcnNlU2VsZWN0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcGFyc2VTZWxlY3RvcjogZnVuY3Rpb24oaW5wdXQpe1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9rZW5TdHJlYW0gPSBuZXcgVG9rZW5TdHJlYW0oaW5wdXQsIFRva2Vucyk7XG5cbiAgICAgICAgICAgICAgICAvL3NraXAgYW55IGxlYWRpbmcgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3NlbGVjdG9yKCk7XG5cbiAgICAgICAgICAgICAgICAvL3NraXAgYW55IHRyYWlsaW5nIHdoaXRlIHNwYWNlXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcblxuICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBhbnl0aGluZyBtb3JlLCB0aGVuIGl0J3MgYW4gaW52YWxpZCBzZWxlY3RvclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZlcmlmeUVuZCgpO1xuXG4gICAgICAgICAgICAgICAgLy9vdGhlcndpc2UgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcnNlcyBhbiBIVE1MIHN0eWxlIGF0dHJpYnV0ZTogYSBzZXQgb2YgQ1NTIGRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICogc2VwYXJhdGVkIGJ5IHNlbWljb2xvbnMuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHRleHQgdG8gcGFyc2UgYXMgYSBzdHlsZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgKiBAbWV0aG9kIHBhcnNlU3R5bGVBdHRyaWJ1dGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcGFyc2VTdHlsZUF0dHJpYnV0ZTogZnVuY3Rpb24oaW5wdXQpe1xuICAgICAgICAgICAgICAgIGlucHV0ICs9IFwifVwiOyAvLyBmb3IgZXJyb3IgcmVjb3ZlcnkgaW4gX3JlYWREZWNsYXJhdGlvbnMoKVxuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VuU3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKGlucHV0LCBUb2tlbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWREZWNsYXJhdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8vY29weSBvdmVyIG9udG8gcHJvdG90eXBlXG4gICAgZm9yIChwcm9wIGluIGFkZGl0aW9ucyl7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYWRkaXRpb25zLCBwcm9wKSl7XG4gICAgICAgICAgICBwcm90b1twcm9wXSA9IGFkZGl0aW9uc1twcm9wXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm90bztcbn0oKTtcblxuXG4vKlxubnRoXG4gIDogUyogWyBbJy0nfCcrJ10/IElOVEVHRVI/IHtOfSBbIFMqIFsnLSd8JysnXSBTKiBJTlRFR0VSIF0/IHxcbiAgICAgICAgIFsnLSd8JysnXT8gSU5URUdFUiB8IHtPfXtEfXtEfSB8IHtFfXtWfXtFfXtOfSBdIFMqXG4gIDtcbiovXG52YXIgUHJvcGVydGllcyA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG5cbiAgICAvL0FcbiAgICBcImFsaWduLWl0ZW1zXCIgICAgICAgICAgICAgICAgICAgOiBcImZsZXgtc3RhcnQgfCBmbGV4LWVuZCB8IGNlbnRlciB8IGJhc2VsaW5lIHwgc3RyZXRjaFwiLFxuICAgIFwiYWxpZ24tY29udGVudFwiICAgICAgICAgICAgICAgICA6IFwiZmxleC1zdGFydCB8IGZsZXgtZW5kIHwgY2VudGVyIHwgc3BhY2UtYmV0d2VlbiB8IHNwYWNlLWFyb3VuZCB8IHN0cmV0Y2hcIixcbiAgICBcImFsaWduLXNlbGZcIiAgICAgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBmbGV4LXN0YXJ0IHwgZmxleC1lbmQgfCBjZW50ZXIgfCBiYXNlbGluZSB8IHN0cmV0Y2hcIixcbiAgICBcIi13ZWJraXQtYWxpZ24taXRlbXNcIiAgICAgICAgICAgOiBcImZsZXgtc3RhcnQgfCBmbGV4LWVuZCB8IGNlbnRlciB8IGJhc2VsaW5lIHwgc3RyZXRjaFwiLFxuICAgIFwiLXdlYmtpdC1hbGlnbi1jb250ZW50XCIgICAgICAgICA6IFwiZmxleC1zdGFydCB8IGZsZXgtZW5kIHwgY2VudGVyIHwgc3BhY2UtYmV0d2VlbiB8IHNwYWNlLWFyb3VuZCB8IHN0cmV0Y2hcIixcbiAgICBcIi13ZWJraXQtYWxpZ24tc2VsZlwiICAgICAgICAgICAgOiBcImF1dG8gfCBmbGV4LXN0YXJ0IHwgZmxleC1lbmQgfCBjZW50ZXIgfCBiYXNlbGluZSB8IHN0cmV0Y2hcIixcbiAgICBcImFsaWdubWVudC1hZGp1c3RcIiAgICAgICAgICAgICAgOiBcImF1dG8gfCBiYXNlbGluZSB8IGJlZm9yZS1lZGdlIHwgdGV4dC1iZWZvcmUtZWRnZSB8IG1pZGRsZSB8IGNlbnRyYWwgfCBhZnRlci1lZGdlIHwgdGV4dC1hZnRlci1lZGdlIHwgaWRlb2dyYXBoaWMgfCBhbHBoYWJldGljIHwgaGFuZ2luZyB8IG1hdGhlbWF0aWNhbCB8IDxwZXJjZW50YWdlPiB8IDxsZW5ndGg+XCIsXG4gICAgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIiAgICAgICAgICAgIDogXCJiYXNlbGluZSB8IHVzZS1zY3JpcHQgfCBiZWZvcmUtZWRnZSB8IHRleHQtYmVmb3JlLWVkZ2UgfCBhZnRlci1lZGdlIHwgdGV4dC1hZnRlci1lZGdlIHwgY2VudHJhbCB8IG1pZGRsZSB8IGlkZW9ncmFwaGljIHwgYWxwaGFiZXRpYyB8IGhhbmdpbmcgfCBtYXRoZW1hdGljYWxcIixcbiAgICBcImFuaW1hdGlvblwiICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiYW5pbWF0aW9uLWRlbGF5XCIgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPHRpbWU+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCJhbmltYXRpb24tZGlyZWN0aW9uXCIgICAgICAgICAgIDogeyBtdWx0aTogXCJub3JtYWwgfCBhbHRlcm5hdGVcIiwgY29tbWE6IHRydWUgfSxcbiAgICBcImFuaW1hdGlvbi1kdXJhdGlvblwiICAgICAgICAgICAgOiB7IG11bHRpOiBcIjx0aW1lPlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiYW5pbWF0aW9uLWZpbGwtbW9kZVwiICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9uZSB8IGZvcndhcmRzIHwgYmFja3dhcmRzIHwgYm90aFwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiICAgICA6IHsgbXVsdGk6IFwiPG51bWJlcj4gfCBpbmZpbml0ZVwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiYW5pbWF0aW9uLW5hbWVcIiAgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9uZSB8IDxpZGVudD5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCIgICAgICAgICAgOiB7IG11bHRpOiBcInJ1bm5pbmcgfCBwYXVzZWRcIiwgY29tbWE6IHRydWUgfSxcbiAgICBcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb25cIiAgICAgOiAxLFxuXG4gICAgLy92ZW5kb3IgcHJlZml4ZWRcbiAgICBcIi1tb3otYW5pbWF0aW9uLWRlbGF5XCIgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPHRpbWU+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItbW96LWFuaW1hdGlvbi1kaXJlY3Rpb25cIiAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vcm1hbCB8IGFsdGVybmF0ZVwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW1vei1hbmltYXRpb24tZHVyYXRpb25cIiAgICAgICAgICAgIDogeyBtdWx0aTogXCI8dGltZT5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi1tb3otYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiICAgICA6IHsgbXVsdGk6IFwiPG51bWJlcj4gfCBpbmZpbml0ZVwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW1vei1hbmltYXRpb24tbmFtZVwiICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCJub25lIHwgPGlkZW50PlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW1vei1hbmltYXRpb24tcGxheS1zdGF0ZVwiICAgICAgICAgIDogeyBtdWx0aTogXCJydW5uaW5nIHwgcGF1c2VkXCIsIGNvbW1hOiB0cnVlIH0sXG5cbiAgICBcIi1tcy1hbmltYXRpb24tZGVsYXlcIiAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8dGltZT5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi1tcy1hbmltYXRpb24tZGlyZWN0aW9uXCIgICAgICAgICAgIDogeyBtdWx0aTogXCJub3JtYWwgfCBhbHRlcm5hdGVcIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi1tcy1hbmltYXRpb24tZHVyYXRpb25cIiAgICAgICAgICAgIDogeyBtdWx0aTogXCI8dGltZT5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi1tcy1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCIgICAgIDogeyBtdWx0aTogXCI8bnVtYmVyPiB8IGluZmluaXRlXCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItbXMtYW5pbWF0aW9uLW5hbWVcIiAgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9uZSB8IDxpZGVudD5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi1tcy1hbmltYXRpb24tcGxheS1zdGF0ZVwiICAgICAgICAgIDogeyBtdWx0aTogXCJydW5uaW5nIHwgcGF1c2VkXCIsIGNvbW1hOiB0cnVlIH0sXG5cbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLWRlbGF5XCIgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPHRpbWU+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1kaXJlY3Rpb25cIiAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vcm1hbCB8IGFsdGVybmF0ZVwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb25cIiAgICAgICAgICAgIDogeyBtdWx0aTogXCI8dGltZT5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZVwiICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9uZSB8IGZvcndhcmRzIHwgYmFja3dhcmRzIHwgYm90aFwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCIgICAgIDogeyBtdWx0aTogXCI8bnVtYmVyPiB8IGluZmluaXRlXCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1uYW1lXCIgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIm5vbmUgfCA8aWRlbnQ+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1wbGF5LXN0YXRlXCIgICAgICAgICAgOiB7IG11bHRpOiBcInJ1bm5pbmcgfCBwYXVzZWRcIiwgY29tbWE6IHRydWUgfSxcblxuICAgIFwiLW8tYW5pbWF0aW9uLWRlbGF5XCIgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPHRpbWU+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCItby1hbmltYXRpb24tZGlyZWN0aW9uXCIgICAgICAgICAgIDogeyBtdWx0aTogXCJub3JtYWwgfCBhbHRlcm5hdGVcIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi1vLWFuaW1hdGlvbi1kdXJhdGlvblwiICAgICAgICAgICAgOiB7IG11bHRpOiBcIjx0aW1lPlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW8tYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiICAgICA6IHsgbXVsdGk6IFwiPG51bWJlcj4gfCBpbmZpbml0ZVwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiLW8tYW5pbWF0aW9uLW5hbWVcIiAgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwibm9uZSB8IDxpZGVudD5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcIi1vLWFuaW1hdGlvbi1wbGF5LXN0YXRlXCIgICAgICAgICAgOiB7IG11bHRpOiBcInJ1bm5pbmcgfCBwYXVzZWRcIiwgY29tbWE6IHRydWUgfSxcblxuICAgIFwiYXBwZWFyYW5jZVwiICAgICAgICAgICAgICAgICAgICA6IFwiaWNvbiB8IHdpbmRvdyB8IGRlc2t0b3AgfCB3b3Jrc3BhY2UgfCBkb2N1bWVudCB8IHRvb2x0aXAgfCBkaWFsb2cgfCBidXR0b24gfCBwdXNoLWJ1dHRvbiB8IGh5cGVybGluayB8IHJhZGlvIHwgcmFkaW8tYnV0dG9uIHwgY2hlY2tib3ggfCBtZW51LWl0ZW0gfCB0YWIgfCBtZW51IHwgbWVudWJhciB8IHB1bGwtZG93bi1tZW51IHwgcG9wLXVwLW1lbnUgfCBsaXN0LW1lbnUgfCByYWRpby1ncm91cCB8IGNoZWNrYm94LWdyb3VwIHwgb3V0bGluZS10cmVlIHwgcmFuZ2UgfCBmaWVsZCB8IGNvbWJvLWJveCB8IHNpZ25hdHVyZSB8IHBhc3N3b3JkIHwgbm9ybWFsIHwgbm9uZSB8IGluaGVyaXRcIixcbiAgICBcImF6aW11dGhcIiAgICAgICAgICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgc2ltcGxlICAgICAgPSBcIjxhbmdsZT4gfCBsZWZ0d2FyZHMgfCByaWdodHdhcmRzIHwgaW5oZXJpdFwiLFxuICAgICAgICAgICAgZGlyZWN0aW9uICAgPSBcImxlZnQtc2lkZSB8IGZhci1sZWZ0IHwgbGVmdCB8IGNlbnRlci1sZWZ0IHwgY2VudGVyIHwgY2VudGVyLXJpZ2h0IHwgcmlnaHQgfCBmYXItcmlnaHQgfCByaWdodC1zaWRlXCIsXG4gICAgICAgICAgICBiZWhpbmQgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgdmFsaWQgICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHBhcnQ7XG5cbiAgICAgICAgaWYgKCFWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgc2ltcGxlKSkge1xuICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcImJlaGluZFwiKSkge1xuICAgICAgICAgICAgICAgIGJlaGluZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCFiZWhpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiYmVoaW5kXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xuICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCAoPCdhemltdXRoJz4pIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvL0JcbiAgICBcImJhY2tmYWNlLXZpc2liaWxpdHlcIiAgICAgICAgICAgOiBcInZpc2libGUgfCBoaWRkZW5cIixcbiAgICBcImJhY2tncm91bmRcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiYmFja2dyb3VuZC1hdHRhY2htZW50XCIgICAgICAgICA6IHsgbXVsdGk6IFwiPGF0dGFjaG1lbnQ+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCJiYWNrZ3JvdW5kLWNsaXBcIiAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8Ym94PlwiLCBjb21tYTogdHJ1ZSB9LFxuICAgIFwiYmFja2dyb3VuZC1jb2xvclwiICAgICAgICAgICAgICA6IFwiPGNvbG9yPiB8IGluaGVyaXRcIixcbiAgICBcImJhY2tncm91bmQtaW1hZ2VcIiAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxiZy1pbWFnZT5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcImJhY2tncm91bmQtb3JpZ2luXCIgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxib3g+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIgICAgICAgICAgIDogeyBtdWx0aTogXCI8YmctcG9zaXRpb24+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCJiYWNrZ3JvdW5kLXJlcGVhdFwiICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8cmVwZWF0LXN0eWxlPlwiIH0sXG4gICAgXCJiYWNrZ3JvdW5kLXNpemVcIiAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8Ymctc2l6ZT5cIiwgY29tbWE6IHRydWUgfSxcbiAgICBcImJhc2VsaW5lLXNoaWZ0XCIgICAgICAgICAgICAgICAgOiBcImJhc2VsaW5lIHwgc3ViIHwgc3VwZXIgfCA8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPlwiLFxuICAgIFwiYmVoYXZpb3JcIiAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJiaW5kaW5nXCIgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImJsZWVkXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxsZW5ndGg+XCIsXG4gICAgXCJib29rbWFyay1sYWJlbFwiICAgICAgICAgICAgICAgIDogXCI8Y29udGVudD4gfCA8YXR0cj4gfCA8c3RyaW5nPlwiLFxuICAgIFwiYm9va21hcmstbGV2ZWxcIiAgICAgICAgICAgICAgICA6IFwibm9uZSB8IDxpbnRlZ2VyPlwiLFxuICAgIFwiYm9va21hcmstc3RhdGVcIiAgICAgICAgICAgICAgICA6IFwib3BlbiB8IGNsb3NlZFwiLFxuICAgIFwiYm9va21hcmstdGFyZ2V0XCIgICAgICAgICAgICAgICA6IFwibm9uZSB8IDx1cmk+IHwgPGF0dHI+XCIsXG4gICAgXCJib3JkZXJcIiAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPiB8fCA8Ym9yZGVyLXN0eWxlPiB8fCA8Y29sb3I+XCIsXG4gICAgXCJib3JkZXItYm90dG9tXCIgICAgICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPiB8fCA8Ym9yZGVyLXN0eWxlPiB8fCA8Y29sb3I+XCIsXG4gICAgXCJib3JkZXItYm90dG9tLWNvbG9yXCIgICAgICAgICAgIDogXCI8Y29sb3I+IHwgaW5oZXJpdFwiLFxuICAgIFwiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiICAgICA6ICBcIjx4LW9uZS1yYWRpdXM+XCIsXG4gICAgXCJib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1c1wiICAgIDogIFwiPHgtb25lLXJhZGl1cz5cIixcbiAgICBcImJvcmRlci1ib3R0b20tc3R5bGVcIiAgICAgICAgICAgOiBcIjxib3JkZXItc3R5bGU+XCIsXG4gICAgXCJib3JkZXItYm90dG9tLXdpZHRoXCIgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPlwiLFxuICAgIFwiYm9yZGVyLWNvbGxhcHNlXCIgICAgICAgICAgICAgICA6IFwiY29sbGFwc2UgfCBzZXBhcmF0ZSB8IGluaGVyaXRcIixcbiAgICBcImJvcmRlci1jb2xvclwiICAgICAgICAgICAgICAgICAgOiB7IG11bHRpOiBcIjxjb2xvcj4gfCBpbmhlcml0XCIsIG1heDogNCB9LFxuICAgIFwiYm9yZGVyLWltYWdlXCIgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJib3JkZXItaW1hZ2Utb3V0c2V0XCIgICAgICAgICAgIDogeyBtdWx0aTogXCI8bGVuZ3RoPiB8IDxudW1iZXI+XCIsIG1heDogNCB9LFxuICAgIFwiYm9yZGVyLWltYWdlLXJlcGVhdFwiICAgICAgICAgICA6IHsgbXVsdGk6IFwic3RyZXRjaCB8IHJlcGVhdCB8IHJvdW5kXCIsIG1heDogMiB9LFxuICAgIFwiYm9yZGVyLWltYWdlLXNsaWNlXCIgICAgICAgICAgICA6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcblxuICAgICAgICB2YXIgdmFsaWQgICA9IGZhbHNlLFxuICAgICAgICAgICAgbnVtZXJpYyA9IFwiPG51bWJlcj4gfCA8cGVyY2VudGFnZT5cIixcbiAgICAgICAgICAgIGZpbGwgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIGNvdW50ICAgPSAwLFxuICAgICAgICAgICAgbWF4ICAgICA9IDQsXG4gICAgICAgICAgICBwYXJ0O1xuXG4gICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCJmaWxsXCIpKSB7XG4gICAgICAgICAgICBmaWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChleHByZXNzaW9uLmhhc05leHQoKSAmJiBjb3VudCA8IG1heCkge1xuICAgICAgICAgICAgdmFsaWQgPSBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYyk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoIWZpbGwpIHtcbiAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcImZpbGxcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uLm5leHQoKTtcbiAgICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCBlbmQgb2YgdmFsdWUgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgKFs8bnVtYmVyPiB8IDxwZXJjZW50YWdlPl17MSw0fSAmJiBmaWxsPykgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcImJvcmRlci1pbWFnZS1zb3VyY2VcIiAgICAgICAgICAgOiBcIjxpbWFnZT4gfCBub25lXCIsXG4gICAgXCJib3JkZXItaW1hZ2Utd2lkdGhcIiAgICAgICAgICAgIDogeyBtdWx0aTogXCI8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiB8IDxudW1iZXI+IHwgYXV0b1wiLCBtYXg6IDQgfSxcbiAgICBcImJvcmRlci1sZWZ0XCIgICAgICAgICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+IHx8IDxib3JkZXItc3R5bGU+IHx8IDxjb2xvcj5cIixcbiAgICBcImJvcmRlci1sZWZ0LWNvbG9yXCIgICAgICAgICAgICAgOiBcIjxjb2xvcj4gfCBpbmhlcml0XCIsXG4gICAgXCJib3JkZXItbGVmdC1zdHlsZVwiICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXN0eWxlPlwiLFxuICAgIFwiYm9yZGVyLWxlZnQtd2lkdGhcIiAgICAgICAgICAgICA6IFwiPGJvcmRlci13aWR0aD5cIixcbiAgICBcImJvcmRlci1yYWRpdXNcIiAgICAgICAgICAgICAgICAgOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG5cbiAgICAgICAgdmFyIHZhbGlkICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHNpbXBsZSA9IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCBpbmhlcml0XCIsXG4gICAgICAgICAgICBzbGFzaCAgID0gZmFsc2UsXG4gICAgICAgICAgICBjb3VudCAgID0gMCxcbiAgICAgICAgICAgIG1heCAgICAgPSA4LFxuICAgICAgICAgICAgcGFydDtcblxuICAgICAgICB3aGlsZSAoZXhwcmVzc2lvbi5oYXNOZXh0KCkgJiYgY291bnQgPCBtYXgpIHtcbiAgICAgICAgICAgIHZhbGlkID0gVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHNpbXBsZSk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoU3RyaW5nKGV4cHJlc3Npb24ucGVlaygpKSA9PT0gXCIvXCIgJiYgY291bnQgPiAwICYmICFzbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBzbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNvdW50ICsgNTtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xuICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCAoPCdib3JkZXItcmFkaXVzJz4pIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJib3JkZXItcmlnaHRcIiAgICAgICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPiB8fCA8Ym9yZGVyLXN0eWxlPiB8fCA8Y29sb3I+XCIsXG4gICAgXCJib3JkZXItcmlnaHQtY29sb3JcIiAgICAgICAgICAgIDogXCI8Y29sb3I+IHwgaW5oZXJpdFwiLFxuICAgIFwiYm9yZGVyLXJpZ2h0LXN0eWxlXCIgICAgICAgICAgICA6IFwiPGJvcmRlci1zdHlsZT5cIixcbiAgICBcImJvcmRlci1yaWdodC13aWR0aFwiICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+XCIsXG4gICAgXCJib3JkZXItc3BhY2luZ1wiICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8bGVuZ3RoPiB8IGluaGVyaXRcIiwgbWF4OiAyIH0sXG4gICAgXCJib3JkZXItc3R5bGVcIiAgICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8Ym9yZGVyLXN0eWxlPlwiLCBtYXg6IDQgfSxcbiAgICBcImJvcmRlci10b3BcIiAgICAgICAgICAgICAgICAgICAgOiBcIjxib3JkZXItd2lkdGg+IHx8IDxib3JkZXItc3R5bGU+IHx8IDxjb2xvcj5cIixcbiAgICBcImJvcmRlci10b3AtY29sb3JcIiAgICAgICAgICAgICAgOiBcIjxjb2xvcj4gfCBpbmhlcml0XCIsXG4gICAgXCJib3JkZXItdG9wLWxlZnQtcmFkaXVzXCIgICAgICAgIDogXCI8eC1vbmUtcmFkaXVzPlwiLFxuICAgIFwiYm9yZGVyLXRvcC1yaWdodC1yYWRpdXNcIiAgICAgICA6IFwiPHgtb25lLXJhZGl1cz5cIixcbiAgICBcImJvcmRlci10b3Atc3R5bGVcIiAgICAgICAgICAgICAgOiBcIjxib3JkZXItc3R5bGU+XCIsXG4gICAgXCJib3JkZXItdG9wLXdpZHRoXCIgICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPlwiLFxuICAgIFwiYm9yZGVyLXdpZHRoXCIgICAgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPGJvcmRlci13aWR0aD5cIiwgbWF4OiA0IH0sXG4gICAgXCJib3R0b21cIiAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8bWFyZ2luLXdpZHRoPiB8IGluaGVyaXRcIixcbiAgICBcIi1tb3otYm94LWFsaWduXCIgICAgICAgICAgICAgICAgOiBcInN0YXJ0IHwgZW5kIHwgY2VudGVyIHwgYmFzZWxpbmUgfCBzdHJldGNoXCIsXG4gICAgXCItbW96LWJveC1kZWNvcmF0aW9uLWJyZWFrXCIgICAgIDogXCJzbGljZSB8Y2xvbmVcIixcbiAgICBcIi1tb3otYm94LWRpcmVjdGlvblwiICAgICAgICAgICAgOiBcIm5vcm1hbCB8IHJldmVyc2UgfCBpbmhlcml0XCIsXG4gICAgXCItbW96LWJveC1mbGV4XCIgICAgICAgICAgICAgICAgIDogXCI8bnVtYmVyPlwiLFxuICAgIFwiLW1vei1ib3gtZmxleC1ncm91cFwiICAgICAgICAgICA6IFwiPGludGVnZXI+XCIsXG4gICAgXCItbW96LWJveC1saW5lc1wiICAgICAgICAgICAgICAgIDogXCJzaW5nbGUgfCBtdWx0aXBsZVwiLFxuICAgIFwiLW1vei1ib3gtb3JkaW5hbC1ncm91cFwiICAgICAgICA6IFwiPGludGVnZXI+XCIsXG4gICAgXCItbW96LWJveC1vcmllbnRcIiAgICAgICAgICAgICAgIDogXCJob3Jpem9udGFsIHwgdmVydGljYWwgfCBpbmxpbmUtYXhpcyB8IGJsb2NrLWF4aXMgfCBpbmhlcml0XCIsXG4gICAgXCItbW96LWJveC1wYWNrXCIgICAgICAgICAgICAgICAgIDogXCJzdGFydCB8IGVuZCB8IGNlbnRlciB8IGp1c3RpZnlcIixcbiAgICBcIi1vLWJveC1kZWNvcmF0aW9uLWJyZWFrXCIgICAgICAgOiBcInNsaWNlIHwgY2xvbmVcIixcbiAgICBcIi13ZWJraXQtYm94LWFsaWduXCIgICAgICAgICAgICAgOiBcInN0YXJ0IHwgZW5kIHwgY2VudGVyIHwgYmFzZWxpbmUgfCBzdHJldGNoXCIsXG4gICAgXCItd2Via2l0LWJveC1kZWNvcmF0aW9uLWJyZWFrXCIgIDogXCJzbGljZSB8Y2xvbmVcIixcbiAgICBcIi13ZWJraXQtYm94LWRpcmVjdGlvblwiICAgICAgICAgOiBcIm5vcm1hbCB8IHJldmVyc2UgfCBpbmhlcml0XCIsXG4gICAgXCItd2Via2l0LWJveC1mbGV4XCIgICAgICAgICAgICAgIDogXCI8bnVtYmVyPlwiLFxuICAgIFwiLXdlYmtpdC1ib3gtZmxleC1ncm91cFwiICAgICAgICA6IFwiPGludGVnZXI+XCIsXG4gICAgXCItd2Via2l0LWJveC1saW5lc1wiICAgICAgICAgICAgIDogXCJzaW5nbGUgfCBtdWx0aXBsZVwiLFxuICAgIFwiLXdlYmtpdC1ib3gtb3JkaW5hbC1ncm91cFwiICAgICA6IFwiPGludGVnZXI+XCIsXG4gICAgXCItd2Via2l0LWJveC1vcmllbnRcIiAgICAgICAgICAgIDogXCJob3Jpem9udGFsIHwgdmVydGljYWwgfCBpbmxpbmUtYXhpcyB8IGJsb2NrLWF4aXMgfCBpbmhlcml0XCIsXG4gICAgXCItd2Via2l0LWJveC1wYWNrXCIgICAgICAgICAgICAgIDogXCJzdGFydCB8IGVuZCB8IGNlbnRlciB8IGp1c3RpZnlcIixcbiAgICBcImJveC1kZWNvcmF0aW9uLWJyZWFrXCIgICAgICAgICAgOiBcInNsaWNlIHwgY2xvbmVcIixcbiAgICBcImJveC1zaGFkb3dcIiAgICAgICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgcGFydDtcblxuICAgICAgICBpZiAoIVZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcIm5vbmVcIikpIHtcbiAgICAgICAgICAgIFZhbGlkYXRpb24ubXVsdGlQcm9wZXJ0eShcIjxzaGFkb3c+XCIsIGV4cHJlc3Npb24sIHRydWUsIEluZmluaXR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uLm5leHQoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgZW5kIG9mIHZhbHVlIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJib3gtc2l6aW5nXCIgICAgICAgICAgICAgICAgICAgIDogXCJjb250ZW50LWJveCB8IGJvcmRlci1ib3ggfCBpbmhlcml0XCIsXG4gICAgXCJicmVhay1hZnRlclwiICAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgYWx3YXlzIHwgYXZvaWQgfCBsZWZ0IHwgcmlnaHQgfCBwYWdlIHwgY29sdW1uIHwgYXZvaWQtcGFnZSB8IGF2b2lkLWNvbHVtblwiLFxuICAgIFwiYnJlYWstYmVmb3JlXCIgICAgICAgICAgICAgICAgICA6IFwiYXV0byB8IGFsd2F5cyB8IGF2b2lkIHwgbGVmdCB8IHJpZ2h0IHwgcGFnZSB8IGNvbHVtbiB8IGF2b2lkLXBhZ2UgfCBhdm9pZC1jb2x1bW5cIixcbiAgICBcImJyZWFrLWluc2lkZVwiICAgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBhdm9pZCB8IGF2b2lkLXBhZ2UgfCBhdm9pZC1jb2x1bW5cIixcblxuICAgIC8vQ1xuICAgIFwiY2FwdGlvbi1zaWRlXCIgICAgICAgICAgICAgICAgICA6IFwidG9wIHwgYm90dG9tIHwgaW5oZXJpdFwiLFxuICAgIFwiY2xlYXJcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IFwibm9uZSB8IHJpZ2h0IHwgbGVmdCB8IGJvdGggfCBpbmhlcml0XCIsXG4gICAgXCJjbGlwXCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImNvbG9yXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxjb2xvcj4gfCBpbmhlcml0XCIsXG4gICAgXCJjb2xvci1wcm9maWxlXCIgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImNvbHVtbi1jb3VudFwiICAgICAgICAgICAgICAgICAgOiBcIjxpbnRlZ2VyPiB8IGF1dG9cIiwgICAgICAgICAgICAgICAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLW11bHRpY29sL1xuICAgIFwiY29sdW1uLWZpbGxcIiAgICAgICAgICAgICAgICAgICA6IFwiYXV0byB8IGJhbGFuY2VcIixcbiAgICBcImNvbHVtbi1nYXBcIiAgICAgICAgICAgICAgICAgICAgOiBcIjxsZW5ndGg+IHwgbm9ybWFsXCIsXG4gICAgXCJjb2x1bW4tcnVsZVwiICAgICAgICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPiB8fCA8Ym9yZGVyLXN0eWxlPiB8fCA8Y29sb3I+XCIsXG4gICAgXCJjb2x1bW4tcnVsZS1jb2xvclwiICAgICAgICAgICAgIDogXCI8Y29sb3I+XCIsXG4gICAgXCJjb2x1bW4tcnVsZS1zdHlsZVwiICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXN0eWxlPlwiLFxuICAgIFwiY29sdW1uLXJ1bGUtd2lkdGhcIiAgICAgICAgICAgICA6IFwiPGJvcmRlci13aWR0aD5cIixcbiAgICBcImNvbHVtbi1zcGFuXCIgICAgICAgICAgICAgICAgICAgOiBcIm5vbmUgfCBhbGxcIixcbiAgICBcImNvbHVtbi13aWR0aFwiICAgICAgICAgICAgICAgICAgOiBcIjxsZW5ndGg+IHwgYXV0b1wiLFxuICAgIFwiY29sdW1uc1wiICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJjb250ZW50XCIgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImNvdW50ZXItaW5jcmVtZW50XCIgICAgICAgICAgICAgOiAxLFxuICAgIFwiY291bnRlci1yZXNldFwiICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJjcm9wXCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8c2hhcGU+IHwgYXV0b1wiLFxuICAgIFwiY3VlXCIgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiY3VlLWFmdGVyIHwgY3VlLWJlZm9yZSB8IGluaGVyaXRcIixcbiAgICBcImN1ZS1hZnRlclwiICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiY3VlLWJlZm9yZVwiICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJjdXJzb3JcIiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcblxuICAgIC8vRFxuICAgIFwiZGlyZWN0aW9uXCIgICAgICAgICAgICAgICAgICAgICA6IFwibHRyIHwgcnRsIHwgaW5oZXJpdFwiLFxuICAgIFwiZGlzcGxheVwiICAgICAgICAgICAgICAgICAgICAgICA6IFwiaW5saW5lIHwgYmxvY2sgfCBsaXN0LWl0ZW0gfCBpbmxpbmUtYmxvY2sgfCB0YWJsZSB8IGlubGluZS10YWJsZSB8IHRhYmxlLXJvdy1ncm91cCB8IHRhYmxlLWhlYWRlci1ncm91cCB8IHRhYmxlLWZvb3Rlci1ncm91cCB8IHRhYmxlLXJvdyB8IHRhYmxlLWNvbHVtbi1ncm91cCB8IHRhYmxlLWNvbHVtbiB8IHRhYmxlLWNlbGwgfCB0YWJsZS1jYXB0aW9uIHwgZ3JpZCB8IGlubGluZS1ncmlkIHwgcnVuLWluIHwgcnVieSB8IHJ1YnktYmFzZSB8IHJ1YnktdGV4dCB8IHJ1YnktYmFzZS1jb250YWluZXIgfCBydWJ5LXRleHQtY29udGFpbmVyIHwgY29udGVudHMgfCBub25lIHwgaW5oZXJpdCB8IC1tb3otYm94IHwgLW1vei1pbmxpbmUtYmxvY2sgfCAtbW96LWlubGluZS1ib3ggfCAtbW96LWlubGluZS1ncmlkIHwgLW1vei1pbmxpbmUtc3RhY2sgfCAtbW96LWlubGluZS10YWJsZSB8IC1tb3otZ3JpZCB8IC1tb3otZ3JpZC1ncm91cCB8IC1tb3otZ3JpZC1saW5lIHwgLW1vei1ncm91cGJveCB8IC1tb3otZGVjayB8IC1tb3otcG9wdXAgfCAtbW96LXN0YWNrIHwgLW1vei1tYXJrZXIgfCAtd2Via2l0LWJveCB8IC13ZWJraXQtaW5saW5lLWJveCB8IC1tcy1mbGV4Ym94IHwgLW1zLWlubGluZS1mbGV4Ym94IHwgZmxleCB8IC13ZWJraXQtZmxleCB8IGlubGluZS1mbGV4IHwgLXdlYmtpdC1pbmxpbmUtZmxleFwiLFxuICAgIFwiZG9taW5hbnQtYmFzZWxpbmVcIiAgICAgICAgICAgICA6IDEsXG4gICAgXCJkcm9wLWluaXRpYWwtYWZ0ZXItYWRqdXN0XCIgICAgIDogXCJjZW50cmFsIHwgbWlkZGxlIHwgYWZ0ZXItZWRnZSB8IHRleHQtYWZ0ZXItZWRnZSB8IGlkZW9ncmFwaGljIHwgYWxwaGFiZXRpYyB8IG1hdGhlbWF0aWNhbCB8IDxwZXJjZW50YWdlPiB8IDxsZW5ndGg+XCIsXG4gICAgXCJkcm9wLWluaXRpYWwtYWZ0ZXItYWxpZ25cIiAgICAgIDogXCJiYXNlbGluZSB8IHVzZS1zY3JpcHQgfCBiZWZvcmUtZWRnZSB8IHRleHQtYmVmb3JlLWVkZ2UgfCBhZnRlci1lZGdlIHwgdGV4dC1hZnRlci1lZGdlIHwgY2VudHJhbCB8IG1pZGRsZSB8IGlkZW9ncmFwaGljIHwgYWxwaGFiZXRpYyB8IGhhbmdpbmcgfCBtYXRoZW1hdGljYWxcIixcbiAgICBcImRyb3AtaW5pdGlhbC1iZWZvcmUtYWRqdXN0XCIgICAgOiBcImJlZm9yZS1lZGdlIHwgdGV4dC1iZWZvcmUtZWRnZSB8IGNlbnRyYWwgfCBtaWRkbGUgfCBoYW5naW5nIHwgbWF0aGVtYXRpY2FsIHwgPHBlcmNlbnRhZ2U+IHwgPGxlbmd0aD5cIixcbiAgICBcImRyb3AtaW5pdGlhbC1iZWZvcmUtYWxpZ25cIiAgICAgOiBcImNhcHMtaGVpZ2h0IHwgYmFzZWxpbmUgfCB1c2Utc2NyaXB0IHwgYmVmb3JlLWVkZ2UgfCB0ZXh0LWJlZm9yZS1lZGdlIHwgYWZ0ZXItZWRnZSB8IHRleHQtYWZ0ZXItZWRnZSB8IGNlbnRyYWwgfCBtaWRkbGUgfCBpZGVvZ3JhcGhpYyB8IGFscGhhYmV0aWMgfCBoYW5naW5nIHwgbWF0aGVtYXRpY2FsXCIsXG4gICAgXCJkcm9wLWluaXRpYWwtc2l6ZVwiICAgICAgICAgICAgIDogXCJhdXRvIHwgbGluZSB8IDxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+XCIsXG4gICAgXCJkcm9wLWluaXRpYWwtdmFsdWVcIiAgICAgICAgICAgIDogXCJpbml0aWFsIHwgPGludGVnZXI+XCIsXG5cbiAgICAvL0VcbiAgICBcImVsZXZhdGlvblwiICAgICAgICAgICAgICAgICAgICAgOiBcIjxhbmdsZT4gfCBiZWxvdyB8IGxldmVsIHwgYWJvdmUgfCBoaWdoZXIgfCBsb3dlciB8IGluaGVyaXRcIixcbiAgICBcImVtcHR5LWNlbGxzXCIgICAgICAgICAgICAgICAgICAgOiBcInNob3cgfCBoaWRlIHwgaW5oZXJpdFwiLFxuXG4gICAgLy9GXG4gICAgXCJmaWx0ZXJcIiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImZpdFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImZpbGwgfCBoaWRkZW4gfCBtZWV0IHwgc2xpY2VcIixcbiAgICBcImZpdC1wb3NpdGlvblwiICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZmxleFwiICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPGZsZXg+XCIsXG4gICAgXCJmbGV4LWJhc2lzXCIgICAgICAgICAgICAgICAgICAgIDogXCI8d2lkdGg+XCIsXG4gICAgXCJmbGV4LWRpcmVjdGlvblwiICAgICAgICAgICAgICAgIDogXCJyb3cgfCByb3ctcmV2ZXJzZSB8IGNvbHVtbiB8IGNvbHVtbi1yZXZlcnNlXCIsXG4gICAgXCJmbGV4LWZsb3dcIiAgICAgICAgICAgICAgICAgICAgIDogXCI8ZmxleC1kaXJlY3Rpb24+IHx8IDxmbGV4LXdyYXA+XCIsXG4gICAgXCJmbGV4LWdyb3dcIiAgICAgICAgICAgICAgICAgICAgIDogXCI8bnVtYmVyPlwiLFxuICAgIFwiZmxleC1zaHJpbmtcIiAgICAgICAgICAgICAgICAgICA6IFwiPG51bWJlcj5cIixcbiAgICBcImZsZXgtd3JhcFwiICAgICAgICAgICAgICAgICAgICAgOiBcIm5vd3JhcCB8IHdyYXAgfCB3cmFwLXJldmVyc2VcIixcbiAgICBcIi13ZWJraXQtZmxleFwiICAgICAgICAgICAgICAgICAgOiBcIjxmbGV4PlwiLFxuICAgIFwiLXdlYmtpdC1mbGV4LWJhc2lzXCIgICAgICAgICAgICA6IFwiPHdpZHRoPlwiLFxuICAgIFwiLXdlYmtpdC1mbGV4LWRpcmVjdGlvblwiICAgICAgICA6IFwicm93IHwgcm93LXJldmVyc2UgfCBjb2x1bW4gfCBjb2x1bW4tcmV2ZXJzZVwiLFxuICAgIFwiLXdlYmtpdC1mbGV4LWZsb3dcIiAgICAgICAgICAgICA6IFwiPGZsZXgtZGlyZWN0aW9uPiB8fCA8ZmxleC13cmFwPlwiLFxuICAgIFwiLXdlYmtpdC1mbGV4LWdyb3dcIiAgICAgICAgICAgICA6IFwiPG51bWJlcj5cIixcbiAgICBcIi13ZWJraXQtZmxleC1zaHJpbmtcIiAgICAgICAgICAgOiBcIjxudW1iZXI+XCIsXG4gICAgXCItd2Via2l0LWZsZXgtd3JhcFwiICAgICAgICAgICAgIDogXCJub3dyYXAgfCB3cmFwIHwgd3JhcC1yZXZlcnNlXCIsXG4gICAgXCItbXMtZmxleFwiICAgICAgICAgICAgICAgICAgICAgIDogXCI8ZmxleD5cIixcbiAgICBcIi1tcy1mbGV4LWFsaWduXCIgICAgICAgICAgICAgICAgOiBcInN0YXJ0IHwgZW5kIHwgY2VudGVyIHwgc3RyZXRjaCB8IGJhc2VsaW5lXCIsXG4gICAgXCItbXMtZmxleC1kaXJlY3Rpb25cIiAgICAgICAgICAgIDogXCJyb3cgfCByb3ctcmV2ZXJzZSB8IGNvbHVtbiB8IGNvbHVtbi1yZXZlcnNlIHwgaW5oZXJpdFwiLFxuICAgIFwiLW1zLWZsZXgtb3JkZXJcIiAgICAgICAgICAgICAgICA6IFwiPG51bWJlcj5cIixcbiAgICBcIi1tcy1mbGV4LXBhY2tcIiAgICAgICAgICAgICAgICAgOiBcInN0YXJ0IHwgZW5kIHwgY2VudGVyIHwganVzdGlmeVwiLFxuICAgIFwiLW1zLWZsZXgtd3JhcFwiICAgICAgICAgICAgICAgICA6IFwibm93cmFwIHwgd3JhcCB8IHdyYXAtcmV2ZXJzZVwiLFxuICAgIFwiZmxvYXRcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IFwibGVmdCB8IHJpZ2h0IHwgbm9uZSB8IGluaGVyaXRcIixcbiAgICBcImZsb2F0LW9mZnNldFwiICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZm9udFwiICAgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJmb250LWZhbWlseVwiICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImZvbnQtZmVhdHVyZS1zZXR0aW5nc1wiICAgICAgICAgOiBcIjxmZWF0dXJlLXRhZy12YWx1ZT4gfCBub3JtYWwgfCBpbmhlcml0XCIsXG4gICAgXCJmb250LWtlcm5pbmdcIiAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgbm9ybWFsIHwgbm9uZSB8IGluaXRpYWwgfCBpbmhlcml0IHwgdW5zZXRcIixcbiAgICBcImZvbnQtc2l6ZVwiICAgICAgICAgICAgICAgICAgICAgOiBcIjxhYnNvbHV0ZS1zaXplPiB8IDxyZWxhdGl2ZS1zaXplPiB8IDxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+IHwgaW5oZXJpdFwiLFxuICAgIFwiZm9udC1zaXplLWFkanVzdFwiICAgICAgICAgICAgICA6IFwiPG51bWJlcj4gfCBub25lIHwgaW5oZXJpdFwiLFxuICAgIFwiZm9udC1zdHJldGNoXCIgICAgICAgICAgICAgICAgICA6IFwibm9ybWFsIHwgdWx0cmEtY29uZGVuc2VkIHwgZXh0cmEtY29uZGVuc2VkIHwgY29uZGVuc2VkIHwgc2VtaS1jb25kZW5zZWQgfCBzZW1pLWV4cGFuZGVkIHwgZXhwYW5kZWQgfCBleHRyYS1leHBhbmRlZCB8IHVsdHJhLWV4cGFuZGVkIHwgaW5oZXJpdFwiLFxuICAgIFwiZm9udC1zdHlsZVwiICAgICAgICAgICAgICAgICAgICA6IFwibm9ybWFsIHwgaXRhbGljIHwgb2JsaXF1ZSB8IGluaGVyaXRcIixcbiAgICBcImZvbnQtdmFyaWFudFwiICAgICAgICAgICAgICAgICAgOiBcIm5vcm1hbCB8IHNtYWxsLWNhcHMgfCBpbmhlcml0XCIsXG4gICAgXCJmb250LXZhcmlhbnQtY2Fwc1wiICAgICAgICAgICAgIDogXCJub3JtYWwgfCBzbWFsbC1jYXBzIHwgYWxsLXNtYWxsLWNhcHMgfCBwZXRpdGUtY2FwcyB8IGFsbC1wZXRpdGUtY2FwcyB8IHVuaWNhc2UgfCB0aXRsaW5nLWNhcHNcIixcbiAgICBcImZvbnQtdmFyaWFudC1wb3NpdGlvblwiICAgICAgICAgOiBcIm5vcm1hbCB8IHN1YiB8IHN1cGVyIHwgaW5oZXJpdCB8IGluaXRpYWwgfCB1bnNldFwiLFxuICAgIFwiZm9udC13ZWlnaHRcIiAgICAgICAgICAgICAgICAgICA6IFwibm9ybWFsIHwgYm9sZCB8IGJvbGRlciB8IGxpZ2h0ZXIgfCAxMDAgfCAyMDAgfCAzMDAgfCA0MDAgfCA1MDAgfCA2MDAgfCA3MDAgfCA4MDAgfCA5MDAgfCBpbmhlcml0XCIsXG5cbiAgICAvL0dcbiAgICBcImdyaWRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC1hcmVhXCIgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLWF1dG8tY29sdW1uc1wiICAgICAgICAgICAgIDogMSxcbiAgICBcImdyaWQtYXV0by1mbG93XCIgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC1hdXRvLXBvc2l0aW9uXCIgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLWF1dG8tcm93c1wiICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImdyaWQtY2VsbC1zdGFja2luZ1wiICAgICAgICAgICAgOiBcImNvbHVtbnMgfCByb3dzIHwgbGF5ZXJcIixcbiAgICBcImdyaWQtY29sdW1uXCIgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC1jb2x1bW5zXCIgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLWNvbHVtbi1hbGlnblwiICAgICAgICAgICAgIDogXCJzdGFydCB8IGVuZCB8IGNlbnRlciB8IHN0cmV0Y2hcIixcbiAgICBcImdyaWQtY29sdW1uLXNpemluZ1wiICAgICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC1jb2x1bW4tc3RhcnRcIiAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLWNvbHVtbi1lbmRcIiAgICAgICAgICAgICAgIDogMSxcbiAgICBcImdyaWQtY29sdW1uLXNwYW5cIiAgICAgICAgICAgICAgOiBcIjxpbnRlZ2VyPlwiLFxuICAgIFwiZ3JpZC1mbG93XCIgICAgICAgICAgICAgICAgICAgICA6IFwibm9uZSB8IHJvd3MgfCBjb2x1bW5zXCIsXG4gICAgXCJncmlkLWxheWVyXCIgICAgICAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj5cIixcbiAgICBcImdyaWQtcm93XCIgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC1yb3dzXCIgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLXJvdy1hbGlnblwiICAgICAgICAgICAgICAgIDogXCJzdGFydCB8IGVuZCB8IGNlbnRlciB8IHN0cmV0Y2hcIixcbiAgICBcImdyaWQtcm93LXN0YXJ0XCIgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC1yb3ctZW5kXCIgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLXJvdy1zcGFuXCIgICAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj5cIixcbiAgICBcImdyaWQtcm93LXNpemluZ1wiICAgICAgICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC10ZW1wbGF0ZVwiICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJncmlkLXRlbXBsYXRlLWFyZWFzXCIgICAgICAgICAgIDogMSxcbiAgICBcImdyaWQtdGVtcGxhdGUtY29sdW1uc1wiICAgICAgICAgOiAxLFxuICAgIFwiZ3JpZC10ZW1wbGF0ZS1yb3dzXCIgICAgICAgICAgICA6IDEsXG5cbiAgICAvL0hcbiAgICBcImhhbmdpbmctcHVuY3R1YXRpb25cIiAgICAgICAgICAgOiAxLFxuICAgIFwiaGVpZ2h0XCIgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPG1hcmdpbi13aWR0aD4gfCA8Y29udGVudC1zaXppbmc+IHwgaW5oZXJpdFwiLFxuICAgIFwiaHlwaGVuYXRlLWFmdGVyXCIgICAgICAgICAgICAgICA6IFwiPGludGVnZXI+IHwgYXV0b1wiLFxuICAgIFwiaHlwaGVuYXRlLWJlZm9yZVwiICAgICAgICAgICAgICA6IFwiPGludGVnZXI+IHwgYXV0b1wiLFxuICAgIFwiaHlwaGVuYXRlLWNoYXJhY3RlclwiICAgICAgICAgICA6IFwiPHN0cmluZz4gfCBhdXRvXCIsXG4gICAgXCJoeXBoZW5hdGUtbGluZXNcIiAgICAgICAgICAgICAgIDogXCJuby1saW1pdCB8IDxpbnRlZ2VyPlwiLFxuICAgIFwiaHlwaGVuYXRlLXJlc291cmNlXCIgICAgICAgICAgICA6IDEsXG4gICAgXCJoeXBoZW5zXCIgICAgICAgICAgICAgICAgICAgICAgIDogXCJub25lIHwgbWFudWFsIHwgYXV0b1wiLFxuXG4gICAgLy9JXG4gICAgXCJpY29uXCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImltYWdlLW9yaWVudGF0aW9uXCIgICAgICAgICAgICAgOiBcImFuZ2xlIHwgYXV0b1wiLFxuICAgIFwiaW1hZ2UtcmVuZGVyaW5nXCIgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJpbWFnZS1yZXNvbHV0aW9uXCIgICAgICAgICAgICAgIDogMSxcbiAgICBcImltZS1tb2RlXCIgICAgICAgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBub3JtYWwgfCBhY3RpdmUgfCBpbmFjdGl2ZSB8IGRpc2FibGVkIHwgaW5oZXJpdFwiLFxuICAgIFwiaW5saW5lLWJveC1hbGlnblwiICAgICAgICAgICAgICA6IFwiaW5pdGlhbCB8IGxhc3QgfCA8aW50ZWdlcj5cIixcblxuICAgIC8vSlxuICAgIFwianVzdGlmeS1jb250ZW50XCIgICAgICAgICAgICAgICA6IFwiZmxleC1zdGFydCB8IGZsZXgtZW5kIHwgY2VudGVyIHwgc3BhY2UtYmV0d2VlbiB8IHNwYWNlLWFyb3VuZFwiLFxuICAgIFwiLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnRcIiAgICAgICA6IFwiZmxleC1zdGFydCB8IGZsZXgtZW5kIHwgY2VudGVyIHwgc3BhY2UtYmV0d2VlbiB8IHNwYWNlLWFyb3VuZFwiLFxuXG4gICAgLy9MXG4gICAgXCJsZWZ0XCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8bWFyZ2luLXdpZHRoPiB8IGluaGVyaXRcIixcbiAgICBcImxldHRlci1zcGFjaW5nXCIgICAgICAgICAgICAgICAgOiBcIjxsZW5ndGg+IHwgbm9ybWFsIHwgaW5oZXJpdFwiLFxuICAgIFwibGluZS1oZWlnaHRcIiAgICAgICAgICAgICAgICAgICA6IFwiPG51bWJlcj4gfCA8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiB8IG5vcm1hbCB8IGluaGVyaXRcIixcbiAgICBcImxpbmUtYnJlYWtcIiAgICAgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBsb29zZSB8IG5vcm1hbCB8IHN0cmljdFwiLFxuICAgIFwibGluZS1zdGFja2luZ1wiICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJsaW5lLXN0YWNraW5nLXJ1YnlcIiAgICAgICAgICAgIDogXCJleGNsdWRlLXJ1YnkgfCBpbmNsdWRlLXJ1YnlcIixcbiAgICBcImxpbmUtc3RhY2tpbmctc2hpZnRcIiAgICAgICAgICAgOiBcImNvbnNpZGVyLXNoaWZ0cyB8IGRpc3JlZ2FyZC1zaGlmdHNcIixcbiAgICBcImxpbmUtc3RhY2tpbmctc3RyYXRlZ3lcIiAgICAgICAgOiBcImlubGluZS1saW5lLWhlaWdodCB8IGJsb2NrLWxpbmUtaGVpZ2h0IHwgbWF4LWhlaWdodCB8IGdyaWQtaGVpZ2h0XCIsXG4gICAgXCJsaXN0LXN0eWxlXCIgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcImxpc3Qtc3R5bGUtaW1hZ2VcIiAgICAgICAgICAgICAgOiBcIjx1cmk+IHwgbm9uZSB8IGluaGVyaXRcIixcbiAgICBcImxpc3Qtc3R5bGUtcG9zaXRpb25cIiAgICAgICAgICAgOiBcImluc2lkZSB8IG91dHNpZGUgfCBpbmhlcml0XCIsXG4gICAgXCJsaXN0LXN0eWxlLXR5cGVcIiAgICAgICAgICAgICAgIDogXCJkaXNjIHwgY2lyY2xlIHwgc3F1YXJlIHwgZGVjaW1hbCB8IGRlY2ltYWwtbGVhZGluZy16ZXJvIHwgbG93ZXItcm9tYW4gfCB1cHBlci1yb21hbiB8IGxvd2VyLWdyZWVrIHwgbG93ZXItbGF0aW4gfCB1cHBlci1sYXRpbiB8IGFybWVuaWFuIHwgZ2VvcmdpYW4gfCBsb3dlci1hbHBoYSB8IHVwcGVyLWFscGhhIHwgbm9uZSB8IGluaGVyaXRcIixcblxuICAgIC8vTVxuICAgIFwibWFyZ2luXCIgICAgICAgICAgICAgICAgICAgICAgICA6IHsgbXVsdGk6IFwiPG1hcmdpbi13aWR0aD4gfCBpbmhlcml0XCIsIG1heDogNCB9LFxuICAgIFwibWFyZ2luLWJvdHRvbVwiICAgICAgICAgICAgICAgICA6IFwiPG1hcmdpbi13aWR0aD4gfCBpbmhlcml0XCIsXG4gICAgXCJtYXJnaW4tbGVmdFwiICAgICAgICAgICAgICAgICAgIDogXCI8bWFyZ2luLXdpZHRoPiB8IGluaGVyaXRcIixcbiAgICBcIm1hcmdpbi1yaWdodFwiICAgICAgICAgICAgICAgICAgOiBcIjxtYXJnaW4td2lkdGg+IHwgaW5oZXJpdFwiLFxuICAgIFwibWFyZ2luLXRvcFwiICAgICAgICAgICAgICAgICAgICA6IFwiPG1hcmdpbi13aWR0aD4gfCBpbmhlcml0XCIsXG4gICAgXCJtYXJrXCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcIm1hcmstYWZ0ZXJcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwibWFyay1iZWZvcmVcIiAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJtYXJrc1wiICAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcIm1hcnF1ZWUtZGlyZWN0aW9uXCIgICAgICAgICAgICAgOiAxLFxuICAgIFwibWFycXVlZS1wbGF5LWNvdW50XCIgICAgICAgICAgICA6IDEsXG4gICAgXCJtYXJxdWVlLXNwZWVkXCIgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcIm1hcnF1ZWUtc3R5bGVcIiAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwibWF4LWhlaWdodFwiICAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCA8Y29udGVudC1zaXppbmc+IHwgbm9uZSB8IGluaGVyaXRcIixcbiAgICBcIm1heC13aWR0aFwiICAgICAgICAgICAgICAgICAgICAgOiBcIjxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+IHwgPGNvbnRlbnQtc2l6aW5nPiB8IG5vbmUgfCBpbmhlcml0XCIsXG4gICAgXCJtaW4taGVpZ2h0XCIgICAgICAgICAgICAgICAgICAgIDogXCI8bGVuZ3RoPiB8IDxwZXJjZW50YWdlPiB8IDxjb250ZW50LXNpemluZz4gfCBjb250YWluLWZsb2F0cyB8IC1tb3otY29udGFpbi1mbG9hdHMgfCAtd2Via2l0LWNvbnRhaW4tZmxvYXRzIHwgaW5oZXJpdFwiLFxuICAgIFwibWluLXdpZHRoXCIgICAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCA8Y29udGVudC1zaXppbmc+IHwgY29udGFpbi1mbG9hdHMgfCAtbW96LWNvbnRhaW4tZmxvYXRzIHwgLXdlYmtpdC1jb250YWluLWZsb2F0cyB8IGluaGVyaXRcIixcbiAgICBcIm1vdmUtdG9cIiAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuXG4gICAgLy9OXG4gICAgXCJuYXYtZG93blwiICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcIm5hdi1pbmRleFwiICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwibmF2LWxlZnRcIiAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJuYXYtcmlnaHRcIiAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcIm5hdi11cFwiICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuXG4gICAgLy9PXG4gICAgXCJvYmplY3QtZml0XCIgICAgICAgICAgICAgICAgICAgIDogXCJmaWxsIHwgY29udGFpbiB8IGNvdmVyIHwgbm9uZSB8IHNjYWxlLWRvd25cIixcbiAgICBcIm9iamVjdC1wb3NpdGlvblwiICAgICAgICAgICAgICAgOiBcIjxiZy1wb3NpdGlvbj5cIixcbiAgICBcIm9wYWNpdHlcIiAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxudW1iZXI+IHwgaW5oZXJpdFwiLFxuICAgIFwib3JkZXJcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPGludGVnZXI+XCIsXG4gICAgXCItd2Via2l0LW9yZGVyXCIgICAgICAgICAgICAgICAgIDogXCI8aW50ZWdlcj5cIixcbiAgICBcIm9ycGhhbnNcIiAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxpbnRlZ2VyPiB8IGluaGVyaXRcIixcbiAgICBcIm91dGxpbmVcIiAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwib3V0bGluZS1jb2xvclwiICAgICAgICAgICAgICAgICA6IFwiPGNvbG9yPiB8IGludmVydCB8IGluaGVyaXRcIixcbiAgICBcIm91dGxpbmUtb2Zmc2V0XCIgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwib3V0bGluZS1zdHlsZVwiICAgICAgICAgICAgICAgICA6IFwiPGJvcmRlci1zdHlsZT4gfCBpbmhlcml0XCIsXG4gICAgXCJvdXRsaW5lLXdpZHRoXCIgICAgICAgICAgICAgICAgIDogXCI8Ym9yZGVyLXdpZHRoPiB8IGluaGVyaXRcIixcbiAgICBcIm92ZXJmbG93XCIgICAgICAgICAgICAgICAgICAgICAgOiBcInZpc2libGUgfCBoaWRkZW4gfCBzY3JvbGwgfCBhdXRvIHwgaW5oZXJpdFwiLFxuICAgIFwib3ZlcmZsb3ctc3R5bGVcIiAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJvdmVyZmxvdy13cmFwXCIgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBicmVhay13b3JkXCIsXG4gICAgXCJvdmVyZmxvdy14XCIgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcIm92ZXJmbG93LXlcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxuXG4gICAgLy9QXG4gICAgXCJwYWRkaW5nXCIgICAgICAgICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8cGFkZGluZy13aWR0aD4gfCBpbmhlcml0XCIsIG1heDogNCB9LFxuICAgIFwicGFkZGluZy1ib3R0b21cIiAgICAgICAgICAgICAgICA6IFwiPHBhZGRpbmctd2lkdGg+IHwgaW5oZXJpdFwiLFxuICAgIFwicGFkZGluZy1sZWZ0XCIgICAgICAgICAgICAgICAgICA6IFwiPHBhZGRpbmctd2lkdGg+IHwgaW5oZXJpdFwiLFxuICAgIFwicGFkZGluZy1yaWdodFwiICAgICAgICAgICAgICAgICA6IFwiPHBhZGRpbmctd2lkdGg+IHwgaW5oZXJpdFwiLFxuICAgIFwicGFkZGluZy10b3BcIiAgICAgICAgICAgICAgICAgICA6IFwiPHBhZGRpbmctd2lkdGg+IHwgaW5oZXJpdFwiLFxuICAgIFwicGFnZVwiICAgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJwYWdlLWJyZWFrLWFmdGVyXCIgICAgICAgICAgICAgIDogXCJhdXRvIHwgYWx3YXlzIHwgYXZvaWQgfCBsZWZ0IHwgcmlnaHQgfCBpbmhlcml0XCIsXG4gICAgXCJwYWdlLWJyZWFrLWJlZm9yZVwiICAgICAgICAgICAgIDogXCJhdXRvIHwgYWx3YXlzIHwgYXZvaWQgfCBsZWZ0IHwgcmlnaHQgfCBpbmhlcml0XCIsXG4gICAgXCJwYWdlLWJyZWFrLWluc2lkZVwiICAgICAgICAgICAgIDogXCJhdXRvIHwgYXZvaWQgfCBpbmhlcml0XCIsXG4gICAgXCJwYWdlLXBvbGljeVwiICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInBhdXNlXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicGF1c2UtYWZ0ZXJcIiAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJwYXVzZS1iZWZvcmVcIiAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInBlcnNwZWN0aXZlXCIgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicGVyc3BlY3RpdmUtb3JpZ2luXCIgICAgICAgICAgICA6IDEsXG4gICAgXCJwaG9uZW1lc1wiICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInBpdGNoXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicGl0Y2gtcmFuZ2VcIiAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJwbGF5LWR1cmluZ1wiICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInBvaW50ZXItZXZlbnRzXCIgICAgICAgICAgICAgICAgOiBcImF1dG8gfCBub25lIHwgdmlzaWJsZVBhaW50ZWQgfCB2aXNpYmxlRmlsbCB8IHZpc2libGVTdHJva2UgfCB2aXNpYmxlIHwgcGFpbnRlZCB8IGZpbGwgfCBzdHJva2UgfCBhbGwgfCBpbmhlcml0XCIsXG4gICAgXCJwb3NpdGlvblwiICAgICAgICAgICAgICAgICAgICAgIDogXCJzdGF0aWMgfCByZWxhdGl2ZSB8IGFic29sdXRlIHwgZml4ZWQgfCBpbmhlcml0XCIsXG4gICAgXCJwcmVzZW50YXRpb24tbGV2ZWxcIiAgICAgICAgICAgIDogMSxcbiAgICBcInB1bmN0dWF0aW9uLXRyaW1cIiAgICAgICAgICAgICAgOiAxLFxuXG4gICAgLy9RXG4gICAgXCJxdW90ZXNcIiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcblxuICAgIC8vUlxuICAgIFwicmVuZGVyaW5nLWludGVudFwiICAgICAgICAgICAgICA6IDEsXG4gICAgXCJyZXNpemVcIiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInJlc3RcIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicmVzdC1hZnRlclwiICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJyZXN0LWJlZm9yZVwiICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInJpY2huZXNzXCIgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicmlnaHRcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiPG1hcmdpbi13aWR0aD4gfCBpbmhlcml0XCIsXG4gICAgXCJyb3RhdGlvblwiICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInJvdGF0aW9uLXBvaW50XCIgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicnVieS1hbGlnblwiICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJydWJ5LW92ZXJoYW5nXCIgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInJ1YnktcG9zaXRpb25cIiAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwicnVieS1zcGFuXCIgICAgICAgICAgICAgICAgICAgICA6IDEsXG5cbiAgICAvL1NcbiAgICBcInNpemVcIiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwic3BlYWtcIiAgICAgICAgICAgICAgICAgICAgICAgICA6IFwibm9ybWFsIHwgbm9uZSB8IHNwZWxsLW91dCB8IGluaGVyaXRcIixcbiAgICBcInNwZWFrLWhlYWRlclwiICAgICAgICAgICAgICAgICAgOiBcIm9uY2UgfCBhbHdheXMgfCBpbmhlcml0XCIsXG4gICAgXCJzcGVhay1udW1lcmFsXCIgICAgICAgICAgICAgICAgIDogXCJkaWdpdHMgfCBjb250aW51b3VzIHwgaW5oZXJpdFwiLFxuICAgIFwic3BlYWstcHVuY3R1YXRpb25cIiAgICAgICAgICAgICA6IFwiY29kZSB8IG5vbmUgfCBpbmhlcml0XCIsXG4gICAgXCJzcGVlY2gtcmF0ZVwiICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInNyY1wiICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwic3RyZXNzXCIgICAgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJzdHJpbmctc2V0XCIgICAgICAgICAgICAgICAgICAgIDogMSxcblxuICAgIFwidGFibGUtbGF5b3V0XCIgICAgICAgICAgICAgICAgICA6IFwiYXV0byB8IGZpeGVkIHwgaW5oZXJpdFwiLFxuICAgIFwidGFiLXNpemVcIiAgICAgICAgICAgICAgICAgICAgICA6IFwiPGludGVnZXI+IHwgPGxlbmd0aD5cIixcbiAgICBcInRhcmdldFwiICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidGFyZ2V0LW5hbWVcIiAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0YXJnZXQtbmV3XCIgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInRhcmdldC1wb3NpdGlvblwiICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidGV4dC1hbGlnblwiICAgICAgICAgICAgICAgICAgICA6IFwibGVmdCB8IHJpZ2h0IHwgY2VudGVyIHwganVzdGlmeSB8IG1hdGNoLXBhcmVudCB8IHN0YXJ0IHwgZW5kIHwgaW5oZXJpdFwiICxcbiAgICBcInRleHQtYWxpZ24tbGFzdFwiICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidGV4dC1kZWNvcmF0aW9uXCIgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0ZXh0LWVtcGhhc2lzXCIgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInRleHQtaGVpZ2h0XCIgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidGV4dC1pbmRlbnRcIiAgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCBpbmhlcml0XCIsXG4gICAgXCJ0ZXh0LWp1c3RpZnlcIiAgICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgbm9uZSB8IGludGVyLXdvcmQgfCBpbnRlci1pZGVvZ3JhcGggfCBpbnRlci1jbHVzdGVyIHwgZGlzdHJpYnV0ZSB8IGthc2hpZGFcIixcbiAgICBcInRleHQtb3V0bGluZVwiICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidGV4dC1vdmVyZmxvd1wiICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0ZXh0LXJlbmRlcmluZ1wiICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgb3B0aW1pemVTcGVlZCB8IG9wdGltaXplTGVnaWJpbGl0eSB8IGdlb21ldHJpY1ByZWNpc2lvbiB8IGluaGVyaXRcIixcbiAgICBcInRleHQtc2hhZG93XCIgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidGV4dC10cmFuc2Zvcm1cIiAgICAgICAgICAgICAgICA6IFwiY2FwaXRhbGl6ZSB8IHVwcGVyY2FzZSB8IGxvd2VyY2FzZSB8IG5vbmUgfCBpbmhlcml0XCIsXG4gICAgXCJ0ZXh0LXdyYXBcIiAgICAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBub25lIHwgYXZvaWRcIixcbiAgICBcInRvcFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxtYXJnaW4td2lkdGg+IHwgaW5oZXJpdFwiLFxuICAgIFwiLW1zLXRvdWNoLWFjdGlvblwiICAgICAgICAgICAgICA6IFwiYXV0byB8IG5vbmUgfCBwYW4teCB8IHBhbi15IHwgcGFuLWxlZnQgfCBwYW4tcmlnaHQgfCBwYW4tdXAgfCBwYW4tZG93biB8IG1hbmlwdWxhdGlvblwiLFxuICAgIFwidG91Y2gtYWN0aW9uXCIgICAgICAgICAgICAgICAgICA6IFwiYXV0byB8IG5vbmUgfCBwYW4teCB8IHBhbi15IHwgcGFuLWxlZnQgfCBwYW4tcmlnaHQgfCBwYW4tdXAgfCBwYW4tZG93biB8IG1hbmlwdWxhdGlvblwiLFxuICAgIFwidHJhbnNmb3JtXCIgICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCIgICAgICAgICAgICAgIDogMSxcbiAgICBcInRyYW5zZm9ybS1zdHlsZVwiICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidHJhbnNpdGlvblwiICAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ0cmFuc2l0aW9uLWRlbGF5XCIgICAgICAgICAgICAgIDogMSxcbiAgICBcInRyYW5zaXRpb24tZHVyYXRpb25cIiAgICAgICAgICAgOiAxLFxuICAgIFwidHJhbnNpdGlvbi1wcm9wZXJ0eVwiICAgICAgICAgICA6IDEsXG4gICAgXCJ0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblwiICAgIDogMSxcblxuICAgIC8vVVxuICAgIFwidW5pY29kZS1iaWRpXCIgICAgICAgICAgICAgICAgICA6IFwibm9ybWFsIHwgZW1iZWQgfCBpc29sYXRlIHwgYmlkaS1vdmVycmlkZSB8IGlzb2xhdGUtb3ZlcnJpZGUgfCBwbGFpbnRleHQgfCBpbmhlcml0XCIsXG4gICAgXCJ1c2VyLW1vZGlmeVwiICAgICAgICAgICAgICAgICAgIDogXCJyZWFkLW9ubHkgfCByZWFkLXdyaXRlIHwgd3JpdGUtb25seSB8IGluaGVyaXRcIixcbiAgICBcInVzZXItc2VsZWN0XCIgICAgICAgICAgICAgICAgICAgOiBcIm5vbmUgfCB0ZXh0IHwgdG9nZ2xlIHwgZWxlbWVudCB8IGVsZW1lbnRzIHwgYWxsIHwgaW5oZXJpdFwiLFxuXG4gICAgLy9WXG4gICAgXCJ2ZXJ0aWNhbC1hbGlnblwiICAgICAgICAgICAgICAgIDogXCJhdXRvIHwgdXNlLXNjcmlwdCB8IGJhc2VsaW5lIHwgc3ViIHwgc3VwZXIgfCB0b3AgfCB0ZXh0LXRvcCB8IGNlbnRyYWwgfCBtaWRkbGUgfCBib3R0b20gfCB0ZXh0LWJvdHRvbSB8IDxwZXJjZW50YWdlPiB8IDxsZW5ndGg+IHwgaW5oZXJpdFwiLFxuICAgIFwidmlzaWJpbGl0eVwiICAgICAgICAgICAgICAgICAgICA6IFwidmlzaWJsZSB8IGhpZGRlbiB8IGNvbGxhcHNlIHwgaW5oZXJpdFwiLFxuICAgIFwidm9pY2UtYmFsYW5jZVwiICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ2b2ljZS1kdXJhdGlvblwiICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInZvaWNlLWZhbWlseVwiICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidm9pY2UtcGl0Y2hcIiAgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ2b2ljZS1waXRjaC1yYW5nZVwiICAgICAgICAgICAgIDogMSxcbiAgICBcInZvaWNlLXJhdGVcIiAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgIFwidm9pY2Utc3RyZXNzXCIgICAgICAgICAgICAgICAgICA6IDEsXG4gICAgXCJ2b2ljZS12b2x1bWVcIiAgICAgICAgICAgICAgICAgIDogMSxcbiAgICBcInZvbHVtZVwiICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuXG4gICAgLy9XXG4gICAgXCJ3aGl0ZS1zcGFjZVwiICAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBwcmUgfCBub3dyYXAgfCBwcmUtd3JhcCB8IHByZS1saW5lIHwgaW5oZXJpdCB8IC1wcmUtd3JhcCB8IC1vLXByZS13cmFwIHwgLW1vei1wcmUtd3JhcCB8IC1ocC1wcmUtd3JhcFwiLCAvL2h0dHA6Ly9wZXJpc2hhYmxlcHJlc3MuY29tL3dyYXBwaW5nLWNvbnRlbnQvXG4gICAgXCJ3aGl0ZS1zcGFjZS1jb2xsYXBzZVwiICAgICAgICAgIDogMSxcbiAgICBcIndpZG93c1wiICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxpbnRlZ2VyPiB8IGluaGVyaXRcIixcbiAgICBcIndpZHRoXCIgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+IHwgPGNvbnRlbnQtc2l6aW5nPiB8IGF1dG8gfCBpbmhlcml0XCIsXG4gICAgXCJ3aWxsLWNoYW5nZVwiICAgICAgICAgICAgICAgICAgIDogeyBtdWx0aTogXCI8aWRlbnQ+XCIsIGNvbW1hOiB0cnVlIH0sXG4gICAgXCJ3b3JkLWJyZWFrXCIgICAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBrZWVwLWFsbCB8IGJyZWFrLWFsbFwiLFxuICAgIFwid29yZC1zcGFjaW5nXCIgICAgICAgICAgICAgICAgICA6IFwiPGxlbmd0aD4gfCBub3JtYWwgfCBpbmhlcml0XCIsXG4gICAgXCJ3b3JkLXdyYXBcIiAgICAgICAgICAgICAgICAgICAgIDogXCJub3JtYWwgfCBicmVhay13b3JkXCIsXG4gICAgXCJ3cml0aW5nLW1vZGVcIiAgICAgICAgICAgICAgICAgIDogXCJob3Jpem9udGFsLXRiIHwgdmVydGljYWwtcmwgfCB2ZXJ0aWNhbC1sciB8IGxyLXRiIHwgcmwtdGIgfCB0Yi1ybCB8IGJ0LXJsIHwgdGItbHIgfCBidC1sciB8IGxyLWJ0IHwgcmwtYnQgfCBsciB8IHJsIHwgdGIgfCBpbmhlcml0XCIsXG5cbiAgICAvL1pcbiAgICBcInotaW5kZXhcIiAgICAgICAgICAgICAgICAgICAgICAgOiBcIjxpbnRlZ2VyPiB8IGF1dG8gfCBpbmhlcml0XCIsXG4gICAgXCJ6b29tXCIgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI8bnVtYmVyPiB8IDxwZXJjZW50YWdlPiB8IG5vcm1hbFwiXG59O1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2VsZWN0b3IgY29tYmluYXRvciAod2hpdGVzcGFjZSwgKywgPikuXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi5jc3NcbiAqIEBjbGFzcyBQcm9wZXJ0eU5hbWVcbiAqIEBleHRlbmRzIHBhcnNlcmxpYi51dGlsLlN5bnRheFVuaXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gaGFjayBUaGUgdHlwZSBvZiBJRSBoYWNrIGFwcGxpZWQgKFwiKlwiLCBcIl9cIiwgb3IgbnVsbCkuXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKiBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICovXG5mdW5jdGlvbiBQcm9wZXJ0eU5hbWUodGV4dCwgaGFjaywgbGluZSwgY29sKXtcblxuICAgIFN5bnRheFVuaXQuY2FsbCh0aGlzLCB0ZXh0LCBsaW5lLCBjb2wsIFBhcnNlci5QUk9QRVJUWV9OQU1FX1RZUEUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgSUUgaGFjayBhcHBsaWVkIChcIipcIiwgXCJfXCIsIG9yIG51bGwpLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSBoYWNrXG4gICAgICovXG4gICAgdGhpcy5oYWNrID0gaGFjaztcblxufVxuXG5Qcm9wZXJ0eU5hbWUucHJvdG90eXBlID0gbmV3IFN5bnRheFVuaXQoKTtcblByb3BlcnR5TmFtZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcm9wZXJ0eU5hbWU7XG5Qcm9wZXJ0eU5hbWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gKHRoaXMuaGFjayA/IHRoaXMuaGFjayA6IFwiXCIpICsgdGhpcy50ZXh0O1xufTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHNpbmdsZSBwYXJ0IG9mIGEgQ1NTIHByb3BlcnR5IHZhbHVlLCBtZWFuaW5nIHRoYXQgaXQgcmVwcmVzZW50c1xuICoganVzdCBldmVyeXRoaW5nIHNpbmdsZSBwYXJ0IGJldHdlZW4gXCI6XCIgYW5kIFwiO1wiLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmFsdWVzXG4gKiBzZXBhcmF0ZWQgYnkgY29tbWFzLCB0aGlzIHR5cGUgcmVwcmVzZW50cyBqdXN0IG9uZSBvZiB0aGUgdmFsdWVzLlxuICogQHBhcmFtIHtTdHJpbmdbXX0gcGFydHMgQW4gYXJyYXkgb2YgdmFsdWUgcGFydHMgbWFraW5nIHVwIHRoaXMgdmFsdWUuXG4gKiBAcGFyYW0ge2ludH0gbGluZSBUaGUgbGluZSBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKiBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXG4gKiBAY2xhc3MgUHJvcGVydHlWYWx1ZVxuICogQGV4dGVuZHMgcGFyc2VybGliLnV0aWwuU3ludGF4VW5pdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFByb3BlcnR5VmFsdWUocGFydHMsIGxpbmUsIGNvbCl7XG5cbiAgICBTeW50YXhVbml0LmNhbGwodGhpcywgcGFydHMuam9pbihcIiBcIiksIGxpbmUsIGNvbCwgUGFyc2VyLlBST1BFUlRZX1ZBTFVFX1RZUEUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcnRzIHRoYXQgbWFrZSB1cCB0aGUgc2VsZWN0b3IuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJvcGVydHkgcGFydHNcbiAgICAgKi9cbiAgICB0aGlzLnBhcnRzID0gcGFydHM7XG5cbn1cblxuUHJvcGVydHlWYWx1ZS5wcm90b3R5cGUgPSBuZXcgU3ludGF4VW5pdCgpO1xuUHJvcGVydHlWYWx1ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcm9wZXJ0eVZhbHVlO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0aGF0IGFsbG93cyBmb3IgZWFzeSBpdGVyYXRpb24gb3ZlciB0aGUgdmFyaW91cyBwYXJ0cyBvZiBhXG4gKiBwcm9wZXJ0eSB2YWx1ZS5cbiAqIEBwYXJhbSB7cGFyc2VybGliLmNzcy5Qcm9wZXJ0eVZhbHVlfSB2YWx1ZSBUaGUgcHJvcGVydHkgdmFsdWUgdG8gaXRlcmF0ZSBvdmVyLlxuICogQG5hbWVzcGFjZSBwYXJzZXJsaWIuY3NzXG4gKiBAY2xhc3MgUHJvcGVydHlWYWx1ZUl0ZXJhdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUHJvcGVydHlWYWx1ZUl0ZXJhdG9yKHZhbHVlKXtcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdG9yIHZhbHVlXG4gICAgICogQHR5cGUgaW50XG4gICAgICogQHByb3BlcnR5IF9pXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYXJ0cyB0aGF0IG1ha2UgdXAgdGhlIHZhbHVlLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByb3BlcnR5IF9wYXJ0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcGFydHMgPSB2YWx1ZS5wYXJ0cztcblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIGJvb2ttYXJrcyBhbG9uZyB0aGUgd2F5LlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByb3BlcnR5IF9tYXJrc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWFya3MgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAdHlwZSBwYXJzZXJsaWIuY3NzLlByb3BlcnR5VmFsdWVcbiAgICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgcGFydHMgaW4gdGhlIHZhbHVlLlxuICogQHJldHVybiB7aW50fSBUaGUgdG90YWwgbnVtYmVyIG9mIHBhcnRzIGluIHRoZSB2YWx1ZS5cbiAqIEBtZXRob2QgY291bnRcbiAqL1xuUHJvcGVydHlWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnRzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogSW5kaWNhdGVzIGlmIHRoZSBpdGVyYXRvciBpcyBwb3NpdGlvbmVkIGF0IHRoZSBmaXJzdCBpdGVtLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBwb3NpdGlvbmVkIGF0IGZpcnN0IGl0ZW0sIGZhbHNlIGlmIG5vdC5cbiAqIEBtZXRob2QgaXNGaXJzdFxuICovXG5Qcm9wZXJ0eVZhbHVlSXRlcmF0b3IucHJvdG90eXBlLmlzRmlyc3QgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9pID09PSAwO1xufTtcblxuLyoqXG4gKiBJbmRpY2F0ZXMgaWYgdGhlcmUgYXJlIG1vcmUgcGFydHMgb2YgdGhlIHByb3BlcnR5IHZhbHVlLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGVyZSBhcmUgbW9yZSBwYXJ0cywgZmFsc2UgaWYgbm90LlxuICogQG1ldGhvZCBoYXNOZXh0XG4gKi9cblByb3BlcnR5VmFsdWVJdGVyYXRvci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICh0aGlzLl9pIDwgdGhpcy5fcGFydHMubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogTWFya3MgdGhlIGN1cnJlbnQgc3BvdCBpbiB0aGUgaXRlcmF0aW9uIHNvIGl0IGNhbiBiZSByZXN0b3JlZCB0b1xuICogbGF0ZXIgb24uXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQG1ldGhvZCBtYXJrXG4gKi9cblByb3BlcnR5VmFsdWVJdGVyYXRvci5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fbWFya3MucHVzaCh0aGlzLl9pKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmV4dCBwYXJ0IG9mIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvciBudWxsIGlmIHRoZXJlIGlzIG5vIG5leHRcbiAqIHBhcnQuIERvZXMgbm90IG1vdmUgdGhlIGludGVybmFsIGNvdW50ZXIgZm9yd2FyZC5cbiAqIEByZXR1cm4ge3BhcnNlcmxpYi5jc3MuUHJvcGVydHlWYWx1ZVBhcnR9IFRoZSBuZXh0IHBhcnQgb2YgdGhlIHByb3BlcnR5IHZhbHVlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbmV4dFxuICogcGFydC5cbiAqIEBtZXRob2QgcGVla1xuICovXG5Qcm9wZXJ0eVZhbHVlSXRlcmF0b3IucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihjb3VudCl7XG4gICAgcmV0dXJuIHRoaXMuaGFzTmV4dCgpID8gdGhpcy5fcGFydHNbdGhpcy5faSArIChjb3VudCB8fCAwKV0gOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IHBhcnQgb2YgdGhlIHByb3BlcnR5IHZhbHVlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbmV4dFxuICogcGFydC5cbiAqIEByZXR1cm4ge3BhcnNlcmxpYi5jc3MuUHJvcGVydHlWYWx1ZVBhcnR9IFRoZSBuZXh0IHBhcnQgb2YgdGhlIHByb3BlcnR5IHZhbHVlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbmV4dFxuICogcGFydC5cbiAqIEBtZXRob2QgbmV4dFxuICovXG5Qcm9wZXJ0eVZhbHVlSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmhhc05leHQoKSA/IHRoaXMuX3BhcnRzW3RoaXMuX2krK10gOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcmV2aW91cyBwYXJ0IG9mIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvciBudWxsIGlmIHRoZXJlIGlzIG5vXG4gKiBwcmV2aW91cyBwYXJ0LlxuICogQHJldHVybiB7cGFyc2VybGliLmNzcy5Qcm9wZXJ0eVZhbHVlUGFydH0gVGhlIHByZXZpb3VzIHBhcnQgb2YgdGhlXG4gKiBwcm9wZXJ0eSB2YWx1ZSBvciBudWxsIGlmIHRoZXJlIGlzIG5vIHByZXZpb3VzIHBhcnQuXG4gKiBAbWV0aG9kIHByZXZpb3VzXG4gKi9cblByb3BlcnR5VmFsdWVJdGVyYXRvci5wcm90b3R5cGUucHJldmlvdXMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9pID4gMCA/IHRoaXMuX3BhcnRzWy0tdGhpcy5faV0gOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXN0b3JlcyB0aGUgbGFzdCBzYXZlZCBib29rbWFyay5cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAbWV0aG9kIHJlc3RvcmVcbiAqL1xuUHJvcGVydHlWYWx1ZUl0ZXJhdG9yLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5fbWFya3MubGVuZ3RoKXtcbiAgICAgICAgdGhpcy5faSA9IHRoaXMuX21hcmtzLnBvcCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNpbmdsZSBwYXJ0IG9mIGEgQ1NTIHByb3BlcnR5IHZhbHVlLCBtZWFuaW5nIHRoYXQgaXQgcmVwcmVzZW50c1xuICoganVzdCBvbmUgcGFydCBvZiB0aGUgZGF0YSBiZXR3ZWVuIFwiOlwiIGFuZCBcIjtcIi5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bml0LlxuICogQHBhcmFtIHtpbnR9IGxpbmUgVGhlIGxpbmUgb2YgdGV4dCBvbiB3aGljaCB0aGUgdW5pdCByZXNpZGVzLlxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xuICogQGNsYXNzIFByb3BlcnR5VmFsdWVQYXJ0XG4gKiBAZXh0ZW5kcyBwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUHJvcGVydHlWYWx1ZVBhcnQodGV4dCwgbGluZSwgY29sKXtcblxuICAgIFN5bnRheFVuaXQuY2FsbCh0aGlzLCB0ZXh0LCBsaW5lLCBjb2wsIFBhcnNlci5QUk9QRVJUWV9WQUxVRV9QQVJUX1RZUEUpO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSB0eXBlIG9mIHZhbHVlIHVuaXQuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcInVua25vd25cIjtcblxuICAgIC8vZmlndXJlIG91dCB3aGF0IHR5cGUgb2YgZGF0YSBpdCBpc1xuXG4gICAgdmFyIHRlbXA7XG5cbiAgICAvL2l0IGlzIGEgbWVhc3VyZW1lbnQ/XG4gICAgaWYgKC9eKFsrXFwtXT9bXFxkXFwuXSspKFthLXpdKykkL2kudGVzdCh0ZXh0KSl7ICAvL2RpbWVuc2lvblxuICAgICAgICB0aGlzLnR5cGUgPSBcImRpbWVuc2lvblwiO1xuICAgICAgICB0aGlzLnZhbHVlID0gK1JlZ0V4cC4kMTtcbiAgICAgICAgdGhpcy51bml0cyA9IFJlZ0V4cC4kMjtcblxuICAgICAgICAvL3RyeSB0byBuYXJyb3cgZG93blxuICAgICAgICBzd2l0Y2godGhpcy51bml0cy50b0xvd2VyQ2FzZSgpKXtcblxuICAgICAgICAgICAgY2FzZSBcImVtXCI6XG4gICAgICAgICAgICBjYXNlIFwicmVtXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJweFwiOlxuICAgICAgICAgICAgY2FzZSBcImNtXCI6XG4gICAgICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICAgIGNhc2UgXCJpblwiOlxuICAgICAgICAgICAgY2FzZSBcInB0XCI6XG4gICAgICAgICAgICBjYXNlIFwicGNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjaFwiOlxuICAgICAgICAgICAgY2FzZSBcInZoXCI6XG4gICAgICAgICAgICBjYXNlIFwidndcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ2bWF4XCI6XG4gICAgICAgICAgICBjYXNlIFwidm1pblwiOlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwibGVuZ3RoXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlIFwiZnJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImdyaWRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImRlZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInJhZFwiOlxuICAgICAgICAgICAgY2FzZSBcImdyYWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImFuZ2xlXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJtc1wiOlxuICAgICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcInRpbWVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImh6XCI6XG4gICAgICAgICAgICBjYXNlIFwia2h6XCI6XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJmcmVxdWVuY3lcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImRwaVwiOlxuICAgICAgICAgICAgY2FzZSBcImRwY21cIjpcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcInJlc29sdXRpb25cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy9kZWZhdWx0XG5cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgvXihbK1xcLV0/W1xcZFxcLl0rKSUkL2kudGVzdCh0ZXh0KSl7ICAvL3BlcmNlbnRhZ2VcbiAgICAgICAgdGhpcy50eXBlID0gXCJwZXJjZW50YWdlXCI7XG4gICAgICAgIHRoaXMudmFsdWUgPSArUmVnRXhwLiQxO1xuICAgIH0gZWxzZSBpZiAoL14oWytcXC1dP1xcZCspJC9pLnRlc3QodGV4dCkpeyAgLy9pbnRlZ2VyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiaW50ZWdlclwiO1xuICAgICAgICB0aGlzLnZhbHVlID0gK1JlZ0V4cC4kMTtcbiAgICB9IGVsc2UgaWYgKC9eKFsrXFwtXT9bXFxkXFwuXSspJC9pLnRlc3QodGV4dCkpeyAgLy9udW1iZXJcbiAgICAgICAgdGhpcy50eXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICtSZWdFeHAuJDE7XG5cbiAgICB9IGVsc2UgaWYgKC9eIyhbYS1mMC05XXszLDZ9KS9pLnRlc3QodGV4dCkpeyAgLy9oZXhjb2xvclxuICAgICAgICB0aGlzLnR5cGUgPSBcImNvbG9yXCI7XG4gICAgICAgIHRlbXAgPSBSZWdFeHAuJDE7XG4gICAgICAgIGlmICh0ZW1wLmxlbmd0aCA9PT0gMyl7XG4gICAgICAgICAgICB0aGlzLnJlZCAgICA9IHBhcnNlSW50KHRlbXAuY2hhckF0KDApK3RlbXAuY2hhckF0KDApLDE2KTtcbiAgICAgICAgICAgIHRoaXMuZ3JlZW4gID0gcGFyc2VJbnQodGVtcC5jaGFyQXQoMSkrdGVtcC5jaGFyQXQoMSksMTYpO1xuICAgICAgICAgICAgdGhpcy5ibHVlICAgPSBwYXJzZUludCh0ZW1wLmNoYXJBdCgyKSt0ZW1wLmNoYXJBdCgyKSwxNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZCAgICA9IHBhcnNlSW50KHRlbXAuc3Vic3RyaW5nKDAsMiksMTYpO1xuICAgICAgICAgICAgdGhpcy5ncmVlbiAgPSBwYXJzZUludCh0ZW1wLnN1YnN0cmluZygyLDQpLDE2KTtcbiAgICAgICAgICAgIHRoaXMuYmx1ZSAgID0gcGFyc2VJbnQodGVtcC5zdWJzdHJpbmcoNCw2KSwxNik7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC9ecmdiXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccypcXCkvaS50ZXN0KHRleHQpKXsgLy9yZ2IoKSBjb2xvciB3aXRoIGFic29sdXRlIG51bWJlcnNcbiAgICAgICAgdGhpcy50eXBlICAgPSBcImNvbG9yXCI7XG4gICAgICAgIHRoaXMucmVkICAgID0gK1JlZ0V4cC4kMTtcbiAgICAgICAgdGhpcy5ncmVlbiAgPSArUmVnRXhwLiQyO1xuICAgICAgICB0aGlzLmJsdWUgICA9ICtSZWdFeHAuJDM7XG4gICAgfSBlbHNlIGlmICgvXnJnYlxcKFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihcXGQrKSVcXHMqXFwpL2kudGVzdCh0ZXh0KSl7IC8vcmdiKCkgY29sb3Igd2l0aCBwZXJjZW50YWdlc1xuICAgICAgICB0aGlzLnR5cGUgICA9IFwiY29sb3JcIjtcbiAgICAgICAgdGhpcy5yZWQgICAgPSArUmVnRXhwLiQxICogMjU1IC8gMTAwO1xuICAgICAgICB0aGlzLmdyZWVuICA9ICtSZWdFeHAuJDIgKiAyNTUgLyAxMDA7XG4gICAgICAgIHRoaXMuYmx1ZSAgID0gK1JlZ0V4cC4kMyAqIDI1NSAvIDEwMDtcbiAgICB9IGVsc2UgaWYgKC9ecmdiYVxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooW1xcZFxcLl0rKVxccypcXCkvaS50ZXN0KHRleHQpKXsgLy9yZ2JhKCkgY29sb3Igd2l0aCBhYnNvbHV0ZSBudW1iZXJzXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJjb2xvclwiO1xuICAgICAgICB0aGlzLnJlZCAgICA9ICtSZWdFeHAuJDE7XG4gICAgICAgIHRoaXMuZ3JlZW4gID0gK1JlZ0V4cC4kMjtcbiAgICAgICAgdGhpcy5ibHVlICAgPSArUmVnRXhwLiQzO1xuICAgICAgICB0aGlzLmFscGhhICA9ICtSZWdFeHAuJDQ7XG4gICAgfSBlbHNlIGlmICgvXnJnYmFcXChcXHMqKFxcZCspJVxccyosXFxzKihcXGQrKSVcXHMqLFxccyooXFxkKyklXFxzKixcXHMqKFtcXGRcXC5dKylcXHMqXFwpL2kudGVzdCh0ZXh0KSl7IC8vcmdiYSgpIGNvbG9yIHdpdGggcGVyY2VudGFnZXNcbiAgICAgICAgdGhpcy50eXBlICAgPSBcImNvbG9yXCI7XG4gICAgICAgIHRoaXMucmVkICAgID0gK1JlZ0V4cC4kMSAqIDI1NSAvIDEwMDtcbiAgICAgICAgdGhpcy5ncmVlbiAgPSArUmVnRXhwLiQyICogMjU1IC8gMTAwO1xuICAgICAgICB0aGlzLmJsdWUgICA9ICtSZWdFeHAuJDMgKiAyNTUgLyAxMDA7XG4gICAgICAgIHRoaXMuYWxwaGEgID0gK1JlZ0V4cC4kNDtcbiAgICB9IGVsc2UgaWYgKC9eaHNsXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKSVcXHMqLFxccyooXFxkKyklXFxzKlxcKS9pLnRlc3QodGV4dCkpeyAvL2hzbCgpXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJjb2xvclwiO1xuICAgICAgICB0aGlzLmh1ZSAgICA9ICtSZWdFeHAuJDE7XG4gICAgICAgIHRoaXMuc2F0dXJhdGlvbiA9ICtSZWdFeHAuJDIgLyAxMDA7XG4gICAgICAgIHRoaXMubGlnaHRuZXNzICA9ICtSZWdFeHAuJDMgLyAxMDA7XG4gICAgfSBlbHNlIGlmICgvXmhzbGFcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihcXGQrKSVcXHMqLFxccyooW1xcZFxcLl0rKVxccypcXCkvaS50ZXN0KHRleHQpKXsgLy9oc2xhKCkgY29sb3Igd2l0aCBwZXJjZW50YWdlc1xuICAgICAgICB0aGlzLnR5cGUgICA9IFwiY29sb3JcIjtcbiAgICAgICAgdGhpcy5odWUgICAgPSArUmVnRXhwLiQxO1xuICAgICAgICB0aGlzLnNhdHVyYXRpb24gPSArUmVnRXhwLiQyIC8gMTAwO1xuICAgICAgICB0aGlzLmxpZ2h0bmVzcyAgPSArUmVnRXhwLiQzIC8gMTAwO1xuICAgICAgICB0aGlzLmFscGhhICA9ICtSZWdFeHAuJDQ7XG4gICAgfSBlbHNlIGlmICgvXnVybFxcKFtcIiddPyhbXlxcKVwiJ10rKVtcIiddP1xcKS9pLnRlc3QodGV4dCkpeyAvL1VSSVxuICAgICAgICB0aGlzLnR5cGUgICA9IFwidXJpXCI7XG4gICAgICAgIHRoaXMudXJpICAgID0gUmVnRXhwLiQxO1xuICAgIH0gZWxzZSBpZiAoL14oW15cXChdKylcXCgvaS50ZXN0KHRleHQpKXtcbiAgICAgICAgdGhpcy50eXBlICAgPSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIHRoaXMubmFtZSAgID0gUmVnRXhwLiQxO1xuICAgICAgICB0aGlzLnZhbHVlICA9IHRleHQ7XG4gICAgfSBlbHNlIGlmICgvXlwiKFteXFxuXFxyXFxmXFxcXFwiXXxcXFxcXFxyXFxufFxcXFxbXlxccjAtOWEtZl18XFxcXFswLTlhLWZdezEsNn0oXFxyXFxufFsgXFxuXFxyXFx0XFxmXSk/KSpcIi9pLnRlc3QodGV4dCkpeyAgICAvL2RvdWJsZS1xdW90ZWQgc3RyaW5nXG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJzdHJpbmdcIjtcbiAgICAgICAgdGhpcy52YWx1ZSAgPSBQcm9wZXJ0eVZhbHVlUGFydC5wYXJzZVN0cmluZyh0ZXh0KTtcbiAgICB9IGVsc2UgaWYgKC9eJyhbXlxcblxcclxcZlxcXFwnXXxcXFxcXFxyXFxufFxcXFxbXlxccjAtOWEtZl18XFxcXFswLTlhLWZdezEsNn0oXFxyXFxufFsgXFxuXFxyXFx0XFxmXSk/KSonL2kudGVzdCh0ZXh0KSl7ICAgIC8vc2luZ2xlLXF1b3RlZCBzdHJpbmdcbiAgICAgICAgdGhpcy50eXBlICAgPSBcInN0cmluZ1wiO1xuICAgICAgICB0aGlzLnZhbHVlICA9IFByb3BlcnR5VmFsdWVQYXJ0LnBhcnNlU3RyaW5nKHRleHQpO1xuICAgIH0gZWxzZSBpZiAoQ29sb3JzW3RleHQudG9Mb3dlckNhc2UoKV0peyAgLy9uYW1lZCBjb2xvclxuICAgICAgICB0aGlzLnR5cGUgICA9IFwiY29sb3JcIjtcbiAgICAgICAgdGVtcCAgICAgICAgPSBDb2xvcnNbdGV4dC50b0xvd2VyQ2FzZSgpXS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIHRoaXMucmVkICAgID0gcGFyc2VJbnQodGVtcC5zdWJzdHJpbmcoMCwyKSwxNik7XG4gICAgICAgIHRoaXMuZ3JlZW4gID0gcGFyc2VJbnQodGVtcC5zdWJzdHJpbmcoMiw0KSwxNik7XG4gICAgICAgIHRoaXMuYmx1ZSAgID0gcGFyc2VJbnQodGVtcC5zdWJzdHJpbmcoNCw2KSwxNik7XG4gICAgfSBlbHNlIGlmICgvXltcXCxcXC9dJC8udGVzdCh0ZXh0KSl7XG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJvcGVyYXRvclwiO1xuICAgICAgICB0aGlzLnZhbHVlICA9IHRleHQ7XG4gICAgfSBlbHNlIGlmICgvXlthLXpcXC1fXFx1MDA4MC1cXHVGRkZGXVthLXowLTlcXC1fXFx1MDA4MC1cXHVGRkZGXSokL2kudGVzdCh0ZXh0KSl7XG4gICAgICAgIHRoaXMudHlwZSAgID0gXCJpZGVudGlmaWVyXCI7XG4gICAgICAgIHRoaXMudmFsdWUgID0gdGV4dDtcbiAgICB9XG5cbn1cblxuUHJvcGVydHlWYWx1ZVBhcnQucHJvdG90eXBlID0gbmV3IFN5bnRheFVuaXQoKTtcblByb3BlcnR5VmFsdWVQYXJ0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByb3BlcnR5VmFsdWVQYXJ0O1xuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gcGFyc2UgYSBDU1Mgc3RyaW5nLlxuICovXG5Qcm9wZXJ0eVZhbHVlUGFydC5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHN0ciA9IHN0ci5zbGljZSgxLCAtMSk7IC8vIFN0cmlwIHN1cnJvdW5kaW5nIHNpbmdsZS9kb3VibGUgcXVvdGVzXG4gICAgdmFyIHJlcGxhY2VyID0gZnVuY3Rpb24obWF0Y2gsIGVzYykge1xuICAgICAgICBpZiAoL14oXFxufFxcclxcbnxcXHJ8XFxmKSQvLnRlc3QoZXNjKSkgeyByZXR1cm4gJyc7IH1cbiAgICAgICAgdmFyIG0gPSAvXlswLTlhLWZdezEsNn0vaS5leGVjKGVzYyk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gcGFyc2VJbnQobVswXSwgMTYpO1xuICAgICAgICAgICAgaWYgKFN0cmluZy5mcm9tQ29kZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFhYWCBObyBzdXBwb3J0IGZvciBzdXJyb2dhdGVzIG9uIG9sZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXNjO1xuICAgIH07XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxcKFxcclxcbnxbXlxccjAtOWEtZl18WzAtOWEtZl17MSw2fShcXHJcXG58WyBcXG5cXHJcXHRcXGZdKT8pL2lnLFxuICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlcik7XG59O1xuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gc2VyaWFsaXplIGEgQ1NTIHN0cmluZy5cbiAqL1xuUHJvcGVydHlWYWx1ZVBhcnQuc2VyaWFsaXplU3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVwbGFjZXIgPSBmdW5jdGlvbihtYXRjaCwgYykge1xuICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgYztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3AgPSBTdHJpbmcuY29kZVBvaW50QXQgPyBTdHJpbmcuY29kZVBvaW50QXQoMCkgOlxuICAgICAgICAgICAgLy8gV2Ugb25seSBlc2NhcGUgbm9uLXN1cnJvZ2F0ZSBjaGFycywgc28gdXNpbmcgY2hhckNvZGVBdFxuICAgICAgICAgICAgLy8gaXMgaGFybWxlc3MgaGVyZS5cbiAgICAgICAgICAgIFN0cmluZy5jaGFyQ29kZUF0KDApO1xuICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyBjcC50b1N0cmluZygxNikgKyBcIiBcIjtcbiAgICB9O1xuICAgIHJldHVybiAnXCInICsgdmFsdWUucmVwbGFjZSgvW1wiXFxyXFxuXFxmXS9nLCByZXBsYWNlcikgKyAnXCInO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3ludGF4IHVuaXQgYmFzZWQgc29sZWx5IG9uIHRoZSBnaXZlbiB0b2tlbi5cbiAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBuZXcgc3ludGF4IHVuaXQgd2hlblxuICogaXQgcmVwcmVzZW50cyBhIHNpbmdsZSB0b2tlbiBpbnN0ZWFkIG9mIG11bHRpcGxlLlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuIFRoZSB0b2tlbiBvYmplY3QgdG8gcmVwcmVzZW50LlxuICogQHJldHVybiB7cGFyc2VybGliLmNzcy5Qcm9wZXJ0eVZhbHVlUGFydH0gVGhlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHRva2VuLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tVG9rZW5cbiAqL1xuUHJvcGVydHlWYWx1ZVBhcnQuZnJvbVRva2VuID0gZnVuY3Rpb24odG9rZW4pe1xuICAgIHJldHVybiBuZXcgUHJvcGVydHlWYWx1ZVBhcnQodG9rZW4udmFsdWUsIHRva2VuLnN0YXJ0TGluZSwgdG9rZW4uc3RhcnRDb2wpO1xufTtcbnZhciBQc2V1ZG9zID0ge1xuICAgIF9fcHJvdG9fXzogICAgICAgbnVsbCxcbiAgICBcIjpmaXJzdC1sZXR0ZXJcIjogMSxcbiAgICBcIjpmaXJzdC1saW5lXCI6ICAgMSxcbiAgICBcIjpiZWZvcmVcIjogICAgICAgMSxcbiAgICBcIjphZnRlclwiOiAgICAgICAgMVxufTtcblxuUHNldWRvcy5FTEVNRU5UID0gMTtcblBzZXVkb3MuQ0xBU1MgPSAyO1xuXG5Qc2V1ZG9zLmlzRWxlbWVudCA9IGZ1bmN0aW9uKHBzZXVkbyl7XG4gICAgcmV0dXJuIHBzZXVkby5pbmRleE9mKFwiOjpcIikgPT09IDAgfHwgUHNldWRvc1twc2V1ZG8udG9Mb3dlckNhc2UoKV0gPT09IFBzZXVkb3MuRUxFTUVOVDtcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZW50aXJlIHNpbmdsZSBzZWxlY3RvciwgaW5jbHVkaW5nIGFsbCBwYXJ0cyBidXQgbm90XG4gKiBpbmNsdWRpbmcgbXVsdGlwbGUgc2VsZWN0b3JzICh0aG9zZSBzZXBhcmF0ZWQgYnkgY29tbWFzKS5cbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xuICogQGNsYXNzIFNlbGVjdG9yXG4gKiBAZXh0ZW5kcyBwYXJzZXJsaWIudXRpbC5TeW50YXhVbml0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcnRzIEFycmF5IG9mIHNlbGVjdG9ycyBwYXJ0cyBtYWtpbmcgdXAgdGhpcyBzZWxlY3Rvci5cbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKi9cbmZ1bmN0aW9uIFNlbGVjdG9yKHBhcnRzLCBsaW5lLCBjb2wpe1xuXG4gICAgU3ludGF4VW5pdC5jYWxsKHRoaXMsIHBhcnRzLmpvaW4oXCIgXCIpLCBsaW5lLCBjb2wsIFBhcnNlci5TRUxFQ1RPUl9UWVBFKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwYXJ0cyB0aGF0IG1ha2UgdXAgdGhlIHNlbGVjdG9yLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByb3BlcnR5IHBhcnRzXG4gICAgICovXG4gICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNwZWNpZmljaXR5IG9mIHRoZSBzZWxlY3Rvci5cbiAgICAgKiBAdHlwZSBwYXJzZXJsaWIuY3NzLlNwZWNpZmljaXR5XG4gICAgICogQHByb3BlcnR5IHNwZWNpZmljaXR5XG4gICAgICovXG4gICAgdGhpcy5zcGVjaWZpY2l0eSA9IFNwZWNpZmljaXR5LmNhbGN1bGF0ZSh0aGlzKTtcblxufVxuXG5TZWxlY3Rvci5wcm90b3R5cGUgPSBuZXcgU3ludGF4VW5pdCgpO1xuU2VsZWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2VsZWN0b3I7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNpbmdsZSBwYXJ0IG9mIGEgc2VsZWN0b3Igc3RyaW5nLCBtZWFuaW5nIGEgc2luZ2xlIHNldCBvZlxuICogZWxlbWVudCBuYW1lIGFuZCBtb2RpZmllcnMuIFRoaXMgZG9lcyBub3QgaW5jbHVkZSBjb21iaW5hdG9ycyBzdWNoIGFzXG4gKiBzcGFjZXMsICssID4sIGV0Yy5cbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xuICogQGNsYXNzIFNlbGVjdG9yUGFydFxuICogQGV4dGVuZHMgcGFyc2VybGliLnV0aWwuU3ludGF4VW5pdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gZWxlbWVudE5hbWUgVGhlIGVsZW1lbnQgbmFtZSBpbiB0aGUgc2VsZWN0b3Igb3IgbnVsbFxuICogICAgICBpZiB0aGVyZSBpcyBubyBlbGVtZW50IG5hbWUuXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgQXJyYXkgb2YgaW5kaXZpZHVhbCBtb2RpZmllcnMgZm9yIHRoZSBlbGVtZW50LlxuICogICAgICBNYXkgYmUgZW1wdHkgaWYgdGhlcmUgYXJlIG5vbmUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKi9cbmZ1bmN0aW9uIFNlbGVjdG9yUGFydChlbGVtZW50TmFtZSwgbW9kaWZpZXJzLCB0ZXh0LCBsaW5lLCBjb2wpe1xuXG4gICAgU3ludGF4VW5pdC5jYWxsKHRoaXMsIHRleHQsIGxpbmUsIGNvbCwgUGFyc2VyLlNFTEVDVE9SX1BBUlRfVFlQRSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFnIG5hbWUgb2YgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhpcyBwYXJ0XG4gICAgICogb2YgdGhlIHNlbGVjdG9yIGFmZmVjdHMuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHByb3BlcnR5IGVsZW1lbnROYW1lXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcnRzIHRoYXQgY29tZSBhZnRlciB0aGUgZWxlbWVudCBuYW1lLCBzdWNoIGFzIGNsYXNzIG5hbWVzLCBJRHMsXG4gICAgICogcHNldWRvIGNsYXNzZXMvZWxlbWVudHMsIGV0Yy5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBwcm9wZXJ0eSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxufVxuXG5TZWxlY3RvclBhcnQucHJvdG90eXBlID0gbmV3IFN5bnRheFVuaXQoKTtcblNlbGVjdG9yUGFydC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZWxlY3RvclBhcnQ7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNlbGVjdG9yIG1vZGlmaWVyIHN0cmluZywgbWVhbmluZyBhIGNsYXNzIG5hbWUsIGVsZW1lbnQgbmFtZSxcbiAqIGVsZW1lbnQgSUQsIHBzZXVkbyBydWxlLCBldGMuXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi5jc3NcbiAqIEBjbGFzcyBTZWxlY3RvclN1YlBhcnRcbiAqIEBleHRlbmRzIHBhcnNlcmxpYi51dGlsLlN5bnRheFVuaXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBzZWxlY3RvciBtb2RpZmllci5cbiAqIEBwYXJhbSB7aW50fSBsaW5lIFRoZSBsaW5lIG9mIHRleHQgb24gd2hpY2ggdGhlIHVuaXQgcmVzaWRlcy5cbiAqIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBvZiB0ZXh0IG9uIHdoaWNoIHRoZSB1bml0IHJlc2lkZXMuXG4gKi9cbmZ1bmN0aW9uIFNlbGVjdG9yU3ViUGFydCh0ZXh0LCB0eXBlLCBsaW5lLCBjb2wpe1xuXG4gICAgU3ludGF4VW5pdC5jYWxsKHRoaXMsIHRleHQsIGxpbmUsIGNvbCwgUGFyc2VyLlNFTEVDVE9SX1NVQl9QQVJUX1RZUEUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgbW9kaWZpZXIuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogU29tZSBzdWJwYXJ0cyBoYXZlIGFyZ3VtZW50cywgdGhpcyByZXByZXNlbnRzIHRoZW0uXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJvcGVydHkgYXJnc1xuICAgICAqL1xuICAgIHRoaXMuYXJncyA9IFtdO1xuXG59XG5cblNlbGVjdG9yU3ViUGFydC5wcm90b3R5cGUgPSBuZXcgU3ludGF4VW5pdCgpO1xuU2VsZWN0b3JTdWJQYXJ0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlbGVjdG9yU3ViUGFydDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2VsZWN0b3IncyBzcGVjaWZpY2l0eS5cbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xuICogQGNsYXNzIFNwZWNpZmljaXR5XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7aW50fSBhIFNob3VsZCBiZSAxIGZvciBpbmxpbmUgc3R5bGVzLCB6ZXJvIGZvciBzdHlsZXNoZWV0IHN0eWxlc1xuICogQHBhcmFtIHtpbnR9IGIgTnVtYmVyIG9mIElEIHNlbGVjdG9yc1xuICogQHBhcmFtIHtpbnR9IGMgTnVtYmVyIG9mIGNsYXNzZXMgYW5kIHBzZXVkbyBjbGFzc2VzXG4gKiBAcGFyYW0ge2ludH0gZCBOdW1iZXIgb2YgZWxlbWVudCBuYW1lcyBhbmQgcHNldWRvIGVsZW1lbnRzXG4gKi9cbmZ1bmN0aW9uIFNwZWNpZmljaXR5KGEsIGIsIGMsIGQpe1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmMgPSBjO1xuICAgIHRoaXMuZCA9IGQ7XG59XG5cblNwZWNpZmljaXR5LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogU3BlY2lmaWNpdHksXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHRoaXMgc3BlY2lmaWNpdHkgdG8gYW5vdGhlci5cbiAgICAgKiBAcGFyYW0ge1NwZWNpZmljaXR5fSBvdGhlciBUaGUgb3RoZXIgc3BlY2lmaWNpdHkgdG8gY29tcGFyZSB0by5cbiAgICAgKiBAcmV0dXJuIHtpbnR9IC0xIGlmIHRoZSBvdGhlciBzcGVjaWZpY2l0eSBpcyBsYXJnZXIsIDEgaWYgc21hbGxlciwgMCBpZiBlcXVhbC5cbiAgICAgKiBAbWV0aG9kIGNvbXBhcmVcbiAgICAgKi9cbiAgICBjb21wYXJlOiBmdW5jdGlvbihvdGhlcil7XG4gICAgICAgIHZhciBjb21wcyA9IFtcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIl0sXG4gICAgICAgICAgICBpLCBsZW47XG5cbiAgICAgICAgZm9yIChpPTAsIGxlbj1jb21wcy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICBpZiAodGhpc1tjb21wc1tpXV0gPCBvdGhlcltjb21wc1tpXV0pe1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpc1tjb21wc1tpXV0gPiBvdGhlcltjb21wc1tpXV0pe1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBudW1lcmljIHZhbHVlIGZvciB0aGUgc3BlY2lmaWNpdHkuXG4gICAgICogQHJldHVybiB7aW50fSBUaGUgbnVtZXJpYyB2YWx1ZSBmb3IgdGhlIHNwZWNpZmljaXR5LlxuICAgICAqIEBtZXRob2QgdmFsdWVPZlxuICAgICAqL1xuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiAodGhpcy5hICogMTAwMCkgKyAodGhpcy5iICogMTAwKSArICh0aGlzLmMgKiAxMCkgKyB0aGlzLmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIHNwZWNpZmljaXR5LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBzcGVjaWZpY2l0eS5cbiAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmEgKyBcIixcIiArIHRoaXMuYiArIFwiLFwiICsgdGhpcy5jICsgXCIsXCIgKyB0aGlzLmQ7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNwZWNpZmljaXR5IG9mIHRoZSBnaXZlbiBzZWxlY3Rvci5cbiAqIEBwYXJhbSB7cGFyc2VybGliLmNzcy5TZWxlY3Rvcn0gVGhlIHNlbGVjdG9yIHRvIGNhbGN1bGF0ZSBzcGVjaWZpY2l0eSBmb3IuXG4gKiBAcmV0dXJuIHtwYXJzZXJsaWIuY3NzLlNwZWNpZmljaXR5fSBUaGUgc3BlY2lmaWNpdHkgb2YgdGhlIHNlbGVjdG9yLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjYWxjdWxhdGVcbiAqL1xuU3BlY2lmaWNpdHkuY2FsY3VsYXRlID0gZnVuY3Rpb24oc2VsZWN0b3Ipe1xuXG4gICAgdmFyIGksIGxlbixcbiAgICAgICAgcGFydCxcbiAgICAgICAgYj0wLCBjPTAsIGQ9MDtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlcyhwYXJ0KXtcblxuICAgICAgICB2YXIgaSwgaiwgbGVuLCBudW0sXG4gICAgICAgICAgICBlbGVtZW50TmFtZSA9IHBhcnQuZWxlbWVudE5hbWUgPyBwYXJ0LmVsZW1lbnROYW1lLnRleHQgOiBcIlwiLFxuICAgICAgICAgICAgbW9kaWZpZXI7XG5cbiAgICAgICAgaWYgKGVsZW1lbnROYW1lICYmIGVsZW1lbnROYW1lLmNoYXJBdChlbGVtZW50TmFtZS5sZW5ndGgtMSkgIT09IFwiKlwiKSB7XG4gICAgICAgICAgICBkKys7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGk9MCwgbGVuPXBhcnQubW9kaWZpZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgIG1vZGlmaWVyID0gcGFydC5tb2RpZmllcnNbaV07XG4gICAgICAgICAgICBzd2l0Y2gobW9kaWZpZXIudHlwZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImF0dHJpYnV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICBjKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgICAgICAgICAgIGIrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwicHNldWRvXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChQc2V1ZG9zLmlzRWxlbWVudChtb2RpZmllci50ZXh0KSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBkKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwibm90XCI6XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaj0wLCBudW09bW9kaWZpZXIuYXJncy5sZW5ndGg7IGogPCBudW07IGorKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZXMobW9kaWZpZXIuYXJnc1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGk9MCwgbGVuPXNlbGVjdG9yLnBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgcGFydCA9IHNlbGVjdG9yLnBhcnRzW2ldO1xuXG4gICAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgU2VsZWN0b3JQYXJ0KXtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlcyhwYXJ0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3BlY2lmaWNpdHkoMCwgYiwgYywgZCk7XG59O1xuXG52YXIgaCA9IC9eWzAtOWEtZkEtRl0kLyxcbiAgICAvL25vbmFzY2lpID0gL15bXFx1MDA4MC1cXHVGRkZGXSQvLFxuICAgIG5sID0gL1xcbnxcXHJcXG58XFxyfFxcZi87XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEhlbHBlciBmdW5jdGlvbnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5mdW5jdGlvbiBpc0hleERpZ2l0KGMpe1xuICAgIHJldHVybiBjICE9PSBudWxsICYmIGgudGVzdChjKTtcbn1cblxuZnVuY3Rpb24gaXNEaWdpdChjKXtcbiAgICByZXR1cm4gYyAhPT0gbnVsbCAmJiAvXFxkLy50ZXN0KGMpO1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoYyl7XG4gICAgcmV0dXJuIGMgIT09IG51bGwgJiYgL1xccy8udGVzdChjKTtcbn1cblxuZnVuY3Rpb24gaXNOZXdMaW5lKGMpe1xuICAgIHJldHVybiBjICE9PSBudWxsICYmIG5sLnRlc3QoYyk7XG59XG5cbmZ1bmN0aW9uIGlzTmFtZVN0YXJ0KGMpe1xuICAgIHJldHVybiBjICE9PSBudWxsICYmICgvW2Etel9cXHUwMDgwLVxcdUZGRkZcXFxcXS9pLnRlc3QoYykpO1xufVxuXG5mdW5jdGlvbiBpc05hbWVDaGFyKGMpe1xuICAgIHJldHVybiBjICE9PSBudWxsICYmIChpc05hbWVTdGFydChjKSB8fCAvWzAtOVxcLVxcXFxdLy50ZXN0KGMpKTtcbn1cblxuZnVuY3Rpb24gaXNJZGVudFN0YXJ0KGMpe1xuICAgIHJldHVybiBjICE9PSBudWxsICYmIChpc05hbWVTdGFydChjKSB8fCAvXFwtXFxcXC8udGVzdChjKSk7XG59XG5cbmZ1bmN0aW9uIG1peChyZWNlaXZlciwgc3VwcGxpZXIpe1xuXHRmb3IgKHZhciBwcm9wIGluIHN1cHBsaWVyKXtcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN1cHBsaWVyLCBwcm9wKSl7XG5cdFx0XHRyZWNlaXZlcltwcm9wXSA9IHN1cHBsaWVyW3Byb3BdO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVjZWl2ZXI7XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENTUyBUb2tlbiBTdHJlYW1cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vKipcbiAqIEEgdG9rZW4gc3RyZWFtIHRoYXQgcHJvZHVjZXMgQ1NTIHRva2Vucy5cbiAqIEBwYXJhbSB7U3RyaW5nfFJlYWRlcn0gaW5wdXQgVGhlIHNvdXJjZSBvZiB0ZXh0IHRvIHRva2VuaXplLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAY2xhc3MgVG9rZW5TdHJlYW1cbiAqIEBuYW1lc3BhY2UgcGFyc2VybGliLmNzc1xuICovXG5mdW5jdGlvbiBUb2tlblN0cmVhbShpbnB1dCl7XG5cdFRva2VuU3RyZWFtQmFzZS5jYWxsKHRoaXMsIGlucHV0LCBUb2tlbnMpO1xufVxuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUgPSBtaXgobmV3IFRva2VuU3RyZWFtQmFzZSgpLCB7XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIFRva2VuU3RyZWFtQmFzZSBtZXRob2Qgb2YgdGhlIHNhbWUgbmFtZVxuICAgICAqIHRvIHByb2R1Y2UgQ1NTIHRva2Vucy5cbiAgICAgKiBAcGFyYW0ge3ZhcmlhbnR9IGNoYW5uZWwgVGhlIG5hbWUgb2YgdGhlIGNoYW5uZWwgdG8gdXNlXG4gICAgICogICAgICBmb3IgdGhlIG5leHQgdG9rZW4uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5leHQgdG9rZW4uXG4gICAgICogQG1ldGhvZCBfZ2V0VG9rZW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRUb2tlbjogZnVuY3Rpb24oY2hhbm5lbCl7XG5cbiAgICAgICAgdmFyIGMsXG4gICAgICAgICAgICByZWFkZXIgPSB0aGlzLl9yZWFkZXIsXG4gICAgICAgICAgICB0b2tlbiAgID0gbnVsbCxcbiAgICAgICAgICAgIHN0YXJ0TGluZSAgID0gcmVhZGVyLmdldExpbmUoKSxcbiAgICAgICAgICAgIHN0YXJ0Q29sICAgID0gcmVhZGVyLmdldENvbCgpO1xuXG4gICAgICAgIGMgPSByZWFkZXIucmVhZCgpO1xuXG5cbiAgICAgICAgd2hpbGUoYyl7XG4gICAgICAgICAgICBzd2l0Y2goYyl7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XG4gICAgICAgICAgICAgICAgICogLSBDT01NRU5UXG4gICAgICAgICAgICAgICAgICogLSBTTEFTSFxuICAgICAgICAgICAgICAgICAqIC0gQ0hBUlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgXCIvXCI6XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocmVhZGVyLnBlZWsoKSA9PT0gXCIqXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNvbW1lbnRUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5jaGFyVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XG4gICAgICAgICAgICAgICAgICogLSBEQVNITUFUQ0hcbiAgICAgICAgICAgICAgICAgKiAtIElOQ0xVREVTXG4gICAgICAgICAgICAgICAgICogLSBQUkVGSVhNQVRDSFxuICAgICAgICAgICAgICAgICAqIC0gU1VGRklYTUFUQ0hcbiAgICAgICAgICAgICAgICAgKiAtIFNVQlNUUklOR01BVENIXG4gICAgICAgICAgICAgICAgICogLSBDSEFSXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FzZSBcInxcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiflwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJeXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgICAgICBpZihyZWFkZXIucGVlaygpID09PSBcIj1cIil7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuY29tcGFyaXNvblRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNoYXJUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgKiAtIFNUUklOR1xuICAgICAgICAgICAgICAgICAqIC0gSU5WQUxJRFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFwiXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnN0cmluZ1Rva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgKiAtIEhBU0hcbiAgICAgICAgICAgICAgICAgKiAtIENIQVJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlIFwiI1wiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYW1lQ2hhcihyZWFkZXIucGVlaygpKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuaGFzaFRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNoYXJUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgKiAtIERPVFxuICAgICAgICAgICAgICAgICAqIC0gTlVNQkVSXG4gICAgICAgICAgICAgICAgICogLSBESU1FTlNJT05cbiAgICAgICAgICAgICAgICAgKiAtIFBFUkNFTlRBR0VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEaWdpdChyZWFkZXIucGVlaygpKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubnVtYmVyVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuY2hhclRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBQb3RlbnRpYWwgdG9rZW5zOlxuICAgICAgICAgICAgICAgICAqIC0gQ0RDXG4gICAgICAgICAgICAgICAgICogLSBNSU5VU1xuICAgICAgICAgICAgICAgICAqIC0gTlVNQkVSXG4gICAgICAgICAgICAgICAgICogLSBESU1FTlNJT05cbiAgICAgICAgICAgICAgICAgKiAtIFBFUkNFTlRBR0VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZGVyLnBlZWsoKSA9PT0gXCItXCIpeyAgLy9jb3VsZCBiZSBjbG9zaW5nIEhUTUwtc3R5bGUgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmh0bWxDb21tZW50RW5kVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYW1lU3RhcnQocmVhZGVyLnBlZWsoKSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmlkZW50T3JGdW5jdGlvblRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNoYXJUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgKiAtIElNUE9SVEFOVF9TWU1cbiAgICAgICAgICAgICAgICAgKiAtIENIQVJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlIFwiIVwiOlxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuaW1wb3J0YW50VG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBBbnkgYXQta2V5d29yZCBvciBDSEFSXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FzZSBcIkBcIjpcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmF0UnVsZVRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgKiAtIE5PVFxuICAgICAgICAgICAgICAgICAqIC0gQ0hBUlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgXCI6XCI6XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5ub3RUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XG4gICAgICAgICAgICAgICAgICogLSBDRE9cbiAgICAgICAgICAgICAgICAgKiAtIENIQVJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuaHRtbENvbW1lbnRTdGFydFRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgKiAtIFVOSUNPREVfUkFOR0VcbiAgICAgICAgICAgICAgICAgKiAtIFVSTFxuICAgICAgICAgICAgICAgICAqIC0gQ0hBUlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhc2UgXCJVXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRlci5wZWVrKCkgPT09IFwiK1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy51bmljb2RlUmFuZ2VUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XG4gICAgICAgICAgICAgICAgICAgICAqIC0gTlVNQkVSXG4gICAgICAgICAgICAgICAgICAgICAqIC0gRElNRU5TSU9OXG4gICAgICAgICAgICAgICAgICAgICAqIC0gTEVOR1RIXG4gICAgICAgICAgICAgICAgICAgICAqIC0gRlJFUVxuICAgICAgICAgICAgICAgICAgICAgKiAtIFRJTUVcbiAgICAgICAgICAgICAgICAgICAgICogLSBFTVNcbiAgICAgICAgICAgICAgICAgICAgICogLSBFWFNcbiAgICAgICAgICAgICAgICAgICAgICogLSBBTkdMRVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGlnaXQoYykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm51bWJlclRva2VuKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcblxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBQb3RlbnRpYWwgdG9rZW5zOlxuICAgICAgICAgICAgICAgICAgICAgKiAtIFNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLndoaXRlc3BhY2VUb2tlbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG5cbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogUG90ZW50aWFsIHRva2VuczpcbiAgICAgICAgICAgICAgICAgICAgICogLSBJREVOVFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSWRlbnRTdGFydChjKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuaWRlbnRPckZ1bmN0aW9uVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIFBvdGVudGlhbCB0b2tlbnM6XG4gICAgICAgICAgICAgICAgICAgICAqIC0gQ0hBUlxuICAgICAgICAgICAgICAgICAgICAgKiAtIFBMVVNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5jaGFyVG9rZW4oYywgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG5cblxuXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9tYWtlIHN1cmUgdGhpcyB0b2tlbiBpcyB3YW50ZWRcbiAgICAgICAgICAgIC8vVE9ETzogY2hlY2sgY2hhbm5lbFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRva2VuICYmIGMgPT09IG51bGwpe1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNyZWF0ZVRva2VuKFRva2Vucy5FT0YsbnVsbCxzdGFydExpbmUsc3RhcnRDb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBNZXRob2RzIHRvIGNyZWF0ZSB0b2tlbnNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgdG9rZW4gYmFzZWQgb24gYXZhaWxhYmxlIGRhdGEgYW5kIHRoZSBjdXJyZW50XG4gICAgICogcmVhZGVyIHBvc2l0aW9uIGluZm9ybWF0aW9uLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgb3RoZXJcbiAgICAgKiBwcml2YXRlIG1ldGhvZHMgdG8gY3JlYXRlIHRva2VucyBhbmQgaXMgbmV2ZXIgY2FsbGVkIGRpcmVjdGx5LlxuICAgICAqIEBwYXJhbSB7aW50fSB0dCBUaGUgdG9rZW4gdHlwZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHRleHQgdmFsdWUgb2YgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAoT3B0aW9uYWwpIFNwZWNpZmllcyBhIGNoYW5uZWwgcHJvcGVydHlcbiAgICAgKiAgICAgIHRvIGluZGljYXRlIHRoYXQgYSBkaWZmZXJlbnQgY2hhbm5lbCBzaG91bGQgYmUgc2Nhbm5lZFxuICAgICAqICAgICAgYW5kL29yIGEgaGlkZSBwcm9wZXJ0eSBpbmRpY2F0aW5nIHRoYXQgdGhlIHRva2VuIHNob3VsZFxuICAgICAqICAgICAgYmUgaGlkZGVuLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjcmVhdGVUb2tlblxuICAgICAqL1xuICAgIGNyZWF0ZVRva2VuOiBmdW5jdGlvbih0dCwgdmFsdWUsIHN0YXJ0TGluZSwgc3RhcnRDb2wsIG9wdGlvbnMpe1xuICAgICAgICB2YXIgcmVhZGVyID0gdGhpcy5fcmVhZGVyO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6ICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0eXBlOiAgICAgICB0dCxcbiAgICAgICAgICAgIGNoYW5uZWw6ICAgIG9wdGlvbnMuY2hhbm5lbCxcbiAgICAgICAgICAgIGVuZENoYXI6ICAgIG9wdGlvbnMuZW5kQ2hhcixcbiAgICAgICAgICAgIGhpZGU6ICAgICAgIG9wdGlvbnMuaGlkZSB8fCBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0TGluZTogIHN0YXJ0TGluZSxcbiAgICAgICAgICAgIHN0YXJ0Q29sOiAgIHN0YXJ0Q29sLFxuICAgICAgICAgICAgZW5kTGluZTogICAgcmVhZGVyLmdldExpbmUoKSxcbiAgICAgICAgICAgIGVuZENvbDogICAgIHJlYWRlci5nZXRDb2woKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBNZXRob2RzIHRvIGNyZWF0ZSBzcGVjaWZpYyB0b2tlbnNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgdG9rZW4gZm9yIGFueSBhdC1ydWxlLiBJZiB0aGUgYXQtcnVsZSBpcyB1bmtub3duLCB0aGVuXG4gICAgICogdGhlIHRva2VuIGlzIGZvciBhIHNpbmdsZSBcIkBcIiBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0IFRoZSBmaXJzdCBjaGFyYWN0ZXIgZm9yIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRDb2wgVGhlIGJlZ2lubmluZyBjb2x1bW4gZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGF0UnVsZVRva2VuXG4gICAgICovXG4gICAgYXRSdWxlVG9rZW46IGZ1bmN0aW9uKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcbiAgICAgICAgdmFyIHJ1bGUgICAgPSBmaXJzdCxcbiAgICAgICAgICAgIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXG4gICAgICAgICAgICB0dCAgICAgID0gVG9rZW5zLkNIQVIsXG4gICAgICAgICAgICBpZGVudDtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBGaXJzdCwgbWFyayB3aGVyZSB3ZSBhcmUuIFRoZXJlIGFyZSBvbmx5IGZvdXIgQCBydWxlcyxcbiAgICAgICAgICogc28gYW55dGhpbmcgZWxzZSBpcyByZWFsbHkganVzdCBhbiBpbnZhbGlkIHRva2VuLlxuICAgICAgICAgKiBCYXNpY2FsbHksIGlmIHRoaXMgZG9lc24ndCBtYXRjaCBvbmUgb2YgdGhlIGtub3duIEBcbiAgICAgICAgICogcnVsZXMsIGp1c3QgcmV0dXJuICdAJyBhcyBhbiB1bmtub3duIHRva2VuIGFuZCBhbGxvd1xuICAgICAgICAgKiBwYXJzaW5nIHRvIGNvbnRpbnVlIGFmdGVyIHRoYXQgcG9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICByZWFkZXIubWFyaygpO1xuXG4gICAgICAgIC8vdHJ5IHRvIGZpbmQgdGhlIGF0LWtleXdvcmRcbiAgICAgICAgaWRlbnQgPSB0aGlzLnJlYWROYW1lKCk7XG4gICAgICAgIHJ1bGUgPSBmaXJzdCArIGlkZW50O1xuICAgICAgICB0dCA9IFRva2Vucy50eXBlKHJ1bGUudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgLy9pZiBpdCdzIG5vdCB2YWxpZCwgdXNlIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb25seSBhbmQgcmVzZXQgdGhlIHJlYWRlclxuICAgICAgICBpZiAodHQgPT09IFRva2Vucy5DSEFSIHx8IHR0ID09PSBUb2tlbnMuVU5LTk9XTil7XG4gICAgICAgICAgICBpZiAocnVsZS5sZW5ndGggPiAxKXtcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5VTktOT1dOX1NZTTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuQ0hBUjtcbiAgICAgICAgICAgICAgICBydWxlID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbih0dCwgcnVsZSwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgY2hhcmFjdGVyIHRva2VuIGJhc2VkIG9uIHRoZSBnaXZlbiBjaGFyYWN0ZXJcbiAgICAgKiBhbmQgbG9jYXRpb24gaW4gdGhlIHN0cmVhbS4gSWYgdGhlcmUncyBhIHNwZWNpYWwgKG5vbi1zdGFuZGFyZClcbiAgICAgKiB0b2tlbiBuYW1lLCB0aGlzIGlzIHVzZWQ7IG90aGVyd2lzZSBDSEFSIGlzIHVzZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGMgVGhlIGNoYXJhY3RlciBmb3IgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgdG9rZW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY2hhclRva2VuXG4gICAgICovXG4gICAgY2hhclRva2VuOiBmdW5jdGlvbihjLCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcbiAgICAgICAgdmFyIHR0ID0gVG9rZW5zLnR5cGUoYyk7XG4gICAgICAgIHZhciBvcHRzID0ge307XG5cbiAgICAgICAgaWYgKHR0ID09PSAtMSl7XG4gICAgICAgICAgICB0dCA9IFRva2Vucy5DSEFSO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5lbmRDaGFyID0gVG9rZW5zW3R0XS5lbmRDaGFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odHQsIGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wsIG9wdHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIGNoYXJhY3RlciB0b2tlbiBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2hhcmFjdGVyXG4gICAgICogYW5kIGxvY2F0aW9uIGluIHRoZSBzdHJlYW0uIElmIHRoZXJlJ3MgYSBzcGVjaWFsIChub24tc3RhbmRhcmQpXG4gICAgICogdG9rZW4gbmFtZSwgdGhpcyBpcyB1c2VkOyBvdGhlcndpc2UgQ0hBUiBpcyB1c2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGZvciB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjb21tZW50VG9rZW5cbiAgICAgKi9cbiAgICBjb21tZW50VG9rZW46IGZ1bmN0aW9uKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcbiAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnJlYWRDb21tZW50KGZpcnN0KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbihUb2tlbnMuQ09NTUVOVCwgY29tbWVudCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgY29tcGFyaXNvbiB0b2tlbiBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2hhcmFjdGVyXG4gICAgICogYW5kIGxvY2F0aW9uIGluIHRoZSBzdHJlYW0uIFRoZSBuZXh0IGNoYXJhY3RlciBtdXN0IGJlXG4gICAgICogcmVhZCBhbmQgaXMgYWxyZWFkeSBrbm93biB0byBiZSBhbiBlcXVhbHMgc2lnbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYyBUaGUgY2hhcmFjdGVyIGZvciB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjb21wYXJpc29uVG9rZW5cbiAgICAgKi9cbiAgICBjb21wYXJpc29uVG9rZW46IGZ1bmN0aW9uKGMsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIGNvbXBhcmlzb24gID0gYyArIHJlYWRlci5yZWFkKCksXG4gICAgICAgICAgICB0dCAgICAgID0gVG9rZW5zLnR5cGUoY29tcGFyaXNvbikgfHwgVG9rZW5zLkNIQVI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odHQsIGNvbXBhcmlzb24sIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIGhhc2ggdG9rZW4gYmFzZWQgb24gdGhlIHNwZWNpZmllZCBpbmZvcm1hdGlvbi4gVGhlXG4gICAgICogZmlyc3QgY2hhcmFjdGVyIHByb3ZpZGVkIGlzIHRoZSBwb3VuZCBzaWduICgjKSBhbmQgdGhlbiB0aGlzXG4gICAgICogbWV0aG9kIHJlYWRzIGEgbmFtZSBhZnRlcndhcmQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0IFRoZSBmaXJzdCBjaGFyYWN0ZXIgKCMpIGluIHRoZSBoYXNoIG5hbWUuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBoYXNoVG9rZW5cbiAgICAgKi9cbiAgICBoYXNoVG9rZW46IGZ1bmN0aW9uKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcbiAgICAgICAgdmFyIG5hbWUgICAgPSB0aGlzLnJlYWROYW1lKGZpcnN0KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbihUb2tlbnMuSEFTSCwgbmFtZSwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgQ0RPIG9yIENIQVIgdG9rZW4gYmFzZWQgb24gdGhlIHNwZWNpZmllZCBpbmZvcm1hdGlvbi4gVGhlXG4gICAgICogZmlyc3QgY2hhcmFjdGVyIGlzIHByb3ZpZGVkIGFuZCB0aGUgcmVzdCBpcyByZWFkIGJ5IHRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmVcbiAgICAgKiB0aGUgY29ycmVjdCB0b2tlbiB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpcnN0IFRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgdG9rZW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2QgaHRtbENvbW1lbnRTdGFydFRva2VuXG4gICAgICovXG4gICAgaHRtbENvbW1lbnRTdGFydFRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XG4gICAgICAgIHZhciByZWFkZXIgICAgICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIHRleHQgICAgICAgID0gZmlyc3Q7XG5cbiAgICAgICAgcmVhZGVyLm1hcmsoKTtcbiAgICAgICAgdGV4dCArPSByZWFkZXIucmVhZENvdW50KDMpO1xuXG4gICAgICAgIGlmICh0ZXh0ID09PSBcIjwhLS1cIil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbihUb2tlbnMuQ0RPLCB0ZXh0LCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhclRva2VuKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIENEQyBvciBDSEFSIHRva2VuIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaW5mb3JtYXRpb24uIFRoZVxuICAgICAqIGZpcnN0IGNoYXJhY3RlciBpcyBwcm92aWRlZCBhbmQgdGhlIHJlc3QgaXMgcmVhZCBieSB0aGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gICAgICogdGhlIGNvcnJlY3QgdG9rZW4gdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRDb2wgVGhlIGJlZ2lubmluZyBjb2x1bW4gZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGh0bWxDb21tZW50RW5kVG9rZW5cbiAgICAgKi9cbiAgICBodG1sQ29tbWVudEVuZFRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XG4gICAgICAgIHZhciByZWFkZXIgICAgICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIHRleHQgICAgICAgID0gZmlyc3Q7XG5cbiAgICAgICAgcmVhZGVyLm1hcmsoKTtcbiAgICAgICAgdGV4dCArPSByZWFkZXIucmVhZENvdW50KDIpO1xuXG4gICAgICAgIGlmICh0ZXh0ID09PSBcIi0tPlwiKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKFRva2Vucy5DREMsIHRleHQsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyVG9rZW4oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGFuIElERU5UIG9yIEZVTkNUSU9OIHRva2VuIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaW5mb3JtYXRpb24uIFRoZVxuICAgICAqIGZpcnN0IGNoYXJhY3RlciBpcyBwcm92aWRlZCBhbmQgdGhlIHJlc3QgaXMgcmVhZCBieSB0aGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gICAgICogdGhlIGNvcnJlY3QgdG9rZW4gdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgdG9rZW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2QgaWRlbnRPckZ1bmN0aW9uVG9rZW5cbiAgICAgKi9cbiAgICBpZGVudE9yRnVuY3Rpb25Ub2tlbjogZnVuY3Rpb24oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIGlkZW50ICAgPSB0aGlzLnJlYWROYW1lKGZpcnN0KSxcbiAgICAgICAgICAgIHR0ICAgICAgPSBUb2tlbnMuSURFTlQsXG4gICAgICAgICAgICB1cmlGbnMgID0gW1widXJsKFwiLCBcInVybC1wcmVmaXgoXCIsIFwiZG9tYWluKFwiXTtcblxuICAgICAgICAvL2lmIHRoZXJlJ3MgYSBsZWZ0IHBhcmVuIGltbWVkaWF0ZWx5IGFmdGVyLCBpdCdzIGEgVVJJIG9yIGZ1bmN0aW9uXG4gICAgICAgIGlmIChyZWFkZXIucGVlaygpID09PSBcIihcIil7XG4gICAgICAgICAgICBpZGVudCArPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHVyaUZucy5pbmRleE9mKGlkZW50LnRvTG93ZXJDYXNlKCkpID4gLTEpe1xuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLlVSSTtcbiAgICAgICAgICAgICAgICBpZGVudCA9IHRoaXMucmVhZFVSSShpZGVudCk7XG5cbiAgICAgICAgICAgICAgICAvL2RpZG4ndCBmaW5kIGEgdmFsaWQgVVJMIG9yIHRoZXJlJ3Mgbm8gY2xvc2luZyBwYXJlblxuICAgICAgICAgICAgICAgIGlmICh1cmlGbnMuaW5kZXhPZihpZGVudC50b0xvd2VyQ2FzZSgpKSA+IC0xKXtcbiAgICAgICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuRlVOQ1RJT047XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5GVU5DVElPTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkZXIucGVlaygpID09PSBcIjpcIil7ICAvL21pZ2h0IGJlIGFuIElFIGZ1bmN0aW9uXG5cbiAgICAgICAgICAgIC8vSUUtc3BlY2lmaWMgZnVuY3Rpb25zIGFsd2F5cyBiZWluZyB3aXRoIHByb2dpZDpcbiAgICAgICAgICAgIGlmIChpZGVudC50b0xvd2VyQ2FzZSgpID09PSBcInByb2dpZFwiKXtcbiAgICAgICAgICAgICAgICBpZGVudCArPSByZWFkZXIucmVhZFRvKFwiKFwiKTtcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5JRV9GVU5DVElPTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHR0LCBpZGVudCwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGFuIElNUE9SVEFOVF9TWU0gb3IgQ0hBUiB0b2tlbiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGluZm9ybWF0aW9uLiBUaGVcbiAgICAgKiBmaXJzdCBjaGFyYWN0ZXIgaXMgcHJvdmlkZWQgYW5kIHRoZSByZXN0IGlzIHJlYWQgYnkgdGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZVxuICAgICAqIHRoZSBjb3JyZWN0IHRva2VuIHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlyc3QgVGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBpbXBvcnRhbnRUb2tlblxuICAgICAqL1xuICAgIGltcG9ydGFudFRva2VuOiBmdW5jdGlvbihmaXJzdCwgc3RhcnRMaW5lLCBzdGFydENvbCl7XG4gICAgICAgIHZhciByZWFkZXIgICAgICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIGltcG9ydGFudCAgID0gZmlyc3QsXG4gICAgICAgICAgICB0dCAgICAgICAgICA9IFRva2Vucy5DSEFSLFxuICAgICAgICAgICAgdGVtcCxcbiAgICAgICAgICAgIGM7XG5cbiAgICAgICAgcmVhZGVyLm1hcmsoKTtcbiAgICAgICAgYyA9IHJlYWRlci5yZWFkKCk7XG5cbiAgICAgICAgd2hpbGUoYyl7XG5cbiAgICAgICAgICAgIC8vdGhlcmUgY2FuIGJlIGEgY29tbWVudCBpbiBoZXJlXG4gICAgICAgICAgICBpZiAoYyA9PT0gXCIvXCIpe1xuXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaXNuJ3QgYSBzdGFyLCB0aGVuIHRoaXMgaXNuJ3QgYSB2YWxpZCAhaW1wb3J0YW50IHRva2VuXG4gICAgICAgICAgICAgICAgaWYgKHJlYWRlci5wZWVrKCkgIT09IFwiKlwiKXtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHRoaXMucmVhZENvbW1lbnQoYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wID09PSBcIlwiKXsgICAgLy9icm9rZW4hXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKXtcbiAgICAgICAgICAgICAgICBpbXBvcnRhbnQgKz0gYyArIHRoaXMucmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL2kvaS50ZXN0KGMpKXtcbiAgICAgICAgICAgICAgICB0ZW1wID0gcmVhZGVyLnJlYWRDb3VudCg4KTtcbiAgICAgICAgICAgICAgICBpZiAoL21wb3J0YW50L2kudGVzdCh0ZW1wKSl7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGFudCArPSBjICsgdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuSU1QT1JUQU5UX1NZTTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhazsgIC8vd2UncmUgZG9uZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYyA9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHQgPT09IFRva2Vucy5DSEFSKXtcbiAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhclRva2VuKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHR0LCBpbXBvcnRhbnQsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICB9XG5cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIE5PVCBvciBDSEFSIHRva2VuIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaW5mb3JtYXRpb24uIFRoZVxuICAgICAqIGZpcnN0IGNoYXJhY3RlciBpcyBwcm92aWRlZCBhbmQgdGhlIHJlc3QgaXMgcmVhZCBieSB0aGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gICAgICogdGhlIGNvcnJlY3QgdG9rZW4gdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdCBUaGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRMaW5lIFRoZSBiZWdpbm5pbmcgbGluZSBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRDb2wgVGhlIGJlZ2lubmluZyBjb2x1bW4gZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIHRva2VuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIG5vdFRva2VuXG4gICAgICovXG4gICAgbm90VG9rZW46IGZ1bmN0aW9uKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcbiAgICAgICAgdmFyIHJlYWRlciAgICAgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgdGV4dCAgICAgICAgPSBmaXJzdDtcblxuICAgICAgICByZWFkZXIubWFyaygpO1xuICAgICAgICB0ZXh0ICs9IHJlYWRlci5yZWFkQ291bnQoNCk7XG5cbiAgICAgICAgaWYgKHRleHQudG9Mb3dlckNhc2UoKSA9PT0gXCI6bm90KFwiKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKFRva2Vucy5OT1QsIHRleHQsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyVG9rZW4oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgbnVtYmVyIHRva2VuIGJhc2VkIG9uIHRoZSBnaXZlbiBjaGFyYWN0ZXJcbiAgICAgKiBhbmQgbG9jYXRpb24gaW4gdGhlIHN0cmVhbS4gVGhpcyBtYXkgcmV0dXJuIGEgdG9rZW4gb2ZcbiAgICAgKiBOVU1CRVIsIEVNUywgRVhTLCBMRU5HVEgsIEFOR0xFLCBUSU1FLCBGUkVRLCBESU1FTlNJT04sXG4gICAgICogb3IgUEVSQ0VOVEFHRS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlyc3QgVGhlIGZpcnN0IGNoYXJhY3RlciBmb3IgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgdG9rZW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2QgbnVtYmVyVG9rZW5cbiAgICAgKi9cbiAgICBudW1iZXJUb2tlbjogZnVuY3Rpb24oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIHZhbHVlICAgPSB0aGlzLnJlYWROdW1iZXIoZmlyc3QpLFxuICAgICAgICAgICAgaWRlbnQsXG4gICAgICAgICAgICB0dCAgICAgID0gVG9rZW5zLk5VTUJFUixcbiAgICAgICAgICAgIGMgICAgICAgPSByZWFkZXIucGVlaygpO1xuXG4gICAgICAgIGlmIChpc0lkZW50U3RhcnQoYykpe1xuICAgICAgICAgICAgaWRlbnQgPSB0aGlzLnJlYWROYW1lKHJlYWRlci5yZWFkKCkpO1xuICAgICAgICAgICAgdmFsdWUgKz0gaWRlbnQ7XG5cbiAgICAgICAgICAgIGlmICgvXmVtJHxeZXgkfF5weCR8XmdkJHxecmVtJHxednckfF52aCR8XnZtYXgkfF52bWluJHxeY2gkfF5jbSR8Xm1tJHxeaW4kfF5wdCR8XnBjJC9pLnRlc3QoaWRlbnQpKXtcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5MRU5HVEg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eZGVnfF5yYWQkfF5ncmFkJC9pLnRlc3QoaWRlbnQpKXtcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5BTkdMRTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL15tcyR8XnMkL2kudGVzdChpZGVudCkpe1xuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLlRJTUU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eaHokfF5raHokL2kudGVzdChpZGVudCkpe1xuICAgICAgICAgICAgICAgIHR0ID0gVG9rZW5zLkZSRVE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eZHBpJHxeZHBjbSQvaS50ZXN0KGlkZW50KSl7XG4gICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuUkVTT0xVVElPTjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHQgPSBUb2tlbnMuRElNRU5TSU9OO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCIlXCIpe1xuICAgICAgICAgICAgdmFsdWUgKz0gcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIHR0ID0gVG9rZW5zLlBFUkNFTlRBR0U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbih0dCwgdmFsdWUsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHN0cmluZyB0b2tlbiBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2hhcmFjdGVyXG4gICAgICogYW5kIGxvY2F0aW9uIGluIHRoZSBzdHJlYW0uIFNpbmNlIHN0cmluZ3MgbWF5IGJlIGluZGljYXRlZFxuICAgICAqIGJ5IHNpbmdsZSBvciBkb3VibGUgcXVvdGVzLCBhIGZhaWx1cmUgdG8gbWF0Y2ggc3RhcnRpbmdcbiAgICAgKiBhbmQgZW5kaW5nIHF1b3RlcyByZXN1bHRzIGluIGFuIElOVkFMSUQgdG9rZW4gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIFRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBpcyBwYXNzZWQgaW4gYW5kIHRoZW5cbiAgICAgKiB0aGUgcmVzdCBhcmUgcmVhZCB1cCB0byBhbmQgaW5jbHVkaW5nIHRoZSBmaW5hbCBxdW90YXRpb24gbWFyay5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlyc3QgVGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydExpbmUgVGhlIGJlZ2lubmluZyBsaW5lIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydENvbCBUaGUgYmVnaW5uaW5nIGNvbHVtbiBmb3IgdGhlIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgdG9rZW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2Qgc3RyaW5nVG9rZW5cbiAgICAgKi9cbiAgICBzdHJpbmdUb2tlbjogZnVuY3Rpb24oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xuICAgICAgICB2YXIgZGVsaW0gICA9IGZpcnN0LFxuICAgICAgICAgICAgc3RyaW5nICA9IGZpcnN0LFxuICAgICAgICAgICAgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIHByZXYgICAgPSBmaXJzdCxcbiAgICAgICAgICAgIHR0ICAgICAgPSBUb2tlbnMuU1RSSU5HLFxuICAgICAgICAgICAgYyAgICAgICA9IHJlYWRlci5yZWFkKCk7XG5cbiAgICAgICAgd2hpbGUoYyl7XG4gICAgICAgICAgICBzdHJpbmcgKz0gYztcblxuICAgICAgICAgICAgLy9pZiB0aGUgZGVsaW1pdGVyIGlzIGZvdW5kIHdpdGggYW4gZXNjYXBlbWVudCwgd2UncmUgZG9uZS5cbiAgICAgICAgICAgIGlmIChjID09PSBkZWxpbSAmJiBwcmV2ICE9PSBcIlxcXFxcIil7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYgdGhlcmUncyBhIG5ld2xpbmUgd2l0aG91dCBhbiBlc2NhcGVtZW50LCBpdCdzIGFuIGludmFsaWQgc3RyaW5nXG4gICAgICAgICAgICBpZiAoaXNOZXdMaW5lKHJlYWRlci5wZWVrKCkpICYmIGMgIT09IFwiXFxcXFwiKXtcbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5JTlZBTElEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3NhdmUgcHJldmlvdXMgYW5kIGdldCBuZXh0XG4gICAgICAgICAgICBwcmV2ID0gYztcbiAgICAgICAgICAgIGMgPSByZWFkZXIucmVhZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiBjIGlzIG51bGwsIHRoYXQgbWVhbnMgd2UncmUgb3V0IG9mIGlucHV0IGFuZCB0aGUgc3RyaW5nIHdhcyBuZXZlciBjbG9zZWRcbiAgICAgICAgaWYgKGMgPT09IG51bGwpe1xuICAgICAgICAgICAgdHQgPSBUb2tlbnMuSU5WQUxJRDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHR0LCBzdHJpbmcsIHN0YXJ0TGluZSwgc3RhcnRDb2wpO1xuICAgIH0sXG5cbiAgICB1bmljb2RlUmFuZ2VUb2tlbjogZnVuY3Rpb24oZmlyc3QsIHN0YXJ0TGluZSwgc3RhcnRDb2wpe1xuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIHZhbHVlICAgPSBmaXJzdCxcbiAgICAgICAgICAgIHRlbXAsXG4gICAgICAgICAgICB0dCAgICAgID0gVG9rZW5zLkNIQVI7XG5cbiAgICAgICAgLy90aGVuIGl0IHNob3VsZCBiZSBhIHVuaWNvZGUgcmFuZ2VcbiAgICAgICAgaWYgKHJlYWRlci5wZWVrKCkgPT09IFwiK1wiKXtcbiAgICAgICAgICAgIHJlYWRlci5tYXJrKCk7XG4gICAgICAgICAgICB2YWx1ZSArPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5yZWFkVW5pY29kZVJhbmdlUGFydCh0cnVlKTtcblxuICAgICAgICAgICAgLy9lbnN1cmUgdGhlcmUncyBhbiBhY3R1YWwgdW5pY29kZSByYW5nZSBoZXJlXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAyKXtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0dCA9IFRva2Vucy5VTklDT0RFX1JBTkdFO1xuXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGEgPyBpbiB0aGUgZmlyc3QgcGFydCwgdGhlcmUgY2FuJ3QgYmUgYSBzZWNvbmQgcGFydFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKFwiP1wiKSA9PT0gLTEpe1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkZXIucGVlaygpID09PSBcIi1cIil7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIubWFyaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wICs9IHRoaXMucmVhZFVuaWNvZGVSYW5nZVBhcnQoZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3Mgbm90IGFub3RoZXIgdmFsdWUsIGJhY2sgdXAgYW5kIGp1c3QgdGFrZSB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wLmxlbmd0aCA9PT0gMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHR0LCB2YWx1ZSwgc3RhcnRMaW5lLCBzdGFydENvbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgUyB0b2tlbiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGluZm9ybWF0aW9uLiBTaW5jZSB3aGl0ZXNwYWNlXG4gICAgICogbWF5IGhhdmUgbXVsdGlwbGUgY2hhcmFjdGVycywgdGhpcyBjb25zdW1lcyBhbGwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICogaW50byBhIHNpbmdsZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlyc3QgVGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TGluZSBUaGUgYmVnaW5uaW5nIGxpbmUgZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0Q29sIFRoZSBiZWdpbm5pbmcgY29sdW1uIGZvciB0aGUgY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSB0b2tlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCB3aGl0ZXNwYWNlVG9rZW5cbiAgICAgKi9cbiAgICB3aGl0ZXNwYWNlVG9rZW46IGZ1bmN0aW9uKGZpcnN0LCBzdGFydExpbmUsIHN0YXJ0Q29sKXtcbiAgICAgICAgdmFyIHZhbHVlICAgPSBmaXJzdCArIHRoaXMucmVhZFdoaXRlc3BhY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4oVG9rZW5zLlMsIHZhbHVlLCBzdGFydExpbmUsIHN0YXJ0Q29sKTtcbiAgICB9LFxuXG5cblxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTWV0aG9kcyB0byByZWFkIHZhbHVlcyBmcm9tIHRoZSBzdHJpbmcgc3RyZWFtXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZWFkVW5pY29kZVJhbmdlUGFydDogZnVuY3Rpb24oYWxsb3dRdWVzdGlvbk1hcmspe1xuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIHBhcnQgPSBcIlwiLFxuICAgICAgICAgICAgYyAgICAgICA9IHJlYWRlci5wZWVrKCk7XG5cbiAgICAgICAgLy9maXJzdCByZWFkIGhleCBkaWdpdHNcbiAgICAgICAgd2hpbGUoaXNIZXhEaWdpdChjKSAmJiBwYXJ0Lmxlbmd0aCA8IDYpe1xuICAgICAgICAgICAgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIHBhcnQgKz0gYztcbiAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aGVuIHJlYWQgcXVlc3Rpb24gbWFya3MgaWYgYWxsb3dlZFxuICAgICAgICBpZiAoYWxsb3dRdWVzdGlvbk1hcmspe1xuICAgICAgICAgICAgd2hpbGUoYyA9PT0gXCI/XCIgJiYgcGFydC5sZW5ndGggPCA2KXtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIHBhcnQgKz0gYztcbiAgICAgICAgICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhlcmUgY2FuJ3QgYmUgYW55IG90aGVyIGNoYXJhY3RlcnMgYWZ0ZXIgdGhpcyBwb2ludFxuXG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgIH0sXG5cbiAgICByZWFkV2hpdGVzcGFjZTogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXG4gICAgICAgICAgICB3aGl0ZXNwYWNlID0gXCJcIixcbiAgICAgICAgICAgIGMgICAgICAgPSByZWFkZXIucGVlaygpO1xuXG4gICAgICAgIHdoaWxlKGlzV2hpdGVzcGFjZShjKSl7XG4gICAgICAgICAgICByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgd2hpdGVzcGFjZSArPSBjO1xuICAgICAgICAgICAgYyA9IHJlYWRlci5wZWVrKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd2hpdGVzcGFjZTtcbiAgICB9LFxuICAgIHJlYWROdW1iZXI6IGZ1bmN0aW9uKGZpcnN0KXtcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXG4gICAgICAgICAgICBudW1iZXIgID0gZmlyc3QsXG4gICAgICAgICAgICBoYXNEb3QgID0gKGZpcnN0ID09PSBcIi5cIiksXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnBlZWsoKTtcblxuXG4gICAgICAgIHdoaWxlKGMpe1xuICAgICAgICAgICAgaWYgKGlzRGlnaXQoYykpe1xuICAgICAgICAgICAgICAgIG51bWJlciArPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIi5cIil7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RvdCl7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0RvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlciArPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9LFxuICAgIHJlYWRTdHJpbmc6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgZGVsaW0gICA9IHJlYWRlci5yZWFkKCksXG4gICAgICAgICAgICBzdHJpbmcgID0gZGVsaW0sXG4gICAgICAgICAgICBwcmV2ICAgID0gZGVsaW0sXG4gICAgICAgICAgICBjICAgICAgID0gcmVhZGVyLnBlZWsoKTtcblxuICAgICAgICB3aGlsZShjKXtcbiAgICAgICAgICAgIGMgPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgc3RyaW5nICs9IGM7XG5cbiAgICAgICAgICAgIC8vaWYgdGhlIGRlbGltaXRlciBpcyBmb3VuZCB3aXRoIGFuIGVzY2FwZW1lbnQsIHdlJ3JlIGRvbmUuXG4gICAgICAgICAgICBpZiAoYyA9PT0gZGVsaW0gJiYgcHJldiAhPT0gXCJcXFxcXCIpe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2lmIHRoZXJlJ3MgYSBuZXdsaW5lIHdpdGhvdXQgYW4gZXNjYXBlbWVudCwgaXQncyBhbiBpbnZhbGlkIHN0cmluZ1xuICAgICAgICAgICAgaWYgKGlzTmV3TGluZShyZWFkZXIucGVlaygpKSAmJiBjICE9PSBcIlxcXFxcIil7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9zYXZlIHByZXZpb3VzIGFuZCBnZXQgbmV4dFxuICAgICAgICAgICAgcHJldiA9IGM7XG4gICAgICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgYyBpcyBudWxsLCB0aGF0IG1lYW5zIHdlJ3JlIG91dCBvZiBpbnB1dCBhbmQgdGhlIHN0cmluZyB3YXMgbmV2ZXIgY2xvc2VkXG4gICAgICAgIGlmIChjID09PSBudWxsKXtcbiAgICAgICAgICAgIHN0cmluZyA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH0sXG4gICAgcmVhZFVSSTogZnVuY3Rpb24oZmlyc3Qpe1xuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIHVyaSAgICAgPSBmaXJzdCxcbiAgICAgICAgICAgIGlubmVyICAgPSBcIlwiLFxuICAgICAgICAgICAgYyAgICAgICA9IHJlYWRlci5wZWVrKCk7XG5cbiAgICAgICAgcmVhZGVyLm1hcmsoKTtcblxuICAgICAgICAvL3NraXAgd2hpdGVzcGFjZSBiZWZvcmVcbiAgICAgICAgd2hpbGUoYyAmJiBpc1doaXRlc3BhY2UoYykpe1xuICAgICAgICAgICAgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pdCdzIGEgc3RyaW5nXG4gICAgICAgIGlmIChjID09PSBcIidcIiB8fCBjID09PSBcIlxcXCJcIil7XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMucmVhZFN0cmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5uZXIgPSB0aGlzLnJlYWRVUkwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xuXG4gICAgICAgIC8vc2tpcCB3aGl0ZXNwYWNlIGFmdGVyXG4gICAgICAgIHdoaWxlKGMgJiYgaXNXaGl0ZXNwYWNlKGMpKXtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlcmUgd2FzIG5vIGlubmVyIHZhbHVlIG9yIHRoZSBuZXh0IGNoYXJhY3RlciBpc24ndCBjbG9zaW5nIHBhcmVuLCBpdCdzIG5vdCBhIFVSSVxuICAgICAgICBpZiAoaW5uZXIgPT09IFwiXCIgfHwgYyAhPT0gXCIpXCIpe1xuICAgICAgICAgICAgdXJpID0gZmlyc3Q7XG4gICAgICAgICAgICByZWFkZXIucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVyaSArPSBpbm5lciArIHJlYWRlci5yZWFkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH0sXG4gICAgcmVhZFVSTDogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHJlYWRlciAgPSB0aGlzLl9yZWFkZXIsXG4gICAgICAgICAgICB1cmwgICAgID0gXCJcIixcbiAgICAgICAgICAgIGMgICAgICAgPSByZWFkZXIucGVlaygpO1xuXG4gICAgICAgIC8vVE9ETzogQ2hlY2sgZm9yIGVzY2FwZSBhbmQgbm9uYXNjaWlcbiAgICAgICAgd2hpbGUgKC9eWyEjJCUmXFxcXCotfl0kLy50ZXN0KGMpKXtcbiAgICAgICAgICAgIHVybCArPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgYyA9IHJlYWRlci5wZWVrKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXJsO1xuXG4gICAgfSxcbiAgICByZWFkTmFtZTogZnVuY3Rpb24oZmlyc3Qpe1xuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIGlkZW50ICAgPSBmaXJzdCB8fCBcIlwiLFxuICAgICAgICAgICAgYyAgICAgICA9IHJlYWRlci5wZWVrKCk7XG5cbiAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICBpZiAoYyA9PT0gXCJcXFxcXCIpe1xuICAgICAgICAgICAgICAgIGlkZW50ICs9IHRoaXMucmVhZEVzY2FwZShyZWFkZXIucmVhZCgpKTtcbiAgICAgICAgICAgICAgICBjID0gcmVhZGVyLnBlZWsoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihjICYmIGlzTmFtZUNoYXIoYykpe1xuICAgICAgICAgICAgICAgIGlkZW50ICs9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgYyA9IHJlYWRlci5wZWVrKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlkZW50O1xuICAgIH0sXG5cbiAgICByZWFkRXNjYXBlOiBmdW5jdGlvbihmaXJzdCl7XG4gICAgICAgIHZhciByZWFkZXIgID0gdGhpcy5fcmVhZGVyLFxuICAgICAgICAgICAgY3NzRXNjYXBlID0gZmlyc3QgfHwgXCJcIixcbiAgICAgICAgICAgIGkgICAgICAgPSAwLFxuICAgICAgICAgICAgYyAgICAgICA9IHJlYWRlci5wZWVrKCk7XG5cbiAgICAgICAgaWYgKGlzSGV4RGlnaXQoYykpe1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNzc0VzY2FwZSArPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGMgPSByZWFkZXIucGVlaygpO1xuICAgICAgICAgICAgfSB3aGlsZShjICYmIGlzSGV4RGlnaXQoYykgJiYgKytpIDwgNik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3NzRXNjYXBlLmxlbmd0aCA9PT0gMyAmJiAvXFxzLy50ZXN0KGMpIHx8XG4gICAgICAgICAgICBjc3NFc2NhcGUubGVuZ3RoID09PSA3IHx8IGNzc0VzY2FwZS5sZW5ndGggPT09IDEpe1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjc3NFc2NhcGUgKyBjO1xuICAgIH0sXG5cbiAgICByZWFkQ29tbWVudDogZnVuY3Rpb24oZmlyc3Qpe1xuICAgICAgICB2YXIgcmVhZGVyICA9IHRoaXMuX3JlYWRlcixcbiAgICAgICAgICAgIGNvbW1lbnQgPSBmaXJzdCB8fCBcIlwiLFxuICAgICAgICAgICAgYyAgICAgICA9IHJlYWRlci5yZWFkKCk7XG5cbiAgICAgICAgaWYgKGMgPT09IFwiKlwiKXtcbiAgICAgICAgICAgIHdoaWxlKGMpe1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gYztcblxuICAgICAgICAgICAgICAgIC8vbG9vayBmb3IgZW5kIG9mIGNvbW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5sZW5ndGggPiAyICYmIGMgPT09IFwiKlwiICYmIHJlYWRlci5wZWVrKCkgPT09IFwiL1wiKXtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjID0gcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgfVxufSk7XG5cbnZhciBUb2tlbnMgID0gW1xuXG4gICAgLypcbiAgICAgKiBUaGUgZm9sbG93aW5nIHRva2VuIG5hbWVzIGFyZSBkZWZpbmVkIGluIENTUzMgR3JhbW1hcjogaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zeW50YXgvI2xleGljYWxcbiAgICAgKi9cblxuICAgIC8vSFRNTC1zdHlsZSBjb21tZW50c1xuICAgIHsgbmFtZTogXCJDRE9cIn0sXG4gICAgeyBuYW1lOiBcIkNEQ1wifSxcblxuICAgIC8vaWdub3JhYmxlc1xuICAgIHsgbmFtZTogXCJTXCIsIHdoaXRlc3BhY2U6IHRydWUvKiwgY2hhbm5lbDogXCJ3c1wiKi99LFxuICAgIHsgbmFtZTogXCJDT01NRU5UXCIsIGNvbW1lbnQ6IHRydWUsIGhpZGU6IHRydWUsIGNoYW5uZWw6IFwiY29tbWVudFwiIH0sXG5cbiAgICAvL2F0dHJpYnV0ZSBlcXVhbGl0eVxuICAgIHsgbmFtZTogXCJJTkNMVURFU1wiLCB0ZXh0OiBcIn49XCJ9LFxuICAgIHsgbmFtZTogXCJEQVNITUFUQ0hcIiwgdGV4dDogXCJ8PVwifSxcbiAgICB7IG5hbWU6IFwiUFJFRklYTUFUQ0hcIiwgdGV4dDogXCJePVwifSxcbiAgICB7IG5hbWU6IFwiU1VGRklYTUFUQ0hcIiwgdGV4dDogXCIkPVwifSxcbiAgICB7IG5hbWU6IFwiU1VCU1RSSU5HTUFUQ0hcIiwgdGV4dDogXCIqPVwifSxcblxuICAgIC8vaWRlbnRpZmllciB0eXBlc1xuICAgIHsgbmFtZTogXCJTVFJJTkdcIn0sXG4gICAgeyBuYW1lOiBcIklERU5UXCJ9LFxuICAgIHsgbmFtZTogXCJIQVNIXCJ9LFxuXG4gICAgLy9hdC1rZXl3b3Jkc1xuICAgIHsgbmFtZTogXCJJTVBPUlRfU1lNXCIsIHRleHQ6IFwiQGltcG9ydFwifSxcbiAgICB7IG5hbWU6IFwiUEFHRV9TWU1cIiwgdGV4dDogXCJAcGFnZVwifSxcbiAgICB7IG5hbWU6IFwiTUVESUFfU1lNXCIsIHRleHQ6IFwiQG1lZGlhXCJ9LFxuICAgIHsgbmFtZTogXCJGT05UX0ZBQ0VfU1lNXCIsIHRleHQ6IFwiQGZvbnQtZmFjZVwifSxcbiAgICB7IG5hbWU6IFwiQ0hBUlNFVF9TWU1cIiwgdGV4dDogXCJAY2hhcnNldFwifSxcbiAgICB7IG5hbWU6IFwiTkFNRVNQQUNFX1NZTVwiLCB0ZXh0OiBcIkBuYW1lc3BhY2VcIn0sXG4gICAgeyBuYW1lOiBcIlZJRVdQT1JUX1NZTVwiLCB0ZXh0OiBbXCJAdmlld3BvcnRcIiwgXCJALW1zLXZpZXdwb3J0XCIsIFwiQC1vLXZpZXdwb3J0XCJdfSxcbiAgICB7IG5hbWU6IFwiRE9DVU1FTlRfU1lNXCIsIHRleHQ6IFtcIkBkb2N1bWVudFwiLCBcIkAtbW96LWRvY3VtZW50XCJdfSxcbiAgICB7IG5hbWU6IFwiVU5LTk9XTl9TWU1cIiB9LFxuICAgIC8veyBuYW1lOiBcIkFUS0VZV09SRFwifSxcblxuICAgIC8vQ1NTMyBhbmltYXRpb25zXG4gICAgeyBuYW1lOiBcIktFWUZSQU1FU19TWU1cIiwgdGV4dDogWyBcIkBrZXlmcmFtZXNcIiwgXCJALXdlYmtpdC1rZXlmcmFtZXNcIiwgXCJALW1vei1rZXlmcmFtZXNcIiwgXCJALW8ta2V5ZnJhbWVzXCIgXSB9LFxuXG4gICAgLy9pbXBvcnRhbnQgc3ltYm9sXG4gICAgeyBuYW1lOiBcIklNUE9SVEFOVF9TWU1cIn0sXG5cbiAgICAvL21lYXN1cmVtZW50c1xuICAgIHsgbmFtZTogXCJMRU5HVEhcIn0sXG4gICAgeyBuYW1lOiBcIkFOR0xFXCJ9LFxuICAgIHsgbmFtZTogXCJUSU1FXCJ9LFxuICAgIHsgbmFtZTogXCJGUkVRXCJ9LFxuICAgIHsgbmFtZTogXCJESU1FTlNJT05cIn0sXG4gICAgeyBuYW1lOiBcIlBFUkNFTlRBR0VcIn0sXG4gICAgeyBuYW1lOiBcIk5VTUJFUlwifSxcblxuICAgIC8vZnVuY3Rpb25zXG4gICAgeyBuYW1lOiBcIlVSSVwifSxcbiAgICB7IG5hbWU6IFwiRlVOQ1RJT05cIn0sXG5cbiAgICAvL1VuaWNvZGUgcmFuZ2VzXG4gICAgeyBuYW1lOiBcIlVOSUNPREVfUkFOR0VcIn0sXG5cbiAgICAvKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgdG9rZW4gbmFtZXMgYXJlIGRlZmluZWQgaW4gQ1NTMyBTZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyNzZWxlY3Rvci1zeW50YXhcbiAgICAgKi9cblxuICAgIC8vaW52YWxpZCBzdHJpbmdcbiAgICB7IG5hbWU6IFwiSU5WQUxJRFwifSxcblxuICAgIC8vY29tYmluYXRvcnNcbiAgICB7IG5hbWU6IFwiUExVU1wiLCB0ZXh0OiBcIitcIiB9LFxuICAgIHsgbmFtZTogXCJHUkVBVEVSXCIsIHRleHQ6IFwiPlwifSxcbiAgICB7IG5hbWU6IFwiQ09NTUFcIiwgdGV4dDogXCIsXCJ9LFxuICAgIHsgbmFtZTogXCJUSUxERVwiLCB0ZXh0OiBcIn5cIn0sXG5cbiAgICAvL21vZGlmaWVyXG4gICAgeyBuYW1lOiBcIk5PVFwifSxcblxuICAgIC8qXG4gICAgICogRGVmaW5lZCBpbiBDU1MzIFBhZ2VkIE1lZGlhXG4gICAgICovXG4gICAgeyBuYW1lOiBcIlRPUExFRlRDT1JORVJfU1lNXCIsIHRleHQ6IFwiQHRvcC1sZWZ0LWNvcm5lclwifSxcbiAgICB7IG5hbWU6IFwiVE9QTEVGVF9TWU1cIiwgdGV4dDogXCJAdG9wLWxlZnRcIn0sXG4gICAgeyBuYW1lOiBcIlRPUENFTlRFUl9TWU1cIiwgdGV4dDogXCJAdG9wLWNlbnRlclwifSxcbiAgICB7IG5hbWU6IFwiVE9QUklHSFRfU1lNXCIsIHRleHQ6IFwiQHRvcC1yaWdodFwifSxcbiAgICB7IG5hbWU6IFwiVE9QUklHSFRDT1JORVJfU1lNXCIsIHRleHQ6IFwiQHRvcC1yaWdodC1jb3JuZXJcIn0sXG4gICAgeyBuYW1lOiBcIkJPVFRPTUxFRlRDT1JORVJfU1lNXCIsIHRleHQ6IFwiQGJvdHRvbS1sZWZ0LWNvcm5lclwifSxcbiAgICB7IG5hbWU6IFwiQk9UVE9NTEVGVF9TWU1cIiwgdGV4dDogXCJAYm90dG9tLWxlZnRcIn0sXG4gICAgeyBuYW1lOiBcIkJPVFRPTUNFTlRFUl9TWU1cIiwgdGV4dDogXCJAYm90dG9tLWNlbnRlclwifSxcbiAgICB7IG5hbWU6IFwiQk9UVE9NUklHSFRfU1lNXCIsIHRleHQ6IFwiQGJvdHRvbS1yaWdodFwifSxcbiAgICB7IG5hbWU6IFwiQk9UVE9NUklHSFRDT1JORVJfU1lNXCIsIHRleHQ6IFwiQGJvdHRvbS1yaWdodC1jb3JuZXJcIn0sXG4gICAgeyBuYW1lOiBcIkxFRlRUT1BfU1lNXCIsIHRleHQ6IFwiQGxlZnQtdG9wXCJ9LFxuICAgIHsgbmFtZTogXCJMRUZUTUlERExFX1NZTVwiLCB0ZXh0OiBcIkBsZWZ0LW1pZGRsZVwifSxcbiAgICB7IG5hbWU6IFwiTEVGVEJPVFRPTV9TWU1cIiwgdGV4dDogXCJAbGVmdC1ib3R0b21cIn0sXG4gICAgeyBuYW1lOiBcIlJJR0hUVE9QX1NZTVwiLCB0ZXh0OiBcIkByaWdodC10b3BcIn0sXG4gICAgeyBuYW1lOiBcIlJJR0hUTUlERExFX1NZTVwiLCB0ZXh0OiBcIkByaWdodC1taWRkbGVcIn0sXG4gICAgeyBuYW1lOiBcIlJJR0hUQk9UVE9NX1NZTVwiLCB0ZXh0OiBcIkByaWdodC1ib3R0b21cIn0sXG5cbiAgICAvKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgdG9rZW4gbmFtZXMgYXJlIGRlZmluZWQgaW4gQ1NTMyBNZWRpYSBRdWVyaWVzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLW1lZGlhcXVlcmllcy8jc3ludGF4XG4gICAgICovXG4gICAgLyp7IG5hbWU6IFwiTUVESUFfT05MWVwiLCBzdGF0ZTogXCJtZWRpYVwifSxcbiAgICB7IG5hbWU6IFwiTUVESUFfTk9UXCIsIHN0YXRlOiBcIm1lZGlhXCJ9LFxuICAgIHsgbmFtZTogXCJNRURJQV9BTkRcIiwgc3RhdGU6IFwibWVkaWFcIn0sKi9cbiAgICB7IG5hbWU6IFwiUkVTT0xVVElPTlwiLCBzdGF0ZTogXCJtZWRpYVwifSxcblxuICAgIC8qXG4gICAgICogVGhlIGZvbGxvd2luZyB0b2tlbiBuYW1lcyBhcmUgbm90IGRlZmluZWQgaW4gYW55IENTUyBzcGVjaWZpY2F0aW9uIGJ1dCBhcmUgdXNlZCBieSB0aGUgbGV4ZXIuXG4gICAgICovXG5cbiAgICAvL25vdCBhIHJlYWwgdG9rZW4sIGJ1dCB1c2VmdWwgZm9yIHN0dXBpZCBJRSBmaWx0ZXJzXG4gICAgeyBuYW1lOiBcIklFX0ZVTkNUSU9OXCIgfSxcblxuICAgIC8vcGFydCBvZiBDU1MzIGdyYW1tYXIgYnV0IG5vdCB0aGUgRmxleCBjb2RlXG4gICAgeyBuYW1lOiBcIkNIQVJcIiB9LFxuXG4gICAgLy9UT0RPOiBOZWVkZWQ/XG4gICAgLy9Ob3QgZGVmaW5lZCBhcyB0b2tlbnMsIGJ1dCBtaWdodCBhcyB3ZWxsIGJlXG4gICAge1xuICAgICAgICBuYW1lOiBcIlBJUEVcIixcbiAgICAgICAgdGV4dDogXCJ8XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJTTEFTSFwiLFxuICAgICAgICB0ZXh0OiBcIi9cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIk1JTlVTXCIsXG4gICAgICAgIHRleHQ6IFwiLVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiU1RBUlwiLFxuICAgICAgICB0ZXh0OiBcIipcIlxuICAgIH0sXG5cbiAgICB7XG4gICAgICAgIG5hbWU6IFwiTEJSQUNFXCIsXG4gICAgICAgIGVuZENoYXI6IFwifVwiLFxuICAgICAgICB0ZXh0OiBcIntcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlJCUkFDRVwiLFxuICAgICAgICB0ZXh0OiBcIn1cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkxCUkFDS0VUXCIsXG4gICAgICAgIGVuZENoYXI6IFwiXVwiLFxuICAgICAgICB0ZXh0OiBcIltcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlJCUkFDS0VUXCIsXG4gICAgICAgIHRleHQ6IFwiXVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiRVFVQUxTXCIsXG4gICAgICAgIHRleHQ6IFwiPVwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiQ09MT05cIixcbiAgICAgICAgdGV4dDogXCI6XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJTRU1JQ09MT05cIixcbiAgICAgICAgdGV4dDogXCI7XCJcbiAgICB9LFxuXG4gICAge1xuICAgICAgICBuYW1lOiBcIkxQQVJFTlwiLFxuICAgICAgICBlbmRDaGFyOiBcIilcIixcbiAgICAgICAgdGV4dDogXCIoXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJSUEFSRU5cIixcbiAgICAgICAgdGV4dDogXCIpXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJET1RcIixcbiAgICAgICAgdGV4dDogXCIuXCJcbiAgICB9XG5dO1xuXG4oZnVuY3Rpb24oKXtcblxuICAgIHZhciBuYW1lTWFwID0gW10sXG4gICAgICAgIHR5cGVNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgVG9rZW5zLlVOS05PV04gPSAtMTtcbiAgICBUb2tlbnMudW5zaGlmdCh7bmFtZTpcIkVPRlwifSk7XG4gICAgZm9yICh2YXIgaT0wLCBsZW4gPSBUb2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICBuYW1lTWFwLnB1c2goVG9rZW5zW2ldLm5hbWUpO1xuICAgICAgICBUb2tlbnNbVG9rZW5zW2ldLm5hbWVdID0gaTtcbiAgICAgICAgaWYgKFRva2Vuc1tpXS50ZXh0KXtcbiAgICAgICAgICAgIGlmIChUb2tlbnNbaV0udGV4dCBpbnN0YW5jZW9mIEFycmF5KXtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGogPCBUb2tlbnNbaV0udGV4dC5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVNYXBbVG9rZW5zW2ldLnRleHRbal1dID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVNYXBbVG9rZW5zW2ldLnRleHRdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIFRva2Vucy5uYW1lID0gZnVuY3Rpb24odHQpe1xuICAgICAgICByZXR1cm4gbmFtZU1hcFt0dF07XG4gICAgfTtcblxuICAgIFRva2Vucy50eXBlID0gZnVuY3Rpb24oYyl7XG4gICAgICAgIHJldHVybiB0eXBlTWFwW2NdIHx8IC0xO1xuICAgIH07XG5cbn0pKCk7XG5cblxuXG4vL1RoaXMgZmlsZSB3aWxsIGxpa2VseSBjaGFuZ2UgYSBsb3QhIFZlcnkgZXhwZXJpbWVudGFsIVxudmFyIFZhbGlkYXRpb24gPSB7XG5cbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKXtcblxuICAgICAgICAvL25vcm1hbGl6ZSBuYW1lXG4gICAgICAgIHZhciBuYW1lICAgICAgICA9IHByb3BlcnR5LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGV4cHJlc3Npb24gID0gbmV3IFByb3BlcnR5VmFsdWVJdGVyYXRvcih2YWx1ZSksXG4gICAgICAgICAgICBzcGVjICAgICAgICA9IFByb3BlcnRpZXNbbmFtZV07XG5cbiAgICAgICAgaWYgKCFzcGVjKSB7XG4gICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKFwiLVwiKSAhPT0gMCl7ICAgIC8vdmVuZG9yIHByZWZpeGVkIGFyZSBva1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJVbmtub3duIHByb3BlcnR5ICdcIiArIHByb3BlcnR5ICsgXCInLlwiLCBwcm9wZXJ0eS5saW5lLCBwcm9wZXJ0eS5jb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjICE9PSBcIm51bWJlclwiKXtcblxuICAgICAgICAgICAgLy9pbml0aWFsaXphdGlvblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09PSBcInN0cmluZ1wiKXtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5pbmRleE9mKFwifHxcIikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwUHJvcGVydHkoc3BlYywgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaW5nbGVQcm9wZXJ0eShzcGVjLCBleHByZXNzaW9uLCAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlYy5tdWx0aSkge1xuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlQcm9wZXJ0eShzcGVjLm11bHRpLCBleHByZXNzaW9uLCBzcGVjLmNvbW1hLCBzcGVjLm1heCB8fCBJbmZpbml0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBzcGVjKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBzaW5nbGVQcm9wZXJ0eTogZnVuY3Rpb24odHlwZXMsIGV4cHJlc3Npb24sIG1heCwgcGFydGlhbCkge1xuXG4gICAgICAgIHZhciByZXN1bHQgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgPSBleHByZXNzaW9uLnZhbHVlLFxuICAgICAgICAgICAgY291bnQgICAgICAgPSAwLFxuICAgICAgICAgICAgcGFydDtcblxuICAgICAgICB3aGlsZSAoZXhwcmVzc2lvbi5oYXNOZXh0KCkgJiYgY291bnQgPCBtYXgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkgJiYgIWV4cHJlc3Npb24uaXNGaXJzdCgpKSB7XG4gICAgICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ucGVlaygpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCBlbmQgb2YgdmFsdWUgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIChcIiArIHR5cGVzICsgXCIpIGJ1dCBmb3VuZCAnXCIgKyB2YWx1ZSArIFwiJy5cIiwgdmFsdWUubGluZSwgdmFsdWUuY29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xuICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ubmV4dCgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBtdWx0aVByb3BlcnR5OiBmdW5jdGlvbiAodHlwZXMsIGV4cHJlc3Npb24sIGNvbW1hLCBtYXgpIHtcblxuICAgICAgICB2YXIgcmVzdWx0ICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlICAgICAgID0gZXhwcmVzc2lvbi52YWx1ZSxcbiAgICAgICAgICAgIGNvdW50ICAgICAgID0gMCxcbiAgICAgICAgICAgIHBhcnQ7XG5cbiAgICAgICAgd2hpbGUoZXhwcmVzc2lvbi5oYXNOZXh0KCkgJiYgIXJlc3VsdCAmJiBjb3VudCA8IG1heCkge1xuICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCB0eXBlcykpIHtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIGlmICghZXhwcmVzc2lvbi5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFN0cmluZyhleHByZXNzaW9uLnBlZWsoKSkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkgJiYgIWV4cHJlc3Npb24uaXNGaXJzdCgpKSB7XG4gICAgICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ucGVlaygpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCBlbmQgb2YgdmFsdWUgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5wcmV2aW91cygpO1xuICAgICAgICAgICAgICAgIGlmIChjb21tYSAmJiBTdHJpbmcocGFydCkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCBlbmQgb2YgdmFsdWUgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCAoXCIgKyB0eXBlcyArIFwiKSBidXQgZm91bmQgJ1wiICsgdmFsdWUgKyBcIicuXCIsIHZhbHVlLmxpbmUsIHZhbHVlLmNvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbi5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIHBhcnQgPSBleHByZXNzaW9uLm5leHQoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJFeHBlY3RlZCBlbmQgb2YgdmFsdWUgYnV0IGZvdW5kICdcIiArIHBhcnQgKyBcIicuXCIsIHBhcnQubGluZSwgcGFydC5jb2wpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgZ3JvdXBQcm9wZXJ0eTogZnVuY3Rpb24gKHR5cGVzLCBleHByZXNzaW9uLCBjb21tYSkge1xuXG4gICAgICAgIHZhciByZXN1bHQgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgPSBleHByZXNzaW9uLnZhbHVlLFxuICAgICAgICAgICAgdHlwZUNvdW50ICAgPSB0eXBlcy5zcGxpdChcInx8XCIpLmxlbmd0aCxcbiAgICAgICAgICAgIGdyb3VwcyAgICAgID0geyBjb3VudDogMCB9LFxuICAgICAgICAgICAgcGFydGlhbCAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBwYXJ0O1xuXG4gICAgICAgIHdoaWxlKGV4cHJlc3Npb24uaGFzTmV4dCgpICYmICFyZXN1bHQpIHtcbiAgICAgICAgICAgIG5hbWUgPSBWYWxpZGF0aW9uVHlwZXMuaXNBbnlPZkdyb3VwKGV4cHJlc3Npb24sIHR5cGVzKTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG5cbiAgICAgICAgICAgICAgICAvL25vIGR1cGVzXG4gICAgICAgICAgICAgICAgaWYgKGdyb3Vwc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncm91cHNbbmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBncm91cHMuY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3Vwcy5jb3VudCA9PT0gdHlwZUNvdW50IHx8ICFleHByZXNzaW9uLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHBhcnRpYWwgJiYgZXhwcmVzc2lvbi5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ucGVlaygpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiRXhwZWN0ZWQgZW5kIG9mIHZhbHVlIGJ1dCBmb3VuZCAnXCIgKyBwYXJ0ICsgXCInLlwiLCBwYXJ0LmxpbmUsIHBhcnQuY29sKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIChcIiArIHR5cGVzICsgXCIpIGJ1dCBmb3VuZCAnXCIgKyB2YWx1ZSArIFwiJy5cIiwgdmFsdWUubGluZSwgdmFsdWUuY29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xuICAgICAgICAgICAgcGFydCA9IGV4cHJlc3Npb24ubmV4dCgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIGVuZCBvZiB2YWx1ZSBidXQgZm91bmQgJ1wiICsgcGFydCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59O1xuLyoqXG4gKiBUeXBlIHRvIHVzZSB3aGVuIGEgdmFsaWRhdGlvbiBlcnJvciBvY2N1cnMuXG4gKiBAY2xhc3MgVmFsaWRhdGlvbkVycm9yXG4gKiBAbmFtZXNwYWNlIHBhcnNlcmxpYi51dGlsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtpbnR9IGxpbmUgVGhlIGxpbmUgYXQgd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxuICogQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIGF0IHdoaWNoIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAqL1xuZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbCl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1uIGF0IHdoaWNoIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAgICAgKiBAdHlwZSBpbnRcbiAgICAgKiBAcHJvcGVydHkgY29sXG4gICAgICovXG4gICAgdGhpcy5jb2wgPSBjb2w7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGluZSBhdCB3aGljaCB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gICAgICogQHR5cGUgaW50XG4gICAgICogQHByb3BlcnR5IGxpbmVcbiAgICAgKi9cbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHByb3BlcnR5IHRleHRcbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG59XG5cbi8vaW5oZXJpdCBmcm9tIEVycm9yXG5WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4vL1RoaXMgZmlsZSB3aWxsIGxpa2VseSBjaGFuZ2UgYSBsb3QhIFZlcnkgZXhwZXJpbWVudGFsIVxudmFyIFZhbGlkYXRpb25UeXBlcyA9IHtcblxuICAgIGlzTGl0ZXJhbDogZnVuY3Rpb24gKHBhcnQsIGxpdGVyYWxzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gcGFydC50ZXh0LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGFyZ3MgPSBsaXRlcmFscy5zcGxpdChcIiB8IFwiKSxcbiAgICAgICAgICAgIGksIGxlbiwgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGk9MCxsZW49YXJncy5sZW5ndGg7IGkgPCBsZW4gJiYgIWZvdW5kOyBpKyspe1xuICAgICAgICAgICAgaWYgKHRleHQgPT09IGFyZ3NbaV0udG9Mb3dlckNhc2UoKSl7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH0sXG5cbiAgICBpc1NpbXBsZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXBsZVt0eXBlXTtcbiAgICB9LFxuXG4gICAgaXNDb21wbGV4OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuY29tcGxleFt0eXBlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbmV4dCBwYXJ0KHMpIG9mIHRoZSBnaXZlbiBleHByZXNzaW9uXG4gICAgICogYXJlIGFueSBvZiB0aGUgZ2l2ZW4gdHlwZXMuXG4gICAgICovXG4gICAgaXNBbnk6IGZ1bmN0aW9uIChleHByZXNzaW9uLCB0eXBlcykge1xuICAgICAgICB2YXIgYXJncyA9IHR5cGVzLnNwbGl0KFwiIHwgXCIpLFxuICAgICAgICAgICAgaSwgbGVuLCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoaT0wLGxlbj1hcmdzLmxlbmd0aDsgaSA8IGxlbiAmJiAhZm91bmQgJiYgZXhwcmVzc2lvbi5oYXNOZXh0KCk7IGkrKyl7XG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMuaXNUeXBlKGV4cHJlc3Npb24sIGFyZ3NbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBuZXh0IHBhcnQocykgb2YgdGhlIGdpdmVuIGV4cHJlc3Npb25cbiAgICAgKiBhcmUgb25lIG9mIGEgZ3JvdXAuXG4gICAgICovXG4gICAgaXNBbnlPZkdyb3VwOiBmdW5jdGlvbihleHByZXNzaW9uLCB0eXBlcykge1xuICAgICAgICB2YXIgYXJncyA9IHR5cGVzLnNwbGl0KFwiIHx8IFwiKSxcbiAgICAgICAgICAgIGksIGxlbiwgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGk9MCxsZW49YXJncy5sZW5ndGg7IGkgPCBsZW4gJiYgIWZvdW5kOyBpKyspe1xuICAgICAgICAgICAgZm91bmQgPSB0aGlzLmlzVHlwZShleHByZXNzaW9uLCBhcmdzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3VuZCA/IGFyZ3NbaS0xXSA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBuZXh0IHBhcnQocykgb2YgdGhlIGdpdmVuIGV4cHJlc3Npb25cbiAgICAgKiBhcmUgb2YgYSBnaXZlbiB0eXBlLlxuICAgICAqL1xuICAgIGlzVHlwZTogZnVuY3Rpb24gKGV4cHJlc3Npb24sIHR5cGUpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBleHByZXNzaW9uLnBlZWsoKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0eXBlLmNoYXJBdCgwKSAhPT0gXCI8XCIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaXNMaXRlcmFsKHBhcnQsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24ubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2ltcGxlW3R5cGVdKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnNpbXBsZVt0eXBlXShwYXJ0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29tcGxleFt0eXBlXShleHByZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuXG5cbiAgICBzaW1wbGU6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuXG4gICAgICAgIFwiPGFic29sdXRlLXNpemU+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgXCJ4eC1zbWFsbCB8IHgtc21hbGwgfCBzbWFsbCB8IG1lZGl1bSB8IGxhcmdlIHwgeC1sYXJnZSB8IHh4LWxhcmdlXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGF0dGFjaG1lbnQ+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgXCJzY3JvbGwgfCBmaXhlZCB8IGxvY2FsXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGF0dHI+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIHBhcnQubmFtZSA9PT0gXCJhdHRyXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8YmctaW1hZ2U+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCI8aW1hZ2U+XCJdKHBhcnQpIHx8IHRoaXNbXCI8Z3JhZGllbnQ+XCJdKHBhcnQpIHx8ICBTdHJpbmcocGFydCkgPT09IFwibm9uZVwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGdyYWRpZW50PlwiOiBmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgL14oPzpcXC0oPzptc3xtb3p8b3x3ZWJraXQpXFwtKT8oPzpyZXBlYXRpbmdcXC0pPyg/OnJhZGlhbFxcLXxsaW5lYXJcXC0pP2dyYWRpZW50L2kudGVzdChwYXJ0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxib3g+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgXCJwYWRkaW5nLWJveCB8IGJvcmRlci1ib3ggfCBjb250ZW50LWJveFwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxjb250ZW50PlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiBwYXJ0Lm5hbWUgPT09IFwiY29udGVudFwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPHJlbGF0aXZlLXNpemU+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgXCJzbWFsbGVyIHwgbGFyZ2VyXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vYW55IGlkZW50aWZpZXJcbiAgICAgICAgXCI8aWRlbnQ+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJpZGVudGlmaWVyXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8bGVuZ3RoPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiAvXig/OlxcLSg/Om1zfG1venxvfHdlYmtpdClcXC0pP2NhbGMvaS50ZXN0KHBhcnQpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwibGVuZ3RoXCIgfHwgcGFydC50eXBlID09PSBcIm51bWJlclwiIHx8IHBhcnQudHlwZSA9PT0gXCJpbnRlZ2VyXCIgfHwgU3RyaW5nKHBhcnQpID09PSBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBcIjxjb2xvcj5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcImNvbG9yXCIgfHwgU3RyaW5nKHBhcnQpID09PSBcInRyYW5zcGFyZW50XCIgfHwgU3RyaW5nKHBhcnQpID09PSBcImN1cnJlbnRDb2xvclwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPG51bWJlcj5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcIm51bWJlclwiIHx8IHRoaXNbXCI8aW50ZWdlcj5cIl0ocGFydCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8aW50ZWdlcj5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcImludGVnZXJcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxsaW5lPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwiaW50ZWdlclwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGFuZ2xlPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwiYW5nbGVcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjx1cmk+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJ1cmlcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxpbWFnZT5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIjx1cmk+XCJdKHBhcnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPHBlcmNlbnRhZ2U+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJwZXJjZW50YWdlXCIgfHwgU3RyaW5nKHBhcnQpID09PSBcIjBcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxib3JkZXItd2lkdGg+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCI8bGVuZ3RoPlwiXShwYXJ0KSB8fCBWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKHBhcnQsIFwidGhpbiB8IG1lZGl1bSB8IHRoaWNrXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGJvcmRlci1zdHlsZT5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcIm5vbmUgfCBoaWRkZW4gfCBkb3R0ZWQgfCBkYXNoZWQgfCBzb2xpZCB8IGRvdWJsZSB8IGdyb292ZSB8IHJpZGdlIHwgaW5zZXQgfCBvdXRzZXRcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8Y29udGVudC1zaXppbmc+XCI6IGZ1bmN0aW9uKHBhcnQpeyAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNpemluZy8jd2lkdGgtaGVpZ2h0LWtleXdvcmRzXG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcImZpbGwtYXZhaWxhYmxlIHwgLW1vei1hdmFpbGFibGUgfCAtd2Via2l0LWZpbGwtYXZhaWxhYmxlIHwgbWF4LWNvbnRlbnQgfCAtbW96LW1heC1jb250ZW50IHwgLXdlYmtpdC1tYXgtY29udGVudCB8IG1pbi1jb250ZW50IHwgLW1vei1taW4tY29udGVudCB8IC13ZWJraXQtbWluLWNvbnRlbnQgfCBmaXQtY29udGVudCB8IC1tb3otZml0LWNvbnRlbnQgfCAtd2Via2l0LWZpdC1jb250ZW50XCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPG1hcmdpbi13aWR0aD5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIjxsZW5ndGg+XCJdKHBhcnQpIHx8IHRoaXNbXCI8cGVyY2VudGFnZT5cIl0ocGFydCkgfHwgVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcImF1dG9cIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8cGFkZGluZy13aWR0aD5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIjxsZW5ndGg+XCJdKHBhcnQpIHx8IHRoaXNbXCI8cGVyY2VudGFnZT5cIl0ocGFydCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8c2hhcGU+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIChwYXJ0Lm5hbWUgPT09IFwicmVjdFwiIHx8IHBhcnQubmFtZSA9PT0gXCJpbnNldC1yZWN0XCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPHRpbWU+XCI6IGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwidGltZVwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGZsZXgtZ3Jvdz5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIjxudW1iZXI+XCJdKHBhcnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPGZsZXgtc2hyaW5rPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiPG51bWJlcj5cIl0ocGFydCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8d2lkdGg+XCI6IGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCI8bWFyZ2luLXdpZHRoPlwiXShwYXJ0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxmbGV4LWJhc2lzPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiPHdpZHRoPlwiXShwYXJ0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxmbGV4LWRpcmVjdGlvbj5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcInJvdyB8IHJvdy1yZXZlcnNlIHwgY29sdW1uIHwgY29sdW1uLXJldmVyc2VcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8ZmxleC13cmFwPlwiOiBmdW5jdGlvbihwYXJ0KXtcbiAgICAgICAgICAgIHJldHVybiBWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKHBhcnQsIFwibm93cmFwIHwgd3JhcCB8IHdyYXAtcmV2ZXJzZVwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxmZWF0dXJlLXRhZy12YWx1ZT5cIjogZnVuY3Rpb24ocGFydCl7XG4gICAgICAgICAgICByZXR1cm4gKHBhcnQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIC9eW0EtWjAtOV17NH0kL2kudGVzdChwYXJ0KSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcGxleDoge1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG5cbiAgICAgICAgXCI8YmctcG9zaXRpb24+XCI6IGZ1bmN0aW9uKGV4cHJlc3Npb24pe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCAgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBudW1lcmljID0gXCI8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPlwiLFxuICAgICAgICAgICAgICAgIHhEaXIgICAgPSBcImxlZnQgfCByaWdodFwiLFxuICAgICAgICAgICAgICAgIHlEaXIgICAgPSBcInRvcCB8IGJvdHRvbVwiLFxuICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKGV4cHJlc3Npb24ucGVlayhjb3VudCkgJiYgZXhwcmVzc2lvbi5wZWVrKGNvdW50KS50ZXh0ICE9PSBcIixcIikge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG5cbi8qXG48cG9zaXRpb24+ID0gW1xuICBbIGxlZnQgfCBjZW50ZXIgfCByaWdodCB8IHRvcCB8IGJvdHRvbSB8IDxwZXJjZW50YWdlPiB8IDxsZW5ndGg+IF1cbnxcbiAgWyBsZWZ0IHwgY2VudGVyIHwgcmlnaHQgfCA8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPiBdXG4gIFsgdG9wIHwgY2VudGVyIHwgYm90dG9tIHwgPHBlcmNlbnRhZ2U+IHwgPGxlbmd0aD4gXVxufFxuICBbIGNlbnRlciB8IFsgbGVmdCB8IHJpZ2h0IF0gWyA8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPiBdPyBdICYmXG4gIFsgY2VudGVyIHwgWyB0b3AgfCBib3R0b20gXSBbIDxwZXJjZW50YWdlPiB8IDxsZW5ndGg+IF0/IF1cbl1cbiovXG5cbiAgICAgICAgICAgIGlmIChjb3VudCA8IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHhEaXIgKyBcIiB8IGNlbnRlciB8IFwiICsgbnVtZXJpYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgeURpciArIFwiIHwgY2VudGVyIHwgXCIgKyBudW1lcmljKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCB5RGlyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCB4RGlyICsgXCIgfCBjZW50ZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHhEaXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgeURpcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIG51bWVyaWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHlEaXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcImNlbnRlclwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCB5RGlyKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHhEaXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIG51bWVyaWMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBudW1lcmljKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCB4RGlyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcImNlbnRlclwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcImNlbnRlclwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIHhEaXIgKyBcIiB8IFwiICsgeURpcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgbnVtZXJpYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8Ymctc2l6ZT5cIjogZnVuY3Rpb24oZXhwcmVzc2lvbil7XG4gICAgICAgICAgICAvLzxiZy1zaXplPiA9IFsgPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCBhdXRvIF17MSwyfSB8IGNvdmVyIHwgY29udGFpblxuICAgICAgICAgICAgdmFyIHJlc3VsdCAgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBudW1lcmljID0gXCI8cGVyY2VudGFnZT4gfCA8bGVuZ3RoPiB8IGF1dG9cIjtcblxuICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcImNvdmVyIHwgY29udGFpblwiKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBudW1lcmljKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIG51bWVyaWMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiPHJlcGVhdC1zdHlsZT5cIjogZnVuY3Rpb24oZXhwcmVzc2lvbil7XG4gICAgICAgICAgICAvL3JlcGVhdC14IHwgcmVwZWF0LXkgfCBbcmVwZWF0IHwgc3BhY2UgfCByb3VuZCB8IG5vLXJlcGVhdF17MSwyfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCAgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgID0gXCJyZXBlYXQgfCBzcGFjZSB8IHJvdW5kIHwgbm8tcmVwZWF0XCIsXG4gICAgICAgICAgICAgICAgcGFydDtcblxuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uaGFzTmV4dCgpKXtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzTGl0ZXJhbChwYXJ0LCBcInJlcGVhdC14IHwgcmVwZWF0LXlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0xpdGVyYWwocGFydCwgdmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSAmJiBWYWxpZGF0aW9uVHlwZXMuaXNMaXRlcmFsKGV4cHJlc3Npb24ucGVlaygpLCB2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIFwiPHNoYWRvdz5cIjogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgLy9pbnNldD8gJiYgWyA8bGVuZ3RoPnsyLDR9ICYmIDxjb2xvcj4/IF1cbiAgICAgICAgICAgIHZhciByZXN1bHQgID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgY291bnQgICA9IDAsXG4gICAgICAgICAgICAgICAgaW5zZXQgICA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbG9yICAgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uaGFzTmV4dCgpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiaW5zZXRcIikpe1xuICAgICAgICAgICAgICAgICAgICBpbnNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKFZhbGlkYXRpb25UeXBlcy5pc0FueShleHByZXNzaW9uLCBcIjxjb2xvcj5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCI8bGVuZ3RoPlwiKSAmJiBjb3VudCA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCI8Y29sb3I+XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgVmFsaWRhdGlvblR5cGVzLmlzQW55KGV4cHJlc3Npb24sIFwiaW5zZXRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChjb3VudCA+PSAyICYmIGNvdW50IDw9IDQpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCI8eC1vbmUtcmFkaXVzPlwiOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAvL1sgPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gXSBbIDxsZW5ndGg+IHwgPHBlcmNlbnRhZ2U+IF0/XG4gICAgICAgICAgICB2YXIgcmVzdWx0ICA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNpbXBsZSA9IFwiPGxlbmd0aD4gfCA8cGVyY2VudGFnZT4gfCBpbmhlcml0XCI7XG5cbiAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgc2ltcGxlKSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgc2ltcGxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBcIjxmbGV4PlwiOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDE0L1dELWNzcy1mbGV4Ym94LTEtMjAxNDAzMjUvI2ZsZXgtcHJvcGVydHlcbiAgICAgICAgICAgIC8vIG5vbmUgfCBbIDxmbGV4LWdyb3c+IDxmbGV4LXNocmluaz4/IHx8IDxmbGV4LWJhc2lzPiBdXG4gICAgICAgICAgICAvLyBWYWxpZCBzeW50YXhlcywgYWNjb3JkaW5nIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mbGV4I1N5bnRheFxuICAgICAgICAgICAgLy8gKiBub25lXG4gICAgICAgICAgICAvLyAqIDxmbGV4LWdyb3c+XG4gICAgICAgICAgICAvLyAqIDxmbGV4LWJhc2lzPlxuICAgICAgICAgICAgLy8gKiA8ZmxleC1ncm93PiA8ZmxleC1iYXNpcz5cbiAgICAgICAgICAgIC8vICogPGZsZXgtZ3Jvdz4gPGZsZXgtc2hyaW5rPlxuICAgICAgICAgICAgLy8gKiA8ZmxleC1ncm93PiA8ZmxleC1zaHJpbms+IDxmbGV4LWJhc2lzPlxuICAgICAgICAgICAgLy8gKiBpbmhlcml0XG4gICAgICAgICAgICB2YXIgcGFydCxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNBbnkoZXhwcmVzc2lvbiwgXCJub25lIHwgaW5oZXJpdFwiKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChWYWxpZGF0aW9uVHlwZXMuaXNUeXBlKGV4cHJlc3Npb24sIFwiPGZsZXgtZ3Jvdz5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24ucGVlaygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmFsaWRhdGlvblR5cGVzLmlzVHlwZShleHByZXNzaW9uLCBcIjxmbGV4LXNocmluaz5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5wZWVrKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gVmFsaWRhdGlvblR5cGVzLmlzVHlwZShleHByZXNzaW9uLCBcIjxmbGV4LWJhc2lzPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzVHlwZShleHByZXNzaW9uLCBcIjxmbGV4LWJhc2lzPlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4cHJlc3Npb24ucGVlaygpID09PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVmFsaWRhdGlvblR5cGVzLmlzVHlwZShleHByZXNzaW9uLCBcIjxmbGV4LWJhc2lzPlwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG1vcmUgdmVyYm9zZSBlcnJvciB0aGFuIFwiRXhwZWN0ZWQgPGZsZXg+Li4uXCJcbiAgICAgICAgICAgICAgICBwYXJ0ID0gZXhwcmVzc2lvbi5wZWVrKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkV4cGVjdGVkIChub25lIHwgWyA8ZmxleC1ncm93PiA8ZmxleC1zaHJpbms+PyB8fCA8ZmxleC1iYXNpcz4gXSkgYnV0IGZvdW5kICdcIiArIGV4cHJlc3Npb24udmFsdWUudGV4dCArIFwiJy5cIiwgcGFydC5saW5lLCBwYXJ0LmNvbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5wYXJzZXJsaWIuY3NzID0ge1xuX19wcm90b19fICAgICAgICAgICA6bnVsbCxcbkNvbG9ycyAgICAgICAgICAgICAgOkNvbG9ycyxcbkNvbWJpbmF0b3IgICAgICAgICAgOkNvbWJpbmF0b3IsXG5QYXJzZXIgICAgICAgICAgICAgIDpQYXJzZXIsXG5Qcm9wZXJ0eU5hbWUgICAgICAgIDpQcm9wZXJ0eU5hbWUsXG5Qcm9wZXJ0eVZhbHVlICAgICAgIDpQcm9wZXJ0eVZhbHVlLFxuUHJvcGVydHlWYWx1ZVBhcnQgICA6UHJvcGVydHlWYWx1ZVBhcnQsXG5NZWRpYUZlYXR1cmUgICAgICAgIDpNZWRpYUZlYXR1cmUsXG5NZWRpYVF1ZXJ5ICAgICAgICAgIDpNZWRpYVF1ZXJ5LFxuU2VsZWN0b3IgICAgICAgICAgICA6U2VsZWN0b3IsXG5TZWxlY3RvclBhcnQgICAgICAgIDpTZWxlY3RvclBhcnQsXG5TZWxlY3RvclN1YlBhcnQgICAgIDpTZWxlY3RvclN1YlBhcnQsXG5TcGVjaWZpY2l0eSAgICAgICAgIDpTcGVjaWZpY2l0eSxcblRva2VuU3RyZWFtICAgICAgICAgOlRva2VuU3RyZWFtLFxuVG9rZW5zICAgICAgICAgICAgICA6VG9rZW5zLFxuVmFsaWRhdGlvbkVycm9yICAgICA6VmFsaWRhdGlvbkVycm9yXG59O1xufSkoKTtcblxuKGZ1bmN0aW9uKCl7XG4vKiBqc2hpbnQgZm9yaW46ZmFsc2UgKi9cbmZvcih2YXIgcHJvcCBpbiBwYXJzZXJsaWIpe1xuZXhwb3J0c1twcm9wXSA9IHBhcnNlcmxpYltwcm9wXTtcbn1cbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL2Nzc3BhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVVJMID0gcmVxdWlyZSgnLi9VUkwnKTtcbnZhciBVUkxVdGlscyA9IHJlcXVpcmUoJy4vVVJMVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhdGlvbjtcblxuZnVuY3Rpb24gTG9jYXRpb24od2luZG93LCBocmVmKSB7XG4gIHRoaXMuX3dpbmRvdyA9IHdpbmRvdztcbiAgdGhpcy5faHJlZiA9IGhyZWY7XG59XG5cbkxvY2F0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVVJMVXRpbHMucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBMb2NhdGlvbiB9LFxuXG4gIC8vIFNwZWNpYWwgYmVoYXZpb3Igd2hlbiBocmVmIGlzIHNldFxuICBocmVmOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2hyZWY7IH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7IHRoaXMuYXNzaWduKHYpOyB9XG4gIH0sXG5cbiAgYXNzaWduOiB7IHZhbHVlOiBmdW5jdGlvbih1cmwpIHtcbiAgICAvLyBSZXNvbHZlIHRoZSBuZXcgdXJsIGFnYWluc3QgdGhlIGN1cnJlbnQgb25lXG4gICAgLy8gWFhYOlxuICAgIC8vIFRoaXMgaXMgbm90IGFjdHVhbGx5IGNvcnJlY3QuIEl0IHNob3VsZCBiZSByZXNvbHZlZCBhZ2FpbnN0XG4gICAgLy8gdGhlIFVSTCBvZiB0aGUgZG9jdW1lbnQgb2YgdGhlIHNjcmlwdC4gRm9yIG5vdywgdGhvdWdoLCBJIG9ubHlcbiAgICAvLyBzdXBwb3J0IGEgc2luZ2xlIHdpbmRvdyBhbmQgdGhlcmUgaXMgb25seSBvbmUgYmFzZSB1cmwuXG4gICAgLy8gU28gdGhpcyBpcyBnb29kIGVub3VnaCBmb3Igbm93LlxuICAgIHZhciBjdXJyZW50ID0gbmV3IFVSTCh0aGlzLl9ocmVmKTtcbiAgICB2YXIgbmV3dXJsID0gY3VycmVudC5yZXNvbHZlKHVybCk7XG5cbiAgICAvLyBTYXZlIHRoZSBuZXcgdXJsXG4gICAgdGhpcy5faHJlZiA9IG5ld3VybDtcblxuICAgIC8vIFN0YXJ0IGxvYWRpbmcgdGhlIG5ldyBkb2N1bWVudCFcbiAgICAvLyBYWFhcbiAgICAvLyBUaGlzIGlzIGp1c3Qgc29tZXRoaW5nIGhhY2tlZCB0b2dldGhlci5cbiAgICAvLyBUaGUgcmVhbCBhbGdvcml0aG0gaXM6IGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2hpc3RvcnkuaHRtbCNuYXZpZ2F0ZVxuICB9fSxcblxuICByZXBsYWNlOiB7IHZhbHVlOiBmdW5jdGlvbih1cmwpIHtcbiAgICAvLyBYWFhcbiAgICAvLyBTaW5jZSB3ZSBhcmVuJ3QgdHJhY2tpbmcgaGlzdG9yeSB5ZXQsIHJlcGxhY2UgaXMgdGhlIHNhbWUgYXMgYXNzaWduXG4gICAgdGhpcy5hc3NpZ24odXJsKTtcbiAgfX0sXG5cbiAgcmVsb2FkOiB7IHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAvLyBYWFg6XG4gICAgLy8gQWN0dWFsbHksIHRoZSBzcGVjIGlzIGEgbG90IG1vcmUgY29tcGxpY2F0ZWQgdGhhbiB0aGlzXG4gICAgdGhpcy5hc3NpZ24odGhpcy5ocmVmKTtcbiAgfX0sXG5cbiAgdG9TdHJpbmc6IHsgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmhyZWY7XG4gIH19XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZG9taW5vL2xpYi9Mb2NhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNuYXZpZ2F0b3JpZFxudmFyIE5hdmlnYXRvcklEID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gIGFwcENvZGVOYW1lOiB7IHZhbHVlOiBcIk1vemlsbGFcIiB9LFxuICBhcHBOYW1lOiB7IHZhbHVlOiBcIk5ldHNjYXBlXCIgfSxcbiAgYXBwVmVyc2lvbjogeyB2YWx1ZTogXCI0LjBcIiB9LFxuICBwbGF0Zm9ybTogeyB2YWx1ZTogXCJcIiB9LFxuICBwcm9kdWN0OiB7IHZhbHVlOiBcIkdlY2tvXCIgfSxcbiAgcHJvZHVjdFN1YjogeyB2YWx1ZTogXCIyMDEwMDEwMVwiIH0sXG4gIHVzZXJBZ2VudDogeyB2YWx1ZTogXCJcIiB9LFxuICB2ZW5kb3I6IHsgdmFsdWU6IFwiXCIgfSxcbiAgdmVuZG9yU3ViOiB7IHZhbHVlOiBcIlwiIH0sXG4gIHRhaW50RW5hYmxlZDogeyB2YWx1ZTogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYXZpZ2F0b3JJRDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvTmF2aWdhdG9ySUQuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjd2luZG93dGltZXJzXG52YXIgV2luZG93VGltZXJzID0ge1xuICBzZXRUaW1lb3V0OiBzZXRUaW1lb3V0LFxuICBjbGVhclRpbWVvdXQ6IGNsZWFyVGltZW91dCxcbiAgc2V0SW50ZXJ2YWw6IHNldEludGVydmFsLFxuICBjbGVhckludGVydmFsOiBjbGVhckludGVydmFsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpbmRvd1RpbWVycztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbWluby9saWIvV2luZG93VGltZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBWQUxVRTogMSwgLy8gVGhlIHZhbHVlIG9mIGEgVGV4dCwgQ29tbWVudCBvciBQSSBub2RlIGNoYW5nZWRcbiAgQVRUUjogMiwgLy8gQSBuZXcgYXR0cmlidXRlIHdhcyBhZGRlZCBvciBhbiBhdHRyaWJ1dGUgdmFsdWUgYW5kL29yIHByZWZpeCBjaGFuZ2VkXG4gIFJFTU9WRV9BVFRSOiAzLCAvLyBBbiBhdHRyaWJ1dGUgd2FzIHJlbW92ZWRcbiAgUkVNT1ZFOiA0LCAvLyBBIG5vZGUgd2FzIHJlbW92ZWRcbiAgTU9WRTogNSwgLy8gQSBub2RlIHdhcyBtb3ZlZFxuICBJTlNFUlQ6IDYgLy8gQSBub2RlIChvciBhIHN1YnRyZWUgb2Ygbm9kZXMpIHdhcyBpbnNlcnRlZFxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kb21pbm8vbGliL011dGF0aW9uQ29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgSW52YWxpZFN0YXRlRXJyb3IsIE5ldHdvcmtFcnJvciwgUHJvZ3Jlc3NFdmVudCwgU2VjdXJpdHlFcnJvciwgU3ludGF4RXJyb3IsIFhNTEh0dHBSZXF1ZXN0LCBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LCBYTUxIdHRwUmVxdWVzdFVwbG9hZCwgaHR0cCwgaHR0cHMsIG9zLCB1cmwsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQoKSB7XG4gICAgICB0aGlzLm9ubG9hZHN0YXJ0ID0gbnVsbDtcbiAgICAgIHRoaXMub25wcm9ncmVzcyA9IG51bGw7XG4gICAgICB0aGlzLm9uYWJvcnQgPSBudWxsO1xuICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMub25sb2FkID0gbnVsbDtcbiAgICAgIHRoaXMub250aW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMub25sb2FkZW5kID0gbnVsbDtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIH1cblxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLm9ubG9hZHN0YXJ0ID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLm9ucHJvZ3Jlc3MgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUub25hYm9ydCA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbmVycm9yID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLm9ubG9hZCA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbnRpbWVvdXQgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUub25sb2FkZW5kID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgYmFzZTtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgKGJhc2UgPSB0aGlzLl9saXN0ZW5lcnMpW2V2ZW50VHlwZV0gfHwgKGJhc2VbZXZlbnRUeXBlXSA9IFtdKTtcbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBpbmRleDtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0uaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBldmVudFR5cGUsIGosIGxlbiwgbGlzdGVuZXIsIGxpc3RlbmVycztcbiAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBldmVudC50YXJnZXQgPSB0aGlzO1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnQudHlwZTtcbiAgICAgIGlmIChsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSkge1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1tqXTtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpc3RlbmVyID0gdGhpc1tcIm9uXCIgKyBldmVudFR5cGVdKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQ7XG5cbiAgfSkoKTtcblxuICBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuXG4gIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcblxuICBvcyA9IHJlcXVpcmUoJ29zJyk7XG5cbiAgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbiAgWE1MSHR0cFJlcXVlc3QgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxIdHRwUmVxdWVzdCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxIdHRwUmVxdWVzdChvcHRpb25zKSB7XG4gICAgICBYTUxIdHRwUmVxdWVzdC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX2Fub255bW91cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbm9uO1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gWE1MSHR0cFJlcXVlc3QuVU5TRU5UO1xuICAgICAgdGhpcy5yZXNwb25zZSA9IG51bGw7XG4gICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9ICcnO1xuICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSAnJztcbiAgICAgIHRoaXMucmVzcG9uc2VVUkwgPSAnJztcbiAgICAgIHRoaXMuc3RhdHVzID0gMDtcbiAgICAgIHRoaXMuc3RhdHVzVGV4dCA9ICcnO1xuICAgICAgdGhpcy50aW1lb3V0ID0gMDtcbiAgICAgIHRoaXMudXBsb2FkID0gbmV3IFhNTEh0dHBSZXF1ZXN0VXBsb2FkKHRoaXMpO1xuICAgICAgdGhpcy5fbWV0aG9kID0gbnVsbDtcbiAgICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgICB0aGlzLl9zeW5jID0gZmFsc2U7XG4gICAgICB0aGlzLl9oZWFkZXJzID0gbnVsbDtcbiAgICAgIHRoaXMuX2xvd2VyZWRIZWFkZXJzID0gbnVsbDtcbiAgICAgIHRoaXMuX21pbWVPdmVycmlkZSA9IG51bGw7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlUGFydHMgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzID0gbnVsbDtcbiAgICAgIHRoaXMuX2Fib3J0aW5nID0gbnVsbDtcbiAgICAgIHRoaXMuX2Vycm9yID0gbnVsbDtcbiAgICAgIHRoaXMuX2xvYWRlZEJ5dGVzID0gMDtcbiAgICAgIHRoaXMuX3RvdGFsQnl0ZXMgPSAwO1xuICAgICAgdGhpcy5fbGVuZ3RoQ29tcHV0YWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnJlYWR5U3RhdGUgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnJlc3BvbnNlID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25zZVRleHQgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc3RhdHVzID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS50aW1lb3V0ID0gbnVsbDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS51cGxvYWQgPSBudWxsO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIHBhc3N3b3JkKSB7XG4gICAgICB2YXIgeGhyVXJsO1xuICAgICAgbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAobWV0aG9kIGluIHRoaXMuX3Jlc3RyaWN0ZWRNZXRob2RzKSB7XG4gICAgICAgIHRocm93IG5ldyBTZWN1cml0eUVycm9yKFwiSFRUUCBtZXRob2QgXCIgKyBtZXRob2QgKyBcIiBpcyBub3QgYWxsb3dlZCBpbiBYSFJcIik7XG4gICAgICB9XG4gICAgICB4aHJVcmwgPSB0aGlzLl9wYXJzZVVybCh1cmwpO1xuICAgICAgaWYgKGFzeW5jID09PSB2b2lkIDApIHtcbiAgICAgICAgYXN5bmMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgY2FzZSBYTUxIdHRwUmVxdWVzdC5VTlNFTlQ6XG4gICAgICAgIGNhc2UgWE1MSHR0cFJlcXVlc3QuT1BFTkVEOlxuICAgICAgICBjYXNlIFhNTEh0dHBSZXF1ZXN0LkRPTkU6XG4gICAgICAgICAgbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBYTUxIdHRwUmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEOlxuICAgICAgICBjYXNlIFhNTEh0dHBSZXF1ZXN0LkxPQURJTkc6XG4gICAgICAgICAgbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21ldGhvZCA9IG1ldGhvZDtcbiAgICAgIHRoaXMuX3VybCA9IHhoclVybDtcbiAgICAgIHRoaXMuX3N5bmMgPSAhYXN5bmM7XG4gICAgICB0aGlzLl9oZWFkZXJzID0ge307XG4gICAgICB0aGlzLl9sb3dlcmVkSGVhZGVycyA9IHt9O1xuICAgICAgdGhpcy5fbWltZU92ZXJyaWRlID0gbnVsbDtcbiAgICAgIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuT1BFTkVEKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzcG9uc2UgPSBudWxsO1xuICAgICAgdGhpcy5zdGF0dXMgPSAwO1xuICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gJyc7XG4gICAgICB0aGlzLl9yZXNwb25zZVBhcnRzID0gW107XG4gICAgICB0aGlzLl9yZXNwb25zZUhlYWRlcnMgPSBudWxsO1xuICAgICAgdGhpcy5fbG9hZGVkQnl0ZXMgPSAwO1xuICAgICAgdGhpcy5fdG90YWxCeXRlcyA9IDA7XG4gICAgICB0aGlzLl9sZW5ndGhDb21wdXRhYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgbG93ZXJlZE5hbWU7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5PUEVORUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0ZUVycm9yKFwiWEhSIHJlYWR5U3RhdGUgbXVzdCBiZSBPUEVORURcIik7XG4gICAgICB9XG4gICAgICBsb3dlcmVkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh0aGlzLl9yZXN0cmljdGVkSGVhZGVyc1tsb3dlcmVkTmFtZV0gfHwgL15zZWNcXC0vLnRlc3QobG93ZXJlZE5hbWUpIHx8IC9ecHJveHktLy50ZXN0KGxvd2VyZWROYW1lKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJSZWZ1c2VkIHRvIHNldCB1bnNhZmUgaGVhZGVyIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIik7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICBpZiAobG93ZXJlZE5hbWUgaW4gdGhpcy5fbG93ZXJlZEhlYWRlcnMpIHtcbiAgICAgICAgbmFtZSA9IHRoaXMuX2xvd2VyZWRIZWFkZXJzW2xvd2VyZWROYW1lXTtcbiAgICAgICAgdGhpcy5faGVhZGVyc1tuYW1lXSA9IHRoaXMuX2hlYWRlcnNbbmFtZV0gKyAnLCAnICsgdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sb3dlcmVkSGVhZGVyc1tsb3dlcmVkTmFtZV0gPSBuYW1lO1xuICAgICAgICB0aGlzLl9oZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXRlRXJyb3IoXCJYSFIgcmVhZHlTdGF0ZSBtdXN0IGJlIE9QRU5FRFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcihcInNlbmQoKSBhbHJlYWR5IGNhbGxlZFwiKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhpcy5fdXJsLnByb3RvY29sKSB7XG4gICAgICAgIGNhc2UgJ2ZpbGU6JzpcbiAgICAgICAgICB0aGlzLl9zZW5kRmlsZShkYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaHR0cDonOlxuICAgICAgICBjYXNlICdodHRwczonOlxuICAgICAgICAgIHRoaXMuX3NlbmRIdHRwKGRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoXCJVbnN1cHBvcnRlZCBwcm90b2NvbCBcIiArIHRoaXMuX3VybC5wcm90b2NvbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXF1ZXN0LmFib3J0KCk7XG4gICAgICB0aGlzLl9zZXRFcnJvcigpO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnYWJvcnQnKTtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBsb3dlcmVkTmFtZTtcbiAgICAgIGlmICghdGhpcy5fcmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbG93ZXJlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJlZE5hbWUgaW4gdGhpcy5fcmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZUhlYWRlcnNbbG93ZXJlZE5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lcywgbmFtZSwgdmFsdWU7XG4gICAgICBpZiAoIXRoaXMuX3Jlc3BvbnNlSGVhZGVycykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBsaW5lcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVzdWx0cztcbiAgICAgICAgcmVmID0gdGhpcy5fcmVzcG9uc2VIZWFkZXJzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgICB2YWx1ZSA9IHJlZltuYW1lXTtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmFtZSArIFwiOiBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gbGluZXMuam9pbihcIlxcclxcblwiKTtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm92ZXJyaWRlTWltZVR5cGUgPSBmdW5jdGlvbihuZXdNaW1lVHlwZSkge1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuTE9BRElORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0ZUVycm9yKFwib3ZlcnJpZGVNaW1lVHlwZSgpIG5vdCBhbGxvd2VkIGluIExPQURJTkcgb3IgRE9ORVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21pbWVPdmVycmlkZSA9IG5ld01pbWVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUubm9kZWpzU2V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGJhc2VVcmwsIHBhcnNlZFVybDtcbiAgICAgIGlmICgnaHR0cEFnZW50JyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubm9kZWpzSHR0cEFnZW50ID0gb3B0aW9ucy5odHRwQWdlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoJ2h0dHBzQWdlbnQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ub2RlanNIdHRwc0FnZW50ID0gb3B0aW9ucy5odHRwc0FnZW50O1xuICAgICAgfVxuICAgICAgaWYgKCdiYXNlVXJsJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGJhc2VVcmwgPSBvcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIGlmIChiYXNlVXJsICE9PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VkVXJsID0gdXJsLnBhcnNlKGJhc2VVcmwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIXBhcnNlZFVybC5wcm90b2NvbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiYmFzZVVybCBtdXN0IGJlIGFuIGFic29sdXRlIFVSTFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlanNCYXNlVXJsID0gYmFzZVVybDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0Lm5vZGVqc1NldCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ub2RlanNTZXQob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuVU5TRU5UID0gMDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LlVOU0VOVCA9IDA7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuT1BFTkVEID0gMTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCA9IDE7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuSEVBREVSU19SRUNFSVZFRCA9IDI7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEID0gMjtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5MT0FESU5HID0gMztcblxuICAgIFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcgPSAzO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLkRPTkUgPSA0O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QuRE9ORSA9IDQ7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUubm9kZWpzSHR0cEFnZW50ID0gaHR0cC5nbG9iYWxBZ2VudDtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ub2RlanNIdHRwc0FnZW50ID0gaHR0cHMuZ2xvYmFsQWdlbnQ7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUubm9kZWpzQmFzZVVybCA9IG51bGw7XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3Jlc3RyaWN0ZWRNZXRob2RzID0ge1xuICAgICAgQ09OTkVDVDogdHJ1ZSxcbiAgICAgIFRSQUNFOiB0cnVlLFxuICAgICAgVFJBQ0s6IHRydWVcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9yZXN0cmljdGVkSGVhZGVycyA9IHtcbiAgICAgICdhY2NlcHQtY2hhcnNldCc6IHRydWUsXG4gICAgICAnYWNjZXB0LWVuY29kaW5nJzogdHJ1ZSxcbiAgICAgICdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnOiB0cnVlLFxuICAgICAgJ2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kJzogdHJ1ZSxcbiAgICAgIGNvbm5lY3Rpb246IHRydWUsXG4gICAgICAnY29udGVudC1sZW5ndGgnOiB0cnVlLFxuICAgICAgY29va2llOiB0cnVlLFxuICAgICAgY29va2llMjogdHJ1ZSxcbiAgICAgIGRhdGU6IHRydWUsXG4gICAgICBkbnQ6IHRydWUsXG4gICAgICBleHBlY3Q6IHRydWUsXG4gICAgICBob3N0OiB0cnVlLFxuICAgICAgJ2tlZXAtYWxpdmUnOiB0cnVlLFxuICAgICAgb3JpZ2luOiB0cnVlLFxuICAgICAgcmVmZXJlcjogdHJ1ZSxcbiAgICAgIHRlOiB0cnVlLFxuICAgICAgdHJhaWxlcjogdHJ1ZSxcbiAgICAgICd0cmFuc2Zlci1lbmNvZGluZyc6IHRydWUsXG4gICAgICB1cGdyYWRlOiB0cnVlLFxuICAgICAgJ3VzZXItYWdlbnQnOiB0cnVlLFxuICAgICAgdmlhOiB0cnVlXG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcHJpdmF0ZUhlYWRlcnMgPSB7XG4gICAgICAnc2V0LWNvb2tpZSc6IHRydWUsXG4gICAgICAnc2V0LWNvb2tpZTInOiB0cnVlXG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fdXNlckFnZW50ID0gKFwiTW96aWxsYS81LjAgKFwiICsgKG9zLnR5cGUoKSkgKyBcIiBcIiArIChvcy5hcmNoKCkpICsgXCIpIFwiKSArIChcIm5vZGUuanMvXCIgKyBwcm9jZXNzLnZlcnNpb25zLm5vZGUgKyBcIiB2OC9cIiArIHByb2Nlc3MudmVyc2lvbnMudjgpO1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9zZXRSZWFkeVN0YXRlID0gZnVuY3Rpb24obmV3UmVhZHlTdGF0ZSkge1xuICAgICAgdmFyIGV2ZW50O1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gbmV3UmVhZHlTdGF0ZTtcbiAgICAgIGV2ZW50ID0gbmV3IFByb2dyZXNzRXZlbnQoJ3JlYWR5c3RhdGVjaGFuZ2UnKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NlbmRGaWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fdXJsLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcignVGhlIGZpbGUgcHJvdG9jb2wgb25seSBzdXBwb3J0cyBHRVQnKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3RvY29sIGZpbGU6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9zZW5kSHR0cCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9zeW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIFhIUiBwcm9jZXNzaW5nIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICgoZGF0YSAhPSBudWxsKSAmJiAodGhpcy5fbWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLl9tZXRob2QgPT09ICdIRUFEJykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRGlzY2FyZGluZyBlbnRpdHkgYm9keSBmb3IgXCIgKyB0aGlzLl9tZXRob2QgKyBcIiByZXF1ZXN0c1wiKTtcbiAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhIHx8IChkYXRhID0gJycpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGxvYWQuX3NldERhdGEoZGF0YSk7XG4gICAgICB0aGlzLl9maW5hbGl6ZUhlYWRlcnMoKTtcbiAgICAgIHRoaXMuX3NlbmRIeHhwUmVxdWVzdCgpO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9zZW5kSHh4cFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhZ2VudCwgaHh4cCwgcmVxdWVzdDtcbiAgICAgIGlmICh0aGlzLl91cmwucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgICAgaHh4cCA9IGh0dHA7XG4gICAgICAgIGFnZW50ID0gdGhpcy5ub2RlanNIdHRwQWdlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoeHhwID0gaHR0cHM7XG4gICAgICAgIGFnZW50ID0gdGhpcy5ub2RlanNIdHRwc0FnZW50O1xuICAgICAgfVxuICAgICAgcmVxdWVzdCA9IGh4eHAucmVxdWVzdCh7XG4gICAgICAgIGhvc3RuYW1lOiB0aGlzLl91cmwuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHRoaXMuX3VybC5wb3J0LFxuICAgICAgICBwYXRoOiB0aGlzLl91cmwucGF0aCxcbiAgICAgICAgYXV0aDogdGhpcy5fdXJsLmF1dGgsXG4gICAgICAgIG1ldGhvZDogdGhpcy5fbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLl9oZWFkZXJzLFxuICAgICAgICBhZ2VudDogYWdlbnRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgIHJlcXVlc3Quc2V0VGltZW91dCh0aGlzLnRpbWVvdXQsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fb25IdHRwVGltZW91dChyZXF1ZXN0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXF1ZXN0Lm9uKCdyZXNwb25zZScsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX29uSHR0cFJlc3BvbnNlKHJlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fb25IdHRwUmVxdWVzdEVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHRoaXMudXBsb2FkLl9zdGFydFVwbG9hZChyZXF1ZXN0KTtcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ID09PSByZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRzdGFydCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9maW5hbGl6ZUhlYWRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2hlYWRlcnNbJ0Nvbm5lY3Rpb24nXSA9ICdrZWVwLWFsaXZlJztcbiAgICAgIHRoaXMuX2hlYWRlcnNbJ0hvc3QnXSA9IHRoaXMuX3VybC5ob3N0O1xuICAgICAgaWYgKHRoaXMuX2Fub255bW91cykge1xuICAgICAgICB0aGlzLl9oZWFkZXJzWydSZWZlcmVyJ10gPSAnYWJvdXQ6YmxhbmsnO1xuICAgICAgfVxuICAgICAgdGhpcy5faGVhZGVyc1snVXNlci1BZ2VudCddID0gdGhpcy5fdXNlckFnZW50O1xuICAgICAgdGhpcy51cGxvYWQuX2ZpbmFsaXplSGVhZGVycyh0aGlzLl9oZWFkZXJzLCB0aGlzLl9sb3dlcmVkSGVhZGVycyk7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlc3BvbnNlID0gZnVuY3Rpb24ocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgIHZhciBsZW5ndGhTdHJpbmc7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdCAhPT0gcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgY2FzZSAzMDE6XG4gICAgICAgIGNhc2UgMzAyOlxuICAgICAgICBjYXNlIDMwMzpcbiAgICAgICAgY2FzZSAzMDc6XG4gICAgICAgIGNhc2UgMzA4OlxuICAgICAgICAgIHRoaXMuX3VybCA9IHRoaXMuX3BhcnNlVXJsKHJlc3BvbnNlLmhlYWRlcnNbJ2xvY2F0aW9uJ10pO1xuICAgICAgICAgIHRoaXMuX21ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgIGlmICgnY29udGVudC10eXBlJyBpbiB0aGlzLl9sb3dlcmVkSGVhZGVycykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNbdGhpcy5fbG93ZXJlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb3dlcmVkSGVhZGVyc1snY29udGVudC10eXBlJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnQ29udGVudC1UeXBlJyBpbiB0aGlzLl9oZWFkZXJzKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJzWydDb250ZW50LUxlbmd0aCddO1xuICAgICAgICAgIHRoaXMudXBsb2FkLl9yZXNldCgpO1xuICAgICAgICAgIHRoaXMuX2ZpbmFsaXplSGVhZGVycygpO1xuICAgICAgICAgIHRoaXMuX3NlbmRIeHhwUmVxdWVzdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICB0aGlzLl9yZXNwb25zZS5vbignZGF0YScsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fb25IdHRwUmVzcG9uc2VEYXRhKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlLm9uKCdlbmQnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fb25IdHRwUmVzcG9uc2VFbmQocmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgdGhpcy5fcmVzcG9uc2Uub24oJ2Nsb3NlJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX29uSHR0cFJlc3BvbnNlQ2xvc2UocmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgdGhpcy5yZXNwb25zZVVSTCA9IHRoaXMuX3VybC5ocmVmLnNwbGl0KCcjJylbMF07XG4gICAgICB0aGlzLnN0YXR1cyA9IHRoaXMuX3Jlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICB0aGlzLnN0YXR1c1RleHQgPSBodHRwLlNUQVRVU19DT0RFU1t0aGlzLnN0YXR1c107XG4gICAgICB0aGlzLl9wYXJzZVJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gICAgICBpZiAobGVuZ3RoU3RyaW5nID0gdGhpcy5fcmVzcG9uc2VIZWFkZXJzWydjb250ZW50LWxlbmd0aCddKSB7XG4gICAgICAgIHRoaXMuX3RvdGFsQnl0ZXMgPSBwYXJzZUludChsZW5ndGhTdHJpbmcpO1xuICAgICAgICB0aGlzLl9sZW5ndGhDb21wdXRhYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2xlbmd0aENvbXB1dGFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQpO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlc3BvbnNlRGF0YSA9IGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fcmVzcG9uc2UgIT09IHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc3BvbnNlUGFydHMucHVzaChkYXRhKTtcbiAgICAgIHRoaXMuX2xvYWRlZEJ5dGVzICs9IGRhdGEubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuTE9BRElORykge1xuICAgICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ3Byb2dyZXNzJyk7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwUmVzcG9uc2VFbmQgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgaWYgKHRoaXMuX3Jlc3BvbnNlICE9PSByZXNwb25zZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXJzZVJlc3BvbnNlKCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcbiAgICAgIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuRE9ORSk7XG4gICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkJyk7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZGVuZCcpO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlc3BvbnNlQ2xvc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgdmFyIHJlcXVlc3Q7XG4gICAgICBpZiAodGhpcy5fcmVzcG9uc2UgIT09IHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3QgPSB0aGlzLl9yZXF1ZXN0O1xuICAgICAgdGhpcy5fc2V0RXJyb3IoKTtcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuRE9ORSk7XG4gICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdlcnJvcicpO1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9vbkh0dHBUaW1lb3V0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgaWYgKHRoaXMuX3JlcXVlc3QgIT09IHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0RXJyb3IoKTtcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuRE9ORSk7XG4gICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCd0aW1lb3V0Jyk7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZGVuZCcpO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlcXVlc3RFcnJvciA9IGZ1bmN0aW9uKHJlcXVlc3QsIGVycm9yKSB7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdCAhPT0gcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRFcnJvcigpO1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5ET05FKTtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2Vycm9yJyk7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hQcm9ncmVzcygnbG9hZGVuZCcpO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX2Rpc3BhdGNoUHJvZ3Jlc3MgPSBmdW5jdGlvbihldmVudFR5cGUpIHtcbiAgICAgIHZhciBldmVudDtcbiAgICAgIGV2ZW50ID0gbmV3IFByb2dyZXNzRXZlbnQoZXZlbnRUeXBlKTtcbiAgICAgIGV2ZW50Lmxlbmd0aENvbXB1dGFibGUgPSB0aGlzLl9sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgZXZlbnQubG9hZGVkID0gdGhpcy5fbG9hZGVkQnl0ZXM7XG4gICAgICBldmVudC50b3RhbCA9IHRoaXMuX3RvdGFsQnl0ZXM7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9zZXRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNwb25zZSA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNwb25zZUhlYWRlcnMgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzcG9uc2VQYXJ0cyA9IG51bGw7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3BhcnNlVXJsID0gZnVuY3Rpb24odXJsU3RyaW5nKSB7XG4gICAgICB2YXIgYWJzb2x1dGVVcmxTdHJpbmcsIGluZGV4LCBwYXNzd29yZCwgdXNlciwgeGhyVXJsO1xuICAgICAgaWYgKHRoaXMubm9kZWpzQmFzZVVybCA9PT0gbnVsbCkge1xuICAgICAgICBhYnNvbHV0ZVVybFN0cmluZyA9IHVybFN0cmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFic29sdXRlVXJsU3RyaW5nID0gdXJsLnJlc29sdmUodGhpcy5ub2RlanNCYXNlVXJsLCB1cmxTdHJpbmcpO1xuICAgICAgfVxuICAgICAgeGhyVXJsID0gdXJsLnBhcnNlKGFic29sdXRlVXJsU3RyaW5nLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB4aHJVcmwuaGFzaCA9IG51bGw7XG4gICAgICBpZiAoeGhyVXJsLmF1dGggJiYgKCh0eXBlb2YgdXNlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB1c2VyICE9PSBudWxsKSB8fCAodHlwZW9mIHBhc3N3b3JkICE9PSBcInVuZGVmaW5lZFwiICYmIHBhc3N3b3JkICE9PSBudWxsKSkpIHtcbiAgICAgICAgaW5kZXggPSB4aHJVcmwuYXV0aC5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgIHVzZXIgPSB4aHJVcmwuYXV0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICB1c2VyID0geGhyVXJsLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcGFzc3dvcmQpIHtcbiAgICAgICAgICAgIHBhc3N3b3JkID0geGhyVXJsLnN1YnN0cmluZyhpbmRleCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVzZXIgfHwgcGFzc3dvcmQpIHtcbiAgICAgICAgeGhyVXJsLmF1dGggPSB1c2VyICsgXCI6XCIgKyBwYXNzd29yZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4aHJVcmw7XG4gICAgfTtcblxuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgdmFyIGxvd2VyZWROYW1lLCBuYW1lLCByZWYsIHZhbHVlO1xuICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzID0ge307XG4gICAgICByZWYgPSByZXNwb25zZS5oZWFkZXJzO1xuICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICB2YWx1ZSA9IHJlZltuYW1lXTtcbiAgICAgICAgbG93ZXJlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlSGVhZGVyc1tsb3dlcmVkTmFtZV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbWltZU92ZXJyaWRlICE9PSBudWxsICYmIGxvd2VyZWROYW1lID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5fbWltZU92ZXJyaWRlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVyc1tsb3dlcmVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9taW1lT3ZlcnJpZGUgIT09IG51bGwgJiYgISgnY29udGVudC10eXBlJyBpbiB0aGlzLl9yZXNwb25zZUhlYWRlcnMpKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVyc1snY29udGVudC10eXBlJ10gPSB0aGlzLl9taW1lT3ZlcnJpZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3BhcnNlUmVzcG9uc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcnJheUJ1ZmZlciwgYnVmZmVyLCBpLCBqLCBqc29uRXJyb3IsIHJlZiwgdmlldztcbiAgICAgIGlmIChCdWZmZXIuY29uY2F0KSB7XG4gICAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQodGhpcy5fcmVzcG9uc2VQYXJ0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIgPSB0aGlzLl9jb25jYXRCdWZmZXJzKHRoaXMuX3Jlc3BvbnNlUGFydHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVzcG9uc2VQYXJ0cyA9IG51bGw7XG4gICAgICBzd2l0Y2ggKHRoaXMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgIHRoaXMuX3BhcnNlVGV4dFJlc3BvbnNlKGJ1ZmZlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gbnVsbDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IEpTT04ucGFyc2UoYnVmZmVyLnRvU3RyaW5nKCd1dGYtOCcpKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICAgIGpzb25FcnJvciA9IGVycm9yMTtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5yZXNwb25zZSA9IGJ1ZmZlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gbnVsbDtcbiAgICAgICAgICBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBidWZmZXIubGVuZ3RoOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBhcnJheUJ1ZmZlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLl9wYXJzZVRleHRSZXNwb25zZShidWZmZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wYXJzZVRleHRSZXNwb25zZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgdmFyIGU7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IGJ1ZmZlci50b1N0cmluZyh0aGlzLl9wYXJzZVJlc3BvbnNlRW5jb2RpbmcoKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgZSA9IGVycm9yMTtcbiAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBidWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNwb25zZSA9IHRoaXMucmVzcG9uc2VUZXh0O1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlRW5jb2RpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb250ZW50VHlwZSwgZW5jb2RpbmcsIG1hdGNoO1xuICAgICAgZW5jb2RpbmcgPSBudWxsO1xuICAgICAgaWYgKGNvbnRlbnRUeXBlID0gdGhpcy5fcmVzcG9uc2VIZWFkZXJzWydjb250ZW50LXR5cGUnXSkge1xuICAgICAgICBpZiAobWF0Y2ggPSAvXFw7XFxzKmNoYXJzZXRcXD0oLiopJC8uZXhlYyhjb250ZW50VHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAndXRmLTgnO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX2NvbmNhdEJ1ZmZlcnMgPSBmdW5jdGlvbihidWZmZXJzKSB7XG4gICAgICB2YXIgYnVmZmVyLCBqLCBrLCBsZW4sIGxlbjEsIGxlbmd0aCwgdGFyZ2V0O1xuICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKDApO1xuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJzWzBdO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGJ1ZmZlcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyc1tqXTtcbiAgICAgICAgbGVuZ3RoICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0YXJnZXQgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgZm9yIChrID0gMCwgbGVuMSA9IGJ1ZmZlcnMubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlcnNba107XG4gICAgICAgIGJ1ZmZlci5jb3B5KHRhcmdldCwgbGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MSHR0cFJlcXVlc3Q7XG5cbiAgfSkoWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxIdHRwUmVxdWVzdDtcblxuICBYTUxIdHRwUmVxdWVzdC5YTUxIdHRwUmVxdWVzdCA9IFhNTEh0dHBSZXF1ZXN0O1xuXG4gIFNlY3VyaXR5RXJyb3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTZWN1cml0eUVycm9yLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFNlY3VyaXR5RXJyb3IoKSB7XG4gICAgICBTZWN1cml0eUVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBTZWN1cml0eUVycm9yO1xuXG4gIH0pKEVycm9yKTtcblxuICBYTUxIdHRwUmVxdWVzdC5TZWN1cml0eUVycm9yID0gU2VjdXJpdHlFcnJvcjtcblxuICBJbnZhbGlkU3RhdGVFcnJvciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEludmFsaWRTdGF0ZUVycm9yLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIEludmFsaWRTdGF0ZUVycm9yKCkge1xuICAgICAgSW52YWxpZFN0YXRlRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEludmFsaWRTdGF0ZUVycm9yO1xuXG4gIH0pKEVycm9yKTtcblxuICBJbnZhbGlkU3RhdGVFcnJvciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEludmFsaWRTdGF0ZUVycm9yLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIEludmFsaWRTdGF0ZUVycm9yKCkge1xuICAgICAgcmV0dXJuIEludmFsaWRTdGF0ZUVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBJbnZhbGlkU3RhdGVFcnJvcjtcblxuICB9KShFcnJvcik7XG5cbiAgWE1MSHR0cFJlcXVlc3QuSW52YWxpZFN0YXRlRXJyb3IgPSBJbnZhbGlkU3RhdGVFcnJvcjtcblxuICBOZXR3b3JrRXJyb3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChOZXR3b3JrRXJyb3IsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gTmV0d29ya0Vycm9yKCkge1xuICAgICAgTmV0d29ya0Vycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBOZXR3b3JrRXJyb3I7XG5cbiAgfSkoRXJyb3IpO1xuXG4gIFhNTEh0dHBSZXF1ZXN0LlN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG5cbiAgU3ludGF4RXJyb3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTeW50YXhFcnJvciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBTeW50YXhFcnJvcigpIHtcbiAgICAgIFN5bnRheEVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBTeW50YXhFcnJvcjtcblxuICB9KShFcnJvcik7XG5cbiAgUHJvZ3Jlc3NFdmVudCA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQcm9ncmVzc0V2ZW50KHR5cGUpIHtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5sZW5ndGhDb21wdXRhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmxvYWRlZCA9IDA7XG4gICAgICB0aGlzLnRvdGFsID0gMDtcbiAgICB9XG5cbiAgICBQcm9ncmVzc0V2ZW50LnByb3RvdHlwZS5idWJibGVzID0gZmFsc2U7XG5cbiAgICBQcm9ncmVzc0V2ZW50LnByb3RvdHlwZS5jYW5jZWxhYmxlID0gZmFsc2U7XG5cbiAgICBQcm9ncmVzc0V2ZW50LnByb3RvdHlwZS50YXJnZXQgPSBudWxsO1xuXG4gICAgUHJvZ3Jlc3NFdmVudC5wcm90b3R5cGUubG9hZGVkID0gbnVsbDtcblxuICAgIFByb2dyZXNzRXZlbnQucHJvdG90eXBlLmxlbmd0aENvbXB1dGFibGUgPSBudWxsO1xuXG4gICAgUHJvZ3Jlc3NFdmVudC5wcm90b3R5cGUudG90YWwgPSBudWxsO1xuXG4gICAgcmV0dXJuIFByb2dyZXNzRXZlbnQ7XG5cbiAgfSkoKTtcblxuICBYTUxIdHRwUmVxdWVzdC5Qcm9ncmVzc0V2ZW50ID0gUHJvZ3Jlc3NFdmVudDtcblxuICBYTUxIdHRwUmVxdWVzdFVwbG9hZCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTEh0dHBSZXF1ZXN0VXBsb2FkLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTEh0dHBSZXF1ZXN0VXBsb2FkKHJlcXVlc3QpIHtcbiAgICAgIFhNTEh0dHBSZXF1ZXN0VXBsb2FkLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICB0aGlzLl9yZXNldCgpO1xuICAgIH1cblxuICAgIFhNTEh0dHBSZXF1ZXN0VXBsb2FkLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gbnVsbDtcbiAgICAgIHRoaXMuX2JvZHkgPSBudWxsO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuXG4gICAgWE1MSHR0cFJlcXVlc3RVcGxvYWQucHJvdG90eXBlLl9zZXREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGJvZHksIGksIGosIGssIG9mZnNldCwgcmVmLCByZWYxLCB2aWV3O1xuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5fY29udGVudFR5cGUgPSAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ib2R5ID0gbmV3IEJ1ZmZlcihkYXRhLCAndXRmOCcpO1xuICAgICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgdGhpcy5fYm9keSA9IGRhdGE7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBib2R5ID0gbmV3IEJ1ZmZlcihkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBkYXRhLmJ5dGVMZW5ndGg7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuICAgICAgICAgIGJvZHlbaV0gPSB2aWV3W2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmJ1ZmZlciAmJiBkYXRhLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGJvZHkgPSBuZXcgQnVmZmVyKGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIG9mZnNldCA9IGRhdGEuYnl0ZU9mZnNldDtcbiAgICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyKTtcbiAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjEgPSBkYXRhLmJ5dGVMZW5ndGg7IDAgPD0gcmVmMSA/IGsgPCByZWYxIDogayA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICBib2R5W2ldID0gdmlld1tpICsgb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNlbmQoKSBkYXRhIFwiICsgZGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdFVwbG9hZC5wcm90b3R5cGUuX2ZpbmFsaXplSGVhZGVycyA9IGZ1bmN0aW9uKGhlYWRlcnMsIGxvd2VyZWRIZWFkZXJzKSB7XG4gICAgICBpZiAodGhpcy5fY29udGVudFR5cGUpIHtcbiAgICAgICAgaWYgKCEoJ2NvbnRlbnQtdHlwZScgaW4gbG93ZXJlZEhlYWRlcnMpKSB7XG4gICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB0aGlzLl9jb250ZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2JvZHkpIHtcbiAgICAgICAgaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IHRoaXMuX2JvZHkubGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBYTUxIdHRwUmVxdWVzdFVwbG9hZC5wcm90b3R5cGUuX3N0YXJ0VXBsb2FkID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgaWYgKHRoaXMuX2JvZHkpIHtcbiAgICAgICAgcmVxdWVzdC53cml0ZSh0aGlzLl9ib2R5KTtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MSHR0cFJlcXVlc3RVcGxvYWQ7XG5cbiAgfSkoWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCk7XG5cbiAgWE1MSHR0cFJlcXVlc3QuWE1MSHR0cFJlcXVlc3RVcGxvYWQgPSBYTUxIdHRwUmVxdWVzdFVwbG9hZDtcblxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3hocjIvbGliL3hocjIuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJodHRwXCJcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiaHR0cHNcIlxuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3NcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJvc1wiXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKSg3OCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2FzcG5ldC1wcmVyZW5kZXJpbmcvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIC4vdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VydmVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tc2VydmVyJztcbmltcG9ydCB7IEFwcE1vZHVsZVNoYXJlZCB9IGZyb20gJy4vYXBwLnNoYXJlZC5tb2R1bGUnO1xuaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2FwcC9hcHAuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBib290c3RyYXA6IFsgQXBwQ29tcG9uZW50IF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBTZXJ2ZXJNb2R1bGUsXG4gICAgICAgIEFwcE1vZHVsZVNoYXJlZFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQXBwTW9kdWxlIHtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2FwcC5zZXJ2ZXIubW9kdWxlLnRzIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEh0dHBDbGllbnRNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBSb3V0ZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG5pbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvYXBwL2FwcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmF2TWVudUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9uYXZtZW51L25hdm1lbnUuY29tcG9uZW50JztcbmltcG9ydCB7IEhvbWVDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvaG9tZS9ob21lLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGZXRjaERhdGFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZmV0Y2hkYXRhL2ZldGNoZGF0YS5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ291bnRlckNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9jb3VudGVyL2NvdW50ZXIuY29tcG9uZW50JztcblxuLy9DYXJ0XG5pbXBvcnQgeyBDYXJ0Q29tcG9uZW50IH0gZnJvbSBcIi4vY29tcG9uZW50cy9jYXJ0L2NhcnQuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBDaGVja291dENvbXBvbmVudCB9IGZyb20gXCIuL2NvbXBvbmVudHMvY2FydC9jaGVja291dC9jaGVja291dC5jb21wb25lbnRcIjtcbmltcG9ydCB7IFByZXZpZXdDb21wb25lbnQgfSBmcm9tIFwiLi9jb21wb25lbnRzL2NhcnQvcHJldmlldy9wcmV2aWV3LmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgUmVjZWlwdENvbXBvbmVudCB9IGZyb20gXCIuL2NvbXBvbmVudHMvY2FydC9yZWNpZXB0L3JlY2VpcHQuY29tcG9uZW50XCI7XG5cblxuLy9TaG9wXG5pbXBvcnQgeyBTaG9wQ29tcG9uZW50IH0gZnJvbSBcIi4vY29tcG9uZW50cy9zaG9wL3Nob3AuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBTaG9wQ29va2Jvb2tzQ29tcG9uZW50IH0gZnJvbSBcIi4vY29tcG9uZW50cy9zaG9wL2Nvb2tib29rcy9jb29rYm9va3MuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBTaG9wQmFraW5nUGxhbmtzQ29tcG9uZW50IH0gZnJvbSBcIi4vY29tcG9uZW50cy9zaG9wL2Jha2luZ3BsYW5rcy9iYWtpbmdwbGFua3MuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBTaG9wQmJxUGxhbmtzQ29tcG9uZW50IH0gZnJvbSBcIi4vY29tcG9uZW50cy9zaG9wL2JicXBsYW5rcy9iYnFwbGFua3MuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBTaG9wTnV0RHJpdmVyQ29tcG9uZW50IH0gZnJvbSBcIi4vY29tcG9uZW50cy9zaG9wL251dGRyaXZlci9udXRkcml2ZXIuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBTaG9wU3BpY2VSdWJzQ29tcG9uZW50IH0gZnJvbSBcIi4vY29tcG9uZW50cy9zaG9wL3NwaWNlcnVicy9zcGljZXJ1YnMuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBTaWRlTWVudUNvbXBvbmVudCB9IGZyb20gXCIuL2NvbXBvbmVudHMvc2hvcC9zaWRlbWVudS5jb21wb25lbnRcIjtcbmltcG9ydCB7IFBsYW5rQ29va2luZ1NlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL3BsYW5rY29va2luZy5zZXJ2aWNlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBBcHBDb21wb25lbnQsXG4gICAgICAgIE5hdk1lbnVDb21wb25lbnQsXG4gICAgICAgIENvdW50ZXJDb21wb25lbnQsXG4gICAgICAgIEZldGNoRGF0YUNvbXBvbmVudCxcbiAgICAgICAgSG9tZUNvbXBvbmVudCxcblxuICAgICAgICBDYXJ0Q29tcG9uZW50LFxuXG4gICAgICAgIFNob3BDb21wb25lbnQsXG4gICAgICAgIFNob3BDb29rYm9va3NDb21wb25lbnQsXG4gICAgICAgIFNob3BCYWtpbmdQbGFua3NDb21wb25lbnQsXG4gICAgICAgIFNob3BCYnFQbGFua3NDb21wb25lbnQsXG4gICAgICAgIFNob3BOdXREcml2ZXJDb21wb25lbnQsXG4gICAgICAgIFNob3BTcGljZVJ1YnNDb21wb25lbnQsXG4gICAgICAgIFNpZGVNZW51Q29tcG9uZW50LFxuICAgICAgICBDaGVja291dENvbXBvbmVudCxcbiAgICAgICAgUHJldmlld0NvbXBvbmVudCxcbiAgICAgICAgUmVjZWlwdENvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEh0dHBDbGllbnRNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSb3V0ZXJNb2R1bGUuZm9yUm9vdChbXG4gICAgICAgICAgICB7IHBhdGg6ICcnLCByZWRpcmVjdFRvOiAnSG9tZScsIHBhdGhNYXRjaDogJ2Z1bGwnIH0sXG4gICAgICAgICAgICB7IHBhdGg6ICdIb21lJywgY29tcG9uZW50OiBIb21lQ29tcG9uZW50IH0sXG4gICAgICAgICAgICB7IHBhdGg6ICdjb3VudGVyJywgY29tcG9uZW50OiBDb3VudGVyQ29tcG9uZW50IH0sXG4gICAgICAgICAgICB7IHBhdGg6ICdmZXRjaC1kYXRhJywgY29tcG9uZW50OiBGZXRjaERhdGFDb21wb25lbnQgfSxcbiAgICAgICAgICAgIHsgcGF0aDogXCJjYXJ0XCIsIGNvbXBvbmVudDogQ2FydENvbXBvbmVudCB9LFxuICAgICAgICAgICAgeyBwYXRoOiBcIkNhcnRcIiwgY29tcG9uZW50OiBDYXJ0Q29tcG9uZW50IH0sXG4gICAgICAgICAgICB7IHBhdGg6IFwiQ2FydC9DaGVja291dFwiLCBjb21wb25lbnQ6IENoZWNrb3V0Q29tcG9uZW50IH0sXG4gICAgICAgICAgICB7IHBhdGg6IFwiQ2FydC9QcmV2aWV3XCIsIGNvbXBvbmVudDogUHJldmlld0NvbXBvbmVudCB9LFxuICAgICAgICAgICAgeyBwYXRoOiBcIkNhcnQvUmVjZWlwdFwiLCBjb21wb25lbnQ6IFJlY2VpcHRDb21wb25lbnQgfSxcbiAgICAgICAgICAgIHsgcGF0aDogXCJzaG9wXCIsIGNvbXBvbmVudDogU2hvcENvbXBvbmVudCB9LFxuICAgICAgICAgICAgeyBwYXRoOiBcIlNob3BcIiwgY29tcG9uZW50OiBTaG9wQ29tcG9uZW50IH0sXG4gICAgICAgICAgICB7IHBhdGg6IFwiU2hvcC9Db29rQm9va3NcIiwgY29tcG9uZW50OiBTaG9wQ29va2Jvb2tzQ29tcG9uZW50IH0sXG4gICAgICAgICAgICB7IHBhdGg6IFwiU2hvcC9CYWtpbmdQbGFua3NcIiwgY29tcG9uZW50OiBTaG9wQmFraW5nUGxhbmtzQ29tcG9uZW50IH0sXG4gICAgICAgICAgICB7IHBhdGg6IFwiU2hvcC9CYnFQbGFua3NcIiwgY29tcG9uZW50OiBTaG9wQmJxUGxhbmtzQ29tcG9uZW50IH0sXG4gICAgICAgICAgICB7IHBhdGg6IFwiU2hvcC9OdXREcml2ZXJcIiwgY29tcG9uZW50OiBTaG9wTnV0RHJpdmVyQ29tcG9uZW50IH0sXG4gICAgICAgICAgICB7IHBhdGg6IFwiU2hvcC9TcGljZVJ1YnNcIiwgY29tcG9uZW50OiBTaG9wU3BpY2VSdWJzQ29tcG9uZW50IH0sXG4gICAgICAgICAgICB7IHBhdGg6IFwiU2hvcC9TaWRlTWVudVwiLCBjb21wb25lbnQ6IFNpZGVNZW51Q29tcG9uZW50IH0sXG4gICAgICAgICAgICB7IHBhdGg6ICcqKicsIHJlZGlyZWN0VG86ICdIb21lJyB9XG4gICAgICAgIF0pXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgUGxhbmtDb29raW5nU2VydmljZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQXBwTW9kdWxlU2hhcmVkIHtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2FwcC5zaGFyZWQubW9kdWxlLnRzIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxKSkoODMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMSkpKDg5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcm91dGVyL2J1bmRsZXMvcm91dGVyLnVtZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgLi92ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPSdjb250YWluZXItZmx1aWQnPlxcbiAgICA8ZGl2IGNsYXNzPSdyb3cnPlxcbiAgICAgICAgPGRpdiBjbGFzcz0nY29sLXhzLTEyIGJvZHktY29udGVudCc+XFxuICAgICAgICAgICAgPHJvdXRlci1vdXRsZXQ+PC9yb3V0ZXItb3V0bGV0PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2FwcC9hcHAuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9hcHAuY29tcG9uZW50LmNzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvYXBwL2FwcC5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAbWVkaWEgKG1heC13aWR0aDogNzY3cHgpIHtcXG4gICAgLyogT24gc21hbGwgc2NyZWVucywgdGhlIG5hdiBtZW51IHNwYW5zIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSBzY3JlZW4uIExlYXZlIGEgc3BhY2UgZm9yIGl0LiAqL1xcbiAgICAuYm9keS1jb250ZW50IHtcXG4gICAgICAgIHBhZGRpbmctdG9wOiA1MHB4O1xcbiAgICB9XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvYXBwL2FwcC5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnbmF2LW1lbnUnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL25hdm1lbnUuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL25hdm1lbnUuY29tcG9uZW50LmNzcycpXVxufSlcbmV4cG9ydCBjbGFzcyBOYXZNZW51Q29tcG9uZW50IHtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvbmF2bWVudS9uYXZtZW51LmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPSdtYWluLW5hdic+XFxuICAgIDxkaXYgY2xhc3M9J25hdmJhciBuYXZiYXItaW52ZXJzZSc+XFxuICAgICAgICA8ZGl2IGNsYXNzPSduYXZiYXItaGVhZGVyJz5cXG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J25hdmJhci10b2dnbGUnIGRhdGEtdG9nZ2xlPSdjb2xsYXBzZScgZGF0YS10YXJnZXQ9Jy5uYXZiYXItY29sbGFwc2UnPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nc3Itb25seSc+VG9nZ2xlIG5hdmlnYXRpb248L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdpY29uLWJhcic+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0naWNvbi1iYXInPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ljb24tYmFyJz48L3NwYW4+XFxuICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgPGEgY2xhc3M9J25hdmJhci1icmFuZCcgW3JvdXRlckxpbmtdPVxcXCJbJy9ob21lJ11cXFwiPlBsYW5rQ29va2luZzwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz0nY2xlYXJmaXgnPjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz0nbmF2YmFyLWNvbGxhcHNlIGNvbGxhcHNlJz5cXG4gICAgICAgICAgICA8dWwgY2xhc3M9J25hdiBuYXZiYXItbmF2Jz5cXG4gICAgICAgICAgICAgICAgPGxpIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydsaW5rLWFjdGl2ZSddXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxhIFtyb3V0ZXJMaW5rXT1cXFwiWycvaG9tZSddXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZ2x5cGhpY29uIGdseXBoaWNvbi1ob21lJz48L3NwYW4+IEhvbWVcXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgPGxpIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydsaW5rLWFjdGl2ZSddXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxhIFtyb3V0ZXJMaW5rXT1cXFwiWycvY291bnRlciddXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZ2x5cGhpY29uIGdseXBoaWNvbi1lZHVjYXRpb24nPjwvc3Bhbj4gQ291bnRlclxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2xpbmstYWN0aXZlJ11cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGEgW3JvdXRlckxpbmtdPVxcXCJbJy9mZXRjaC1kYXRhJ11cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdnbHlwaGljb24gZ2x5cGhpY29uLXRoLWxpc3QnPjwvc3Bhbj4gRmV0Y2ggZGF0YVxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvbmF2bWVudS9uYXZtZW51LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4gICAgICAgIHZhciByZXN1bHQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL25hdm1lbnUuY29tcG9uZW50LmNzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvbmF2bWVudS9uYXZtZW51LmNvbXBvbmVudC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImxpIC5nbHlwaGljb24ge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxufVxcblxcbi8qIEhpZ2hsaWdodGluZyBydWxlcyBmb3IgbmF2IG1lbnUgaXRlbXMgKi9cXG5saS5saW5rLWFjdGl2ZSBhLFxcbmxpLmxpbmstYWN0aXZlIGE6aG92ZXIsXFxubGkubGluay1hY3RpdmUgYTpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM0MTg5Qzc7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuLyogS2VlcCB0aGUgbmF2IG1lbnUgaW5kZXBlbmRlbnQgb2Ygc2Nyb2xsaW5nIGFuZCBvbiB0b3Agb2Ygb3RoZXIgaXRlbXMgKi9cXG4ubWFpbi1uYXYge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHotaW5kZXg6IDE7XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcbiAgICAvKiBPbiBzbWFsbCBzY3JlZW5zLCBjb252ZXJ0IHRoZSBuYXYgbWVudSB0byBhIHZlcnRpY2FsIHNpZGViYXIgKi9cXG4gICAgLm1haW4tbmF2IHtcXG4gICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgIHdpZHRoOiBjYWxjKDI1JSAtIDIwcHgpO1xcbiAgICB9XFxuICAgIC5uYXZiYXIge1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMHB4O1xcbiAgICAgICAgYm9yZGVyLXdpZHRoOiAwcHg7XFxuICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIH1cXG4gICAgLm5hdmJhci1oZWFkZXIge1xcbiAgICAgICAgZmxvYXQ6IG5vbmU7XFxuICAgIH1cXG4gICAgLm5hdmJhci1jb2xsYXBzZSB7XFxuICAgICAgICBib3JkZXItdG9wOiAxcHggc29saWQgIzQ0NDtcXG4gICAgICAgIHBhZGRpbmc6IDBweDtcXG4gICAgfVxcbiAgICAubmF2YmFyIHVsIHtcXG4gICAgICAgIGZsb2F0OiBub25lO1xcbiAgICB9XFxuICAgIC5uYXZiYXIgbGkge1xcbiAgICAgICAgZmxvYXQ6IG5vbmU7XFxuICAgICAgICBmb250LXNpemU6IDE1cHg7XFxuICAgICAgICBtYXJnaW46IDZweDtcXG4gICAgfVxcbiAgICAubmF2YmFyIGxpIGEge1xcbiAgICAgICAgcGFkZGluZzogMTBweCAxNnB4O1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgICB9XFxuICAgIC5uYXZiYXIgYSB7XFxuICAgICAgICAvKiBJZiBhIG1lbnUgaXRlbSdzIHRleHQgaXMgdG9vIGxvbmcsIHRydW5jYXRlIGl0ICovXFxuICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICAgIH1cXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9uYXZtZW51L25hdm1lbnUuY29tcG9uZW50LmNzc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2hvbWUnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2hvbWUuY29tcG9uZW50Lmh0bWwnKVxufSlcbmV4cG9ydCBjbGFzcyBIb21lQ29tcG9uZW50IHtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvaG9tZS9ob21lLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDE+SGVsbG8sIHdvcmxkITwvaDE+XFxuPHA+V2VsY29tZSB0byB5b3VyIG5ldyBzaW5nbGUtcGFnZSBhcHBsaWNhdGlvbiwgYnVpbHQgd2l0aDo8L3A+XFxuPHVsPlxcbiAgICA8bGk+PGEgaHJlZj0naHR0cHM6Ly9nZXQuYXNwLm5ldC8nPkFTUC5ORVQgQ29yZTwvYT4gYW5kIDxhIGhyZWY9J2h0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvNjdlZjhzYmQuYXNweCc+QyM8L2E+IGZvciBjcm9zcy1wbGF0Zm9ybSBzZXJ2ZXItc2lkZSBjb2RlPC9saT5cXG4gICAgPGxpPjxhIGhyZWY9J2h0dHBzOi8vYW5ndWxhci5pby8nPkFuZ3VsYXI8L2E+IGFuZCA8YSBocmVmPSdodHRwOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy8nPlR5cGVTY3JpcHQ8L2E+IGZvciBjbGllbnQtc2lkZSBjb2RlPC9saT5cXG4gICAgPGxpPjxhIGhyZWY9J2h0dHBzOi8vd2VicGFjay5naXRodWIuaW8vJz5XZWJwYWNrPC9hPiBmb3IgYnVpbGRpbmcgYW5kIGJ1bmRsaW5nIGNsaWVudC1zaWRlIHJlc291cmNlczwvbGk+XFxuICAgIDxsaT48YSBocmVmPSdodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS8nPkJvb3RzdHJhcDwvYT4gZm9yIGxheW91dCBhbmQgc3R5bGluZzwvbGk+XFxuPC91bD5cXG48cD5UbyBoZWxwIHlvdSBnZXQgc3RhcnRlZCwgd2UndmUgYWxzbyBzZXQgdXA6PC9wPlxcbjx1bD5cXG4gICAgPGxpPjxzdHJvbmc+Q2xpZW50LXNpZGUgbmF2aWdhdGlvbjwvc3Ryb25nPi4gRm9yIGV4YW1wbGUsIGNsaWNrIDxlbT5Db3VudGVyPC9lbT4gdGhlbiA8ZW0+QmFjazwvZW0+IHRvIHJldHVybiBoZXJlLjwvbGk+XFxuICAgIDxsaT48c3Ryb25nPlNlcnZlci1zaWRlIHByZXJlbmRlcmluZzwvc3Ryb25nPi4gRm9yIGZhc3RlciBpbml0aWFsIGxvYWRpbmcgYW5kIGltcHJvdmVkIFNFTywgeW91ciBBbmd1bGFyIGFwcCBpcyBwcmVyZW5kZXJlZCBvbiB0aGUgc2VydmVyLiBUaGUgcmVzdWx0aW5nIEhUTUwgaXMgdGhlbiB0cmFuc2ZlcnJlZCB0byB0aGUgYnJvd3NlciB3aGVyZSBhIGNsaWVudC1zaWRlIGNvcHkgb2YgdGhlIGFwcCB0YWtlcyBvdmVyLjwvbGk+XFxuICAgIDxsaT48c3Ryb25nPldlYnBhY2sgZGV2IG1pZGRsZXdhcmU8L3N0cm9uZz4uIEluIGRldmVsb3BtZW50IG1vZGUsIHRoZXJlJ3Mgbm8gbmVlZCB0byBydW4gdGhlIDxjb2RlPndlYnBhY2s8L2NvZGU+IGJ1aWxkIHRvb2wuIFlvdXIgY2xpZW50LXNpZGUgcmVzb3VyY2VzIGFyZSBkeW5hbWljYWxseSBidWlsdCBvbiBkZW1hbmQuIFVwZGF0ZXMgYXJlIGF2YWlsYWJsZSBhcyBzb29uIGFzIHlvdSBtb2RpZnkgYW55IGZpbGUuPC9saT5cXG4gICAgPGxpPjxzdHJvbmc+SG90IG1vZHVsZSByZXBsYWNlbWVudDwvc3Ryb25nPi4gSW4gZGV2ZWxvcG1lbnQgbW9kZSwgeW91IGRvbid0IGV2ZW4gbmVlZCB0byByZWxvYWQgdGhlIHBhZ2UgYWZ0ZXIgbWFraW5nIG1vc3QgY2hhbmdlcy4gV2l0aGluIHNlY29uZHMgb2Ygc2F2aW5nIGNoYW5nZXMgdG8gZmlsZXMsIHlvdXIgQW5ndWxhciBhcHAgd2lsbCBiZSByZWJ1aWx0IGFuZCBhIG5ldyBpbnN0YW5jZSBpbmplY3RlZCBpbnRvIHRoZSBwYWdlLjwvbGk+XFxuICAgIDxsaT48c3Ryb25nPkVmZmljaWVudCBwcm9kdWN0aW9uIGJ1aWxkczwvc3Ryb25nPi4gSW4gcHJvZHVjdGlvbiBtb2RlLCBkZXZlbG9wbWVudC10aW1lIGZlYXR1cmVzIGFyZSBkaXNhYmxlZCwgYW5kIHRoZSA8Y29kZT53ZWJwYWNrPC9jb2RlPiBidWlsZCB0b29sIHByb2R1Y2VzIG1pbmlmaWVkIHN0YXRpYyBDU1MgYW5kIEphdmFTY3JpcHQgZmlsZXMuPC9saT5cXG48L3VsPlxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2hvbWUvaG9tZS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIdHRwIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnZmV0Y2hkYXRhJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9mZXRjaGRhdGEuY29tcG9uZW50Lmh0bWwnKVxufSlcbmV4cG9ydCBjbGFzcyBGZXRjaERhdGFDb21wb25lbnQge1xuICAgIHB1YmxpYyBmb3JlY2FzdHM6IFdlYXRoZXJGb3JlY2FzdFtdO1xuXG4gICAgY29uc3RydWN0b3IoaHR0cDogSHR0cCwgQEluamVjdCgnQkFTRV9VUkwnKSBiYXNlVXJsOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5mb3JlY2FzdHMgPSBbXTtcbiAgICAgICAgaHR0cC5nZXQoYmFzZVVybCArICdhcGkvU2FtcGxlRGF0YS9XZWF0aGVyRm9yZWNhc3RzJykuc3Vic2NyaWJlKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICB0aGlzLmZvcmVjYXN0cyA9IHJlc3VsdC5qc29uKCkgYXMgV2VhdGhlckZvcmVjYXN0W107XG4gICAgICAgIH0sIGVycm9yID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IpKTtcbiAgICB9XG59XG5cbmludGVyZmFjZSBXZWF0aGVyRm9yZWNhc3Qge1xuICAgIGRhdGVGb3JtYXR0ZWQ6IHN0cmluZztcbiAgICB0ZW1wZXJhdHVyZUM6IG51bWJlcjtcbiAgICB0ZW1wZXJhdHVyZUY6IG51bWJlcjtcbiAgICBzdW1tYXJ5OiBzdHJpbmc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2ZldGNoZGF0YS9mZXRjaGRhdGEuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxoMT5XZWF0aGVyIGZvcmVjYXN0PC9oMT5cXG5cXG48cD5UaGlzIGNvbXBvbmVudCBkZW1vbnN0cmF0ZXMgZmV0Y2hpbmcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuPC9wPlxcblxcbjxwICpuZ0lmPVxcXCIhZm9yZWNhc3RzXFxcIj48ZW0+TG9hZGluZy4uLjwvZW0+PC9wPlxcblxcbjx0YWJsZSBjbGFzcz0ndGFibGUnICpuZ0lmPVxcXCJmb3JlY2FzdHNcXFwiPlxcbiAgICA8dGhlYWQ+XFxuICAgICAgICA8dHI+XFxuICAgICAgICAgICAgPHRoPkRhdGU8L3RoPlxcbiAgICAgICAgICAgIDx0aD5UZW1wLiAoQyk8L3RoPlxcbiAgICAgICAgICAgIDx0aD5UZW1wLiAoRik8L3RoPlxcbiAgICAgICAgICAgIDx0aD5TdW1tYXJ5PC90aD5cXG4gICAgICAgIDwvdHI+XFxuICAgIDwvdGhlYWQ+XFxuICAgIDx0Ym9keT5cXG4gICAgICAgIDx0ciAqbmdGb3I9XFxcImxldCBmb3JlY2FzdCBvZiBmb3JlY2FzdHNcXFwiPlxcbiAgICAgICAgICAgIDx0ZD57eyBmb3JlY2FzdC5kYXRlRm9ybWF0dGVkIH19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+e3sgZm9yZWNhc3QudGVtcGVyYXR1cmVDIH19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+e3sgZm9yZWNhc3QudGVtcGVyYXR1cmVGIH19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+e3sgZm9yZWNhc3Quc3VtbWFyeSB9fTwvdGQ+XFxuICAgICAgICA8L3RyPlxcbiAgICA8L3Rib2R5PlxcbjwvdGFibGU+XFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvZmV0Y2hkYXRhL2ZldGNoZGF0YS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2NvdW50ZXInLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2NvdW50ZXIuY29tcG9uZW50Lmh0bWwnKVxufSlcbmV4cG9ydCBjbGFzcyBDb3VudGVyQ29tcG9uZW50IHtcbiAgICBwdWJsaWMgY3VycmVudENvdW50ID0gMDtcblxuICAgIHB1YmxpYyBpbmNyZW1lbnRDb3VudGVyKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRDb3VudCsrO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY291bnRlci9jb3VudGVyLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDE+Q291bnRlcjwvaDE+XFxuXFxuPHA+VGhpcyBpcyBhIHNpbXBsZSBleGFtcGxlIG9mIGFuIEFuZ3VsYXIgY29tcG9uZW50LjwvcD5cXG5cXG48cD5DdXJyZW50IGNvdW50OiA8c3Ryb25nPnt7IGN1cnJlbnRDb3VudCB9fTwvc3Ryb25nPjwvcD5cXG5cXG48YnV0dG9uIChjbGljayk9XFxcImluY3JlbWVudENvdW50ZXIoKVxcXCI+SW5jcmVtZW50PC9idXR0b24+XFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY291bnRlci9jb3VudGVyLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6IFwiY2FydFwiLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2NhcnQuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2NhcnQuY29tcG9uZW50LmNzcycpXVxufSlcbmV4cG9ydCBjbGFzcyBDYXJ0Q29tcG9uZW50IHtcblxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY2FydC9jYXJ0LmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG4gICAgPGRpdiBpZD1cXFwiY29udGVudFxcXCIgY2xhc3M9XFxcIm1haW5Db250ZW50XFxcIj5cXG4gICAgIFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoaWRkZW4teHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93IHNob3BwaW5nUm93XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNyBjb2wtbWQtOCBjb2wtbGctOCBzaG9wcGluZ1RleHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoZWFkZXJTdHlsZVxcXCI+U0hPUFBJTkcgQ0FSVDogWW91ciBzaG9wcGluZyBjYXJ0IGNvbnRhaW5zIDEgaXRlbXMuPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTUgY29sLW1kLTQgY29sLWxnLTQgdGV4dFJpZ2h0XFxcIj48YSBjbGFzcz1cXFwibGlua1N0eWxlXFxcIiByb3V0ZXJMaW5rPVxcXCIvQ2FydC9DaGVja291dFxcXCI+PGltZyBjbGFzcz1cXFwibGlua0ltZ1N0eWxlXFxcIiBhbHQ9XFxcIkNoZWNrIE91dFxcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi8uLi93d3dyb290L2ltYWdlcy9DaGVja291dF9idXR0b24ucG5nXCIpICsgXCJcXFwiPjwvYT4gPGEgY2xhc3M9XFxcImxpbmtTdHlsZVxcXCIgcm91dGVyTGluaz1cXFwiL1Nob3BcXFwiPjxpbWcgYWx0PVxcXCJjb250aW51ZSBzaG9wcGluZ1xcXCIgY2xhc3M9XFxcImltZy1yZXNwb25zaXZlXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL0NvbnRpbnVlU2hvcHBpbmdfYnV0dG9uLnBuZ1wiKSArIFwiXFxcIj48L2E+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0YWJsZVN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgYm9yZGVyPVxcXCIwXFxcIiBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwidGl0bGVTdHlsZVxcXCI+U2hpcHBpbmcgdG8gWW91PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInRhYmxlQ29sdW1uc1N0eWxlXFxcIj5QcmljZTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJ0YWJsZUNvbHVtbnNTdHlsZVxcXCI+UXVhbnRpdHk8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwidGFibGVDb2x1bW5zU3R5bGVcXFwiPlRvdGFsPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCAgY2xhc3M9XFxcInByb2R1Y3RUaXRsZVN0eWxlXFxcIj5TUE9SVCBTdGVhayBTZWFzb25pbmcgUnViPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInByb2R1Y3RSb3dzXFxcIj4kNS4wMDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJwcm9kdWN0Um93c1xcXCI+PGlucHV0IGNsYXNzPVxcXCJxdWFudGl0eVN0eWxlXFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwicHJvZHVjdFRvdGFsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJpY2VQYWRkaW5nXFxcIj4kNS4wMDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZW1vdmVEaXZTdHlsZVxcXCI+PGltZyBjbGFzcz1cXFwicmVtb3ZlSW1nXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL1JlbW92ZV9CdXR0b24ucG5nXCIpICsgXCJcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJ0ZFNwYWNlXFxcIj4mbmJzcDs8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic3ViVGl0bGVTdHlsZVxcXCI+U3VidG90YWw6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInByaWNlU3R5bGVcXFwiPiQ1LjAwPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiNFxcXCIgY2xhc3M9XFxcIm1haW5MaW5rU3R5bGVcXFwiPjxhIGNsYXNzPVxcXCJjaGVja091dExpbmtcXFwiIHJvdXRlckxpbms9XFxcIi9DYXJ0L0NoZWNrb3V0XFxcIj48aW1nIGFsdD1cXFwiQ2hlY2sgT3V0XFxcIiBjbGFzcz1cXFwiY2hlY2tPdXRJbWdcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vLi4vd3d3cm9vdC9pbWFnZXMvQ2hlY2tvdXRfYnV0dG9uLnBuZ1wiKSArIFwiXFxcIj48L2E+PGEgcm91dGVyTGluaz1cXFwiL1Nob3BcXFwiIGNsYXNzPVxcXCJjb250aW51ZUxpbmtTdHlsZVxcXCI+PGltZyBhbHQ9XFxcIkNvbnRpbnVlIFNob3BwaW5nXFxcIiAgY2xhc3M9XFxcImltZy1yZXNwb25zaXZlXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL0NvbnRpbnVlU2hvcHBpbmdfYnV0dG9uLnBuZ1wiKSArIFwiXFxcIj48L2E+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidmlzaWJsZS14c1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgc2hvcHBpbmdSb3dTbWFsbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXhzLTYgc2hvcHBpbmdUZXh0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVhZGVyU3R5bGVTbWFsbFxcXCI+U0hPUFBJTkcgQ0FSVDogWW91ciBzaG9wcGluZyBjYXJ0IGNvbnRhaW5zIDEgaXRlbXMuPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC14cy02IHRleHRSaWdodFxcXCI+PGEgcm91dGVyTGluaz1cXFwiL0NhcnQvQ2hlY2tvdXRcXFwiPjxpbWcgYWx0PVxcXCJDaGVjayBPdXRcXFwiIGNsYXNzPVxcXCJpbWctcmVzcG9uc2l2ZSBzbWFsbEltZ1N0eWxlXFxcIiAgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi8uLi93d3dyb290L2ltYWdlcy9DaGVja291dF9idXR0b24ucG5nXCIpICsgXCJcXFwiPjwvYT48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcFxcXCIgY2xhc3M9XFxcInNtYWxsTGlua1N0eWxlXFxcIj48aW1nIGFsdD1cXFwiQ29udGludWUgU2hvcHBpbmdcXFwiIGNsYXNzPVxcXCJpbWctcmVzcG9uc2l2ZVxcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi8uLi93d3dyb290L2ltYWdlcy9Db250aW51ZVNob3BwaW5nX2J1dHRvbi5wbmdcIikgKyBcIlxcXCI+PC9hPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0YWJsZVN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgYm9yZGVyPVxcXCIwXFxcIiBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxUaXRsZVN0eWxlXFxcIj5TaGlwcGluZyB0byBZb3U8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwidGFibGVDb2x1bW5zU3R5bGVcXFwiPlByaWNlPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInRhYmxlQ29sdW1uc1N0eWxlXFxcIj5RdWFudGl0eTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJ0YWJsZUNvbHVtbnNTdHlsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRvdGFsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQcm9kdWN0VGl0bGVcXFwiPlNQT1JUIFN0ZWFrIFNlYXNvbmluZyBSdWI8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQcm9kdWN0Um93XFxcIj4kNS4wMDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbFF0eVJvd1xcXCI+PGlucHV0IGNsYXNzPVxcXCJxdWFudGl0eVN0eWxlXFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQcm9kdWN0VG90YWxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcmljZVBhZGRpbmcgXFxcIj4kNS4wMDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzbWFsbFJlbW92ZURpdlN0eWxlXFxcIj48aW1nIGNsYXNzPVxcXCJyZW1vdmVJbWdcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vLi4vd3d3cm9vdC9pbWFnZXMvUmVtb3ZlX0J1dHRvbi5wbmdcIikgKyBcIlxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsVGRTcGFjZVxcXCI+Jm5ic3A7PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsU3ViVGl0bGVTdHlsZVxcXCI+U3VidG90YWw6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsUHJpY2VTdHlsZVxcXCI+JDUuMDA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsTWFpblN0eWxlXFxcIiBjb2xzcGFuPVxcXCI0XFxcIj48YSByb3V0ZXJMaW5rPVxcXCIvQ2FydC9DaGVja291dFxcXCIgY2xhc3M9XFxcInNtYWxsQ2hlY2tPdXRMaW5rXFxcIj48aW1nIGFsdD1cXFwiQ2hlY2sgT3V0XFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL0NoZWNrb3V0X2J1dHRvbi5wbmdcIikgKyBcIlxcXCI+PC9hPiA8YSByb3V0ZXJMaW5rPVxcXCIvU2hvcFxcXCIgY2xhc3M9XFxcInNtYWxsQ29udGludWVMaW5rU3R5bGVcXFwiPjxpbWcgYWx0PVxcXCJDb250aW51ZSBTaG9wcGluZ1xcXCIgY2xhc3M9XFxcImltZy1yZXNwb25zaXZlXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL0NvbnRpbnVlU2hvcHBpbmdfYnV0dG9uLnBuZ1wiKSArIFwiXFxcIj48L2E+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgXFxuICAgIDwvZGl2PlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbjxhICBbcm91dGVyTGlua109XFxcIlsnL3Nob3AnXVxcXCI+R28gVG8gU2hvcDwvYT5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L2NhcnQuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY2FydC5jb21wb25lbnQuY3NzXCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L2NhcnQuY29tcG9uZW50LmNzc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLm1haW5Db250ZW50IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlOyB0b3A6IDYwcHg7XFxufVxcblxcblxcbi5zaG9wcGluZ1JvdyB7XFxuICAgIGhlaWdodDo1MHB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2JjOWE3MjsgXFxuICAgIGZvbnQtZmFtaWx5OiBDYW1icmlhbjsgXFxuICAgIGZvbnQtc2l6ZTogMTZweDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkO1xcbn1cXG5cXG4uc2hvcHBpbmdSb3dTbWFsbCB7XFxuICAgIGhlaWdodDo4MHB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2JjOWE3MjsgXFxuICAgIGZvbnQtZmFtaWx5OiBDYW1icmlhbjsgXFxuICAgIGZvbnQtc2l6ZTogMTRweDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkO1xcbn1cXG5cXG4uc2hvcHBpbmdUZXh0IHtcXG4gICAgdGV4dC1hbGlnbjpsZWZ0O1xcbn1cXG5cXG4uaGVhZGVyU3R5bGUge1xcbiAgICBwYWRkaW5nOiAxNXB4IDAgMCAxMHB4O1xcbn1cXG5cXG4uaGVhZGVyU3R5bGVTbWFsbCB7XFxuICAgIHBhZGRpbmc6IDE1cHggMCAwIDVweDtcXG59XFxuXFxuLnRleHRSaWdodCB7XFxuICAgIHRleHQtYWxpZ246cmlnaHQ7XFxufVxcblxcbi5saW5rU3R5bGUge1xcbiAgICBmbG9hdDpyaWdodDsgXFxuICAgIHBhZGRpbmc6MTJweCA1cHggMCAwO1xcbn1cXG5cXG4uc21hbGxMaW5rU3R5bGUge1xcbiAgICBmbG9hdDpyaWdodDsgXFxuICAgIHBhZGRpbmc6MTJweCA1cHggMCAwO1xcbn1cXG5cXG5cXG5cXG4ubGlua0ltZ1N0eWxlIHtcXG4gICAgY3Vyc29yOnBvaW50ZXI7IFxcbiAgICBmbG9hdDpyaWdodDsgXFxuICAgIHBhZGRpbmc6MCAxMHB4IDAgNXB4O1xcbn1cXG5cXG4uc21hbGxJbWdTdHlsZSB7XFxuICAgIGN1cnNvcjpwb2ludGVyOyBcXG4gICAgZmxvYXQ6cmlnaHQ7IFxcbiAgICBwYWRkaW5nOjEycHggMTBweCAwIDVweDtcXG59XFxuXFxuLnRhYmxlU3R5bGUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZThlM2M4O1xcbiAgICAgbWFyZ2luOiAxNXB4IDAgMCAwOyBcXG4gICAgcGFkZGluZzogMTBweDtcXG59XFxuXFxuXFxuXFxuLnRpdGxlU3R5bGUge1xcbiAgICB3aWR0aDogNTAwcHg7IFxcbiAgICBoZWlnaHQ6IDI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBwYWRkaW5nOiA1cHg7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZDJiZTlkOyBcXG4gICAgY29sb3I6ICM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDogYm9sZDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxuICAgIFxcbn1cXG5cXG4uc21hbGxUaXRsZVN0eWxlIHtcXG4gICAgd2lkdGg6IDUwMHB4OyBcXG4gICAgaGVpZ2h0OiAyNXB4OyBcXG4gICAgcGFkZGluZzogNXB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2QyYmU5ZDsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4udGFibGVDb2x1bW5zU3R5bGUge1xcbiAgICB3aWR0aDogMTAwcHg7IFxcbiAgICBoZWlnaHQ6IDI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZDJiZTlkOyBcXG4gICAgY29sb3I6ICM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDogYm9sZDsgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG4gICAgXFxufVxcblxcbi5wcm9kdWN0VGl0bGVTdHlsZSB7XFxuICAgIHdpZHRoOiA1MDBweDsgXFxuICAgIHRleHQtYWxpZ246bGVmdDsgXFxuICAgIHBhZGRpbmc6IDVweDsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbiAgICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsUHJvZHVjdFRpdGxlIHtcXG4gICAgcGFkZGluZzogNXB4O1xcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5wcm9kdWN0Um93cyB7XFxuICAgIHdpZHRoOiAxMDBweDsgXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsUHJvZHVjdFJvdyB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG4gICAgXFxufVxcblxcbi5zbWFsbFF0eVJvdyB7XFxuICAgIHBhZGRpbmc6IDVweDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5xdWFudGl0eVN0eWxlIHtcXG4gICAgd2lkdGg6MzVweDsgXFxuICAgIGhlaWdodDoyNXB4OyBcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzkyOTI5MjsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xcbiAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbn1cXG5cXG4ucHJvZHVjdFRvdGFsIHtcXG4gICAgd2lkdGg6IDEwMHB4OyBcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG4gICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgICAgXFxufVxcblxcbi5zbWFsbFByb2R1Y3RUb3RhbCB7XFxuICAgdGV4dC1hbGlnbjogY2VudGVyOyBcXG4gICBjb2xvcjogIzRiMjkwYzsgXFxuICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnByaWNlUGFkZGluZyB7XFxuICAgIHBhZGRpbmctdG9wOiAxMHB4O1xcbn1cXG5cXG4ucmVtb3ZlRGl2U3R5bGUge1xcbiAgICBwYWRkaW5nLXRvcDogMTBweDsgXFxuICAgIHBhZGRpbmctYm90dG9tOjVweDsgXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLnNtYWxsUmVtb3ZlRGl2U3R5bGUge1xcbiAgICBwYWRkaW5nLXRvcDogMTBweDsgXFxuICAgIHBhZGRpbmctYm90dG9tOjVweDtcXG59XFxuXFxuLnJlbW92ZUltZyB7XFxuICAgIGN1cnNvcjpwb2ludGVyO1xcbn1cXG5cXG4udGRTcGFjZSB7XFxuICAgIHdpZHRoOiAxMDBweDtcXG4gICAgIHBhZGRpbmctdG9wOiA1cHg7IFxcbiAgICAgaGVpZ2h0OiAzNXB4OyBcXG4gICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgIGZvbnQtd2VpZ2h0OiBib2xkOyBcXG4gICAgIHRleHQtYWxpZ246IGNlbnRlcjsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgIFxcbn1cXG5cXG4uc21hbGxUZFNwYWNlIHtcXG4gICAgcGFkZGluZy10b3A6IDVweDsgXFxuICAgIGhlaWdodDogMzVweDsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7IFxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zdWJUaXRsZVN0eWxlIHtcXG4gICAgd2lkdGg6IDEwMHB4O1xcbiAgICAgaGVpZ2h0OiAzNXB4OyBcXG4gICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgIGZvbnQtd2VpZ2h0OiBib2xkOyBcXG4gICAgIHRleHQtYWxpZ246IHJpZ2h0OyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxTdWJUaXRsZVN0eWxlIHtcXG4gICAgaGVpZ2h0OiAzNXB4OyBcXG4gICAgY29sb3I6ICM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDogYm9sZDsgXFxuICAgIHRleHQtYWxpZ246IHJpZ2h0OyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4ucHJpY2VTdHlsZSB7XFxuICAgIHdpZHRoOiAxMDBweDsgXFxuICAgIGhlaWdodDogMzVweDsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7IFxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsUHJpY2VTdHlsZSB7XFxuICAgIGhlaWdodDogMzVweDsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7IFxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLm1haW5MaW5rU3R5bGUge1xcbiAgICBoZWlnaHQ6IDQ1cHg7IFxcbiAgICBib3JkZXI6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIHBhZGRpbmctcmlnaHQ6NXB4OyBcXG4gICAgdGV4dC1hbGlnbjpyaWdodDtcXG59XFxuXFxuLnNtYWxsTWFpblN0eWxlIHtcXG4gICAgaGVpZ2h0OiA0NXB4OyBcXG4gICAgYm9yZGVyOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICB0ZXh0LWFsaWduOiByaWdodDsgXFxuICAgIHBhZGRpbmctcmlnaHQ6NXB4O1xcbn1cXG5cXG4uY2hlY2tPdXRMaW5rIHtcXG4gICAgZmxvYXQ6cmlnaHQ7IFxcbiAgICBwYWRkaW5nOjEycHggNXB4IDAgMDtcXG59XFxuXFxuLnNtYWxsQ2hlY2tPdXRMaW5rIHtcXG4gICAgZmxvYXQ6cmlnaHQ7IFxcbiAgICBwYWRkaW5nOjAgMCAwIDVweDtcXG59XFxuXFxuLmNoZWNrT3V0SW1nIHtcXG4gICAgY3Vyc29yOnBvaW50ZXI7IFxcbiAgICBmbG9hdDpyaWdodDsgXFxuICAgIHBhZGRpbmc6MCAwIDAgNXB4O1xcbn1cXG5cXG4uY29udGludWVMaW5rU3R5bGUge1xcbiAgICBmbG9hdDpyaWdodDsgXFxuICAgIHBhZGRpbmc6MTBweCA1cHggMCAwO1xcbn1cXG5cXG4uc21hbGxDb250aW51ZUxpbmtTdHlsZSB7XFxuICAgIGZsb2F0OnJpZ2h0OyBcXG4gICAgcGFkZGluZzogMCA1cHggMCAwO1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2NhcnQvY2FydC5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdjaGVja291dCcsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vY2hlY2tvdXQuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2NoZWNrb3V0LmNvbXBvbmVudC5jc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBDaGVja291dENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgY29uc3RydWN0b3IoKSB7IH1cblxuICAgIG5nT25Jbml0KCkgeyB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L2NoZWNrb3V0L2NoZWNrb3V0LmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICAgICAgICBcXG4gICAgICAgIDxkaXYgaWQ9XFxcImNvbnRlbnRcXFwiIGNsYXNzPVxcXCJtYWluQ29udGVudFxcXCI+XFxuICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgPGZvcm0gbmFtZT1cXFwiY2hlY2tvdXRGb3JtXFxcIiBjbGFzcz1cXFwiaGlkZGVuLXhzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtYWluRm9ybURpdlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRpdGxlRGl2XFxcIj4gPHNwYW4+RW50ZXIgQmlsbGluZyAmYW1wOyBTaGlwcGluZyBJbmZvcm1hdGlvbiAmZ3Q7IFN0ZXAgMiBvZiA0PC9zcGFuPjwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0YWJsZVBhZGRpbmdcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjVcXFwiIGNlbGxzcGFjaW5nPVxcXCI1XFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFkZHJlc3NTdHlsZVxcXCI+QmlsbGluZyBBZGRyZXNzPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWRkcmVzc1N0eWxlXFxcIj48c3BhbiBjbGFzcz1cXFwic2hpcHBpbmdBZGRyZXNzUGFkZGluZ1xcXCI+U2hpcHBpbmcgQWRkcmVzczwvc3Bhbj4gPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIj4gU2FtZSBhcyBCaWxsaW5nIEFkZHJlc3M8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcIm91dGVyVGRcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgYm9yZGVyPVxcXCIwXFxcIiBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5GaXJzdCBOYW1lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxpbnB1dCBuYW1lPVxcXCJiaWxsaW5nRmlyc3ROYW1lXFxcIiBtYXhsZW5ndGg9XFxcIjEwMFxcXCIgY2xhc3M9XFxcInRleHRCb3hcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+TGFzdCBOYW1lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxpbnB1dCBuYW1lPVxcXCJiaWxsaW5nTGFzdE5hbWVcXFwiIG1heGxlbmd0aD1cXFwiMTAwXFxcIiBjbGFzcz1cXFwidGV4dEJveFxcXCIgLz48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkFkZHJlc3M6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGlucHV0IG5hbWU9XFxcImJpbGxpbmdBZGRyZXNzMVxcXCIgbWF4bGVuZ3RoPVxcXCIyNTBcXFwiIGNsYXNzPVxcXCJ0ZXh0Qm94XFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkFkZHJlc3MgMjo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgbmFtZT1cXFwiYmlsbGluZ0FkZHJlc3MyXFxcIiBtYXhsZW5ndGg9XFxcIjI1MFxcXCIgY2xhc3M9XFxcInRleHRCb3hcXFwiIHBsYWNlaG9sZGVyPVxcXCJPcHRpb25hbFxcXCIgLz48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkNpdHk6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGlucHV0IG5hbWU9XFxcImJpbGxpbmdDaXR5XFxcIiBtYXhsZW5ndGg9XFxcIjEwMFxcXCIgY2xhc3M9XFxcInRleHRCb3hcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+U3RhdGU6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XFxcInRleHRCb3hcXFwiIG5hbWU9XFxcImJpbGxpbmdTdGF0ZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCI/XFxcIj5TZWxlY3Q8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFMXFxcIj5BbGFiYW1hPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBS1xcXCI+QWxhc2thPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBWlxcXCI+QXJpem9uYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQVJcXFwiPkFya2Fuc2FzPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDQVxcXCI+Q2FsaWZvcm5pYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQ09cXFwiPkNvbG9yYWRvPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDVFxcXCI+Q29ubmVjdGljdXQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkRFXFxcIj5EZWxhd2FyZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRENcXFwiPkRpc3Qgb2YgQ29sdW1iaWE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkZMXFxcIj5GbG9yaWRhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHQVxcXCI+R2VvcmdpYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSElcXFwiPkhhd2FpaTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSURcXFwiPklkYWhvPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJTFxcXCI+SWxsaW5vaXM8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklOXFxcIj5JbmRpYW5hPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJQVxcXCI+SW93YTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiS1NcXFwiPkthbnNhczwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiS1lcXFwiPktlbnR1Y2t5PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJMQVxcXCI+TG91aXNpYW5hPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNRVxcXCI+TWFpbmU8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1EXFxcIj5NYXJ5bGFuZDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTUFcXFwiPk1hc3NhY2h1c2V0dHM8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1JXFxcIj5NaWNoaWdhbjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTU5cXFwiPk1pbm5lc290YTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTVNcXFwiPk1pc3Npc3NpcHBpPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNT1xcXCI+TWlzc291cmk8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1UXFxcIj5Nb250YW5hPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJORVxcXCI+TmVicmFza2E8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5WXFxcIj5OZXZhZGE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5IXFxcIj5OZXcgSGFtcHNoaXJlPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOSlxcXCI+TmV3IEplcnNleTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTk1cXFwiPk5ldyBNZXhpY288L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5ZXFxcIj5OZXcgWW9yazwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTkNcXFwiPk5vcnRoIENhcm9saW5hPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJORFxcXCI+Tm9ydGggRGFrb3RhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJPSFxcXCI+T2hpbzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiT0tcXFwiPk9rbGFob21hPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJPUlxcXCI+T3JlZ29uPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJQQVxcXCI+UGVubnN5bHZhbmlhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJSSVxcXCI+UmhvZGUgSXNsYW5kPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTQ1xcXCI+U291dGggQ2Fyb2xpbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNEXFxcIj5Tb3V0aCBEYWtvdGE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlROXFxcIj5UZW5uZXNzZWU8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlRYXFxcIj5UZXhhczwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVVRcXFwiPlV0YWg8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlZUXFxcIj5WZXJtb250PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJWQVxcXCI+VmlyZ2luaWE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIldBXFxcIj5XYXNoaW5ndG9uPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJXVlxcXCI+V2VzdCBWaXJnaW5pYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiV0lcXFwiPldpc2NvbnNpbjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiV1lcXFwiPld5b21pbmc8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5aaXAgLyBQb3N0YWw6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGlucHV0IG5hbWU9XFxcImJpbGxpbmdQb3N0YWxDb2RlXFxcIiBtYXhsZW5ndGg9XFxcIjIwXFxcIiBjbGFzcz1cXFwidGV4dEJveFxcXCI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5QaG9uZTo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgbmFtZT1cXFwiYmlsbGluZ1Bob25lXFxcIiBtYXhsZW5ndGg9XFxcIjIwXFxcIiBjbGFzcz1cXFwidGV4dEJveFxcXCI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5FbWFpbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgbmFtZT1cXFwiYmlsbGluZ0VtYWlsXFxcIiBtYXhsZW5ndGg9XFxcIjI1MFxcXCIgY2xhc3M9XFxcInRleHRCb3hcXFwiIC8+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcIm91dGVyU2hpcHBpbmdUZFxcXCIgdmFsaWduPVxcXCJ0b3BcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIwXFxcIiBjZWxsc3BhY2luZz1cXFwiMFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkZpcnN0IE5hbWU6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGlucHV0IG5hbWU9XFxcInNoaXBwaW5nRmlyc3ROYW1lXFxcIiBtYXhsZW5ndGg9XFxcIjEwMFxcXCIgY2xhc3M9XFxcInRleHRCb3hcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+TGFzdCBOYW1lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxpbnB1dCBuYW1lPVxcXCJzaGlwcGluZ0xhc3ROYW1lXFxcIiBtYXhsZW5ndGg9XFxcIjEwMFxcXCIgY2xhc3M9XFxcInRleHRCb3hcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+QWRkcmVzczo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgbmFtZT1cXFwic2hpcHBpbmdBZGRyZXNzMVxcXCIgbWF4bGVuZ3RoPVxcXCIyNTBcXFwiIGNsYXNzPVxcXCJ0ZXh0Qm94XFxcIiAvPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+QWRkcmVzcyAyOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxpbnB1dCBtYXhsZW5ndGg9XFxcIjI1MFxcXCIgY2xhc3M9XFxcInRleHRCb3hcXFwiIHBsYWNlaG9sZGVyPVxcXCJPcHRpb25hbFxcXCI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5DaXR5OjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxpbnB1dCBuYW1lPVxcXCJzaGlwcGluZ0ZpcnN0TmFtZVxcXCIgbWF4bGVuZ3RoPVxcXCIxMDBcXFwiIGNsYXNzPVxcXCJ0ZXh0Qm94XFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPlN0YXRlOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVxcXCJ0ZXh0Qm94XFxcIiBuYW1lPVxcXCJzaGlwcGluZ1N0YXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIj9cXFwiPlNlbGVjdDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQUxcXFwiPkFsYWJhbWE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFLXFxcIj5BbGFza2E8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFaXFxcIj5Bcml6b25hPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBUlxcXCI+QXJrYW5zYXM8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNBXFxcIj5DYWxpZm9ybmlhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDT1xcXCI+Q29sb3JhZG88L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNUXFxcIj5Db25uZWN0aWN1dDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiREVcXFwiPkRlbGF3YXJlPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJEQ1xcXCI+RGlzdCBvZiBDb2x1bWJpYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRkxcXFwiPkZsb3JpZGE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkdBXFxcIj5HZW9yZ2lhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJISVxcXCI+SGF3YWlpPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJRFxcXCI+SWRhaG88L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklMXFxcIj5JbGxpbm9pczwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSU5cXFwiPkluZGlhbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklBXFxcIj5Jb3dhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJLU1xcXCI+S2Fuc2FzPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJLWVxcXCI+S2VudHVja3k8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkxBXFxcIj5Mb3Vpc2lhbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1FXFxcIj5NYWluZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTURcXFwiPk1hcnlsYW5kPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNQVxcXCI+TWFzc2FjaHVzZXR0czwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTUlcXFwiPk1pY2hpZ2FuPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNTlxcXCI+TWlubmVzb3RhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNU1xcXCI+TWlzc2lzc2lwcGk8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1PXFxcIj5NaXNzb3VyaTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTVRcXFwiPk1vbnRhbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5FXFxcIj5OZWJyYXNrYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTlZcXFwiPk5ldmFkYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTkhcXFwiPk5ldyBIYW1wc2hpcmU8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5KXFxcIj5OZXcgSmVyc2V5PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOTVxcXCI+TmV3IE1leGljbzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTllcXFwiPk5ldyBZb3JrPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOQ1xcXCI+Tm9ydGggQ2Fyb2xpbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5EXFxcIj5Ob3J0aCBEYWtvdGE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk9IXFxcIj5PaGlvPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJPS1xcXCI+T2tsYWhvbWE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk9SXFxcIj5PcmVnb248L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlBBXFxcIj5QZW5uc3lsdmFuaWE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlJJXFxcIj5SaG9kZSBJc2xhbmQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNDXFxcIj5Tb3V0aCBDYXJvbGluYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU0RcXFwiPlNvdXRoIERha290YTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVE5cXFwiPlRlbm5lc3NlZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVFhcXFwiPlRleGFzPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJVVFxcXCI+VXRhaDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVlRcXFwiPlZlcm1vbnQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlZBXFxcIj5WaXJnaW5pYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiV0FcXFwiPldhc2hpbmd0b248L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIldWXFxcIj5XZXN0IFZpcmdpbmlhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJXSVxcXCI+V2lzY29uc2luPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJXWVxcXCI+V3lvbWluZzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPlppcCAvIFBvc3RhbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgY2xhc3M9XFxcInRleHRCb3hcXFwiIG1heGxlbmd0aD1cXFwiMjBcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+UGhvbmU6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGlucHV0IGNsYXNzPVxcXCJ0ZXh0Qm94XFxcIiBtYXhsZW5ndGg9XFxcIjIwXFxcIiBwbGFjZWhvbGRlcj1cXFwiT3B0aW9uYWxcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+RW1haWw6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGlucHV0IGNsYXNzPVxcXCJ0ZXh0Qm94XFxcIiBtYXhsZW5ndGg9XFxcIjI1MFxcXCIgcGxhY2Vob2xkZXI9XFxcIk9wdGlvbmFsXFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNoaXBwaW5nMllvdU1haW5cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNoaXBwaW5nMllvdVRpdGxlXFxcIj5TaGlwcGluZyB0byBZb3U8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJ0ZFByaWNlUXVhbnRpdHlUb3RhbEhlYWRlclxcXCI+UHJpY2U8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJ0ZFByaWNlUXVhbnRpdHlUb3RhbEhlYWRlclxcXCI+UXVhbnRpdHk8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJ0ZFByaWNlUXVhbnRpdHlUb3RhbEhlYWRlclxcXCI+VG90YWw8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInByb2R1Y3RIZWFkZXJcXFwiPlNQT1JUIFN0ZWFrIFNlYXNvbmluZyBSdWI8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJwcm9kdWN0UHJpY2VUb3RhbFxcXCI+JDUuMDA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJwcm9kdWN0UXVhbnRpdHlcXFwiPjE8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJwcm9kdWN0UHJpY2VUb3RhbFxcXCI+JDUuMDA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiMlxcXCIgY2xhc3M9XFxcInN1YlRvdGFsU3BhY2VcXFwiPiZuYnNwOzwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInN1YlRvdGFsSGVhZGVyXFxcIj5TdWJ0b3RhbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzdWJUb3RhbFByaWNlXFxcIj48c3BhbiBpZD1cXFwiY2FydC10b3RhbFxcXCI+JDUuMDA8L3NwYW4+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNoaXBwaW5nMllvdU1haW5cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImNvbW1lbnRzU3R5bGVcXFwiPkNvbW1lbnRzIG9yIEFkZGl0aW9uYWwgSW5mb3JtYXRpb248L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInRleHRBcmVhU3R5bGVcXFwiPjx0ZXh0YXJlYSBjb2xzPVxcXCIzNVxcXCIgcm93cz1cXFwiM1xcXCI+PC90ZXh0YXJlYT48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnV0dG9uU3R5bGVcXFwiPiA8YSByb3V0ZXJMaW5rPVxcXCIvQ2FydFxcXCI+IDxpbnB1dCB0eXBlPVxcXCJpbWFnZVxcXCIgc3JjPVxcXCIvaW1hZ2VzL0JhY2tfYnV0dG9uLnBuZ1xcXCI+PC9hPiA8YSByb3V0ZXJMaW5rPVxcXCIvQ2FydC9QcmV2aWV3XFxcIj48aW5wdXQgdHlwZT1cXFwiaW1hZ2VcXFwiIHNyYz1cXFwiL2ltYWdlcy9DaGVja291dF9idXR0b24ucG5nXFxcIj48L2E+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XFxuICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICA8Zm9ybSBuYW1lPVxcXCJjaGVja291dEZvcm1cXFwiIGNsYXNzPVxcXCJ2aXNpYmxlLXhzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzbWFsbE1haW5Gb3JtRGl2XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic21hbGxUb3BQYWRkaW5nXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCI1XFxcIiBjZWxsc3BhY2luZz1cXFwiNVxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbEFkZHJlc3NTdHlsZVxcXCI+QmlsbGluZyBBZGRyZXNzPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbE91dGVyVGRcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgYm9yZGVyPVxcXCIwXFxcIiBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+Rmlyc3QgTmFtZTo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgbmFtZT1cXFwiYmlsbGluZ0ZpcnN0TmFtZVxcXCIgbWF4bGVuZ3RoPVxcXCIxMDBcXFwiIGNsYXNzPVxcXCJzbWFsbFRleHRCb3hcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+TGFzdCBOYW1lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxpbnB1dCBuYW1lPVxcXCJiaWxsaW5nTGFzdE5hbWVcXFwiIG1heGxlbmd0aD1cXFwiMTAwXFxcIiAgY2xhc3M9XFxcInNtYWxsVGV4dEJveFxcXCI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5BZGRyZXNzOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxpbnB1dCBuYW1lPVxcXCJiaWxsaW5nQWRkcmVzczFcXFwiIG1heGxlbmd0aD1cXFwiMjUwXFxcIiBjbGFzcz1cXFwic21hbGxUZXh0Qm94XFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkFkZHJlc3MgMjo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgbmFtZT1cXFwiYmlsbGluZ0FkZHJlc3MyXFxcIiBtYXhsZW5ndGg9XFxcIjI1MFxcXCIgY2xhc3M9XFxcInNtYWxsVGV4dEJveFxcXCIgcGxhY2Vob2xkZXI9XFxcIk9wdGlvbmFsXFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkNpdHk6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGlucHV0IG5hbWU9XFxcImJpbGxpbmdDaXR5XFxcIiBtYXhsZW5ndGg9XFxcIjEwMFxcXCIgIGNsYXNzPVxcXCJzbWFsbFRleHRCb3hcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+U3RhdGU6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XFxcInNtYWxsVGV4dEJveFxcXCIgbmFtZT1cXFwiYmlsbGluZ1N0YXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIj9cXFwiPlNlbGVjdDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQUxcXFwiPkFsYWJhbWE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFLXFxcIj5BbGFza2E8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFaXFxcIj5Bcml6b25hPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBUlxcXCI+QXJrYW5zYXM8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNBXFxcIj5DYWxpZm9ybmlhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDT1xcXCI+Q29sb3JhZG88L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNUXFxcIj5Db25uZWN0aWN1dDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiREVcXFwiPkRlbGF3YXJlPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJEQ1xcXCI+RGlzdCBvZiBDb2x1bWJpYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRkxcXFwiPkZsb3JpZGE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkdBXFxcIj5HZW9yZ2lhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJISVxcXCI+SGF3YWlpPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJRFxcXCI+SWRhaG88L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklMXFxcIj5JbGxpbm9pczwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSU5cXFwiPkluZGlhbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklBXFxcIj5Jb3dhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJLU1xcXCI+S2Fuc2FzPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJLWVxcXCI+S2VudHVja3k8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkxBXFxcIj5Mb3Vpc2lhbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1FXFxcIj5NYWluZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTURcXFwiPk1hcnlsYW5kPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNQVxcXCI+TWFzc2FjaHVzZXR0czwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTUlcXFwiPk1pY2hpZ2FuPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNTlxcXCI+TWlubmVzb3RhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNU1xcXCI+TWlzc2lzc2lwcGk8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1PXFxcIj5NaXNzb3VyaTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTVRcXFwiPk1vbnRhbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5FXFxcIj5OZWJyYXNrYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTlZcXFwiPk5ldmFkYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTkhcXFwiPk5ldyBIYW1wc2hpcmU8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5KXFxcIj5OZXcgSmVyc2V5PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOTVxcXCI+TmV3IE1leGljbzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTllcXFwiPk5ldyBZb3JrPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOQ1xcXCI+Tm9ydGggQ2Fyb2xpbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5EXFxcIj5Ob3J0aCBEYWtvdGE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk9IXFxcIj5PaGlvPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJPS1xcXCI+T2tsYWhvbWE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk9SXFxcIj5PcmVnb248L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlBBXFxcIj5QZW5uc3lsdmFuaWE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlJJXFxcIj5SaG9kZSBJc2xhbmQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNDXFxcIj5Tb3V0aCBDYXJvbGluYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU0RcXFwiPlNvdXRoIERha290YTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVE5cXFwiPlRlbm5lc3NlZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVFhcXFwiPlRleGFzPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJVVFxcXCI+VXRhaDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVlRcXFwiPlZlcm1vbnQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlZBXFxcIj5WaXJnaW5pYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiV0FcXFwiPldhc2hpbmd0b248L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIldWXFxcIj5XZXN0IFZpcmdpbmlhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJXSVxcXCI+V2lzY29uc2luPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJXWVxcXCI+V3lvbWluZzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPlppcCAvIFBvc3RhbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgbmFtZT1cXFwiYmlsbGluZ1Bvc3RhbENvZGVcXFwiIG1heGxlbmd0aD1cXFwiMjBcXFwiIGNsYXNzPVxcXCJzbWFsbFRleHRCb3hcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+UGhvbmU6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGlucHV0IG5hbWU9XFxcImJpbGxpbmdQaG9uZVxcXCIgbWF4bGVuZ3RoPVxcXCIyMFxcXCIgY2xhc3M9XFxcInNtYWxsVGV4dEJveFxcXCI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5FbWFpbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgbmFtZT1cXFwiYmlsbGluZ0VtYWlsXFxcIiBtYXhsZW5ndGg9XFxcIjI1MFxcXCIgIGNsYXNzPVxcXCJzbWFsbFRleHRCb3hcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjVcXFwiIGNlbGxzcGFjaW5nPVxcXCI1XFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsU2hpcHBpbmcyWW91VGl0bGVcXFwiPjxzcGFuIGNsYXNzPVxcXCJzbWFsbFNoaXBwaW5nUGFkZGluZ1xcXCI+U2hpcHBpbmcgQWRkcmVzczwvc3Bhbj4gPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIj4gU2FtZSBhcyBCaWxsaW5nIEFkZHJlc3M8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsT3V0ZXJTaGlwcGluZ1RkXFxcIiB2YWxpZ249XFxcInRvcFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkZpcnN0IE5hbWU6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGlucHV0IG5hbWU9XFxcInNoaXBwaW5nRmlyc3ROYW1lXFxcIiBtYXhsZW5ndGg9XFxcIjEwMFxcXCIgIGNsYXNzPVxcXCJzbWFsbFRleHRCb3hcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+TGFzdCBOYW1lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxpbnB1dCBuYW1lPVxcXCJzaGlwcGluZ0xhc3ROYW1lXFxcIiBtYXhsZW5ndGg9XFxcIjEwMFxcXCIgIGNsYXNzPVxcXCJzbWFsbFRleHRCb3hcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+QWRkcmVzczo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgbmFtZT1cXFwic2hpcHBpbmdBZGRyZXNzMVxcXCIgbWF4bGVuZ3RoPVxcXCIyNTBcXFwiIGNsYXNzPVxcXCJzbWFsbFRleHRCb3hcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+QWRkcmVzcyAyOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxpbnB1dCBtYXhsZW5ndGg9XFxcIjI1MFxcXCIgY2xhc3M9XFxcInNtYWxsVGV4dEJveFxcXCIgcGxhY2Vob2xkZXI9XFxcIk9wdGlvbmFsXFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkNpdHk6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGlucHV0IG5hbWU9XFxcInNoaXBwaW5nRmlyc3ROYW1lXFxcIiBtYXhsZW5ndGg9XFxcIjEwMFxcXCIgY2xhc3M9XFxcInNtYWxsVGV4dEJveFxcXCI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5TdGF0ZTo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cXFwic21hbGxUZXh0Qm94XFxcIiBuYW1lPVxcXCJzaGlwcGluZ1N0YXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIj9cXFwiPlNlbGVjdDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQUxcXFwiPkFsYWJhbWE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFLXFxcIj5BbGFza2E8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFaXFxcIj5Bcml6b25hPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBUlxcXCI+QXJrYW5zYXM8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNBXFxcIj5DYWxpZm9ybmlhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDT1xcXCI+Q29sb3JhZG88L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNUXFxcIj5Db25uZWN0aWN1dDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiREVcXFwiPkRlbGF3YXJlPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJEQ1xcXCI+RGlzdCBvZiBDb2x1bWJpYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRkxcXFwiPkZsb3JpZGE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkdBXFxcIj5HZW9yZ2lhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJISVxcXCI+SGF3YWlpPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJRFxcXCI+SWRhaG88L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklMXFxcIj5JbGxpbm9pczwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSU5cXFwiPkluZGlhbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklBXFxcIj5Jb3dhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJLU1xcXCI+S2Fuc2FzPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJLWVxcXCI+S2VudHVja3k8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkxBXFxcIj5Mb3Vpc2lhbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1FXFxcIj5NYWluZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTURcXFwiPk1hcnlsYW5kPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNQVxcXCI+TWFzc2FjaHVzZXR0czwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTUlcXFwiPk1pY2hpZ2FuPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNTlxcXCI+TWlubmVzb3RhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNU1xcXCI+TWlzc2lzc2lwcGk8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1PXFxcIj5NaXNzb3VyaTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTVRcXFwiPk1vbnRhbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5FXFxcIj5OZWJyYXNrYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTlZcXFwiPk5ldmFkYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTkhcXFwiPk5ldyBIYW1wc2hpcmU8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5KXFxcIj5OZXcgSmVyc2V5PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOTVxcXCI+TmV3IE1leGljbzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTllcXFwiPk5ldyBZb3JrPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOQ1xcXCI+Tm9ydGggQ2Fyb2xpbmE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5EXFxcIj5Ob3J0aCBEYWtvdGE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk9IXFxcIj5PaGlvPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJPS1xcXCI+T2tsYWhvbWE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk9SXFxcIj5PcmVnb248L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlBBXFxcIj5QZW5uc3lsdmFuaWE8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlJJXFxcIj5SaG9kZSBJc2xhbmQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNDXFxcIj5Tb3V0aCBDYXJvbGluYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU0RcXFwiPlNvdXRoIERha290YTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVE5cXFwiPlRlbm5lc3NlZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVFhcXFwiPlRleGFzPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJVVFxcXCI+VXRhaDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVlRcXFwiPlZlcm1vbnQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlZBXFxcIj5WaXJnaW5pYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiV0FcXFwiPldhc2hpbmd0b248L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIldWXFxcIj5XZXN0IFZpcmdpbmlhPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJXSVxcXCI+V2lzY29uc2luPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJXWVxcXCI+V3lvbWluZzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPlppcCAvIFBvc3RhbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgY2xhc3M9XFxcInNtYWxsVGV4dEJveFxcXCIgbWF4bGVuZ3RoPVxcXCIyMFxcXCI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5QaG9uZTo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48aW5wdXQgY2xhc3M9XFxcInNtYWxsVGV4dEJveFxcXCIgbWF4bGVuZ3RoPVxcXCIyMFxcXCIgcGxhY2Vob2xkZXI9XFxcIk9wdGlvbmFsXFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkVtYWlsOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxpbnB1dCBjbGFzcz1cXFwic21hbGxUZXh0Qm94XFxcIiBtYXhsZW5ndGg9XFxcIjI1MFxcXCIgcGxhY2Vob2xkZXI9XFxcIk9wdGlvbmFsXFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNoaXBwaW5nMllvdU1haW4gXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIwXFxcIiBjZWxsc3BhY2luZz1cXFwiMFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbFNoaXBwaW5nVGl0bGVcXFwiPlNoaXBwaW5nIHRvIFlvdTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsVGRQcmljZVF1YW50aXR5SGVhZGVyXFxcIj5QcmljZTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsVGRQcmljZVF1YW50aXR5SGVhZGVyXFxcIj5RdWFudGl0eTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsVG90YWxIZWFkZXJcXFwiPlRvdGFsPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbFByb2R1Y3RIZWFkZXJcXFwiPlNQT1JUIFN0ZWFrIFNlYXNvbmluZyBSdWI8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbFByb2R1Y3RQcmljZVxcXCIgPiQ1LjAwPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQcm9kdWN0UXVhbnRpdHlcXFwiID4xPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQcm9kdWN0VG90YWxcXFwiPiQ1LjAwPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49XFxcIjJcXFwiIGNsYXNzPVxcXCJzbWFsbFN1YlRvdGFsU3BhY2VcXFwiPiZuYnNwOzwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsU3ViVG9hbEhlYWRlclxcXCI+U3VidG90YWw6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxTdWJUb3RhbFByaWNlXFxcIj48c3BhbiBpZD1cXFwiY2FydC10b3RhbFxcXCIgPiQ1LjAwPC9zcGFuPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzaGlwcGluZzJZb3VNYWluXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIwXFxcIiBjZWxsc3BhY2luZz1cXFwiMFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbENvbW1lbnRzU3R5bGVcXFwiPkNvbW1lbnRzIG9yIEFkZGl0aW9uYWwgSW5mb3JtYXRpb248L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsVGV4dEFyZWFTdHlsZVxcXCI+PHRleHRhcmVhIGNvbHM9XFxcIjM1XFxcIiByb3dzPVxcXCIzXFxcIj48L3RleHRhcmVhPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzbWFsbEJ1dHRvblN0eWxlXFxcIj4gPGEgcm91dGVyTGluaz1cXFwiL0NhcnRcXFwiPiA8aW5wdXQgdHlwZT1cXFwiaW1hZ2VcXFwiIHNyYz1cXFwiL2ltYWdlcy9CYWNrX2J1dHRvbi5wbmdcXFwiPjwvYT4gPGEgcm91dGVyTGluaz1cXFwiL0NhcnQvUHJldmlld1xcXCI+PGlucHV0IHR5cGU9XFxcImltYWdlXFxcIiBzcmM9XFxcIi9pbWFnZXMvQ2hlY2tvdXRfYnV0dG9uLnBuZ1xcXCI+PC9hPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxcbiAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuXFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY2FydC9jaGVja291dC9jaGVja291dC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jaGVja291dC5jb21wb25lbnQuY3NzXCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L2NoZWNrb3V0L2NoZWNrb3V0LmNvbXBvbmVudC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5tYWluQ29udGVudCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgXFxuICAgIHRvcDogLTEwcHg7XFxufVxcblxcbi5tYWluRm9ybURpdiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6I2U4ZTNjODsgXFxuICAgIG1hcmdpbjogNXB4IDAgMCAxNXB4OyBcXG4gICAgcGFkZGluZzoxMHB4O1xcbn1cXG5cXG4uc21hbGxNYWluRm9ybURpdiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6I2U4ZTNjODsgXFxuICAgIG1hcmdpbjogNXB4IDAgMCAwcHg7IFxcbiAgICBwYWRkaW5nOjEwcHggMCAxMHB4IDA7XFxufVxcblxcbi5zbWFsbFRvcFBhZGRpbmcge1xcbiAgICBwYWRkaW5nLXRvcDo1cHg7XFxufVxcblxcbi50aXRsZURpdiB7XFxuICAgIGhlaWdodDogNDBweDtcXG4gICAgdGV4dC1hbGlnbjpsZWZ0O1xcbiAgICBwYWRkaW5nLXRvcDogOXB4O1xcbiAgICBwYWRkaW5nLWxlZnQ6IDE1cHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNiYzlhNzI7XFxuICAgIGNvbG9yOiM0YjI5MGM7XFxuICAgIGZvbnQtZmFtaWx5OiBDYW1icmlhO1xcbiAgICBmb250LXNpemU6IDE2cHg7XFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7XFxufVxcblxcbi50YWJsZVBhZGRpbmcge1xcbiAgICBwYWRkaW5nLXRvcDo1cHg7XFxufVxcblxcbi5hZGRyZXNzU3R5bGUge1xcbiAgICB3aWR0aDo0MzBweDsgXFxuICAgIGhlaWdodDoyNXB4OyBcXG4gICAgdGV4dC1hbGlnbjpsZWZ0OyBcXG4gICAgcGFkZGluZzo1cHg7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNkMmJlOWQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsQWRkcmVzc1N0eWxlIHtcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNoaXBwaW5nQWRkcmVzc1BhZGRpbmcge1xcbiAgICBwYWRkaW5nLXJpZ2h0OjEwcHg7XFxufVxcblxcbi5vdXRlclRkIHtcXG4gICAgd2lkdGg6NDMwcHg7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItYm90dG9tOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxPdXRlclRkIHtcXG4gICAgcGFkZGluZzo1cHg7ICBcXG4gICAgdGV4dC1hbGlnbjpsZWZ0OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5vdXRlclNoaXBwaW5nVGQge1xcbiAgICB3aWR0aDo0MzBweDsgXFxuICAgIHBhZGRpbmc6NXB4OyBcXG4gICAgdGV4dC1hbGlnbjpsZWZ0OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGJvcmRlcjogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxPdXRlclNoaXBwaW5nVGQge1xcbiAgICBwYWRkaW5nOjVweDsgIFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgYm9yZGVyOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5hbGlnblJpZ2h0IHtcXG4gICAgdGV4dC1hbGlnbjpyaWdodDtcXG59XFxuXFxuLnRleHRCb3gge1xcbiAgICB3aWR0aDoyMjVweDsgXFxuICAgIG1hcmdpbjo1cHg7XFxufVxcblxcbi5zbWFsbFRleHRCb3gge1xcbiAgICB3aWR0aDoxMDAlOyBcXG4gICAgbWFyZ2luOjVweDtcXG59XFxuXFxuLnNoaXBwaW5nMllvdU1haW4ge1xcbiAgICBwYWRkaW5nLXRvcDoyNXB4O1xcbn1cXG5cXG4uc2hpcHBpbmcyWW91VGl0bGUge1xcbiAgICB3aWR0aDo1MDBweDsgXFxuICAgIGhlaWdodDoyNXB4OyBcXG4gICAgdGV4dC1hbGlnbjpsZWZ0OyBcXG4gICAgcGFkZGluZzo1cHg7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNkMmJlOWQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFNoaXBwaW5nMllvdVRpdGxlIHtcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFNoaXBwaW5nVGl0bGUge1xcbiAgICBoZWlnaHQ6MjVweDsgXFxuICAgIHRleHQtYWxpZ246bGVmdDsgXFxuICAgIHBhZGRpbmc6NXB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojZDJiZTlkOyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxTaGlwcGluZ1BhZGRpbmcge1xcbiAgICBwYWRkaW5nLXJpZ2h0OjEwcHg7XFxufVxcblxcbi50ZFByaWNlUXVhbnRpdHlUb3RhbEhlYWRlciB7XFxuICAgIHdpZHRoOjEwMHB4OyBcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsVGRQcmljZVF1YW50aXR5SGVhZGVyIHtcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDtcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxUb3RhbEhlYWRlciB7XFxuICAgIGhlaWdodDoyNXB4OyBcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNkMmJlOWQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnByb2R1Y3RIZWFkZXIge1xcbiAgICB3aWR0aDogNTAwcHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBwYWRkaW5nOiA1cHg7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFByb2R1Y3RIZWFkZXIge1xcbiAgICBwYWRkaW5nOiA1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5wcm9kdWN0UHJpY2VUb3RhbCB7XFxuICAgIHdpZHRoOiAxMDBweDsgXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsUHJvZHVjdFByaWNlIHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyBcXG4gICAgY29sb3I6ICM0YjI5MGM7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxQcm9kdWN0VG90YWwge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuXFxuLnByb2R1Y3RRdWFudGl0eSB7XFxuICAgIHdpZHRoOiAxMDBweDsgXFxuICAgIHBhZGRpbmc6IDVweDsgXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsUHJvZHVjdFF1YW50aXR5IHtcXG4gICAgcGFkZGluZzogNXB4OyBcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyBcXG4gICAgY29sb3I6ICM0YjI5MGM7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7XFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zdWJUb3RhbFNwYWNlIHtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG5cXG4uc21hbGxTdWJUb3RhbFNwYWNlIHtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG5cXG4uc3ViVG90YWxIZWFkZXIge1xcbiAgICB3aWR0aDogMTAwcHg7IFxcbiAgICBoZWlnaHQ6IDM1cHg7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkOyBcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItYm90dG9tOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFN1YlRvYWxIZWFkZXIge1xcbiAgICBoZWlnaHQ6IDM1cHg7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkOyBcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItYm90dG9tOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zdWJUb3RhbFByaWNlIHtcXG4gICAgd2lkdGg6IDEwMHB4OyBcXG4gICAgaGVpZ2h0OiAzNXB4OyBcXG4gICAgY29sb3I6ICM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDogYm9sZDsgXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxTdWJUb3RhbFByaWNlIHsgIFxcbiAgICBoZWlnaHQ6IDM1cHg7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkOyBcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItYm90dG9tOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcblxcblxcbi5jb21tZW50c1N0eWxlIHtcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxDb21tZW50c1N0eWxlIHtcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi50ZXh0QXJlYVN0eWxlIHtcXG4gICAgcGFkZGluZzo1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxUZXh0QXJlYVN0eWxlIHtcXG4gICAgcGFkZGluZzo1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uYnV0dG9uU3R5bGUge1xcbiAgICBtYXJnaW4tdG9wOjI1cHg7IFxcbiAgICBwYWRkaW5nOjEwcHg7IFxcbiAgICBib3JkZXI6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIHRleHQtYWxpZ246cmlnaHQ7XFxufVxcblxcbi5zbWFsbEJ1dHRvblN0eWxlIHtcXG4gICAgbWFyZ2luLXRvcDoyNXB4OyBcXG4gICAgcGFkZGluZzoxMHB4OyBcXG4gICAgYm9yZGVyOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICB0ZXh0LWFsaWduOnJpZ2h0O1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2NhcnQvY2hlY2tvdXQvY2hlY2tvdXQuY29tcG9uZW50LmNzc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncHJldmlldycsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vcHJldmlldy5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vcHJldmlldy5jb21wb25lbnQuY3NzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgUHJldmlld0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgY29uc3RydWN0b3IoKSB7IH1cblxuICAgIG5nT25Jbml0KCkgeyB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L3ByZXZpZXcvcHJldmlldy5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuICAgIDxkaXYgaWQ9XFxcImNvbnRlbnRcXFwiIGNsYXNzPVxcXCJtYWluQ29udGVudFxcXCI+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoaWRkZW4teHMgaGlkZGVuLXNtIGhlYWRlckRpdlxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVhZGVyU3R5bGVcXFwiPjxzcGFuPlByZXZpZXcgT3JkZXIgJmFtcDsgRW50ZXIgUGF5bWVudCBJbmZvcm1hdGlvbiAmZ3Q7IFN0ZXAgMyBvZiA0PC9zcGFuPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoaWRkZW4teHMgaGlkZGVuLXNtIHRhYmxlTWFpbkRpdlxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFkZGluZ1ByZXZpZXdcXFwiPlxcbiAgICAgICAgICAgICAgICA8dGFibGUgYm9yZGVyPVxcXCIwXFxcIiBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYmlsbGluZ0FkZHJlc3NcXFwiPkJpbGxpbmcgQWRkcmVzczwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic2hpcHBpbmdBZGRyZXNzXFxcIj5TaGlwcGluZyBBZGRyZXNzPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJiaWxsaW5nU3R5bGVcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIyXFxcIiBjZWxsc3BhY2luZz1cXFwiMlxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5OYW1lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+SmFzb24gU3RhbmxleTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCIgdmFsaWduPVxcXCJ0b3BcXFwiPkFkZHJlc3M6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD41MzA3IE4gQWRhbXMgU3QgPGJyPlNwb2thbmUsIFdBIDk5MjA1PGJyPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+UGhvbmU6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD41MDkyOTAyMzUzPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5FbWFpbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPmphc29uc3RhbmwzeUBnbWFpbC5jb208L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNoaXBwaW5nU3R5bGVcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIyXFxcIiBjZWxsc3BhY2luZz1cXFwiMlxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5OYW1lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduQ2VudGVyXFxcIj5KYXNvbiBTdGFubGV5PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIiB2YWxpZ249XFxcInRvcFxcXCI+QWRkcmVzczo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnbkNlbnRlclxcXCI+NTMwNyBOIEFkYW1zIFN0IDxicj5TcG9rYW5lLCBXQSA5OTIwNTxicj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPlBob25lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduQ2VudGVyXFxcIj41MDkyOTAyMzUzPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5FbWFpbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnbkNlbnRlclxcXCI+amFzb25zdGFubDN5QGdtYWlsLmNvbTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFkZGluZ1RvcFxcXCI+XFxuICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIwXFxcIiBjZWxsc3BhY2luZz1cXFwiMFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzaGlwcGluZzJZb3VTdHlsZVxcXCI+U2hpcHBpbmcgdG8gWW91PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJwcmljZVF1YW50aXR5U3R5bGVIZWFkZXJcXFwiPlByaWNlPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJwcmljZVF1YW50aXR5U3R5bGVIZWFkZXJcXFwiPlF1YW50aXR5PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJ0b3RhbFN0eWxlSGVhZGVyXFxcIj5Ub3RhbDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwicHJvZHVjdFN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNQT1JUIFN0ZWFrIFNlYXNvbmluZyBSdWJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJwcmljZVN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQ1LjAwXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwicXVhbnRpdHlTdHlsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwidG90YWxTdHlsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkNS4wMFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiMlxcXCIgY2xhc3M9XFxcInN1YlRvdGFsU3BhY2VcXFwiPiZuYnNwOzwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic3ViVG90YWxIZWFkZXJcXFwiPlN1YnRvdGFsOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic3ViVG90YWxQcmljZVxcXCI+JDUuMDA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiMlxcXCIgY2xhc3M9XFxcInRheFNwYWNlXFxcIj4mbmJzcDs8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInRheEhlYWRlclxcXCI+VGF4OjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwidGF4QW1vdW50XFxcIj4kMC4wMDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic2hpcHBpbmdIYW5kbGluZ1N0eWxlXFxcIiBjb2xzcGFuPVxcXCIzXFxcIiBhbGlnbj1cXFwicmlnaHRcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpTaGlwcGluZyAmYW1wOyBIYW5kbGluZzpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3Q+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiU2VsZWN0XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjEzN1xcXCIgc2VsZWN0ZWQ9XFxcInNlbGVjdGVkXFxcIj5TZWxlY3Q8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJVLlMuUC5TLiBQYXJjZWwgKDMgLSA4IGRheXMpXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjEzOFxcXCI+VS5TLlAuUy4gUGFyY2VsICgzIC0gOCBkYXlzKTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIlUuUy5QLlMuIFByaW9yaXR5ICgyIC0gNCBkYXlzKVxcXCIgdmFsdWU9XFxcIm9iamVjdDoxMzlcXFwiPlUuUy5QLlMuIFByaW9yaXR5ICgyIC0gNCBkYXlzKTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic2hpcHBpbmdIYW5kbGluZ1ByaWNlXFxcIiB2YWxpZ249XFxcInRvcFxcXCI+JDAuMDA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiMlxcXCIgY2xhc3M9XFxcInRvdGFsU3BhY2VcXFwiPiZuYnNwOzwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwidG90YWxIZWFkZXJcXFwiPlRvdGFsOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBpZD1cXFwidGRUb3RhbFByaWNlXFxcIiBjbGFzcz1cXFwidG90YWxQcmljZVxcXCI+JDUuMDA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiNFxcXCIgY2xhc3M9XFxcIm5vdGVTdHlsZVxcXCI+KlNoaXBwaW5nIGR1cmF0aW9ucyBhcmUgZXN0aW1hdGVzIGFuZCBub3QgYSBndWFyYW50ZWU8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFkZGluZ1RvcFxcXCI+XFxuICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIwXFxcIiBjZWxsc3BhY2luZz1cXFwiMFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJwYXlJbmZvSGVhZGVyXFxcIj5QYXltZW50IEluZm9ybWF0aW9uPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJwYXlJbmZvVGRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmVkQ29sb3JcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+Q2FyZCBUeXBlOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cXFwic2VsZWN0Q2FyZFN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiU2VsZWN0XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE0MVxcXCIgc2VsZWN0ZWQ9XFxcInNlbGVjdGVkXFxcIj5TZWxlY3Q8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiVmlzYVxcXCIgdmFsdWU9XFxcIm9iamVjdDoxNDJcXFwiPlZpc2E8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiTWFzdGVyQ2FyZFxcXCIgdmFsdWU9XFxcIm9iamVjdDoxNDNcXFwiPk1hc3RlckNhcmQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiRGlzY292ZXJcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTQ0XFxcIj5EaXNjb3Zlcjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJBbWVyaWNhbiBFeHByZXNzXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE0NVxcXCI+QW1lcmljYW4gRXhwcmVzczwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIyXFxcIj4mbmJzcDs8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkNhcmQgTnVtYmVyOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImNhcmRUZFxcXCI+PGlucHV0IGNsYXNzPVxcXCJjYXJkSW5wdXRTdHlsZVxcXCIgcGxhY2Vob2xkZXI9XFxcIkNhcmQgTnVtYmVyXFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5FeHBpcmF0aW9uOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cXFwiZXhwaXJhdGlvblNlbGVjdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIlNlbGVjdFxcXCIgdmFsdWU9XFxcIm9iamVjdDoxNDhcXFwiIHNlbGVjdGVkPVxcXCJzZWxlY3RlZFxcXCI+U2VsZWN0PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIkphbnVhcnlcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTQ5XFxcIj5KYW51YXJ5PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIkZlYnJ1YXJ5XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE1MFxcXCI+RmVicnVhcnk8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiTWFyY2hcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTUxXFxcIj5NYXJjaDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJBcHJpbFxcXCIgdmFsdWU9XFxcIm9iamVjdDoxNTJcXFwiPkFwcmlsPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIk1heVxcXCIgdmFsdWU9XFxcIm9iamVjdDoxNTNcXFwiPk1heTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJKdW5lXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE1NFxcXCI+SnVuZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJKdWx5XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE1NVxcXCI+SnVseTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJBdWd1c3RcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTU2XFxcIj5BdWd1c3Q8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiU2VwdGVtYmVyXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE1N1xcXCI+U2VwdGVtYmVyPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIk9jdG9iZXJcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTU4XFxcIj5PY3RvYmVyPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIk5vdmVtYmVyXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE1OVxcXCI+Tm92ZW1iZXI8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiRGVjZW1iZXJcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTYwXFxcIj5EZWNlbWJlcjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XFxcImV4cGlyYXRpb25TZWxlY3RcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJTZWxlY3RcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTYyXFxcIiBzZWxlY3RlZD1cXFwic2VsZWN0ZWRcXFwiPlNlbGVjdDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDE3XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2M1xcXCI+MjAxNzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDE4XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2NFxcXCI+MjAxODwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDE5XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2NVxcXCI+MjAxOTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDIwXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2NlxcXCI+MjAyMDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDIxXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2N1xcXCI+MjAyMTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDIyXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2OFxcXCI+MjAyMjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDIzXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2OVxcXCI+MjAyMzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDI0XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE3MFxcXCI+MjAyNDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDI1XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE3MVxcXCI+MjAyNTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDI2XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE3MlxcXCI+MjAyNjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDI3XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE3M1xcXCI+MjAyNzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJsaW5rU3BhY2luZ1xcXCI+Jm5ic3A7PGEgcm91dGVyTGluaz1cXFwiL0NhcnQvQ2hlY2tvdXRcXFwiPjxpbWcgYWx0PVxcXCJCYWNrXFxcIiBjbGFzcz1cXFwicG9pbnRlclxcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi93d3dyb290L2ltYWdlcy9CYWNrX2J1dHRvbi5wbmdcIikgKyBcIlxcXCI+PC9hPiA8YSByb3V0ZXJMaW5rPVxcXCIvQ2FydC9SZWNlaXB0XFxcIj48aW1nIGFsdD1cXFwiUHVyY2hhc2VcXFwiIGNsYXNzPVxcXCJwb2ludGVyXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL1B1cmNoYXNlX2J1dHRvbi5wbmdcIikgKyBcIlxcXCI+PC9hPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInZpc2libGUteHMgdmlzaWJsZS1zbSBzbWFsbE1haW5Db250ZW50XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzbWFsbEhlYWRlclN0eWxlXFxcIj48c3Bhbj5TdGVwIDMgb2YgNDwvc3Bhbj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidmlzaWJsZS14cyB2aXNpYmxlLXNtIHRhYmxlU21hbGxEaXZcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZGRpbmdQcmV2aWV3XFxcIj5cXG4gICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsQmlsbGluZ0FkZHJlc3NcXFwiPkJpbGxpbmcgQWRkcmVzczwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxCaWxsaW5nU3R5bGVcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIyXFxcIiBjZWxsc3BhY2luZz1cXFwiMlxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5OYW1lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsQWxpZ25MZWZ0V2l0aFBhZGRpbmdcXFwiPkphc29uIFN0YW5sZXk8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5BZGRyZXNzOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsQWxpZ25MZWZ0V2l0aFBhZGRpbmdcXFwiPjUzMDcgTiBBZGFtcyBTdCA8YnI+U3Bva2FuZSwgV0EgOTkyMDU8YnI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5QaG9uZTo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbEFsaWduTGVmdFdpdGhQYWRkaW5nXFxcIj41MDk4NDQ1Njk4PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5FbWFpbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbEFsaWduTGVmdFdpdGhQYWRkaW5nXFxcIj5qYXNvbnN0YW5sM3lAZ21haWwuY29tPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbFNoaXBwaW5nSGVhZGVyXFxcIj5TaGlwcGluZyBBZGRyZXNzPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbFNoaXBwaW5nU3R5bGVcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIyXFxcIiBjZWxsc3BhY2luZz1cXFwiMlxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5OYW1lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgc3R5bGU9XFxcInRleHQtYWxpZ246bGVmdDsgcGFkZGluZzowIDAgMCA1cHhcXFwiPkphc29uIFN0YW5sZXk8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5BZGRyZXNzOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsQWxpZ25MZWZ0V2l0aFBhZGRpbmdcXFwiPjUzMDcgTiBBZGFtcyBTdCA8YnI+U3Bva2FuZSwgV0EgOTkyMDU8YnI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5QaG9uZTo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbEFsaWduTGVmdFdpdGhQYWRkaW5nXFxcIj41MDk4NDQ1Njk4PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5FbWFpbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbEFsaWduTGVmdFdpdGhQYWRkaW5nXFxcIj5qYXNvbnN0YW5sM3lAZ21haWwuY29tPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWRkaW5nVG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsU2hpcHBpbmcyWW91U3R5bGVcXFwiPlNoaXBwaW5nIHRvIFlvdTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQcmljZVF1YW50aXR5SGVhZGVyXFxcIj5QcmljZTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQcmljZVF1YW50aXR5SGVhZGVyXFxcIj5RdWFudGl0eTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxUb3RhbFN0eWxlSGVhZGVyXFxcIj5Ub3RhbDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQcm9kdWN0U3R5bGVcXFwiPlNQT1JUIFN0ZWFrIFNlYXNvbmluZyBSdWI8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsUHJpY2VTdHlsZVxcXCI+JDUuMDA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsUXVhbnRpdHlTdHlsZVxcXCI+MTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxUb3RhbFN0eWxlXFxcIj4kNS4wMDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIyXFxcIiBjbGFzcz1cXFwic21hbGxTdWJUb3RhbFNwYWNlXFxcIj4mbmJzcDs8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsU3ViVG90YWxIZWFkZXJcXFwiPlN1YnRvdGFsOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxTdWJUb3RhbFByaWNlXFxcIj4kNS4wMDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIyXFxcIiBjbGFzcz1cXFwidGF4U3BhY2VcXFwiPiZuYnNwOzwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxUYXhIZWFkZXJcXFwiPlRheDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsVGF4QW1vdW50XFxcIj4kMC4wMDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic2hpcHBpbmdIYW5kbGluZ1N0eWxlXFxcIiBjb2xzcGFuPVxcXCIzXFxcIiBhbGlnbj1cXFwicmlnaHRcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpTaGlwcGluZyAmYW1wOyBIYW5kbGluZzpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3Q+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiU2VsZWN0XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjEzN1xcXCIgc2VsZWN0ZWQ9XFxcInNlbGVjdGVkXFxcIj5TZWxlY3Q8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJVLlMuUC5TLiBQYXJjZWwgKDMgLSA4IGRheXMpXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjEzOFxcXCI+VS5TLlAuUy4gUGFyY2VsICgzIC0gOCBkYXlzKTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIlUuUy5QLlMuIFByaW9yaXR5ICgyIC0gNCBkYXlzKVxcXCIgdmFsdWU9XFxcIm9iamVjdDoxMzlcXFwiPlUuUy5QLlMuIFByaW9yaXR5ICgyIC0gNCBkYXlzKTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxTaGlwcGluZ0hhbmRsaW5nUHJpY2VcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj4kMC4wMDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIyXFxcIiBjbGFzcz1cXFwidG90YWxTcGFjZVxcXCI+Jm5ic3A7PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbFRvdGFsSGVhZGVyXFxcIj5Ub3RhbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgaWQ9XFxcInRkVG90YWxQcmljZVxcXCIgY2xhc3M9XFxcInNtYWxsVG90YWxQcmljZVxcXCI+JDUuMDA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiNFxcXCIgY2xhc3M9XFxcInNtYWxsTm90ZVN0eWxlXFxcIj4qU2hpcHBpbmcgZHVyYXRpb25zIGFyZSBlc3RpbWF0ZXMgYW5kIG5vdCBhIGd1YXJhbnRlZTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICBcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWRkaW5nVG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsUGF5SW5mb0hlYWRlclxcXCI+UGF5bWVudCBJbmZvcm1hdGlvbjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQYXlJbmZvVGRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmVkQ29sb3JcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+Q2FyZCBUeXBlOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduTGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cXFwic21hbGxTZWxlY3RDYXJkU3R5bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJTZWxlY3RcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTQxXFxcIiBzZWxlY3RlZD1cXFwic2VsZWN0ZWRcXFwiPlNlbGVjdDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJWaXNhXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE0MlxcXCI+VmlzYTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJNYXN0ZXJDYXJkXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE0M1xcXCI+TWFzdGVyQ2FyZDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJEaXNjb3ZlclxcXCIgdmFsdWU9XFxcIm9iamVjdDoxNDRcXFwiPkRpc2NvdmVyPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIkFtZXJpY2FuIEV4cHJlc3NcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTQ1XFxcIj5BbWVyaWNhbiBFeHByZXNzPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkNhcmQgTnVtYmVyOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsQ2FyZFRkXFxcIj48aW5wdXQgY2xhc3M9XFxcInNtYWxsQ2FyZElucHV0U3R5bGVcXFwiIHBsYWNlaG9sZGVyPVxcXCJDYXJkIE51bWJlclxcXCI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5FeHBpcmF0aW9uOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduTGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cXFwiZXhwaXJhdGlvblNlbGVjdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIlNlbGVjdFxcXCIgdmFsdWU9XFxcIm9iamVjdDoxNDhcXFwiIHNlbGVjdGVkPVxcXCJzZWxlY3RlZFxcXCI+U2VsZWN0PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIkphbnVhcnlcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTQ5XFxcIj5KYW51YXJ5PC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIkZlYnJ1YXJ5XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE1MFxcXCI+RmVicnVhcnk8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiTWFyY2hcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTUxXFxcIj5NYXJjaDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJBcHJpbFxcXCIgdmFsdWU9XFxcIm9iamVjdDoxNTJcXFwiPkFwcmlsPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIk1heVxcXCIgdmFsdWU9XFxcIm9iamVjdDoxNTNcXFwiPk1heTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJKdW5lXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE1NFxcXCI+SnVuZTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJKdWx5XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE1NVxcXCI+SnVseTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJBdWd1c3RcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTU2XFxcIj5BdWd1c3Q8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiU2VwdGVtYmVyXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE1N1xcXCI+U2VwdGVtYmVyPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIk9jdG9iZXJcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTU4XFxcIj5PY3RvYmVyPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gbGFiZWw9XFxcIk5vdmVtYmVyXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE1OVxcXCI+Tm92ZW1iZXI8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBsYWJlbD1cXFwiRGVjZW1iZXJcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTYwXFxcIj5EZWNlbWJlcjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XFxcImV4cGlyYXRpb25TZWxlY3RcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCJTZWxlY3RcXFwiIHZhbHVlPVxcXCJvYmplY3Q6MTYyXFxcIiBzZWxlY3RlZD1cXFwic2VsZWN0ZWRcXFwiPlNlbGVjdDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDE3XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2M1xcXCI+MjAxNzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDE4XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2NFxcXCI+MjAxODwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDE5XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2NVxcXCI+MjAxOTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDIwXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2NlxcXCI+MjAyMDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDIxXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2N1xcXCI+MjAyMTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDIyXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2OFxcXCI+MjAyMjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDIzXFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE2OVxcXCI+MjAyMzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDI0XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE3MFxcXCI+MjAyNDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDI1XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE3MVxcXCI+MjAyNTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDI2XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE3MlxcXCI+MjAyNjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIGxhYmVsPVxcXCIyMDI3XFxcIiB2YWx1ZT1cXFwib2JqZWN0OjE3M1xcXCI+MjAyNzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJsaW5rU3BhY2luZ1xcXCI+PGEgcm91dGVyTGluaz1cXFwiL0NhcnQvQ2hlY2tvdXRcXFwiPjxpbWcgYWx0PVxcXCJCYWNrXFxcIiBjbGFzcz1cXFwicG9pbnRlclxcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi93d3dyb290L2ltYWdlcy9CYWNrX2J1dHRvbi5wbmdcIikgKyBcIlxcXCI+PC9hPiA8YSByb3V0ZXJMaW5rPVxcXCIvQ2FydC9SZWNlaXB0XFxcIj48aW1nIGFsdD1cXFwiUHVyY2hhc2VcXFwiIGNsYXNzPVxcXCJwb2ludGVyXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL1B1cmNoYXNlX2J1dHRvbi5wbmdcIikgKyBcIlxcXCI+PC9hPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY2FydC9wcmV2aWV3L3ByZXZpZXcuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJldmlldy5jb21wb25lbnQuY3NzXCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L3ByZXZpZXcvcHJldmlldy5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubWFpbkNvbnRlbnQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IFxcbiAgICB0b3A6IC0xMHB4O1xcbn1cXG5cXG4uc21hbGxNYWluQ29udGVudCB7XFxuICAgIG1hcmdpbjogMHB4IDAgMCAwcHg7XFxufVxcblxcbi5oZWFkZXJEaXYge1xcbiAgICBtYXJnaW46IDE1cHggMCAwIDE1cHg7XFxufVxcblxcbi5oZWFkZXJTdHlsZSB7XFxuICAgIGhlaWdodDogNDBweDsgXFxuICAgIHBhZGRpbmctdG9wOiA5cHg7IFxcbiAgICBwYWRkaW5nLWxlZnQ6IDE1cHg7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmM5YTcyOyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtZmFtaWx5OiBDYW1icmlhOyBcXG4gICAgZm9udC1zaXplOiAxNnB4OyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDtcXG59XFxuXFxuLnNtYWxsSGVhZGVyU3R5bGUge1xcbiAgICBoZWlnaHQ6IDUwcHg7IFxcbiAgICBwYWRkaW5nLXRvcDogOXB4OyBcXG4gICAgcGFkZGluZy1sZWZ0OiA1cHg7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmM5YTcyOyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtZmFtaWx5OiBDYW1icmlhOyBcXG4gICAgZm9udC1zaXplOiAxNHB4OyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDtcXG59XFxuXFxuLnRhYmxlTWFpbkRpdiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6I2U4ZTNjODsgXFxuICAgIG1hcmdpbjogNXB4IDAgMCAxNXB4OyBcXG4gICAgcGFkZGluZzoxMHB4O1xcbn1cXG5cXG4udGFibGVTbWFsbERpdiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6I2U4ZTNjODsgXFxuICAgIG1hcmdpbjogNXB4IDAgMCAwcHg7IFxcbiAgICBwYWRkaW5nOjEwcHg7XFxufVxcblxcbi5wYWRkaW5nUHJldmlldyB7XFxuICAgIHBhZGRpbmctdG9wOjVweDtcXG59XFxuXFxuLmJpbGxpbmdBZGRyZXNzIHtcXG4gICAgd2lkdGg6NDMwcHg7IFxcbiAgICBoZWlnaHQ6MjVweDtcXG4gICAgcGFkZGluZzo1cHg7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNkMmJlOWQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbEJpbGxpbmdBZGRyZXNzIHtcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNoaXBwaW5nQWRkcmVzcyB7XFxuICAgIHdpZHRoOjQzMHB4OyBcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5iaWxsaW5nU3R5bGUge1xcbiAgICB3aWR0aDo0MzBweDsgXFxuICAgIHBhZGRpbmc6NXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbEJpbGxpbmdTdHlsZSB7XFxuICAgIHBhZGRpbmc6NXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5hbGlnblJpZ2h0IHtcXG4gICAgdGV4dC1hbGlnbjpyaWdodDtcXG59XFxuXFxuLnNtYWxsQWxpZ25MZWZ0V2l0aFBhZGRpbmcge1xcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBwYWRkaW5nOjAgMCAwIDVweDtcXG59XFxuXFxuLnNoaXBwaW5nU3R5bGUge1xcbiAgICB3aWR0aDo0MzBweDsgXFxuICAgIHRleHQtYWxpZ246bGVmdDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBib3JkZXI6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsU2hpcHBpbmdIZWFkZXIge1xcbiAgICBoZWlnaHQ6MjVweDsgXFxuICAgIHBhZGRpbmc6NXB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojZDJiZTlkOyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICBib3JkZXI6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsU2hpcHBpbmdTdHlsZSB7XFxuICAgIHRleHQtYWxpZ246bGVmdDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBib3JkZXI6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLmFsaWduQ2VudGVyIHtcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7XFxufVxcblxcbi5wYWRkaW5nVG9wIHtcXG4gICAgcGFkZGluZy10b3A6MjVweDtcXG59XFxuXFxuLnNoaXBwaW5nMllvdVN0eWxlIHtcXG4gICAgd2lkdGg6NTAwcHg7IFxcbiAgICBoZWlnaHQ6MjVweDsgXFxuICAgIHBhZGRpbmc6NXB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojZDJiZTlkOyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxTaGlwcGluZzJZb3VTdHlsZSB7XFxuICAgIGhlaWdodDoyNXB4OyBcXG4gICAgcGFkZGluZzo1cHg7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNkMmJlOWQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5wcmljZVF1YW50aXR5U3R5bGVIZWFkZXIge1xcbiAgICB3aWR0aDoxMDBweDsgXFxuICAgIGhlaWdodDoyNXB4OyBcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNkMmJlOWQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFByaWNlUXVhbnRpdHlIZWFkZXIge1xcbiAgICBoZWlnaHQ6MjVweDsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyOyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojZDJiZTlkOyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4udG90YWxTdHlsZUhlYWRlciB7XFxuICAgIHdpZHRoOjEwMHB4OyBcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxUb3RhbFN0eWxlSGVhZGVyIHtcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4ucHJvZHVjdFN0eWxlIHtcXG4gICAgd2lkdGg6IDUwMHB4OyBcXG4gICAgcGFkZGluZzogNXB4OyBcXG4gICAgY29sb3I6ICM0YjI5MGM7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7XFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFByb2R1Y3RTdHlsZSB7XFxuICAgIHBhZGRpbmc6IDVweDsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnByaWNlU3R5bGUge1xcbiAgICB3aWR0aDogMTAwcHg7IFxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsUHJpY2VTdHlsZSB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnF1YW50aXR5U3R5bGUge1xcbiAgICB3aWR0aDogMTAwcHg7IFxcbiAgICBwYWRkaW5nOiA1cHg7IFxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsUXVhbnRpdHlTdHlsZSB7XFxuICAgIHBhZGRpbmc6IDVweDsgXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnRvdGFsU3R5bGUge1xcbiAgICB3aWR0aDogMTAwcHg7IFxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxUb3RhbFN0eWxlIHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyBcXG4gICAgY29sb3I6ICM0YjI5MGM7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcblxcbi5zdWJUb3RhbFNwYWNlIHtcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsU3ViVG90YWxTcGFjZSB7XFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zdWJUb3RhbEhlYWRlciB7XFxuICAgIHdpZHRoOjEwMHB4OyBcXG4gICAgaGVpZ2h0OjM1cHg7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgdGV4dC1hbGlnbjpyaWdodDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsU3ViVG90YWxIZWFkZXIge1xcbiAgICBoZWlnaHQ6MzVweDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICB0ZXh0LWFsaWduOnJpZ2h0OyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc3ViVG90YWxQcmljZSB7XFxuICAgIHdpZHRoOjEwMHB4OyBcXG4gICAgaGVpZ2h0OjM1cHg7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsU3ViVG90YWxQcmljZSB7XFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi50YXhTcGFjZSB7XFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi50YXhIZWFkZXIge1xcbiAgICB3aWR0aDoxMDBweDsgXFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIHRleHQtYWxpZ246cmlnaHQ7XFxufVxcblxcbi5zbWFsbFRheEhlYWRlciB7XFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIHRleHQtYWxpZ246cmlnaHQ7XFxufVxcblxcbi50YXhBbW91bnQge1xcbiAgICB3aWR0aDoxMDBweDsgXFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFRheEFtb3VudCB7XFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zaGlwcGluZ0hhbmRsaW5nU3R5bGUge1xcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgY29sb3I6IzRiMjkwYztcXG59XFxuXFxuLnNoaXBwaW5nSGFuZGxpbmdQcmljZSB7XFxuICAgIHdpZHRoOjEwMHB4OyBcXG4gICAgaGVpZ2h0OjM1cHg7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsU2hpcHBpbmdIYW5kbGluZ1ByaWNlIHtcXG4gICAgaGVpZ2h0OjM1cHg7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnRvdGFsU3BhY2Uge1xcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4udG90YWxIZWFkZXIge1xcbiAgICB3aWR0aDoxMDBweDsgXFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICB0ZXh0LWFsaWduOnJpZ2h0OyBcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxUb3RhbEhlYWRlciB7XFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICB0ZXh0LWFsaWduOnJpZ2h0OyBcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4udG90YWxQcmljZSB7XFxuICAgIHdpZHRoOjEwMHB4OyBcXG4gICAgaGVpZ2h0OjM1cHg7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItYm90dG9tOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFRvdGFsUHJpY2Uge1xcbiAgICBoZWlnaHQ6MzVweDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLm5vdGVTdHlsZSB7XFxuICAgIHRleHQtYWxpZ246cmlnaHQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC1zdHlsZTppdGFsaWM7IFxcbiAgICBwYWRkaW5nLXRvcDoycHg7IFxcbiAgICBwYWRkaW5nLXJpZ2h0OjNweDtcXG59XFxuXFxuLnNtYWxsTm90ZVN0eWxlIHtcXG4gICAgdGV4dC1hbGlnbjpyaWdodDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXN0eWxlOml0YWxpYzsgXFxuICAgIHBhZGRpbmctdG9wOjJweDsgXFxuICAgIHBhZGRpbmctcmlnaHQ6M3B4O1xcbn1cXG5cXG4ucGF5SW5mb0hlYWRlciB7XFxuICAgIGhlaWdodDoyNXB4OyBcXG4gICAgcGFkZGluZzo1cHg7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNkMmJlOWQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsUGF5SW5mb0hlYWRlciB7XFxuICAgIGhlaWdodDoyNXB4OyBcXG4gICAgcGFkZGluZzo1cHg7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNkMmJlOWQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnBheUluZm9UZCB7XFxuICAgIHBhZGRpbmc6NXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsUGF5SW5mb1RkIHtcXG4gICAgcGFkZGluZzo1cHg7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4ucmVkQ29sb3Ige1xcbiAgICBjb2xvcjpyZWQ7XFxufVxcblxcbi5hbGlnbkxlZnQge1xcbiAgICB0ZXh0LWFsaWduOmxlZnQ7XFxufVxcblxcbi5zZWxlY3RDYXJkU3R5bGUge1xcbiAgICB3aWR0aDozMjBweDtcXG4gICAgbWFyZ2luOjVweDtcXG59XFxuXFxuLnNtYWxsU2VsZWN0Q2FyZFN0eWxlIHtcXG4gICAgbWFyZ2luOjVweDtcXG59XFxuXFxuLmNhcmRUZCB7XFxuICAgIHBhZGRpbmctcmlnaHQ6MTBweDtcXG59XFxuXFxuLnNtYWxsQ2FyZFRkIHtcXG4gICAgdGV4dC1hbGlnbjpsZWZ0OyBcXG4gICAgcGFkZGluZy1yaWdodDoxMHB4O1xcbn1cXG5cXG4uY2FyZElucHV0U3R5bGUge1xcbiAgICB3aWR0aDozMjBweDsgXFxuICAgIG1hcmdpbjo1cHg7XFxufVxcblxcbi5zbWFsbENhcmRJbnB1dFN0eWxlIHtcXG4gICAgbWFyZ2luOjVweDtcXG59XFxuXFxuLmV4cGlyYXRpb25TZWxlY3Qge1xcbiAgICB3aWR0aDoxMDBweDtcXG59XFxuXFxuLmxpbmtTcGFjaW5nIHtcXG4gICAgaGVpZ2h0OjQ1cHg7IFxcbiAgICBwYWRkaW5nOjEwcHg7IFxcbiAgICBib3JkZXI6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIHRleHQtYWxpZ246cmlnaHQ7IFxcbiAgICBwYWRkaW5nLXJpZ2h0OjVweDtcXG59XFxuXFxuXFxuXFxuLnBvaW50ZXIge1xcbiAgICBjdXJzb3I6cG9pbnRlcjtcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L3ByZXZpZXcvcHJldmlldy5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdyZWNlaXB0JyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9yZWNlaXB0LmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9yZWNlaXB0LmNvbXBvbmVudC5jc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBSZWNlaXB0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gICAgbmdPbkluaXQoKSB7IH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL2NhcnQvcmVjaWVwdC9yZWNlaXB0LmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwiY29udGVudFxcXCIgY2xhc3M9XFxcIm1haW5Db250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhpZGRlbi14cyBoaWRkZW4tc20gaGVhZGVyRGl2XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhlYWRlclN0eWxlXFxcIj48c3Bhbj5PcmRlciBSZWNlaXB0ICZndDsgU3RlcCA0IG9mIDQ8L3NwYW4+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoaWRkZW4teHMgaGlkZGVuLXNtIG1haW5EaXZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidG9wUGFkZGluZ1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImJpbGxpbmdBZGRyZXNzSGVhZGVyXFxcIj5CaWxsaW5nIEFkZHJlc3M8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic2hpcHBpbmdBZGRyZXNzSGVhZGVyXFxcIj5TaGlwcGluZyBBZGRyZXNzPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJiaWxsaW5nQWRkcmVzc1RkXFxcIiB2YWxpZ249XFxcInRvcFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIyXFxcIiBjZWxsc3BhY2luZz1cXFwiMlxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5OYW1lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5KYXNvbiBTdGFubGV5PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIiB2YWxpZ249XFxcInRvcFxcXCI+QWRkcmVzczo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+NTMwNyBOIEFkYW1zIFN0IDxicj5TcG9rYW5lLCBXQSA5OTIwNTxicj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPlBob25lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD41MDkyOTAyMzUzPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5FbWFpbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+amFzb25zdGFubDN5QGdtYWlsLmNvbTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNoaXBwaW5nQWRkcmVzc1RkXFxcIiB2YWxpZ249XFxcInRvcFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIyXFxcIiBjZWxsc3BhY2luZz1cXFwiMlxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5OYW1lOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25DZW50ZXJcXFwiPkphc29uIFN0YW5sZXk8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5BZGRyZXNzOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25DZW50ZXJcXFwiPjUzMDcgTiBBZGFtcyBTdCA8YnI+U3Bva2FuZSwgV0EgOTkyMDU8YnI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5QaG9uZTo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduQ2VudGVyXFxcIj41MDkyOTAyMzUzPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5FbWFpbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduQ2VudGVyXFxcIj5qYXNvbnN0YW5sM3lAZ21haWwuY29tPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0b3BQYWRkaW5nTGFyZ2VyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgYm9yZGVyPVxcXCIwXFxcIiBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic2hpcHBpbmdUb1lvdUhlYWRlclxcXCI+U2hpcHBpbmcgdG8gWW91PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInByaWNlUXVhbnRpdHlTdHlsZVxcXCI+UHJpY2U8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwicHJpY2VRdWFudGl0eVN0eWxlXFxcIj5RdWFudGl0eTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJ0b3RhbEhlYWRlclN0eWxlXFxcIj5Ub3RhbDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcIm5nLXNjb3BlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInByb2R1Y3RTdHlsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNQT1JUIFN0ZWFrIFNlYXNvbmluZyBSdWJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwicHJpY2VTdHlsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQ1LjAwXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInF1YW50aXR5U3R5bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInRvdGFsUHJpY2VTdHlsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQ1LjAwXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiMlxcXCIgY2xhc3M9XFxcInN1YlRvdGFsU3BhY2VcXFwiPiZuYnNwOzwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzdWJUb3RhbEhlYWRlclxcXCI+U3VidG90YWw6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInN1YlRvdGFsUHJpY2VcXFwiID4kNS4wMDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzaGlwcGluZ0hhbmRsaW5nU3R5bGVcXFwiIGNvbHNwYW49XFxcIjNcXFwiIGFsaWduPVxcXCJyaWdodFxcXCIgdmFsaWduPVxcXCJ0b3BcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqU2hpcHBpbmcgJmFtcDsgSGFuZGxpbmc6XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPlUuUy5QLlMuIFBhcmNlbCAoMyAtIDggZGF5cyk8L3A+XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNoaXBwaW5nSGFuZGxpbmdQcmljZVxcXCIgdmFsaWduPVxcXCJ0b3BcXFwiID4kMy4wMDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIyXFxcIiBjbGFzcz1cXFwidG90YWxTcGFjZVxcXCI+Jm5ic3A7PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInRvdGFsSGVhZGVyXFxcIj5Ub3RhbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBpZD1cXFwidGRUb3RhbFByaWNlXFxcIiBjbGFzcz1cXFwidG90YWxQcmljZVxcXCIgPiQ1LjAwPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49XFxcIjRcXFwiIGNsYXNzPVxcXCJub3RlU3R5bGVcXFwiPipTaGlwcGluZyBkdXJhdGlvbnMgYXJlIGVzdGltYXRlcyBhbmQgbm90IGEgZ3VhcmFudGVlPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidG9wUGFkZGluZ0xhcmdlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInBheUluZm9cXFwiPlBheW1lbnQgSW5mb3JtYXRpb248L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImNhcmRUZFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlZENvbG9yXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+Q29uZmlybWF0aW9uIENvZGU6IDkyMTExLTg1MjIyMTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIyXFxcIj4mbmJzcDs8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkNhcmQgTnVtYmVyOiBWaXNhIDExMTExMTExMTExMTExMTwvdGQ+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIyXFxcIj4mbmJzcDs8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJib3R0b21UZFN0eWxlXFxcIj48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2aXNpYmxlLXhzIHZpc2libGUtc20gc21hbGxIZWFkZXJEaXYgdG9wUGFkZGluZ0xhcmdlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzbWFsbEhlYWRlclN0eWxlXFxcIj48c3Bhbj5PcmRlciBSZWNlaXB0ICZndDsgU3RlcCA0IG9mIDQ8L3NwYW4+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2aXNpYmxlLXhzIHZpc2libGUtc20gc21hbGxNYWluRGl2XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRvcFBhZGRpbmdcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBib3JkZXI9XFxcIjBcXFwiIGNlbGxwYWRkaW5nPVxcXCIwXFxcIiBjZWxsc3BhY2luZz1cXFwiMFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbEJpbGxpbmdBZGRyZXNzSGVhZGVyXFxcIj5CaWxsaW5nIEFkZHJlc3M8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsQmlsbGluZ0FkZHJlc3NUZFxcXCIgdmFsaWduPVxcXCJ0b3BcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgYm9yZGVyPVxcXCIwXFxcIiBjZWxscGFkZGluZz1cXFwiMlxcXCIgY2VsbHNwYWNpbmc9XFxcIjJcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+TmFtZTo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsQWxpZ25MZWZ0UGFkZGluZ1xcXCI+SmFzb24gU3RhbmxleTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCIgdmFsaWduPVxcXCJ0b3BcXFwiPkFkZHJlc3M6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbEFsaWduTGVmdFBhZGRpbmdcXFwiPjUzMDcgTiBBZGFtcyBTdCA8YnI+U3Bva2FuZSwgV0EgOTkyMDU8YnI+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJhbGlnblJpZ2h0XFxcIj5QaG9uZTo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsQWxpZ25MZWZ0UGFkZGluZ1xcXCI+NTA5ODQ0NTY5ODwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+RW1haWw6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbEFsaWduTGVmdFBhZGRpbmdcXFwiPmphc29uc3RhbmwzeUBnbWFpbC5jb208L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxTaGlwcGluZ0FkZHJlc3NIZWFkZXJcXFwiPlNoaXBwaW5nIEFkZHJlc3M8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsU2hpcHBpbmdBZGRyZXNzVGRcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjJcXFwiIGNlbGxzcGFjaW5nPVxcXCIyXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPk5hbWU6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbEFsaWduTGVmdFBhZGRpbmdcXFwiPkphc29uIFN0YW5sZXk8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiIHZhbGlnbj1cXFwidG9wXFxcIj5BZGRyZXNzOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxBbGlnbkxlZnRQYWRkaW5nXFxcIj41MzA3IE4gQWRhbXMgU3QgPGJyPlNwb2thbmUsIFdBIDk5MjA1PGJyPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+UGhvbmU6PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbEFsaWduTGVmdFBhZGRpbmdcXFwiPjUwOTg0NDU2OTg8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkVtYWlsOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxBbGlnbkxlZnRQYWRkaW5nXFxcIj5qYXNvbnN0YW5sM3lAZ21haWwuY29tPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0b3BQYWRkaW5nTGFyZ2VyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgYm9yZGVyPVxcXCIwXFxcIiBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxTaGlwcGluZ1RvWW91SGVhZGVyXFxcIj5TaGlwcGluZyB0byBZb3U8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQcmljZVF1YW50aXR5U3R5bGVcXFwiPlByaWNlPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsUHJpY2VRdWFudGl0eVN0eWxlXFxcIj5RdWFudGl0eTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbFRvdGFsSGVhZGVyU3R5bGVcXFwiPlRvdGFsPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQcm9kdWN0U3R5bGVcXFwiPlNQT1JUIFN0ZWFrIFNlYXNvbmluZyBSdWI8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxQcmljZVN0eWxlXFxcIj4kNS4wMDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbFF1YW50aXR5U3R5bGVcXFwiPjE8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxUb3RhbFByaWNlU3R5bGVcXFwiPiQ1LjAwPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIyXFxcIiBjbGFzcz1cXFwic3ViVG90YWxTcGFjZVxcXCI+Jm5ic3A7PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNtYWxsU3ViVG90YWxIZWFkZXJcXFwiPlN1YnRvdGFsOjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbFN1YlRvdGFsUHJpY2VcXFwiPiQ1LjAwPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInNoaXBwaW5nSGFuZGxpbmdTdHlsZVxcXCIgY29sc3Bhbj1cXFwiM1xcXCIgYWxpZ249XFxcInJpZ2h0XFxcIiB2YWxpZ249XFxcInRvcFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpTaGlwcGluZyAmYW1wOyBIYW5kbGluZzpcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+VS5TLlAuUy4gUGFyY2VsICgzIC0gOCBkYXlzKTwvcD5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxTaGlwcGluZ0hhbmRsaW5nUHJpY2VcXFwiIHZhbGlnbj1cXFwidG9wXFxcIiA+JDMuMDA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiMlxcXCIgY2xhc3M9XFxcInRvdGFsU3BhY2VcXFwiPiZuYnNwOzwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbFRvdGFsSGVhZGVyXFxcIj5Ub3RhbDo8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBpZD1cXFwidGRUb3RhbFByaWNlXFxcIiBjbGFzcz1cXFwic21hbGxUb3RhbFByaWNlXFxcIiA+JDUuMDA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiNFxcXCIgY2xhc3M9XFxcIm5vdGVTdHlsZVxcXCI+KlNoaXBwaW5nIGR1cmF0aW9ucyBhcmUgZXN0aW1hdGVzIGFuZCBub3QgYSBndWFyYW50ZWU8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidG9wUGFkZGluZ0xhcmdlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInBheUluZm9cXFwiPlBheW1lbnQgSW5mb3JtYXRpb248L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImNhcmRUZFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlZENvbG9yXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiYWxpZ25SaWdodFxcXCI+Q29uZmlybWF0aW9uIENvZGU6IDkyMTExLTg1MjIyMTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIyXFxcIj4mbmJzcDs8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImFsaWduUmlnaHRcXFwiPkNhcmQgTnVtYmVyOiBWaXNhIDExMTExMTExMTExMTExMTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIyXFxcIj4mbmJzcDs8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY2FydC9yZWNpZXB0L3JlY2VpcHQuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcmVjZWlwdC5jb21wb25lbnQuY3NzXCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9jYXJ0L3JlY2llcHQvcmVjZWlwdC5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubWFpbkNvbnRlbnQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IFxcbiAgICB0b3A6IC0xMHB4O1xcbn1cXG5cXG4uaGVhZGVyRGl2IHtcXG4gICAgbWFyZ2luOiAxNXB4IDAgMCAxNXB4O1xcbn1cXG5cXG4uc21hbGxIZWFkZXJEaXYge1xcbiAgICBtYXJnaW46IDBweCAwIDAgMHB4O1xcbn1cXG5cXG4uaGVhZGVyU3R5bGUge1xcbiAgICBoZWlnaHQ6IDQwcHg7IFxcbiAgICBwYWRkaW5nLXRvcDogOXB4OyBcXG4gICAgcGFkZGluZy1sZWZ0OiAxNXB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2JjOWE3MjsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LWZhbWlseTogQ2FtYnJpYTsgXFxuICAgIGZvbnQtc2l6ZTogMTZweDsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7XFxufVxcblxcbi5zbWFsbEhlYWRlclN0eWxlIHtcXG4gICAgaGVpZ2h0OiA1MHB4OyBcXG4gICAgcGFkZGluZy10b3A6IDlweDsgXFxuICAgIHBhZGRpbmctbGVmdDogNXB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2JjOWE3MjsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LWZhbWlseTogQ2FtYnJpYTsgXFxuICAgIGZvbnQtc2l6ZTogMTRweDsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7XFxufVxcblxcbi5tYWluRGl2IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojZThlM2M4OyBcXG4gICAgbWFyZ2luOiA1cHggMCAwIDE1cHg7IFxcbiAgICBwYWRkaW5nOjEwcHg7XFxufVxcblxcbi5zbWFsbE1haW5EaXYge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNlOGUzYzg7IFxcbiAgICBtYXJnaW46IDVweCAwIDAgMHB4OyBcXG4gICAgcGFkZGluZzoxMHB4O1xcbn1cXG5cXG4udG9wUGFkZGluZyB7XFxuICAgIHBhZGRpbmctdG9wOjVweDtcXG59XFxuLnRvcFBhZGRpbmdMYXJnZXIge1xcbiAgICBwYWRkaW5nLXRvcDoyNXB4O1xcbn1cXG5cXG4uc21hbGxUb3BQYWRkaW5nIHtcXG4gICAgcGFkZGluZy10b3A6IDM1cHg7XFxufVxcblxcbi5iaWxsaW5nQWRkcmVzc0hlYWRlciB7XFxuICAgIHdpZHRoOjQzMHB4OyBcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsQmlsbGluZ0FkZHJlc3NIZWFkZXIge1xcbiAgICBoZWlnaHQ6MjVweDsgXFxuICAgIHBhZGRpbmc6NXB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojZDJiZTlkOyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG4uc2hpcHBpbmdBZGRyZXNzSGVhZGVyIHtcXG4gICAgd2lkdGg6NDMwcHg7IFxcbiAgICBoZWlnaHQ6MjVweDsgXFxuICAgIHBhZGRpbmc6NXB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojZDJiZTlkOyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICBib3JkZXI6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsU2hpcHBpbmdBZGRyZXNzSGVhZGVyIHtcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5iaWxsaW5nQWRkcmVzc1RkIHtcXG4gICAgd2lkdGg6NDMwcHg7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItYm90dG9tOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxCaWxsaW5nQWRkcmVzc1RkIHtcXG4gICAgcGFkZGluZzo1cHg7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLmFsaWduUmlnaHQge1xcbiAgICB0ZXh0LWFsaWduOnJpZ2h0O1xcbn1cXG5cXG4uYWxpZ25DZW50ZXIge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5zbWFsbEFsaWduTGVmdFBhZGRpbmcge1xcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBwYWRkaW5nOjAgMCAwIDVweDsgICAgICAgICBcXG59XFxuXFxuLnNoaXBwaW5nQWRkcmVzc1RkIHtcXG4gICAgd2lkdGg6NDMwcHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgYm9yZGVyOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFNoaXBwaW5nQWRkcmVzc1RkIHtcXG4gICAgdGV4dC1hbGlnbjpsZWZ0OyBjb2xvcjojNGIyOTBjOyBcXG4gICAgYm9yZGVyOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zaGlwcGluZ1RvWW91SGVhZGVyIHtcXG4gICAgd2lkdGg6NTAwcHg7IFxcbiAgICBoZWlnaHQ6MjVweDsgXFxuICAgIHBhZGRpbmc6NXB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojZDJiZTlkOyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxTaGlwcGluZ1RvWW91SGVhZGVyIHtcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnByaWNlUXVhbnRpdHlTdHlsZSB7XFxuICAgIHdpZHRoOjEwMHB4OyBcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsUHJpY2VRdWFudGl0eVN0eWxlIHtcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnRvdGFsSGVhZGVyU3R5bGUge1xcbiAgICB3aWR0aDoxMDBweDsgXFxuICAgIGhlaWdodDoyNXB4OyBcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNkMmJlOWQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsVG90YWxIZWFkZXJTdHlsZSB7XFxuICAgIGhlaWdodDoyNXB4OyBcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNkMmJlOWQ7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuXFxuLnByb2R1Y3RTdHlsZSB7XFxuICAgIHdpZHRoOiA1MDBweDsgXFxuICAgIHBhZGRpbmc6IDVweDsgXFxuICAgIGNvbG9yOiAjNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxQcm9kdWN0U3R5bGUge1xcbiAgICBwYWRkaW5nOiA1cHg7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5wcmljZVN0eWxlIHtcXG4gICAgd2lkdGg6IDEwMHB4OyBcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyBcXG4gICAgY29sb3I6ICM0YjI5MGM7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7XFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFByaWNlU3R5bGUge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5xdWFudGl0eVN0eWxlIHtcXG4gICAgd2lkdGg6IDEwMHB4OyBcXG4gICAgcGFkZGluZzogNXB4OyBcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyOyBcXG4gICAgY29sb3I6ICM0YjI5MGM7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7XFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFF1YW50aXR5U3R5bGUge1xcbiAgICBwYWRkaW5nOiA1cHg7IFxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi50b3RhbFByaWNlU3R5bGUge1xcbiAgICB3aWR0aDogMTAwcHg7IFxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxUb3RhbFByaWNlU3R5bGUge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxcbiAgICBjb2xvcjogIzRiMjkwYzsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItcmlnaHQ6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnN1YlRvdGFsU3BhY2Uge1xcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG5cXG5cXG4uc3ViVG90YWxIZWFkZXIge1xcbiAgICB3aWR0aDoxMDBweDsgXFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIHRleHQtYWxpZ246cmlnaHQ7IFxcbiAgICBib3JkZXItdG9wOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFN1YlRvdGFsSGVhZGVyIHtcXG4gICAgaGVpZ2h0OjM1cHg7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgdGV4dC1hbGlnbjpyaWdodDsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnN1YlRvdGFsUHJpY2Uge1xcbiAgICB3aWR0aDoxMDBweDsgXFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFN1YlRvdGFsUHJpY2Uge1xcbiAgICBoZWlnaHQ6MzVweDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjsgXFxuICAgIGJvcmRlci10b3A6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc2hpcHBpbmdIYW5kbGluZ1N0eWxlIHtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGNvbG9yOiM0YjI5MGM7XFxufVxcblxcblxcbi5zaGlwcGluZ0hhbmRsaW5nUHJpY2Uge1xcbiAgICB3aWR0aDoxMDBweDsgXFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5zbWFsbFNoaXBwaW5nSGFuZGxpbmdQcmljZSB7XFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi50b3RhbFNwYWNlIHtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnRvdGFsSGVhZGVyIHtcXG4gICAgd2lkdGg6MTAwcHg7IFxcbiAgICBoZWlnaHQ6MzVweDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgdGV4dC1hbGlnbjpyaWdodDsgXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnNtYWxsVG90YWxIZWFkZXIge1xcbiAgICBoZWlnaHQ6MzVweDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgdGV4dC1hbGlnbjpyaWdodDsgXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgIzkyOTI5MjtcXG59XFxuXFxuLnRvdGFsUHJpY2Uge1xcbiAgICB3aWR0aDoxMDBweDsgXFxuICAgIGhlaWdodDozNXB4OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtd2VpZ2h0OmJvbGQ7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG4uc21hbGxUb3RhbFByaWNlIHtcXG4gICAgaGVpZ2h0OjM1cHg7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItYm90dG9tOiAxcHggZGFzaGVkICM5MjkyOTI7XFxufVxcblxcbi5ub3RlU3R5bGUge1xcbiAgICB0ZXh0LWFsaWduOnJpZ2h0OyBcXG4gICAgY29sb3I6IzRiMjkwYzsgXFxuICAgIGZvbnQtc3R5bGU6aXRhbGljOyBcXG4gICAgcGFkZGluZy10b3A6MnB4OyBcXG4gICAgcGFkZGluZy1yaWdodDozcHg7XFxufVxcblxcblxcblxcbi5wYXlJbmZvIHtcXG4gICAgaGVpZ2h0OjI1cHg7IFxcbiAgICBwYWRkaW5nOjVweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6I2QyYmU5ZDsgXFxuICAgIGNvbG9yOiM0YjI5MGM7IFxcbiAgICBmb250LXdlaWdodDpib2xkOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG5cXG5cXG4uY2FyZFRkIHtcXG4gICAgcGFkZGluZzo1cHg7IFxcbiAgICBjb2xvcjojNGIyOTBjOyBcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkYXNoZWQgIzkyOTI5MjsgXFxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjOTI5MjkyO1xcbn1cXG5cXG5cXG4ucmVkQ29sb3Ige1xcbiAgICBjb2xvcjpyZWQ7XFxufVxcblxcbi5ib3R0b21UZFN0eWxlIHtcXG4gICAgaGVpZ2h0OjQ1cHg7IFxcbiAgICBwYWRkaW5nOjEwcHg7IFxcbiAgICBib3JkZXItYm90dG9tOiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICBib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjOTI5MjkyOyBcXG4gICAgYm9yZGVyLXJpZ2h0OiAxcHggZGFzaGVkICM5MjkyOTI7IFxcbiAgICB0ZXh0LWFsaWduOnJpZ2h0OyBcXG4gICAgcGFkZGluZy1yaWdodDo1cHg7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvY2FydC9yZWNpZXB0L3JlY2VpcHQuY29tcG9uZW50LmNzc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiBcInNob3BcIixcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9zaG9wLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9zaG9wLmNvbXBvbmVudC5jc3MnKV1cbn0pXG5leHBvcnQgY2xhc3MgU2hvcENvbXBvbmVudCB7XG5cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL3Nob3AuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbiAgICA8c2lkZS1tZW51Pjwvc2lkZS1tZW51PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ2aXNpYmxlLXhzIHZpc2libGUtc20gY2xlYXJmaXggY29sLW1kLTMgZGl2TWFpbkxpbmtzRHJvcFxcXCI+XFxuXFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tY3VzdG9tIGJ0bi1sZyBkcm9wZG93bi10b2dnbGVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIiBhcmlhLWhhc3BvcHVwPVxcXCJ0cnVlXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCIgc3R5bGU9XFxcIndpZHRoOjI4MHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiMyMjE5MGY7IGNvbG9yOiNmOGYzZGM7XFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNob3BUaXRsZURyb3BTdHlsZVxcXCI+U2hvcDwvc3Bhbj4gPHNwYW4gY2xhc3M9XFxcImNhcmV0XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9idXR0b24+XFxuXFxuXFxuXFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51IGRyb3BEb3duTWVudVdpZHRoXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvU3BpY2VSdWJzXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5TUElDRSBSVUJTPC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcERvd25MaW5rU3R5bGVcXFwiPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL0Nvb2tCb29rc1xcXCIgdGFyZ2V0PVxcXCJfc2VsZlxcXCI+Q09PS0JPT0tTPC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcERvd25MaW5rU3R5bGVcXFwiPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL0Jha2luZ1BsYW5rc1xcXCIgdGFyZ2V0PVxcXCJfc2VsZlxcXCI+QkFLSU5HIFBMQU5LUzwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImRyb3BEb3duTGlua1N0eWxlXFxcIj48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9CYnFQbGFua3NcXFwiIHRhcmdldD1cXFwiX3NlbGZcXFwiPkJCUSBQTEFOS1M8L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvTnV0RHJpdmVyXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5OVVQgRFJJVkVSPC9hPjwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG5cXG5cXG48ZGl2IGNsYXNzPVxcXCJjb250YWluZXItZmx1aWRcXFwiPlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhpZGRlbi14cyBtaWRkbGVCYWNrZ3JvdW5kXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZG90dGVkX2xpbmVfdG9wIGRvdHRlZExpbmVDbGFzc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJjb250ZW50X3RpdGxlXFxcIiBjbGFzcz1cXFwiZG90dGVkX2xpbmVfYm90dG9tIGRvdHRlZF9saW5lX3JpZ2h0IHByb2R1Y3RzVGl0bGVDbGFzc1xcXCI+UExBTktDT09LSU5HIFBST0RVQ1RTPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkaXZDdWJlc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgYm9yZGVyPVxcXCIwXFxcIiBjZWxscGFkZGluZz1cXFwiMjVcXFwiIGNlbGxzcGFjaW5nPVxcXCIyNVxcXCIgYWxpZ249XFxcImNlbnRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvU3BpY2VSdWJzXFxcIj48aW1nIGFsdD1cXFwiU3BpY2UgUnVic1xcXCIgY2xhc3M9XFxcImN1YmVzSW1hZ2VzXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL1NwaWNlUnVic19jdWJlLnBuZ1wiKSArIFwiXFxcIj48L2E+PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9Db29rQm9va3NcXFwiPjxpbWcgYWx0PVxcXCJDb29rYm9va3NcXFwiIGNsYXNzPVxcXCJjdWJlc0ltYWdlc1xcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi8uLi93d3dyb290L2ltYWdlcy9Db29rYm9va3NfY3ViZS5wbmdcIikgKyBcIlxcXCI+PC9hPjwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9CYWtpbmdQbGFua3NcXFwiPjxpbWcgYWx0PVxcXCJCYWtpbmcgUGxhbmtzXFxcIiBjbGFzcz1cXFwiY3ViZXNJbWFnZXNcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vLi4vd3d3cm9vdC9pbWFnZXMvQmFraW5nUGxhbmtzX2N1YmUucG5nXCIpICsgXCJcXFwiPjwvYT48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL0JicVBsYW5rc1xcXCI+PGltZyBhbHQ9XFxcIkJCUSBQbGFua3NcXFwiIGNsYXNzPVxcXCJjdWJlc0ltYWdlc1xcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi8uLi93d3dyb290L2ltYWdlcy9CQlFfUGxhbmtzX2N1YmUucG5nXCIpICsgXCJcXFwiPjwvYT48L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm90dG9tQmFja2dyb3VuZFxcXCI+Jm5ic3A7PC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidmlzaWJsZS14c1xcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNtYWxsRGl2TWFpblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkb3R0ZWRfbGluZV90b3AgZG90dGVkTGluZVNtYWxsQ2xhc3NcXFwiPjxkaXYgaWQ9XFxcImNvbnRlbnRfdGl0bGVcXFwiIGNsYXNzPVxcXCJkb3R0ZWRfbGluZV9ib3R0b20gZG90dGVkX2xpbmVfcmlnaHQgcHJvZHVjdHNUaXRsZUNsYXNzXFxcIj5QTEFOS0NPT0tJTkcgUFJPRFVDVFM8L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRpdlNtYWxsSW1hZ2VMaW5rc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cXFwiMFxcXCIgY2VsbHBhZGRpbmc9XFxcIjVcXFwiIGNlbGxzcGFjaW5nPVxcXCI1XFxcIiBhbGlnbj1cXFwiY2VudGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9TcGljZVJ1YnNcXFwiPjxpbWcgYWx0PVxcXCJTcGljZSBSdWJzXFxcIiBjbGFzcz1cXFwiY3ViZXNJbWFnZXNcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vLi4vd3d3cm9vdC9pbWFnZXMvU3BpY2VSdWJzX2N1YmUucG5nXCIpICsgXCJcXFwiIGNsYXNzPVxcXCJpbWctcmVzcG9uc2l2ZVxcXCI+PC9hPjwvdGQ+PHRkPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL0Nvb2tCb29rc1xcXCI+PGltZyBhbHQ9XFxcIkNvb2tib29rc1xcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi8uLi93d3dyb290L2ltYWdlcy9Db29rYm9va3NfY3ViZS5wbmdcIikgKyBcIlxcXCIgY2xhc3M9XFxcImN1YmVzSW1hZ2VzIGltZy1yZXNwb25zaXZlXFxcIj48L2E+PC90ZD48L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9CYWtpbmdQbGFua3NcXFwiPjxpbWcgYWx0PVxcXCJCYWtpbmcgUGxhbmtzXFxcIiBjbGFzcz1cXFwiY3ViZXNJbWFnZXNcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vLi4vd3d3cm9vdC9pbWFnZXMvQmFraW5nUGxhbmtzX2N1YmUucG5nXCIpICsgXCJcXFwiIGNsYXNzPVxcXCJpbWctcmVzcG9uc2l2ZVxcXCI+PC9hPjwvdGQ+PHRkPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL0JicVBsYW5rc1xcXCI+PGltZyBhbHQ9XFxcIkJCUSBQbGFua3NcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vLi4vd3d3cm9vdC9pbWFnZXMvQkJRX1BsYW5rc19jdWJlLnBuZ1wiKSArIFwiXFxcIiBjbGFzcz1cXFwiY3ViZXNJbWFnZXMgaW1nLXJlc3BvbnNpdmVcXFwiPjwvYT48L3RkPjwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuPGEgW3JvdXRlckxpbmtdPVxcXCJbJy9jYXJ0J11cXFwiPkdvIFRvIENhcnQ8L2E+XFxuPGJyIC8+XFxuPGJyIC8+XFxuPGEgW3JvdXRlckxpbmtdPVxcXCJbJy9TaG9wL0Nvb2tCb29rcyddXFxcIj5HbyBUbyBDb29rYm9va3M8L2E+XFxuXFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9zaG9wLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4gICAgICAgIHZhciByZXN1bHQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3Nob3AuY29tcG9uZW50LmNzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9zaG9wLmNvbXBvbmVudC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5kcm9wRG93bkxpbmtTdHlsZSB7XFxuICAgIGhlaWdodDozMHB4O1xcbn1cXG5cXG4uZGl2TWFpbkxpbmtzRHJvcCB7XFxuICAgIHRleHQtYWxpZ246Y2VudGVyOyBcXG4gICAgbWFyZ2luOjAgMCAzMHB4IDA7XFxufVxcblxcbi5zaG9wVGl0bGVEcm9wU3R5bGUge1xcbiAgICBmb250LXNpemU6MjRweDtcXG59XFxuXFxuLmRyb3BEb3duTWVudVdpZHRoIHtcXG4gICAgd2lkdGg6MjgwcHg7XFxufVxcbi5kb3R0ZWRMaW5lQ2xhc3Mge1xcbiAgICBtYXJnaW46IDBweCAyNXB4IDAgMjVweDtcXG59XFxuXFxuLmRvdHRlZExpbmVTbWFsbENsYXNzIHtcXG4gICAgbWFyZ2luOjEwcHggMHB4IDAgMHB4O1xcbn1cXG5cXG4ucHJvZHVjdHNUaXRsZUNsYXNzIHtcXG4gICAgd2lkdGg6MjUwcHg7XFxufVxcblxcblxcblxcbi5kaXZDdWJlcyB7XFxuICAgICBtYXJnaW46MTVweCAyNXB4IDI1cHggMTAwcHg7XFxuICAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcXG59XFxuLmRpdlNtYWxsSW1hZ2VMaW5rcyB7XFxuICAgIG1hcmdpbi10b3A6MTVweDsgXFxuICAgIHBvc2l0aW9uOnJlbGF0aXZlO1xcblxcbn1cXG5cXG4uY3ViZXNJbWFnZXMge1xcbiAgICBib3JkZXI6bm9uZTtcXG59XFxuXFxuLm1pZGRsZUJhY2tncm91bmQge1xcbiAgICBwb3NpdGlvbjpyZWxhdGl2ZTsgXFxuICAgIGxlZnQ6NDBweDsgdG9wOjBweDsgXFxuICAgIHdpZHRoOjYyNXB4OyBcXG4gICAgcGFkZGluZy10b3A6MzBweDsgXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgvaW1hZ2VzL1BhcGVyQmFja2dyb3VuZF9NaWRkbGUucG5nKTsgXFxuICAgIGJhY2tncm91bmQtcmVwZWF0OnJlcGVhdC15O1xcbn1cXG5cXG4uYm90dG9tQmFja2dyb3VuZCB7XFxuICAgIHdpZHRoOjYyNnB4OyBcXG4gICAgaGVpZ2h0OjM1cHg7IFxcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoL2ltYWdlcy9QYXBlckJhY2tncm91bmRfQm90dG9tLnBuZyk7IFxcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7XFxufVxcblxcbi5zbWFsbERpdk1haW4ge1xcbiAgICBkaXNwbGF5OmlubGluZS1ibG9jaztcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL3Nob3AuY29tcG9uZW50LmNzc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBQcm9kdWN0IH0gZnJvbSAnLi4vLi4vLi4vbW9kZWxzL1Byb2R1Y3QnO1xuaW1wb3J0IHsgUGxhbmtDb29raW5nU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZpY2VzL3BsYW5rY29va2luZy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6IFwic2hvcC1jb29rYm9va3NcIixcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9jb29rYm9va3MuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2Nvb2tib29rcy5jb21wb25lbnQuY3NzJyldXG59KVxuZXhwb3J0IGNsYXNzIFNob3BDb29rYm9va3NDb21wb25lbnQge1xuXG4gICAgcHJvZHVjdHM6UHJvZHVjdFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBwbGFua0Nvb2tpbmdTZXJ2aWNlOiBQbGFua0Nvb2tpbmdTZXJ2aWNlKSB7IFxuICAgIFxuICAgICAgICB0aGlzLnByb2R1Y3RzID0gW107XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucGxhbmtDb29raW5nU2VydmljZS5nZXRDb29rQm9va3MoKS5zdWJzY3JpYmUocHJvZHVjdHMgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9kdWN0cyA9IHByb2R1Y3RzO1xuICAgICAgICB9KTtcbiAgICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9jb29rYm9va3MvY29va2Jvb2tzLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG48c2lkZS1tZW51Pjwvc2lkZS1tZW51PlxcblxcbiAgIFxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ2aXNpYmxlLXhzIHZpc2libGUtc20gY2xlYXJmaXggY29sLW1kLTMgbWFpbkNsYXNzXFxcIj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cFxcXCI+XFxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1jdXN0b20gYnRuLWxnIGRyb3Bkb3duLXRvZ2dsZSBkcm9wRG93blN0eWxlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGRhdGEtdG9nZ2xlPVxcXCJkcm9wZG93blxcXCIgYXJpYS1oYXNwb3B1cD1cXFwidHJ1ZVxcXCIgYXJpYS1leHBhbmRlZD1cXFwiZmFsc2VcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic2hvcFRpdGxlRHJvcFN0eWxlXFxcIj5TaG9wPC9zcGFuPiA8c3BhbiBjbGFzcz1cXFwiY2FyZXRcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2J1dHRvbj5cXG5cXG4gICAgICAgICAgICA8dWwgY2xhc3M9XFxcImRyb3Bkb3duLW1lbnUgbWVudVN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvU3BpY2VSdWJzXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5TUElDRSBSVUJTPC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcERvd25MaW5rU3R5bGVcXFwiPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL0Nvb2tCb29rc1xcXCIgdGFyZ2V0PVxcXCJfc2VsZlxcXCI+Q09PS0JPT0tTPC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcERvd25MaW5rU3R5bGVcXFwiPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL0Jha2luZ1BsYW5rc1xcXCIgdGFyZ2V0PVxcXCJfc2VsZlxcXCI+QkFLSU5HIFBMQU5LUzwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImRyb3BEb3duTGlua1N0eWxlXFxcIj48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9CYnFQbGFua3NcXFwiIHRhcmdldD1cXFwiX3NlbGZcXFwiPkJCUSBQTEFOS1M8L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvTnV0RHJpdmVyXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5OVVQgRFJJVkVSPC9hPjwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvZGl2PlxcblxcblxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLWZsdWlkXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcblxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoaWRkZW4teHMgY29udGFpbmVyU3R5bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcImJhY2tncm91bmRJbWFnZVN0eWxlXFxcIj48aW1nIGFsdD1cXFwiQkJRIFBsYW5rc1xcXCIgIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vd3d3cm9vdC9pbWFnZXMvQ29va2Jvb2tzX0hlYWRlci5wbmdcIikgKyBcIlxcXCIgY2xhc3M9XFxcImltZy1yZXNwb25zaXZlIGhlYWRlclN0eWxlXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJhY2tncm91bmRNaWRkbGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBvc2l0aW9uU3R5bGVcXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoaWRkZW4teHNcXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgKm5nRm9yPVxcXCJsZXQgcHJvZHVjdCBvZiBwcm9kdWN0c1xcXCIgY2xhc3M9XFxcImhpZGRlbi14c1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRvdHRlZF9saW5lX3RvcCBwcm9kdWN0VGl0bGVcXFwiID5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRlbnRUaXRsZXMgZG90dGVkX2xpbmVfYm90dG9tIGRvdHRlZF9saW5lX3JpZ2h0IHByb2R1Y3RXaWR0aFxcXCI+e3twcm9kdWN0Lm5hbWV9fTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZHVjdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImRlc2NyaXB0aW9uU3R5bGVcXFwiIHZhbGlnbj1cXFwidG9wXFxcIiBhbGlnbj1cXFwibGVmdFxcXCI+e3twcm9kdWN0LmRlc2NyaXB0aW9ufX0gPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCB2YWxpZ249XFxcInRvcFxcXCIgYWxpZ249XFxcImNlbnRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5QcmljZToge3twcm9kdWN0LnByaWNlLnRvRml4ZWQoMil9fSA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoZWlnaHRUZXh0Qm94U3R5bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0ZXh0Qm94XFxcIj5RdWFudGl0eTogPGlucHV0IGNsYXNzPVxcXCJ0ZXh0Qm94X1F1YW50aXR5XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dEJveFxcXCI+PGlucHV0IHR5cGU9XFxcImltYWdlXFxcIiBjbGFzcz1cXFwiaW1nLXJlc3BvbnNpdmVcXFwiIGFsdD1cXFwiQWRkIFRvIENhcnRcXFwiIHNyYz1cXFwiL2ltYWdlcy9BZGRUb0NhcnRfYnV0dG9uLnBuZ1xcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW1nU3R5bGVcXFwiPjxpbWcgY2xhc3M9XFxcImNhcnRJbWFnZVBhdGhcXFwiIHNyYz1cXFwie3twcm9kdWN0LmltYWdlUGF0aH19XFxcIiBhbHQ9XFxcIlByb2R1Y3RcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmFja2dyb3VuZEJvdHRvbVxcXCI+Jm5ic3A7PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInZpc2libGUteHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzbWFsbFNpemVIZWFkZXJcXFwiPjxpbWcgYWx0PVxcXCJDb29rYm9vayBDb3ZlcnNcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vd3d3cm9vdC9pbWFnZXMvQ29va2Jvb2tzX0hlYWRlci5wbmdcIikgKyBcIlxcXCIgY2xhc3M9XFxcImltZy1yZXNwb25zaXZlXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IHByb2R1Y3Qgb2YgcHJvZHVjdHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZG90dGVkX2xpbmVfdG9wIG1haW5DbGFzc1NtYWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50VGl0bGVzIGRvdHRlZF9saW5lX2JvdHRvbSBkb3R0ZWRfbGluZV9yaWdodCBcXFwiPnt7cHJvZHVjdC5uYW1lfX08L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2VsbHBhZGRpbmc9XFxcIjBcXFwiIGNlbGxzcGFjaW5nPVxcXCIwXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwic21hbGxEZXNjcmlwdGlvblN0eWxlXFxcIiB2YWxpZ249XFxcInRvcFxcXCIgYWxpZ249XFxcImxlZnRcXFwiPnt7cHJvZHVjdC5kZXNjcmlwdGlvbn19PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgdmFsaWduPVxcXCJ0b3BcXFwiIGFsaWduPVxcXCJjZW50ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlByaWNlOiAke3twcm9kdWN0LnByaWNlLnRvRml4ZWQoMil9fTxicj57e3Byb2R1Y3QucHJpY2VEZXNjcmlwdGlvbn19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcnRUZXh0U21hbGxIZWlnaHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5RdWFudGl0eTogPGlucHV0IGNsYXNzPVxcXCJ0ZXh0Qm94X1F1YW50aXR5XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+PGlucHV0IHR5cGU9XFxcImltYWdlXFxcIiBjbGFzcz1cXFwiY2FydEJ0blNtYWxsUGFkZGluZ1xcXCIgYWx0PVxcXCJBZGQgVG8gQ2FydFxcXCIgc3JjPVxcXCIvaW1hZ2VzL0FkZFRvQ2FydF9idXR0b24ucG5nXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImltZ1N0eWxlXFxcIj48aW1nIGNsYXNzPVxcXCJzbWFsbEltZ1N0eWxlXFxcIiBzcmM9XFxcInt7cHJvZHVjdC5pbWFnZVBhdGh9fVxcXCIgYWx0PVxcXCJQcm9kdWN0XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuXFxuICAgIDwvZGl2PlxcblxcblxcblxcblxcblxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3Nob3AvY29va2Jvb2tzL2Nvb2tib29rcy5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jb29rYm9va3MuY29tcG9uZW50LmNzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9jb29rYm9va3MvY29va2Jvb2tzLmNvbXBvbmVudC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5kcm9wRG93bkxpbmtTdHlsZSB7XFxuICAgIGhlaWdodDozMHB4O1xcbn1cXG5cXG4ubWFpbkNsYXNzIHtcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBtYXJnaW46MCAwIDMwcHggMDtcXG59XFxuXFxuLmRyb3BEb3duU3R5bGUge1xcbiAgICB3aWR0aDoyODBweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6IzIyMTkwZjsgXFxuICAgIGNvbG9yOiNmOGYzZGM7XFxufVxcblxcbi5zaG9wVGl0bGVEcm9wU3R5bGUge1xcbiAgICBmb250LXNpemU6MjRweDtcXG59XFxuXFxuLm1lbnVTdHlsZSB7XFxuICAgIHdpZHRoOjI4MHB4O1xcbn1cXG5cXG4uY29udGFpbmVyU3R5bGUge1xcbiAgICBwb3NpdGlvbjpyZWxhdGl2ZTsgXFxuICAgIGxlZnQ6NDBweDtcXG59XFxuXFxuLmJhY2tncm91bmRJbWFnZVN0eWxlIHtcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7IFxcbiAgICBoZWlnaHQ6MzY0cHg7IFxcbiAgICB3aWR0aDo2NTBweDsgXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6dXJsKC9pbWFnZXMvUGhvdG9fQmFja2dyb3VuZC5wbmcpO1xcbn1cXG5cXG4uaGVhZGVyU3R5bGUge1xcbiAgICBwb3NpdGlvbjpyZWxhdGl2ZTsgXFxuICAgIHRvcDoyMHB4OyBcXG4gICAgbGVmdDoyNnB4O1xcbn1cXG5cXG4uYmFja2dyb3VuZE1pZGRsZSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgXFxuICAgIHRvcDogLTI1cHg7IFxcbiAgICBsZWZ0OiAxMXB4OyBcXG4gICAgd2lkdGg6IDYyNnB4OyBcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKC9pbWFnZXMvUGFwZXJCYWNrZ3JvdW5kX01pZGRsZS5wbmcpOyBcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXk7XFxufVxcblxcbi5wb3NpdGlvblN0eWxlIHtcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7IFxcbiAgICB0b3A6NXB4OyBcXG4gICAgbGVmdDozMXB4XFxufVxcblxcbi5wcm9kdWN0VGl0bGUge1xcbiAgICBtYXJnaW46IDEwcHggMCAxMHB4IDA7IFxcbiAgICB3aWR0aDo1NzBweDsgXFxuICAgIHRleHQtYWxpZ246bGVmdDtcXG59XFxuXFxuLnByb2R1Y3RXaWR0aCB7XFxuICAgIHdpZHRoOjM1MHB4O1xcbn1cXG5cXG4ucHJvZHVjdCB7XFxuICAgIHdpZHRoOjU3MHB4O1xcbn1cXG5cXG4uZGVzY3JpcHRpb25TdHlsZSB7XFxuICAgIHdpZHRoOjM1MHB4OyBcXG4gICAgcGFkZGluZy1yaWdodDoxNXB4O1xcbn1cXG5cXG4uaGVpZ2h0VGV4dEJveFN0eWxlIHtcXG4gICAgaGVpZ2h0OjM4cHg7XFxufVxcblxcbi50ZXh0Qm94IHtcXG4gICAgd2lkdGg6MTAwcHg7XFxufVxcblxcbi50ZXh0Qm94X1F1YW50aXR5IHtcXG4gICAgd2lkdGg6MjVweDsgXFxuICAgIGNvbG9yOmJsYWNrOyBcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7XFxufVxcblxcbi5pbWdTdHlsZSB7XFxuICAgIHBhZGRpbmctdG9wOjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcXG59XFxuXFxuLmNhcnRJbWFnZVBhdGgge1xcbiAgICBib3JkZXI6bm9uZTtcXG4gfVxcblxcbiAuYmFja2dyb3VuZEJvdHRvbSB7XFxuICAgIHdpZHRoOiA2MjZweDsgXFxuICAgIGhlaWdodDogMzVweDsgXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgvaW1hZ2VzL1BhcGVyQmFja2dyb3VuZF9Cb3R0b20ucG5nKTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLnNtYWxsU2l6ZUhlYWRlciB7XFxuICAgIGRpc3BsYXk6aW5saW5lLWJsb2NrO1xcbn1cXG5cXG4ubWFpbkNsYXNzU21hbGwge1xcbiAgICBtYXJnaW46IDEwcHggMCAxMHB4IDA7XFxuICAgICB0ZXh0LWFsaWduOmxlZnQ7XFxufVxcblxcbi5zbWFsbERlc2NyaXB0aW9uU3R5bGUge1xcbiAgICBwYWRkaW5nLXJpZ2h0OjE1cHg7XFxufVxcblxcbi5jYXJ0QnRuU21hbGxQYWRkaW5nIHtcXG4gICAgcGFkZGluZzozcHggNXB4IDAgMFxcbn1cXG5cXG4uY2FydFRleHRTbWFsbEhlaWdodCB7XFxuICAgIGhlaWdodDozOHB4O1xcbn1cXG5cXG4uc21hbGxJbWdTdHlsZSB7XFxuICAgIGJvcmRlcjpub25lXFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9jb29rYm9va3MvY29va2Jvb2tzLmNvbXBvbmVudC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUHJvZHVjdCB9IGZyb20gJy4uLy4uLy4uL21vZGVscy9Qcm9kdWN0JztcbmltcG9ydCB7IFBsYW5rQ29va2luZ1NlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9zZXJ2aWNlcy9wbGFua2Nvb2tpbmcuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnc2hvcC1iYWtpbmdwbGFua3MnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2Jha2luZ3BsYW5rcy5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vYmFraW5ncGxhbmtzLmNvbXBvbmVudC5jc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBTaG9wQmFraW5nUGxhbmtzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBwcm9kdWN0czpQcm9kdWN0W107XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBsYW5rQ29va2luZ1NlcnZpY2U6IFBsYW5rQ29va2luZ1NlcnZpY2UpIHsgXG4gICAgXG4gICAgICAgIHRoaXMucHJvZHVjdHMgPSBbXTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5wbGFua0Nvb2tpbmdTZXJ2aWNlLmdldEJha2luZ1BsYW5rcygpLnN1YnNjcmliZShwcm9kdWN0cyA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2R1Y3RzID0gcHJvZHVjdHM7XG4gICAgICAgIH0pO1xuICAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL2Jha2luZ3BsYW5rcy9iYWtpbmdwbGFua3MuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzaWRlLW1lbnU+PC9zaWRlLW1lbnU+XFxuICAgIDxkaXYgY2xhc3M9XFxcInZpc2libGUteHMgdmlzaWJsZS1zbSBjbGVhcmZpeCBjb2wtbWQtMyBtYWluQ2xhc3NcXFwiPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLWN1c3RvbSBidG4tbGcgZHJvcGRvd24tdG9nZ2xlIGRyb3BEb3duU3R5bGVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIiBhcmlhLWhhc3BvcHVwPVxcXCJ0cnVlXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzaG9wVGl0bGVEcm9wU3R5bGVcXFwiPlNob3A8L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJjYXJldFxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvYnV0dG9uPlxcblxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCIgc3R5bGU9XFxcIndpZHRoOjI4MHB4O1xcXCI+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcERvd25MaW5rU3R5bGVcXFwiPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL1NwaWNlUnVic1xcXCIgdGFyZ2V0PVxcXCJfc2VsZlxcXCI+U1BJQ0UgUlVCUzwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImRyb3BEb3duTGlua1N0eWxlXFxcIj48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9Db29rQm9va3NcXFwiIHRhcmdldD1cXFwiX3NlbGZcXFwiPkNPT0tCT09LUzwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImRyb3BEb3duTGlua1N0eWxlXFxcIj48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9CYWtpbmdQbGFua3NcXFwiIHRhcmdldD1cXFwiX3NlbGZcXFwiPkJBS0lORyBQTEFOS1M8L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvQmJxUGxhbmtzXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5CQlEgUExBTktTPC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcERvd25MaW5rU3R5bGVcXFwiPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL051dERyaXZlclxcXCIgdGFyZ2V0PVxcXCJfc2VsZlxcXCI+TlVUIERSSVZFUjwvYT48L2xpPlxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICA8L2Rpdj5cXG5cXG5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lci1mbHVpZFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05XFxcIj5cXG5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGlkZGVuLXhzIGNvbnRhaW5lclN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJhY2tncm91bmRJbWFnZVN0eWxlXFxcIj48aW1nIGNsYXNzPVxcXCJoZWFkZXJTdHlsZVxcXCIgYWx0PVxcXCJCYWtpbmcgUGxhbmtzXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL0Jha2luZ1BsYW5rc19IZWFkZXIucG5nXCIpICsgXCJcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmFja2dyb3VuZE1pZGRsZVxcXCI+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicG9zaXRpb25TdHlsZVxcXCI+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRlc2NyaXB0aW9uU3R5bGVcXFwiPkNlZGFyIGFuZCBBbGRlciBwbGFua3MgaW1wYXJ0IGEgc3VidGxlIHlldCBmdWxsIGZsYXZvcmVkIGFyb21hIHRvIGFueXRoaW5nIHJvYXN0ZWQgb24gdGhlbS4gT3VyIHBsYW5rcyBhcmUgbWFkZSBmcm9tIGNsZWFyIGtpbG4gZHJpZWQgV2VzdGVybiBSZWQgQ2VkYXIgYW5kIEFsZGVyLiBDZWRhciByb2FzdGluZyBwbGFua3MgY29tZSBpbiB0d28gc2l6ZXMuIEFsZGVyIHBsYW5rcyBhcmUgYXZhaWxhYmxlIGluIG9uZSBzaXplIG9ubHkuPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiAqbmdGb3I9XFxcImxldCBwcm9kdWN0IG9mIHByb2R1Y3RzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRvdHRlZF9saW5lX3RvcCBwcm9kdWN0VGl0bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRlbnRUaXRsZXMgZG90dGVkX2xpbmVfYm90dG9tIGRvdHRlZF9saW5lX3JpZ2h0IHByb2R1Y3RXaWR0aFxcXCI+e3twcm9kdWN0Lm5hbWV9fTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9kdWN0U3R5bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+e3twcm9kdWN0LmRlc2NyaXB0aW9ufX08L2Rpdj5cXG5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0YWJsZVN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNlbGxwYWRkaW5nPVxcXCIwXFxcIiBjZWxsc3BhY2luZz1cXFwiMFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJwcm9kdWN0TmFtZVN0eWxlXFxcIiB2YWxpZ249XFxcInRvcFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e3Byb2R1Y3QubmFtZX19XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9kdWN0SW1hZ2VQYXRoXFxcIj48aW1nIGNsYXNzPVxcXCJpbWdQYXRoXFxcIiBhbHQ9XFxcIk5vIFBpY3R1cmUgb2Yge3twcm9kdWN0Lm5hbWV9fVxcXCIgc3JjPVxcXCJ7e3Byb2R1Y3QuaW1hZ2VQYXRofX1cXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgdmFsaWduPVxcXCJ0b3BcXFwiIGNsYXNzPVxcXCJwcmljZVN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+UHJpY2U6ICR7e3Byb2R1Y3QucHJpY2UudG9GaXhlZCgyKX19IDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVpZ2h0VGV4dEJveFN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0ZXh0Qm94XFxcIj5RdWFudGl0eTogPGlucHV0IGNsYXNzPVxcXCJ0ZXh0Qm94X1F1YW50aXR5XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0ZXh0Qm94XFxcIj48aW5wdXQgY2xhc3M9XFxcImltZ0FkZFRvQ2FydFxcXCIgdHlwZT1cXFwiaW1hZ2VcXFwiIGFsdD1cXFwiQWRkIFRvIENhcnRcXFwiIHNyYz1cXFwiL2ltYWdlcy9BZGRUb0NhcnRfYnV0dG9uLnBuZ1xcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJhY2tncm91bmRCb3R0b21cXFwiPiZuYnNwOzwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2aXNpYmxlLXhzIG1haW5DbGFzc1NtYWxsXFxcIj5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNtYWxsU2l6ZUhlYWRlclxcXCI+PGltZyBhbHQ9XFxcIkJha2luZyBQbGFua3NcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vd3d3cm9vdC9pbWFnZXMvQmFraW5nUGxhbmtzX0hlYWRlci5wbmdcIikgKyBcIlxcXCIgY2xhc3M9XFxcImltZy1yZXNwb25zaXZlXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNtYWxsU2l6ZVBvc2l0aW9uXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cXFwicGFkZGluZy10b3A6IDEwcHg7IHBhZGRpbmctYm90dG9tOiA1cHhcXFwiPkNlZGFyIGFuZCBBbGRlciBwbGFua3MgaW1wYXJ0IGEgc3VidGxlIHlldCBmdWxsIGZsYXZvcmVkIGFyb21hIHRvIGFueXRoaW5nIHJvYXN0ZWQgb24gdGhlbS4gT3VyIHBsYW5rcyBhcmUgbWFkZSBmcm9tIGNsZWFyIGtpbG4gZHJpZWQgV2VzdGVybiBSZWQgQ2VkYXIgYW5kIEFsZGVyLiBDZWRhciByb2FzdGluZyBwbGFua3MgY29tZSBpbiB0d28gc2l6ZXMuIEFsZGVyIHBsYW5rcyBhcmUgYXZhaWxhYmxlIGluIG9uZSBzaXplIG9ubHkuPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IHByb2R1Y3Qgb2YgcHJvZHVjdHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkb3R0ZWRfbGluZV90b3AgZG90dGVkTGluZUNsYXNzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRlbnRUaXRsZXMgZG90dGVkX2xpbmVfYm90dG9tIGRvdHRlZF9saW5lX3JpZ2h0XFxcIj57e3Byb2R1Y3QubmFtZX19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj57e3Byb2R1Y3QuZGVzY3JpcHRpb259fS48L2Rpdj5cXG5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRhYmxlU3R5bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwicHJvZHVjdE5hbWVTdHlsZVxcXCIgdmFsaWduPVxcXCJ0b3BcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e3Byb2R1Y3QubmFtZX19XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2R1Y3RJbWFnZVBhdGhcXFwiPjxpbWcgYWx0PVxcXCJQcm9kdWN0XFxcIiBzdHlsZT1cXFwiYm9yZGVyOm5vbmVcXFwiIHNyYz1cXFwie3twcm9kdWN0LmltYWdlUGF0aH19XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCB2YWxpZ249XFxcInRvcFxcXCIgY2xhc3M9XFxcInByaWNlU3R5bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlByaWNlOiAke3twcm9kdWN0LnByaWNlLnRvRml4ZWQoMil9fSA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVpZ2h0VGV4dEJveFN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRleHRCb3hcXFwiPlF1YW50aXR5OiA8aW5wdXQgY2xhc3M9XFxcInRleHRCb3hfUXVhbnRpdHlcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dEJveFxcXCI+PGlucHV0IGNsYXNzPVxcXCJpbWdBZGRUb0NhcnRcXFwiIHR5cGU9XFxcImltYWdlXFxcIiBhbHQ9XFxcIkFkZCBUbyBDYXJ0XFxcIiBzcmM9XFxcIi9pbWFnZXMvQWRkVG9DYXJ0X2J1dHRvbi5wbmdcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3Nob3AvYmFraW5ncGxhbmtzL2Jha2luZ3BsYW5rcy5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9iYWtpbmdwbGFua3MuY29tcG9uZW50LmNzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9iYWtpbmdwbGFua3MvYmFraW5ncGxhbmtzLmNvbXBvbmVudC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5tYWluQ2xhc3Mge1xcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjsgXFxuICAgIG1hcmdpbjowIDAgMzBweCAwO1xcbn1cXG5cXG4uc2hvcFRpdGxlRHJvcFN0eWxlIHtcXG4gICAgZm9udC1zaXplOjI0cHg7XFxufVxcblxcbi5kcm9wRG93blN0eWxlIHtcXG4gICAgd2lkdGg6MjgwcHg7IFxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiMyMjE5MGY7IFxcbiAgICBjb2xvcjojZjhmM2RjO1xcbn1cXG5cXG4uZHJvcERvd25MaW5rU3R5bGUge1xcbiAgICBoZWlnaHQ6MzBweDtcXG59XFxuXFxuLmNvbnRhaW5lclN0eWxlIHtcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7IFxcbiAgICBsZWZ0OjQwcHg7XFxufVxcblxcbi5iYWNrZ3JvdW5kSW1hZ2VTdHlsZSB7XFxuICAgIHBvc2l0aW9uOnJlbGF0aXZlOyBcXG4gICAgaGVpZ2h0OjM2NHB4OyBcXG4gICAgd2lkdGg6NjUwcHg7IFxcbiAgICBiYWNrZ3JvdW5kLWltYWdlOnVybCgvaW1hZ2VzL1Bob3RvX0JhY2tncm91bmQucG5nKTtcXG59XFxuXFxuLmhlYWRlclN0eWxlIHtcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7IFxcbiAgICB0b3A6MjBweDsgXFxuICAgIGxlZnQ6MDtcXG59XFxuXFxuLmJhY2tncm91bmRNaWRkbGUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IFxcbiAgICB0b3A6IC0yNXB4OyBcXG4gICAgbGVmdDogMTFweDsgXFxuICAgIHdpZHRoOiA2MjZweDsgXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgvaW1hZ2VzL1BhcGVyQmFja2dyb3VuZF9NaWRkbGUucG5nKTsgXFxuICAgIGJhY2tncm91bmQtcmVwZWF0OnJlcGVhdC15O1xcbn1cXG5cXG4ucG9zaXRpb25TdHlsZSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgXFxuICAgIHRvcDogNXB4OyBcXG4gICAgbGVmdDogMzFweDsgXFxuICAgIHRleHQtYWxpZ246bGVmdDtcXG59XFxuXFxuLmRlc2NyaXB0aW9uU3R5bGUge1xcbiAgICB3aWR0aDogNTcwcHg7IFxcbiAgICBwYWRkaW5nLXRvcDogMTBweDsgXFxuICAgIHBhZGRpbmctYm90dG9tOiA1cHg7XFxufVxcblxcbi5wcm9kdWN0VGl0bGUge1xcbiAgICBtYXJnaW46IDEwcHggMCAxMHB4IDA7IFxcbiAgICB3aWR0aDo1NzBweDsgXFxufVxcblxcbi5wcm9kdWN0V2lkdGgge1xcbiAgICB3aWR0aDozNTBweDtcXG59XFxuXFxuLnByb2R1Y3RTdHlsZSB7XFxuICAgIHdpZHRoOjU3MHB4O1xcbn1cXG5cXG4udGFibGVTdHlsZSB7XFxuICAgIHBhZGRpbmctdG9wOiAyMHB4OyBcXG4gICAgd2lkdGg6MTAwJTtcXG59XFxuXFxuLnByb2R1Y3ROYW1lU3R5bGUge1xcbiAgICB3aWR0aDo3NSU7IFxcbiAgICBwYWRkaW5nLXJpZ2h0OjE1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7XFxufVxcblxcbi5wcm9kdWN0SW1hZ2VQYXRoIHtcXG4gICAgcGFkZGluZy10b3A6NXB4O1xcbiAgICB0ZXh0LWFsaWduOmxlZnQ7XFxufVxcblxcbi5pbWdQYXRoIHtcXG4gICAgYm9yZGVyOiBub25lO1xcbn1cXG5cXG4ucHJpY2VTdHlsZSB7XFxuICAgIHRleHQtYWxpZ246bGVmdDtcXG59XFxuXFxuLmhlaWdodFRleHRCb3hTdHlsZSB7XFxuICAgIGhlaWdodDozOHB4O1xcbn1cXG5cXG4udGV4dEJveCB7XFxuICAgIGZsb2F0OmxlZnQ7XFxuICAgICB3aWR0aDoxMDBweDtcXG59XFxuXFxuLnRleHRCb3hfUXVhbnRpdHkge1xcbiAgICB3aWR0aDoyNXB4OyBcXG4gICAgY29sb3I6YmxhY2s7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcXG59XFxuXFxuLmltZ0FkZFRvQ2FydCB7XFxuICAgIHBhZGRpbmctcmlnaHQ6NXB4O1xcbn1cXG5cXG4uYmFja2dyb3VuZEJvdHRvbSB7XFxuICAgIHdpZHRoOiA2MjZweDsgXFxuICAgIGhlaWdodDogMzVweDsgXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgvaW1hZ2VzL1BhcGVyQmFja2dyb3VuZF9Cb3R0b20ucG5nKTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLm1haW5DbGFzc1NtYWxsIHtcXG4gICAgd2lkdGg6MTAwJTtcXG59XFxuXFxuLnNtYWxsU2l6ZUhlYWRlciB7XFxuICAgIGRpc3BsYXk6aW5saW5lLWJsb2NrO1xcbn1cXG5cXG4uc21hbGxTaXplUG9zaXRpb24ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IFxcbiAgICB0b3A6IDVweDsgXFxuICAgIGxlZnQ6IDBweDsgXFxuICAgIHRleHQtYWxpZ246bGVmdDtcXG59XFxuXFxuLmRvdHRlZExpbmVDbGFzcyB7XFxuICAgIG1hcmdpbjogMTBweCAwIDEwcHggMDtcXG59XFxuXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL2Jha2luZ3BsYW5rcy9iYWtpbmdwbGFua3MuY29tcG9uZW50LmNzc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQbGFua0Nvb2tpbmdTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZXMvcGxhbmtjb29raW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgUHJvZHVjdCB9IGZyb20gJy4uLy4uLy4uL21vZGVscy9Qcm9kdWN0JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdzaG9wLWJicXBsYW5rcycsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYmJxcGxhbmtzLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9iYnFwbGFua3MuY29tcG9uZW50LmNzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIFNob3BCYnFQbGFua3NDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgcHJvZHVjdHM6UHJvZHVjdFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBwbGFua0Nvb2tpbmdTZXJ2aWNlOiBQbGFua0Nvb2tpbmdTZXJ2aWNlKSB7IFxuICAgIFxuICAgICAgICB0aGlzLnByb2R1Y3RzID0gW107XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucGxhbmtDb29raW5nU2VydmljZS5nZXRCYnFQbGFua3MoKS5zdWJzY3JpYmUocHJvZHVjdHMgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9kdWN0cyA9IHByb2R1Y3RzO1xuICAgICAgICB9KTtcbiAgICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9iYnFwbGFua3MvYmJxcGxhbmtzLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8c2lkZS1tZW51Pjwvc2lkZS1tZW51PlxcblxcblxcbiAgXFxuICAgIDxkaXYgY2xhc3M9XFxcInZpc2libGUteHMgdmlzaWJsZS1zbSBjbGVhcmZpeCBjb2wtbWQtMyBtYWluRHJvcERvd25DbGFzc1xcXCI+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tY3VzdG9tIGJ0bi1sZyBkcm9wZG93bi10b2dnbGUgZHJvcERvd25TdHlsZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBkYXRhLXRvZ2dsZT1cXFwiZHJvcGRvd25cXFwiIGFyaWEtaGFzcG9wdXA9XFxcInRydWVcXFwiIGFyaWEtZXhwYW5kZWQ9XFxcImZhbHNlXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNob3BUaXRsZURyb3BTdHlsZVxcXCI+U2hvcDwvc3Bhbj4gPHNwYW4gY2xhc3M9XFxcImNhcmV0XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9idXR0b24+XFxuXFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIiBzdHlsZT1cXFwid2lkdGg6MjgwcHg7XFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvU3BpY2VSdWJzXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5TUElDRSBSVUJTPC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcERvd25MaW5rU3R5bGVcXFwiPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL0Nvb2tCb29rc1xcXCIgdGFyZ2V0PVxcXCJfc2VsZlxcXCI+Q09PS0JPT0tTPC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcERvd25MaW5rU3R5bGVcXFwiPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL0Jha2luZ1BsYW5rc1xcXCIgdGFyZ2V0PVxcXCJfc2VsZlxcXCI+QkFLSU5HIFBMQU5LUzwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImRyb3BEb3duTGlua1N0eWxlXFxcIj48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9CYnFQbGFua3NcXFwiIHRhcmdldD1cXFwiX3NlbGZcXFwiPkJCUSBQTEFOS1M8L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvTnV0RHJpdmVyXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5OVVQgRFJJVkVSPC9hPjwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgIDwvZGl2PlxcblxcblxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLWZsdWlkXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcblxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoaWRkZW4teHMgY29udGFpbmVyU3R5bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmFja2dyb3VuZEltYWdlU3R5bGVcXFwiPjxpbWcgYWx0PVxcXCJCQlEgUGxhbmtzXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL0JCUVBsYW5rc19IZWFkZXIucG5nXCIpICsgXCJcXFwiIGNsYXNzPVxcXCJpbWctcmVzcG9uc2l2ZSBoZWFkZXJTdHlsZVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJiYWNrZ3JvdW5kTWlkZGxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IHByb2R1Y3Qgb2YgcHJvZHVjdHNcXFwiIGNsYXNzPVxcXCJwb3NpdGlvblN0eWxlXFxcIj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZG90dGVkX2xpbmVfdG9wIHByb2R1Y3RUaXRsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50VGl0bGVzIGRvdHRlZF9saW5lX2JvdHRvbSBkb3R0ZWRfbGluZV9yaWdodCBwcm9kdWN0V2lkdGhcXFwiPnt7cHJvZHVjdC5uYW1lfX08L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2R1Y3RcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNlbGxwYWRkaW5nPVxcXCIwXFxcIiBjZWxsc3BhY2luZz1cXFwiMFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJkZXNjcmlwdGlvblN0eWxlXFxcIiB2YWxpZ249XFxcInRvcFxcXCIgYWxpZ249XFxcImxlZnRcXFwiPnt7cHJvZHVjdC5kZXNjcmlwdGlvbn19IDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgdmFsaWduPVxcXCJ0b3BcXFwiIGFsaWduPVxcXCJjZW50ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+UHJpY2U6ICR7e3Byb2R1Y3QucHJpY2UudG9GaXhlZCgyKX19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVpZ2h0VGV4dEJveFN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dEJveFxcXCI+UXVhbnRpdHk6IDxpbnB1dCBjbGFzcz1cXFwidGV4dEJveF9RdWFudGl0eVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRleHRCb3hcXFwiPjxpbnB1dCB0eXBlPVxcXCJpbWFnZVxcXCIgY2xhc3M9XFxcImltZy1yZXNwb25zaXZlIGNhcnRCdG5QYWRkaW5nXFxcIiBhbHQ9XFxcIkFkZCBUbyBDYXJ0XFxcIiBzcmM9XFxcIi9pbWFnZXMvQWRkVG9DYXJ0X2J1dHRvbi5wbmdcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImltZ1N0eWxlXFxcIj48aW1nIGNsYXNzPVxcXCJzbWFsbEltZ1N0eWxlXFxcIiBzcmM9XFxcInt7cHJvZHVjdC5pbWFnZVBhdGh9fVxcXCIgYWx0PVxcXCJQcm9kdWN0XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJiYWNrZ3JvdW5kQm90dG9tXFxcIj4mbmJzcDs8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidmlzaWJsZS14c1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzbWFsbFNpemVIZWFkZXJcXFwiPjxpbWcgYWx0PVxcXCJCQlEgUGxhbmtzXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL0JCUVBsYW5rc19IZWFkZXIucG5nXCIpICsgXCJcXFwiIGNsYXNzPVxcXCJpbWctcmVzcG9uc2l2ZVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IHByb2R1Y3Qgb2YgcHJvZHVjdHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZG90dGVkX2xpbmVfdG9wIG1haW5DbGFzc1NtYWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50VGl0bGVzIGRvdHRlZF9saW5lX2JvdHRvbSBkb3R0ZWRfbGluZV9yaWdodCBcXFwiPnt7cHJvZHVjdC5uYW1lfX08L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbERlc2NyaXB0aW9uU3R5bGVcXFwiIHZhbGlnbj1cXFwidG9wXFxcIiBhbGlnbj1cXFwibGVmdFxcXCI+e3twcm9kdWN0LmRlc2NyaXB0aW9ufX0uIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIHZhbGlnbj1cXFwidG9wXFxcIiBhbGlnbj1cXFwiY2VudGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5QcmljZTogJHt7cHJvZHVjdC5wcmljZS50b0ZpeGVkKDIpfX08YnI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcnRUZXh0U21hbGxIZWlnaHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5RdWFudGl0eTogPGlucHV0IGNsYXNzPVxcXCJ0ZXh0Qm94X1F1YW50aXR5XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+PGlucHV0IGNsYXNzPVxcXCJzbWFsbEFkZFRvQ2FydEltZ1xcXCIgdHlwZT1cXFwiaW1hZ2VcXFwiIGNsYXNzPVxcXCJpbWctcmVzcG9uc2l2ZVxcXCIgYWx0PVxcXCJBZGQgVG8gQ2FydFxcXCIgc3JjPVxcXCIvaW1hZ2VzL0FkZFRvQ2FydF9idXR0b24ucG5nXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImltZ1N0eWxlXFxcIj48aW1nIGNsYXNzPVxcXCJzbWFsbEltZ1N0eWxlXFxcIiBzcmM9XFxcInt7cHJvZHVjdC5pbWFnZVBhdGh9fVxcXCIgYWx0PVxcXCJQcm9kdWN0XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICBcXG5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcblxcbiAgICA8L2Rpdj5cXG5cXG5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL2JicXBsYW5rcy9iYnFwbGFua3MuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYmJxcGxhbmtzLmNvbXBvbmVudC5jc3NcIik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3Nob3AvYmJxcGxhbmtzL2JicXBsYW5rcy5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubWFpbkRyb3BEb3duQ2xhc3Mge1xcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjsgXFxuICAgIG1hcmdpbjowIDAgMzBweCAwO1xcbn1cXG5cXG4uZHJvcERvd25TdHlsZSB7XFxuICAgIHdpZHRoOjI4MHB4OyBcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojMjIxOTBmOyBcXG4gICAgY29sb3I6I2Y4ZjNkYztcXG59XFxuXFxuLnNob3BUaXRsZURyb3BTdHlsZSB7XFxuICAgIGZvbnQtc2l6ZToyNHB4O1xcbn1cXG5cXG4uZHJvcERvd25MaW5rU3R5bGUge1xcbiAgICBoZWlnaHQ6MzBweDtcXG59XFxuXFxuLmNvbnRhaW5lclN0eWxlIHtcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7IFxcbiAgICBsZWZ0OjQwcHg7XFxufVxcblxcbi5iYWNrZ3JvdW5kSW1hZ2VTdHlsZSB7XFxuICAgIHBvc2l0aW9uOnJlbGF0aXZlOyBcXG4gICAgaGVpZ2h0OjM2NHB4OyBcXG4gICAgd2lkdGg6NjUwcHg7IFxcbiAgICBiYWNrZ3JvdW5kLWltYWdlOnVybCgvaW1hZ2VzL1Bob3RvX0JhY2tncm91bmQucG5nKTtcXG59XFxuXFxuLmhlYWRlclN0eWxlIHtcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7IFxcbiAgICB0b3A6MjBweDsgXFxuICAgIGxlZnQ6MjZweDtcXG59XFxuXFxuLmJhY2tncm91bmRNaWRkbGUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IFxcbiAgICB0b3A6IC0yNXB4OyBcXG4gICAgbGVmdDogMTFweDsgXFxuICAgIHdpZHRoOiA2MjZweDsgXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgvaW1hZ2VzL1BhcGVyQmFja2dyb3VuZF9NaWRkbGUucG5nKTsgXFxuICAgIGJhY2tncm91bmQtcmVwZWF0OnJlcGVhdC15O1xcbn1cXG5cXG4ucG9zaXRpb25TdHlsZSB7XFxuICAgIHBvc2l0aW9uOnJlbGF0aXZlOyBcXG4gICAgdG9wOjVweDsgXFxuICAgIGxlZnQ6MzFweFxcbn1cXG5cXG4ucHJvZHVjdFRpdGxlIHtcXG4gICAgbWFyZ2luOiAxMHB4IDAgMTBweCAwOyBcXG4gICAgd2lkdGg6NTcwcHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7XFxufVxcblxcbi5wcm9kdWN0V2lkdGgge1xcbiAgICB3aWR0aDozNTBweDtcXG59XFxuXFxuLnByb2R1Y3Qge1xcbiAgICB3aWR0aDo1NzBweDtcXG59XFxuXFxuLmRlc2NyaXB0aW9uU3R5bGUge1xcbiAgICB3aWR0aDozNTBweDsgXFxuICAgIHBhZGRpbmctcmlnaHQ6MTVweDtcXG59XFxuXFxuLmhlaWdodFRleHRCb3hTdHlsZSB7XFxuICAgIGhlaWdodDozOHB4O1xcbn1cXG5cXG4udGV4dEJveCB7XFxuICAgIHdpZHRoOjEwMHB4O1xcbn1cXG5cXG4udGV4dEJveF9RdWFudGl0eSB7XFxuICAgIHdpZHRoOjI1cHg7IFxcbiAgICBjb2xvcjpibGFjazsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xcbn1cXG5cXG4uY2FydEJ0blBhZGRpbmcge1xcbiAgIHBhZGRpbmc6NXB4IDVweCAwIDA7XFxufVxcblxcbi5pbWdTdHlsZSB7XFxuICAgIHBhZGRpbmctdG9wOjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcXG59XFxuXFxuLnNtYWxsSW1nU3R5bGUge1xcbiAgICBib3JkZXI6bm9uZTtcXG59XFxuXFxuLmJhY2tncm91bmRCb3R0b20ge1xcbiAgICB3aWR0aDogNjI2cHg7IFxcbiAgICBoZWlnaHQ6IDM1cHg7IFxcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoL2ltYWdlcy9QYXBlckJhY2tncm91bmRfQm90dG9tLnBuZyk7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcblxcbi5zbWFsbFNpemVIZWFkZXIge1xcbiAgICBkaXNwbGF5OmlubGluZS1ibG9jaztcXG59XFxuXFxuLm1haW5DbGFzc1NtYWxsIHtcXG4gICAgbWFyZ2luOiAxMHB4IDAgMTBweCAwO1xcbiAgICAgdGV4dC1hbGlnbjpsZWZ0O1xcbn1cXG5cXG4uc21hbGxEZXNjcmlwdGlvblN0eWxlIHtcXG4gICAgcGFkZGluZy1yaWdodDoxNXB4O1xcbn1cXG5cXG4uY2FydFRleHRTbWFsbEhlaWdodCB7XFxuICAgIGhlaWdodDozOHB4O1xcbn1cXG5cXG4uc21hbGxBZGRUb0NhcnRJbWcge1xcbiAgICBwYWRkaW5nOjNweCA1cHggMCAwO1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3Nob3AvYmJxcGxhbmtzL2JicXBsYW5rcy5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFByb2R1Y3QgfSBmcm9tICcuLi8uLi8uLi9tb2RlbHMvUHJvZHVjdCc7XG5pbXBvcnQgeyBQbGFua0Nvb2tpbmdTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZXMvcGxhbmtjb29raW5nLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3Nob3AtbnV0ZHJpdmVyJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9udXRkcml2ZXIuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL251dGRyaXZlci5jb21wb25lbnQuY3NzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgU2hvcE51dERyaXZlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgcHJvZHVjdHM6UHJvZHVjdFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBwbGFua0Nvb2tpbmdTZXJ2aWNlOiBQbGFua0Nvb2tpbmdTZXJ2aWNlKSB7IFxuICAgIFxuICAgICAgICB0aGlzLnByb2R1Y3RzID0gW107XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucGxhbmtDb29raW5nU2VydmljZS5nZXROdXRkcml2ZXIoKS5zdWJzY3JpYmUocHJvZHVjdHMgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9kdWN0cyA9IHByb2R1Y3RzO1xuICAgICAgICB9KTtcbiAgICAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9udXRkcml2ZXIvbnV0ZHJpdmVyLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8c2lkZS1tZW51Pjwvc2lkZS1tZW51PlxcblxcblxcbiAgXFxuPGRpdiBjbGFzcz1cXFwidmlzaWJsZS14cyB2aXNpYmxlLXNtIGNsZWFyZml4IGNvbC1tZC0zIG1haW5DbGFzc1xcXCI+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cFxcXCI+XFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLWN1c3RvbSBidG4tbGcgZHJvcGRvd24tdG9nZ2xlIGRyb3BEb3duU3R5bGVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIiBhcmlhLWhhc3BvcHVwPVxcXCJ0cnVlXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNob3BUaXRsZURyb3BTdHlsZVxcXCI+U2hvcDwvc3Bhbj4gPHNwYW4gY2xhc3M9XFxcImNhcmV0XFxcIj48L3NwYW4+XFxuICAgICAgICA8L2J1dHRvbj5cXG5cXG4gICAgICAgIDx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudSBtZW51U3R5bGVcXFwiPlxcbiAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcERvd25MaW5rU3R5bGVcXFwiPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL1NwaWNlUnVic1xcXCIgdGFyZ2V0PVxcXCJfc2VsZlxcXCI+U1BJQ0UgUlVCUzwvYT48L2xpPlxcbiAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcERvd25MaW5rU3R5bGVcXFwiPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL0Nvb2tCb29rc1xcXCIgdGFyZ2V0PVxcXCJfc2VsZlxcXCI+Q09PS0JPT0tTPC9hPjwvbGk+XFxuICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvQmFraW5nUGxhbmtzXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5CQUtJTkcgUExBTktTPC9hPjwvbGk+XFxuICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvQmJxUGxhbmtzXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5CQlEgUExBTktTPC9hPjwvbGk+XFxuICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvTnV0RHJpdmVyXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5OVVQgRFJJVkVSPC9hPjwvbGk+XFxuICAgICAgICA8L3VsPlxcbiAgICA8L2Rpdj5cXG5cXG5cXG48L2Rpdj5cXG4gICBcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLWZsdWlkXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTlcXFwiPlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoaWRkZW4teHMgY29udGFpbmVyU3R5bGVcXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmFja2dyb3VuZEltYWdlU3R5bGVcXFwiPjxpbWcgY2xhc3M9XFxcImltZy1yZXNwb25zaXZlIGhlYWRlclN0eWxlXFxcIiBhbHQ9XFxcIk51dCBEcml2ZXJcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vd3d3cm9vdC9pbWFnZXMvQ29va2Jvb2tzX0hlYWRlci5wbmdcIikgKyBcIlxcXCI+PC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2ICAqbmdGb3I9XFxcImxldCBwcm9kdWN0IG9mIHByb2R1Y3RzXFxcIiBjbGFzcz1cXFwiYmFja2dyb3VuZE1pZGRsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicG9zaXRpb25TdHlsZVxcXCI+XFxuXFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkb3R0ZWRfbGluZV90b3AgcHJvZHVjdFRpdGxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50VGl0bGVzIGRvdHRlZF9saW5lX2JvdHRvbSBkb3R0ZWRfbGluZV9yaWdodCBwcm9kdWN0V2lkdGhcXFwiPnt7cHJvZHVjdC5uYW1lfX08L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZHVjdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJkZXNjcmlwdGlvblN0eWxlXFxcIiB2YWxpZ249XFxcInRvcFxcXCIgYWxpZ249XFxcImxlZnRcXFwiPnt7cHJvZHVjdC5kZXNjcmlwdGlvbn19PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgdmFsaWduPVxcXCJ0b3BcXFwiIGFsaWduPVxcXCJjZW50ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlByaWNlOiAke3twcm9kdWN0LnByaWNlLnRvRml4ZWQoMil9fSA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVpZ2h0VGV4dEJveFN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRleHRCb3hcXFwiPlF1YW50aXR5OiA8aW5wdXQgY2xhc3M9XFxcInRleHRCb3hfUXVhbnRpdHlcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dEJveFxcXCI+PGlucHV0IHR5cGU9XFxcImltYWdlXFxcIiBjbGFzcz1cXFwiaW1nLXJlc3BvbnNpdmUgY2FydEJ0blBhZGRpbmdcXFwiIGFsdD1cXFwiQWRkIFRvIENhcnRcXFwiIHNyYz1cXFwiL2ltYWdlcy9BZGRUb0NhcnRfYnV0dG9uLnBuZ1xcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpbWdTdHlsZVxcXCI+PGltZyBjbGFzcz1cXFwiaW1nLXJlc3BvbnNpdmUgc21hbGxJbWdTdHlsZVxcXCIgc3JjPVxcXCJ7e3Byb2R1Y3QuaW1hZ2VQYXRofX1cXFwiIGFsdD1cXFwiUHJvZHVjdFxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgXFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGlkZGVuLXhzIGJhY2tncm91bmRCb3R0b21cXFwiPiZuYnNwOzwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2aXNpYmxlLXhzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNtYWxsU2l6ZUhlYWRlclxcXCI+PGltZyBhbHQ9XFxcIkNvb2tib29rIENvdmVyc1xcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi93d3dyb290L2ltYWdlcy9Db29rYm9va3NfSGVhZGVyLnBuZ1wiKSArIFwiXFxcIiBjbGFzcz1cXFwiaW1nLXJlc3BvbnNpdmVcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IHByb2R1Y3Qgb2YgcHJvZHVjdHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZG90dGVkX2xpbmVfdG9wIG1haW5DbGFzc1NtYWxsXFxcIj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50VGl0bGVzIGRvdHRlZF9saW5lX2JvdHRvbSBkb3R0ZWRfbGluZV9yaWdodFxcXCI+e3twcm9kdWN0Lm5hbWV9fTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbERlc2NyaXB0aW9uU3R5bGVcXFwiIHZhbGlnbj1cXFwidG9wXFxcIiBhbGlnbj1cXFwibGVmdFxcXCI+e3twcm9kdWN0LmRlc2NyaXB0aW9ufX08L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCB2YWxpZ249XFxcInRvcFxcXCIgYWxpZ249XFxcImNlbnRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+UHJpY2U6ICR7e3Byb2R1Y3QucHJpY2UudG9GaXhlZCgyKX19PGJyPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJ0VGV4dFNtYWxsSGVpZ2h0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+UXVhbnRpdHk6IDxpbnB1dCBjbGFzcz1cXFwidGV4dEJveF9RdWFudGl0eVxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PjxpbnB1dCB0eXBlPVxcXCJpbWFnZVxcXCIgY2xhc3M9XFxcImltZy1yZXNwb25zaXZlIGNhcnRCdG5QYWRkaW5nXFxcIiBhbHQ9XFxcIkFkZCBUbyBDYXJ0XFxcIiBzcmM9XFxcIi9pbWFnZXMvQWRkVG9DYXJ0X2J1dHRvbi5wbmdcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW1nU3R5bGVcXFwiPjxpbWcgY2xhc3M9XFxcInNtYWxsSW1nU3R5bGVcXFwiIHNyYz1cXFwie3twcm9kdWN0LmltYWdlUGF0aH19XFxcIiBhbHQ9XFxcIlByb2R1Y3RcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcblxcblxcblxcblxcblxcblxcblxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3Nob3AvbnV0ZHJpdmVyL251dGRyaXZlci5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9udXRkcml2ZXIuY29tcG9uZW50LmNzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9udXRkcml2ZXIvbnV0ZHJpdmVyLmNvbXBvbmVudC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5kcm9wRG93bkxpbmtTdHlsZSB7XFxuICAgIGhlaWdodDozMHB4O1xcbn1cXG5cXG4ubWFpbkNsYXNzIHtcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBtYXJnaW46MCAwIDMwcHggMDtcXG59XFxuXFxuLmRyb3BEb3duU3R5bGUge1xcbiAgICB3aWR0aDoyODBweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6IzIyMTkwZjsgXFxuICAgIGNvbG9yOiNmOGYzZGM7XFxufVxcblxcbi5zaG9wVGl0bGVEcm9wU3R5bGUge1xcbiAgICBmb250LXNpemU6MjRweDtcXG59XFxuXFxuLm1lbnVTdHlsZSB7XFxuICAgIHdpZHRoOjI4MHB4O1xcbn1cXG5cXG4uY29udGFpbmVyU3R5bGUge1xcbiAgICBwb3NpdGlvbjpyZWxhdGl2ZTsgXFxuICAgIGxlZnQ6NDBweDtcXG59XFxuXFxuLmJhY2tncm91bmRJbWFnZVN0eWxlIHtcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7IFxcbiAgICBoZWlnaHQ6MzY0cHg7IFxcbiAgICB3aWR0aDo2NTBweDsgXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6dXJsKC9pbWFnZXMvUGhvdG9fQmFja2dyb3VuZC5wbmcpO1xcbn1cXG5cXG4uaGVhZGVyU3R5bGUge1xcbiAgICBwb3NpdGlvbjpyZWxhdGl2ZTsgXFxuICAgIHRvcDoyMHB4OyBcXG4gICAgbGVmdDoyNnB4O1xcbn1cXG5cXG4uYmFja2dyb3VuZE1pZGRsZSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgXFxuICAgIHRvcDogLTI1cHg7IFxcbiAgICBsZWZ0OiAxMXB4OyBcXG4gICAgd2lkdGg6IDYyNnB4OyBcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKC9pbWFnZXMvUGFwZXJCYWNrZ3JvdW5kX01pZGRsZS5wbmcpOyBcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXk7XFxufVxcblxcbi5wb3NpdGlvblN0eWxlIHtcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7IFxcbiAgICB0b3A6NXB4OyBcXG4gICAgbGVmdDozMXB4XFxufVxcblxcbi5wcm9kdWN0VGl0bGUge1xcbiAgICBtYXJnaW46IDEwcHggMCAxMHB4IDA7IFxcbiAgICB3aWR0aDo1NzBweDsgXFxuICAgIHRleHQtYWxpZ246bGVmdDtcXG59XFxuXFxuLnByb2R1Y3RXaWR0aCB7XFxuICAgIHdpZHRoOjM1MHB4O1xcbn1cXG5cXG4ucHJvZHVjdCB7XFxuICAgIHdpZHRoOjU3MHB4O1xcbn1cXG5cXG4uZGVzY3JpcHRpb25TdHlsZSB7XFxuICAgIHdpZHRoOjM1MHB4OyBcXG4gICAgcGFkZGluZy1yaWdodDoxNXB4O1xcbn1cXG5cXG4uaGVpZ2h0VGV4dEJveFN0eWxlIHtcXG4gICAgaGVpZ2h0OjM4cHg7XFxufVxcblxcbi50ZXh0Qm94IHtcXG4gICAgd2lkdGg6MTAwcHg7XFxufVxcblxcbi50ZXh0Qm94X1F1YW50aXR5IHtcXG4gICAgd2lkdGg6MjVweDsgXFxuICAgIGNvbG9yOmJsYWNrOyBcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7XFxufVxcblxcbi5jYXJ0QnRuUGFkZGluZyB7XFxuICAgIHBhZGRpbmc6NXB4IDVweCAwIDBcXG59XFxuXFxuLmltZ1N0eWxlIHtcXG4gICAgcGFkZGluZy10b3A6MjVweDsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xcbn1cXG5cXG4uc21hbGxJbWdTdHlsZSB7XFxuICAgIGJvcmRlcjpub25lXFxufVxcblxcbi5iYWNrZ3JvdW5kQm90dG9tIHtcXG4gICAgd2lkdGg6IDYyNnB4OyBcXG4gICAgaGVpZ2h0OiAzNXB4OyBcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKC9pbWFnZXMvUGFwZXJCYWNrZ3JvdW5kX0JvdHRvbS5wbmcpO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG5cXG4uc21hbGxTaXplSGVhZGVyIHtcXG4gICAgZGlzcGxheTppbmxpbmUtYmxvY2s7XFxufVxcblxcbi5tYWluQ2xhc3NTbWFsbCB7XFxuICAgIG1hcmdpbjogMTBweCAwIDEwcHggMDtcXG4gICAgIHRleHQtYWxpZ246bGVmdDtcXG59XFxuXFxuLnNtYWxsRGVzY3JpcHRpb25TdHlsZSB7XFxuICAgIHBhZGRpbmctcmlnaHQ6MTVweDtcXG59XFxuXFxuLmNhcnRUZXh0U21hbGxIZWlnaHQge1xcbiAgICBoZWlnaHQ6MzhweDtcXG59XFxuXFxuLnRleHRCb3hfUXVhbnRpdHkge1xcbiAgICB3aWR0aDoyNXB4OyBcXG4gICAgY29sb3I6YmxhY2s7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcXG59XFxuXFxuLmNhcnRCdG5QYWRkaW5nIHtcXG4gICAgcGFkZGluZzo1cHggNXB4IDAgMFxcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3Nob3AvbnV0ZHJpdmVyL251dGRyaXZlci5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFByb2R1Y3QgfSBmcm9tICcuLi8uLi8uLi9tb2RlbHMvUHJvZHVjdCc7XG5pbXBvcnQgeyBXZWJzaXRlIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWxzL1dlYnNpdGUnO1xuaW1wb3J0IHsgQ2F0ZWdvcnkgfSBmcm9tICcuLi8uLi8uLi9tb2RlbHMvQ2F0ZWdvcnknO1xuaW1wb3J0IHsgT3JkZXJDYXJ0IH0gZnJvbSAnLi4vLi4vLi4vbW9kZWxzL09yZGVyQ2FydCc7XG5pbXBvcnQgeyBQbGFua0Nvb2tpbmdTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZXMvcGxhbmtjb29raW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgT3JkZXJJdGVtIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWxzL09yZGVySXRlbSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IEh0dHBDbGllbnQsIEh0dHBIZWFkZXJzIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuXG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdzaG9wLXNwaWNlcnVicycsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vc3BpY2VydWJzLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9zcGljZXJ1YnMuY29tcG9uZW50LmNzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIFNob3BTcGljZVJ1YnNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgcHJvZHVjdHM6UHJvZHVjdFtdO1xuICAgIHF1YW50aXR5Ok9yZGVySXRlbVtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBwbGFua0Nvb2tpbmdTZXJ2aWNlOiBQbGFua0Nvb2tpbmdTZXJ2aWNlLCAgcHJpdmF0ZSBodHRwOiBIdHRwQ2xpZW50KSB7IFxuICAgIFxuICAgICAgICB0aGlzLnByb2R1Y3RzID0gW107XG4gICAgICAgIHRoaXMucXVhbnRpdHkgPSBbXTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5wbGFua0Nvb2tpbmdTZXJ2aWNlLmdldFNwaWNlUnVicygpLnN1YnNjcmliZShwcm9kdWN0cyA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2R1Y3RzID0gcHJvZHVjdHM7XG4gICAgICAgIH0pO1xuICAgICB9XG5cbiAgICAgYWRkUHJvZHVjdCAocXR5OiBudW1iZXIpOiBPYnNlcnZhYmxlPE9yZGVySXRlbT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcInRoZSBxdHkgPSBcIiArIHF0eSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBodHRwT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgSHR0cEhlYWRlcnMoeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0pXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAucG9zdDxPcmRlckl0ZW0+KCdhcGkvdjEvcGxhbmtjb29raW5nL2FkZC9zcGljZXJ1YnMnLCBxdHksIGh0dHBPcHRpb25zKTtcbiAgICAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL3NwaWNlcnVicy9zcGljZXJ1YnMuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzaWRlLW1lbnU+PC9zaWRlLW1lbnU+XFxuICAgXFxuICAgIDxkaXYgY2xhc3M9XFxcInZpc2libGUteHMgdmlzaWJsZS1zbSBjbGVhcmZpeCBjb2wtbWQtMyBtYWluQ2xhc3NcXFwiPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwXFxcIj5cXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLWN1c3RvbSBidG4tbGcgZHJvcGRvd24tdG9nZ2xlIGRyb3BEb3duU3R5bGVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIiBhcmlhLWhhc3BvcHVwPVxcXCJ0cnVlXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzaG9wVGl0bGVEcm9wU3R5bGVcXFwiPlNob3A8L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJjYXJldFxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvYnV0dG9uPlxcblxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudSBtZW51U3R5bGVcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImRyb3BEb3duTGlua1N0eWxlXFxcIj48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9TcGljZVJ1YnNcXFwiIHRhcmdldD1cXFwiX3NlbGZcXFwiPlNQSUNFIFJVQlM8L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvQ29va0Jvb2tzXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5DT09LQk9PS1M8L2E+PC9saT5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJkcm9wRG93bkxpbmtTdHlsZVxcXCI+PGEgcm91dGVyTGluaz1cXFwiL1Nob3AvQmFraW5nUGxhbmtzXFxcIiB0YXJnZXQ9XFxcIl9zZWxmXFxcIj5CQUtJTkcgUExBTktTPC9hPjwvbGk+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwiZHJvcERvd25MaW5rU3R5bGVcXFwiPjxhIHJvdXRlckxpbms9XFxcIi9TaG9wL0JicVBsYW5rc1xcXCIgdGFyZ2V0PVxcXCJfc2VsZlxcXCI+QkJRIFBMQU5LUzwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImRyb3BEb3duTGlua1N0eWxlXFxcIj48YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9OdXREcml2ZXJcXFwiIHRhcmdldD1cXFwiX3NlbGZcXFwiPk5VVCBEUklWRVI8L2E+PC9saT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgPC9kaXY+XFxuXFxuXFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXItZmx1aWRcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOVxcXCI+XFxuXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhpZGRlbi14cyBjb250YWluZXJTdHlsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJiYWNrZ3JvdW5kSW1hZ2VTdHlsZVxcXCI+PGltZyAgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi93d3dyb290L2ltYWdlcy9TcGljZVJ1YnNfSGVhZGVyLnBuZ1wiKSArIFwiXFxcIiBjbGFzcz1cXFwiaW1nLXJlc3BvbnNpdmUgaGVhZGVyU3R5bGVcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmFja2dyb3VuZE1pZGRsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicG9zaXRpb25TdHlsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxhcmdlVmlld1RpdGxlXFxcIj5DaGVmIEhvd2llIGNyZWF0ZWQgMyBDaGVmcyBJbiBBIFR1YiBzcGljZSBydWJzIGFuZCBzZWFzb25pbmcgYmxlbmRzIHRvIGJyaW5nIHByb2Zlc3Npb25hbCBmbGF2b3IgdG8gaG9tZSBjb29raW5nLiBWZXJ5IGVhc3kgdG8gdXNlLiBKdXN0IHNlYXNvbiBjb29rIGFuZCBzZXJ2ZS4gTWFkZSB3aXRoIGFsbCBuYXR1cmFsIGluZ3JlZGllbnRzLCBkcmllZCBoZXJicyBhbmQgbXVzaHJvb21zLCBzcGljZXMsIGxlbW9uLCBnYXJsaWMsIG9uaW9uLCBicm93biBzdWdhciBhbmQga29zaGVyIHNhbHQsIG5vIE1TRyBvciBvdGhlciBjaGVtaWNhbCBhZGRpdGl2ZXMuPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhpZGRlbi14c1xcXCI+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiAqbmdGb3I9XFxcImxldCBwcm9kdWN0IG9mIHByb2R1Y3RzXFxcIiBjbGFzcz1cXFwiaGlkZGVuLXhzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRvdHRlZF9saW5lX3RvcCBwcm9kdWN0VGl0bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50VGl0bGVzIGRvdHRlZF9saW5lX2JvdHRvbSBkb3R0ZWRfbGluZV9yaWdodCBwcm9kdWN0V2lkdGhcXFwiID57e3Byb2R1Y3QubmFtZX19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9kdWN0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcImRlc2NyaXB0aW9uU3R5bGVcXFwiIHZhbGlnbj1cXFwidG9wXFxcIiBhbGlnbj1cXFwibGVmdFxcXCI+e3twcm9kdWN0LmRlc2NyaXB0aW9ufX0gPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCB2YWxpZ249XFxcInRvcFxcXCIgYWxpZ249XFxcImNlbnRlclxcXCI+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4ke3twcm9kdWN0LnByaWNlLnRvRml4ZWQoMil9fSB7e3Byb2R1Y3QucHJpY2VEZXNjcmlwdGlvbn19PC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVpZ2h0VGV4dEJveFN0eWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dEJveFxcXCI+UXVhbnRpdHk6IDxpbnB1dCAjcXR5IGNsYXNzPVxcXCJ0ZXh0Qm94X1F1YW50aXR5XFxcIiAvPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0ZXh0Qm94XFxcIj48aW5wdXQgKGNsaWNrKT1cXFwiYWRkUHJvZHVjdChxdHkudmFsdWUsIHByb2R1Y3QubmFtZSlcXFwiIHR5cGU9XFxcImltYWdlXFxcIiBjbGFzcz1cXFwiaW1nLXJlc3BvbnNpdmUgY2FydEJ0blBhZGRpbmdcXFwiIGFsdD1cXFwiQWRkIFRvIENhcnRcXFwiIHNyYz1cXFwiL2ltYWdlcy9BZGRUb0NhcnRfYnV0dG9uLnBuZ1xcXCIgPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImltZ1N0eWxlXFxcIj48aW1nIGNsYXNzPVxcXCJjYXJ0SW1hZ2VQYXRoXFxcIiBzcmM9XFxcInt7cHJvZHVjdC5pbWFnZVBhdGh9fVxcXCIgYWx0PVxcXCJQcm9kdWN0XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJhY2tncm91bmRCb3R0b21cXFwiPiZuYnNwOzwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ2aXNpYmxlLXhzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNtYWxsU2l6ZUhlYWRlclxcXCI+PGltZyAgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi93d3dyb290L2ltYWdlcy9TcGljZVJ1YnNfSGVhZGVyLnBuZ1wiKSArIFwiXFxcIiBjbGFzcz1cXFwiaW1nLXJlc3BvbnNpdmVcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgKm5nRm9yPVxcXCJsZXQgcHJvZHVjdCBvZiBwcm9kdWN0c1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiAgY2xhc3M9XFxcImRvdHRlZF9saW5lX3RvcCBtYWluQ2xhc3NTbWFsbFxcXCI+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRlbnRUaXRsZXMgZG90dGVkX2xpbmVfYm90dG9tIGRvdHRlZF9saW5lX3JpZ2h0XFxcIj57e3Byb2R1Y3QubmFtZX19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjZWxscGFkZGluZz1cXFwiMFxcXCIgY2VsbHNwYWNpbmc9XFxcIjBcXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJzbWFsbERlc2NyaXB0aW9uU3R5bGVcXFwiIHZhbGlnbj1cXFwidG9wXFxcIiBhbGlnbj1cXFwibGVmdFxcXCI+e3twcm9kdWN0LmRlc2NyaXB0aW9ufX0gPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIHZhbGlnbj1cXFwidG9wXFxcIiBhbGlnbj1cXFwiY2VudGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+UHJpY2U6ICR7e3Byb2R1Y3QucHJpY2UudG9GaXhlZCgyKX19PGJyPnt7cHJvZHVjdC5wcmljZURlc2NyaXB0aW9ufX08L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcnRUZXh0U21hbGxIZWlnaHRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+UXVhbnRpdHk6IDxpbnB1dCAgY2xhc3M9XFxcInRleHRCb3hfUXVhbnRpdHlcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+PGlucHV0ICB0eXBlPVxcXCJpbWFnZVxcXCIgY2xhc3M9XFxcImltZy1yZXNwb25zaXZlIGNhcnRCdG5TbWFsbFBhZGRpbmdcXFwiIGFsdD1cXFwiQWRkIFRvIENhcnRcXFwiIHNyYz1cXFwiL2ltYWdlcy9BZGRUb0NhcnRfYnV0dG9uLnBuZ1xcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImltZ1N0eWxlXFxcIj48aW1nIGNsYXNzPVxcXCJzbWFsbEltZ1N0eWxlXFxcIiBzcmM9XFxcInt7cHJvZHVjdC5pbWFnZVBhdGh9fVxcXCIgYWx0PVxcXCJQcm9kdWN0XFxcIiA+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICBcXG5cXG5cXG5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL3NwaWNlcnVicy9zcGljZXJ1YnMuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3BpY2VydWJzLmNvbXBvbmVudC5jc3NcIik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3Nob3Avc3BpY2VydWJzL3NwaWNlcnVicy5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuZHJvcERvd25MaW5rU3R5bGUge1xcbiAgICBoZWlnaHQ6MzBweDtcXG59XFxuXFxuLnNob3BUaXRsZURyb3BTdHlsZSB7XFxuICAgIGZvbnQtc2l6ZToyNHB4O1xcbn1cXG5cXG4ubWFpbkNsYXNzIHtcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7IFxcbiAgICBtYXJnaW46MCAwIDMwcHggMDtcXG59XFxuXFxuLmRyb3BEb3duU3R5bGUge1xcbiAgICB3aWR0aDoyODBweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6IzIyMTkwZjsgXFxuICAgIGNvbG9yOiNmOGYzZGM7XFxufVxcblxcbi5tZW51U3R5bGUge1xcbiAgICB3aWR0aDoyODBweDtcXG59XFxuXFxuLmNvbnRhaW5lclN0eWxlIHtcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7IFxcbiAgICBsZWZ0OjQwcHg7XFxufVxcblxcbi5iYWNrZ3JvdW5kSW1hZ2VTdHlsZSB7XFxuICAgIHBvc2l0aW9uOnJlbGF0aXZlOyBcXG4gICAgaGVpZ2h0OjM2NHB4OyBcXG4gICAgd2lkdGg6NjUwcHg7IFxcbiAgICBiYWNrZ3JvdW5kLWltYWdlOnVybCgvaW1hZ2VzL1Bob3RvX0JhY2tncm91bmQucG5nKTtcXG59XFxuXFxuLmhlYWRlclN0eWxlIHtcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7IFxcbiAgICB0b3A6MjBweDsgXFxuICAgIGxlZnQ6MjZweDtcXG59XFxuXFxuLmJhY2tncm91bmRNaWRkbGUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IFxcbiAgICB0b3A6IC0yNXB4OyBcXG4gICAgbGVmdDogMTFweDsgXFxuICAgIHdpZHRoOiA2MjZweDsgXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgvaW1hZ2VzL1BhcGVyQmFja2dyb3VuZF9NaWRkbGUucG5nKTsgXFxuICAgIGJhY2tncm91bmQtcmVwZWF0OnJlcGVhdC15O1xcbn1cXG5cXG4ucG9zaXRpb25TdHlsZSB7XFxuICAgIHBvc2l0aW9uOnJlbGF0aXZlOyBcXG4gICAgdG9wOjVweDsgXFxuICAgIGxlZnQ6MzFweFxcbn1cXG5cXG4ubGFyZ2VWaWV3VGl0bGUge1xcbiAgICB3aWR0aDo1NzBweDsgXFxuICAgIHBhZGRpbmctdG9wOjEwcHg7IFxcbiAgICBwYWRkaW5nLWJvdHRvbTo1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmxlZnQ7XFxufVxcblxcbi5wcm9kdWN0VGl0bGUge1xcbiAgICBtYXJnaW46IDEwcHggMCAxMHB4IDA7IFxcbiAgICB3aWR0aDo1NzBweDsgXFxuICAgIHRleHQtYWxpZ246bGVmdDtcXG59XFxuXFxuLnByb2R1Y3RXaWR0aCB7XFxuICAgIHdpZHRoOjM1MHB4O1xcbn1cXG4uc21hbGxEZXNjcmlwdGlvblN0eWxlIHtcXG4gICAgcGFkZGluZy1yaWdodDoxNXB4O1xcbn1cXG4uZGVzY3JpcHRpb25TdHlsZSB7XFxuICAgIHdpZHRoOjM1MHB4OyBcXG4gICAgcGFkZGluZy1yaWdodDoxNXB4O1xcbn1cXG5cXG4udGV4dEJveCB7XFxuICAgIHdpZHRoOjEwMHB4O1xcbn1cXG5cXG4udGV4dEJveF9RdWFudGl0eSB7XFxuICAgIHdpZHRoOjI1cHg7IFxcbiAgICBjb2xvcjpibGFjazsgXFxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xcbn1cXG5cXG4uaGVpZ2h0VGV4dEJveFN0eWxlIHtcXG4gICAgaGVpZ2h0OjM4cHg7XFxufVxcblxcbi5pbWdTdHlsZSB7XFxuICAgIHBhZGRpbmctdG9wOjI1cHg7IFxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcXG59XFxuLnNtYWxsSW1nU3R5bGUge1xcbiAgICBib3JkZXI6bm9uZVxcbn1cXG5cXG4uYmFja2dyb3VuZEJvdHRvbSB7XFxuICAgIHdpZHRoOiA2MjZweDsgXFxuICAgIGhlaWdodDogMzVweDsgXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgvaW1hZ2VzL1BhcGVyQmFja2dyb3VuZF9Cb3R0b20ucG5nKTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLmNhcnRJbWFnZVBhdGgge1xcbiAgIGJvcmRlcjpub25lO1xcbn1cXG5cXG4uY2FydEJ0blBhZGRpbmcge1xcbiAgICBwYWRkaW5nOjVweCA1cHggMCAwXFxufVxcblxcbi5jYXJ0QnRuU21hbGxQYWRkaW5nIHtcXG4gICAgcGFkZGluZzozcHggNXB4IDAgMFxcbn1cXG5cXG4uc21hbGxTaXplSGVhZGVyIHtcXG4gICAgZGlzcGxheTppbmxpbmUtYmxvY2s7XFxufVxcblxcbi5tYWluQ2xhc3NTbWFsbCB7XFxuICAgIG1hcmdpbjogMTBweCAwIDEwcHggMDtcXG4gICAgIHRleHQtYWxpZ246bGVmdDtcXG59XFxuXFxuLmNhcnRUZXh0U21hbGxIZWlnaHQge1xcbiAgICBoZWlnaHQ6MzhweDtcXG59XFxuXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL3NwaWNlcnVicy9zcGljZXJ1YnMuY29tcG9uZW50LmNzc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnc2lkZS1tZW51JyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9zaWRlbWVudS5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vc2lkZW1lbnUuY29tcG9uZW50LmNzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIFNpZGVNZW51Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gICAgbmdPbkluaXQoKSB7IH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vQ2xpZW50QXBwL2FwcC9jb21wb25lbnRzL3Nob3Avc2lkZW1lbnUuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcblxcbjxkaXYgY2xhc3M9XFxcImhpZGRlbi14cyBoaWRkZW4tc20gY29sLW1kLTNcXFwiPlxcblxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJtYWluRGl2XFxcIj5cXG5cXG4gICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgPGltZyBhbHQ9XFxcIlBhZ2UgVGl0bGVcXFwiIGNsYXNzPVxcXCJtZW51SGVhZGVyXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uLy4uL3d3d3Jvb3QvaW1hZ2VzL1Nob3BfTWVudUhlYWRlci5wbmdcIikgKyBcIlxcXCIgLz5cXG5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtYWluTGlua3NEaXZcXFwiPlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkb3R0ZWRfbGluZSBkb3R0ZWRMaW5lQ2xhc3NcXFwiPjwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL1Nob3AvU3BpY2VSdWJzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGVmdE1lbnVUaXRsZVxcXCI+U1BJQ0UgUlVCUzwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRvdHRlZF9saW5lIGRvdHRlZExpbmVDbGFzc1xcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9Db29rQm9va3NcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsZWZ0TWVudVRpdGxlXFxcIj5DT09LQk9PS1M8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkb3R0ZWRfbGluZSBkb3R0ZWRMaW5lQ2xhc3NcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL1Nob3AvQmFraW5nUGxhbmtzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGVmdE1lbnVUaXRsZVxcXCI+QkFLSU5HIFBMQU5LUzwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgIGNsYXNzPVxcXCJkb3R0ZWRfbGluZSBkb3R0ZWRMaW5lQ2xhc3NcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL1Nob3AvQmJxUGxhbmtzXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGVmdE1lbnVUaXRsZVxcXCI+QkJRIFBMQU5LUzwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRvdHRlZF9saW5lIGRvdHRlZExpbmVDbGFzc1xcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvU2hvcC9OdXREcml2ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsZWZ0TWVudVRpdGxlXFxcIj5OVVQgRFJJVkVSPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZG90dGVkX2xpbmUgZG90dGVkTGluZUNsYXNzXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICA8L2Rpdj5cXG5cXG48L2Rpdj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL3NpZGVtZW51LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBT3dBQUFCQkNBTUFBQURsajdnV0FBQURBRkJNVkVVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCTWFYRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQ0FJZ0Znb2hGd3NpR0F3ZkZRa2ZGQWdkRWdjZUV3Z2dGUWtmRkFrakdRMGhGZ29lRkFnZUV3Y2dGUW9jRVFZaUZ3c2hGZ3NmRlFvaUZ3d2VGQWtnRmdzaEZ3d2RFd2drR2c0YkVBWWNFUWNpR0EwakdBc2VFZ2NjRUFZY0VnY2pHUXdkRXdjZ0Zna2pHUTRkRVFZZEVnWWlHQXNqR2c0ZEVnZ2FEd1FmRXdna0d3OGhGd3E4bW5JS0F3QWpHQTBrR1EwWkRnUWRFUWNYREFRZkZRZ1dDd1FmRmdvYkR3VWFEd2FaZlYwUUNBTWJFQVVrR2c4YURnVVFCZ0VTQ1FNVENRTWtHZzFUUkRJbEdnOE5CUUlnRkFnYkVRWWlGd29WQ2dNaEZna2xHZzBXQ2dNVkRBVUlBZ0FsR3crdmtHcXFpMmVuaVdVUENBTWxHdzBOQkFFUkNBTWhGUWtpR1F5ZmdtQzFsRzRaRHdVWkRRUVVDd1FlRXdtN21YRVFDZ1FSQ2dVWERRVU9CZ0lTQndJT0JRRzVsM0FjRWdZWURRUWdGd29nRlFnYUVBVWpGd29aRUFjaUZncTJsVzZsaG1PNm1IR2VnV0FlRkFjN0x5R3NqV2d1SXhheGtHc0dBUUFMQlFJY0VnaEtQQ3dvSFJGNVlraHpYa1dDYWsramhXTXFIeEVlRlFnZkV3Y2ZGQW8rTVNKWVNEV05jMVZBTXlSZVN6V1dlMXFiZjE2MGsyMnBpbWFSZDFoQ01pR3prMjFIT1NjdkloUkVOQ09HYmxGYVNETlFRVEI5WjB4c1Z6OWRURGd2SkJlYWZsMmNnRjg0S2hxVGVGbWhoR0ZxVlQyWmZsMTBYMGFpaFdJeUpoY1REQVl0SXhaZ1REVnZXMEpSUWpHT2RWWklPaXFJY0ZKYlNqVmlUamVRZGxkUFBpeExQQ3M1S3h4UVB5c3JJQk5jU2pZMktScHBVem83TGg5R05pVWhHQXdVQ1FOaVVEdVlmRnlVZVZwdFdVRjFZRWROUHk2QmFFdzdMaDVxVmo2RmJFOTFYMFZWUlRNbkhBOXhYRU43WlV1U2RsZUxjVlF4SkJhM2xtOGZGZ2tmRlF1WmZWdHhXa0JsVVRoQ05TWitaVWxZUmpHSmIxRm1VejUzWUVVMEtCaVVwN3dyQUFBQUpuUlNUbE9GQVFOdGIwb0VCeXdXS1FZQUV3cytIWDlPRVFoYU5CZ01aRHdmYWlRUFFpZ1NSMGtVVitMK1BQUUFBQlZWU1VSQlZIZ0I1TStIZGNVZ0RBQkFBYmJBRXU2OUYrdG4veEh6WDhaUWJvT0RHSTJ4aU14ZUxXWkVhMHlNRUwvVmJqcHVrVXdwa2Z1WXVtODNnckcrYU1kMXZ5Z29SZGUram0zaHJRR0RSVjdSc0p6UG02cjBQdWN5VUpVWGFNQjJiUlhLcHA4M2wraTB6WDFUaHFydExPQTBVdmx4TlNoV3UwOUo0NFNBeHpvMDdrYzUxd3pyZ2NEM3Z2UzE5bXpkTC92TndIS2RNMmpQd254ZXd1Q0ZuazEvZG50SVBQZ3N2RTUvMXIwaCs4dW1pZjVza3Y3djdDL2ZZNHdhTVF4RTBlUEU2Z3lCVkc3aXdsVWdqZkFpQklzS3lRWVJnbUp2TVlvYUk1QXRHOVkzc0E2MHA5QlJNdDRENURId1A2LzZveE9OTGdvSElLSUdwUVRNWG9Eenc1ZUxxQUlFQlRBamo4Y2NrRE5uUHp6eGZobUdhVm44dW0weTBVUTNvZVN2M21UT2lqSE8rVGRuQzc5ZXJ0T1NzMS9sdXQ3WmZmcThNKzU5cDNLWE95ZWpsRkhMTG9MV0tTV2FFRTJQa2FhUlVqb2VGQnM5R2RHaEhMRWNwMHN4Q3R3TU1RTHVETUtGQU1JSjNQblBzMVd4Vis5RnNlOHZGU0dreENzTFF1cTZyTnUrSVI5MWk5RmFhNnk5MmRzVGUySnMzeHZUMU1hMHpkdnJoZjl3enRrZllXVzAyemFPaGVISDRTRVBlU1NLSWdVSEhXY3FPYmJXOHNLR2dTUWRZN09vVVJTNThIb0Q5RzZSWEV6bVluTXpRZExKVFI2aGo3V1BzaitOTHFZWWRMekhJblZJeWNELy9ZZWtmbHFHTC9GcXZyMlBNYzdqSkU0bWcyWG1zR0laNWlZK1B2N243OVhaMmRuUFB6OC9QRDQ4WkdMd2ZzVHRsOXYzTVBnOTRnL2FFZisrdmIzOTlPbmpMU3orNWRQSDl3OFBENytoUGR2ZGpsbDJPOW5kUE4yOGZMNjcyZStmN203dVh0YlZFZGhTa3g1Ukl0ejBXMUxvUjJpRXFkVHFVWnU4VDlUcTZmUWEwT1B4eGZpNm5GNWNsRzE1WFNJcnl3dXd1dTNsVDQvM2w4dkxEN0hpd1lidGxVVk01aEc4blFNc2V5K2hXQTNEeEhrUjJmRnVGYjU4V2UxMlgzWjg5OEs4dTdsN3VudmFmVS83L21tL2Y3bHAyODh2bi9mN2ZidEg2bE54OW53NkN5SFl1TFdPQ3lmQ2NiQjJ1NDJXQzNzRWxsU2hldU9KNkkwbU9xa1VtYUloNVZXelZnckVTcndvQUM4V1pXcGJWQm9sbjE3b2FZbnlVOUp3UTF6Y1h0NS8rSEIxdFEwc0hPdzJjOXBvNXpHRURqTlcyTjkxWVljS3J6aGZRTzI2QUhuREpJYjhydTJxNFA1RWUyV1lwUll4QWoycXBrWVI3QktmZko4NEZyV2t0VzQ5VjRVWjdLd1NQZ2FMS3BZbExjcXkxQ1h5U21sbFNDK0lkS3NKQ1lKODc1WDBxVWV0azhiVUdvVHd3R3cyU2pHN1lidDhmSHk4MzhiQnR4ZjdEWWNoaEdqRGdCWndBVGp3YW5CMk11bmV6ZTJrczRDYnU5QUYwQWJHYnlYOW4yb2ZobGsxY0pYZjJ4akZyTGcyaklIeHZrbStjczQxRUVYUTQwT2hQQVFkZ1QwdjljWDQ2MjVGODduSWl5bnk4Zmg2WEY1UEYxaTcxK08vbGpxUlQ5T3BoZ2NMbi9TYUZ1dCtqVGxZYnBlWDk4dmxWVENTMnBUNkVPUEFod2dJWm1qckJqc3dLajZaenlkYkxPNzVkamtmWXNSdzNqbDJyRHhnYWZSZDdXeVVVUVU0alJIL1dxbXdjWTREcHV0R2lWZ2I2dnpuWEhuR255akowVDJyejh1UjFpbnpJbFNsUm1sMEdKVVhaZG5xRFB1djhSZ0hVWmtXMkx6bGRKcDAyVjVmNHlsU2FqekhHTU9zTWdmSmZzM2J5d2pDNE5oV0xndmdBN1p3bDlkdzRBSmppMnJuU2svaVNyaFFUVmFaZlAyN2RrUXdYdUhQc21aV1lueU9oSHZsbGVGZ0xaQUxJeXVza1NJN1ZUUENwNVQ4c1dWTUJMMUVpZ2pwR3lKamFJVGJDT2lBU21pYU5CdzViMHM5R3VHY3hueHExQThualVhTWlLaVl3WDBsdUl6Z1VuYkxVak16UmxYdHBYS1NjUm42NzNqMXRFOGVMRGQzR0daMFFTNllPckRXLzlQdWpXSHVlMFdlVmVKWFZmT21WeGxXZkZYWEF0aDVOeC9nbTdQQWhzMDF6TEVPemg2RkphV1UyZlE5NURib2pLbG1Kd2ZwbVI4c3FnRU9rdkpjVDl0cGlVVlFvdDVrbnY5NW11Z1FUVzJMalVEYzY2L2N2UUtzQ2d6bVFqYmdCeGd6bERBcTRYNE1YUmVDVzNFWFVPUVZJMmZIQ01ONG5SRWRGb25GN21UR3NPQktUTldMWVRpNE1YMlAzaE9MdXZuZEtDbmdYSzIrTmVwb1pkZUVXS3pWZWdUaFFLOVBmakNrakFJc0FoT1U4aXVKRnBUMFF0U0NFS1k0czcwcEJHb3FnNU9FWDJFVWl5aVBLVk1KOE1CaVhSVVF6bkdNemkyWG5lM0NQSVpWZDlyWmFMdG83ZHppYWVCZ1JHQk9tRm5ITmk2anpiQWNodUNxS3RnWk15cGRtRUp0bEdmWXN1TENmVFVLSS95K05lci9mR2NSZjJsSkwxTDVGcU5TcStidEZITmxxY2ZZbDJVT2plOE9OakFlTHNqN2ZGSW5aRG55K3UwSnkzMnFEeXVjdk9xVmVDSXhpZ2RiOE13aW5tTThYWjZDYnBqSE9UNDUxaUovRnhETUxFbHFUNGNkbjVlQ3MvRlhoNU1lQ0Nqbkp0ZTlGL1JWeFdDdmdyUHpiNDF5ZnpEcUNDektxVWxSSmo1MEk5RFMzd2luY1FsUWRLMHV6M09xR3hvaG4yWnpSdWU0VDlGQW41RkJmdGpiaVpSUDFETUJYeE9HekZuL0dtcmNFRTh0enFSSnZBSjBqUG56K2lOY2dOaENrZ2R0WFRjZTBkVGlwYkl4cUVKRS9GcmxucnloSHFhYXlnQTJnTlNDMDMzWHFLUExHSlFqcXVqTlNPVU5la0FtQStRYzR4YlBrR00wY3Y4NG9ickpucUNWTGFxTk94SlNtRGhNbzd4ZVFhOFFlV3BTbTZqSk5oQ0p3MjZTemdrcXVRcVdPeFFXc1BsNmgwY3NVZ2pLNW93cU1ISXN4bG9zQXllSkVHWW1nRldHUFpsaUUweFJPWnYzUnZkOW80N0FrczQwK3I5OG1QdHZFOWtWeC8rYm5wbmp1Ym4yOVFSUFpzYmpHR3F5YmpkR3dVb0ZTOVNvcUdxREZOR29paDMxQjJLcVdxcG9DRVVxQ1VxSVJCNmhxL0orUDFnZ3NMQkF0RkRlNzBlN1hmYTkzVWUzNy9mM0RHcC9DTWhIdmhsbjVpck01enkrNTF5WUtXUzhJOWtaZ2lZVEN3RVE0WWc0czUvVFdCNjhnRjEyM282RG5Xd0pwVGVuRUdYRUVhQnprejA5Nzgvdm5GeEQxdGdiUFQwOWI0eWwzbjYvQnphNUZOS3NGMjJieEwyZDIzNEF1Si9MQnJGZkg5M0dXbXNJbUtOZFhJeEVyZGswZjJmWnNoOFBPMDJwVEVwQjRsNWpDVEF6Uk12VkxOczE5cjNNVVExZ1NjQW9Jejk5ajRKVVFHS1pnSUZPc2dncmcrV2lHeEs1a0xCWEpXVTduMCtNQ0daY3FNc2hUVlowZDJiMzc3cXZ6WjZZZmNMV3pVUGQzZDJIYm1idTNlaUd6ZjZlVFduYncvZncvTjBUVnlmN0VPT1QyQ0MyNzh2UDlvaWNRY2FoTmtwcmZPRzAxb2o5eWcwYjFoWVlUYUpKcDVrWWtBZzZ4a1ZDUjlNdUs5WEUrZ1ZITllEVmJMTEdNRmlJUFkvSVkzNjlpeWdnMXlLNWVJd0hqQXMyTVhzRVEzTENXakNzY0laZENha3JkeWwxL2NUbHZZdnMrYjlXQnQ3UkxmYTlXcmwyejRXZHJ3Kzk1UkdyUnpQN0J2N1NwQS92Ry9ueTRXTE15WDBIeXJYanJCNVBqSnlhRSsxV2FEYWdrYUVETDIyZ3hJcjliRzVqV3BFb1BiSGloRXZTMDRtQkxUTTJSTDlwb2FNYXBYSEE4cWF3RE1KTFhReGtLY29RTjlrS1F4dFlMUlo3NG9rL2RvR2VFRnZaU1JEYjJEY3VaTk9RNU5ZSDQrUDNYSzNwelF0dkxXVjZNRkFlK0NVZU4vMTdTK1crcTlUVXBRdTFhWU9lZVd4ZzR2WmRCRVB2S0IrOGgxZTlNSFRoZnRvWUI0RnFRdjBCbU5HVzA5L0VBU3FCL1NZdDB4TEROTUpLRW1qQ2xDRmhWU0lCWm9HakdoNEVVc0N5dy8rWFpvdjFHN25rcmRldEVOU2hMUklXQlBKTm50cXZocUVJdGhpaTZRbzFUS014cUhkSHF6UHpXVU5zWE5mMyt3YkxnLzFhR2Y3b1NQV3BOczdkL1VPVkI5cWdzQjUvVlptZGdseGRMRitleHp0K1VhL3NqYlUxcmJUcnBqUkJqZ3duWUl6MFRUaHh0ekVDblhBVExCUEw4MkZONWhWcFBnc2MxU2l5VW80ZWdvVUFBZ2JBQVJRcUNPSnFoUlBDZFRhZWlCNmpVakV3b3VQS3J0aGt0eTI5Q0VLTTdkNG5vN1d6NyszNjI5d2Fqd3JaYk4vVzh0WStZM3dEMk9OdDJreFg2cnVWUUtuamxkRnpUOWJuRXQzbHkzOVF6dEg5OWNweFlVTmNsR1lNOUVRZ0ZubVY5R1dGVzZ4TW9rMmFLcjltMGtTNGdmVEZmdTJneXk1d1ZDT0I4aWkwQUx1YzRxNERDOEVmRUhIV3kxTEdFMUxKY2FHWEtHTUpOTFJKZm1MRm4rZDI3UGJvbHVyRkd6Tm5kdmI3UVRpMXRUeHk2ZE9lbm4rZHIxV2ZaaDMzME5CWG56bXR6UWpDUEJMODhFKy9uZTR1SC94ODE1bVB4NGYrN3NpTWE1RFptbDF5c2lycktCVDdJc3gxS1lMNmFxTU5oRlliZmlWanZZTEFNMHZKS3B3VjBaOFdPS29Cck90U2k0VllybHNYeGd6MnBwQUNSRGJ3SUo4Rm56d1lCUUg3Y1drajRxRVVzclJtRytGRW9IRVdUTFlMYW52VS8vMHIrK3IxQTlXenN6Zjc3ZWpCMW5KdDVHeDM5MkJsdEhyVXN2b3UxZytjTGhWYVM5bzV0cU5jUFk2RFMzZTVOckIvY1B5TCs4MEYvTmJxbEdTc0t2bE9hNms1bDh1dC9PM0tYTWxZbHF0ZDFyN1cyUUtVRk54K1FQNVBFa3ZVa2hXdHVWd3J2TGZBVVExZ1BZcWx5VW9XODVLWVlhZFZXTzliRnBpQ0xyOHdQTHc5c0JCVU1jSVNYcS9McDJUZWVpNXFPQWpsRjRPM1dFeEc3VmJXQzhJckh3eU5WbmJ2dEpNQyt4Lzh6ZUkvQWJ2MFc5R2grcEVaek5ub1UwOEErelFSd3g1ZTRUVG52ZzVHaFEvT01LQ0JBcVBDQzdsaC9CZmQxOVlPOTBxdklNT2U3Nk1JVEFFQmNObGc5NHFjdUtUNUJVYzFna1VNZ3hEQ2t3ZG9YTERrVzEweExxTGErNzFWdm9Xbm9TaVdiUVY1aUZOb2NTbVFaTThBRlROSEorYm1aUHVhS05tNVoyZExIbVBJL0dEOTRONmt3STRjV3gxRjBTZTE2bEVNWTZlSHRsenJ3MUNkY3U4Z2pZOUIwNURHajVRTWYybW5HU2JUNC8rUUZXdTlYUGYyNWxhdHgyMUZpQ25VU2hNNTJzTzhwS1dBdi9GeVJ6V3EyUlFtWVZIZitMZ3VaL2NrZmtIaUlxSytIL2k5QlJNbnNJZGxCU2hmOElVWlgzdldZbkVBTE4rSnZPajdFVzFlTkQwOVprWEowUDVIYmVKV3NnallyUTg2K3Z1ajAwZXExenM2b2c4cjlmMTdrc1RxVjdNVG85TktzeGFCRW9aNEFrbzdHNXZ4NHRCVytlWWtqQkk1WHU1S1JOdVVOdmhBOFVsQm9wbFo1Q2t0d0M4NnFnRnNURUlVV0M0SG04QUNKQStMUE03NlJoR2V1TDVoMTJQWjZMRm04bnl5WGJ4RHJwU1JWbVNKbnpMYjEyNVlabDBiT0RYNWRqRTVkWFdpY2ppSzV0QjY1cUxWSGRITWtlcWRZdFFSM1JvYVB6V1d5VXc5UERjMDhrQXI5WXVMNVIyUE5MTXJ4MW1OeVVCQnZKamxIT3NZd0txMk5tV01NaXFiZFNTeUdrcmt1b2FKWFlxMStPV09hZ0FMbDZFYzJFWGhzeGRQVGliTCtLWUJab0xRNzBKZWhwdUlKSW1KMlJqODIwWmpoNys5ZDMwdXNCWkJzVXV0cTc3N3N4L2F5ZE8xZzd1djd2cjBvL09Wa3gzOWV5NGhXUy90eWMrOXMyOUw1Y2F1cWFpWWZIeGc1TlNaWGMvT1R3eSthV2YwMkRPVTd1ZlhGVGpWa2liQWF6YWlNNGJ4WVlJTGhCQjNuRFpneTBFeEs5TXd1T0Y4eG43MWNrYzFTbU5HS3dRblN4QzdxSXRsRUE3eitXSTdEbmFJbVZWTTJzVmlaMUdPUU8waXc0RVhFOHY3ZU5zM2J5N2hIZFp2ejdiK0tlcEkzaGsvZWVYUDU4NE9UaC91Nk84NE00aHhjWEJ2TkhaN29qNDBmbUlxYWw4ZGZYaHJZSEQvam8vM0pwRUxkUFBjZ2ZLV2tXZUFnTFpvekE3QUJxWkY1QXFOUzVUQlloaUJITmc2em1VbmpSTGRpQUl0L1pjdjg5dHgwL2ppK052OEJoQ3NnWUFad0FQanhzaEZDbDQ1Nm9hTmRzMkZMZlYzczhwRnRMZVd1dlZGbGFvYlZYbUJYa1o1cXZaUitqbVF1NjQ5OW80UmE1ODUzKzhjenA4endIdUpxSXNsM2tLTWtUOFFobDNiZGRXK1BYWXV2dWdvdFUyMzNTL2JZOXNkSmNUZ3hLU2FoUmMwQUM3K1lIanV6V0lwWlQySEJmdjl2dUlYVzdDNjVhTHR3clo2Zk95TzFUTGN5dDM5dm5NWDNvbThPYzhJbnJlcjF4c3ErbDBhVUwyaXJhUUZWMnJPQTBXV3IyWVJhdVgwSE9tbU9SSWRaWGdlRnl3dVJ1N2IyeGVKdWdBVzl5bHhrNjFzdC90d3o4Q25iUGNBNVc1YmdYL2I3U1dhTG5tN1FKVzNMS2pqT0RYeFExTnNycTJpd0pmY0F6NmdyZVAzaitGOTZTWnR0ZThXaTNaYlZkdXUyNFo1MXk2KzZTekJtMkoxdHU5WGR2ZWNYcjBLUEl5VEFtWUdpMjhqTmJ0WDBrSlRVVVo5ekhKU0tJT2IyWEh3L1dPT1ErcGt6aEIxcVZQaExrNkZLc2tMYmpEWHY5MDJQSlpIVjNXVlM5eHR4L3pSbWVwMHlZaDFLUmVaOUtEZ05tVkYzTmpHK3FiTWpTSHFodU5YK2VtKzRwTG81WlN6MGkwSjRoMW1qaXNydjUwMnA5TW1BTzJPenZwQSt3Szk2YUZTdE15OEg4RW1GV1drR1dSK1UrdUVZbVRTQXdVcjVISXYyNUJPMUM4VGRRbXMwaEpqbHptS3VOM1J2VUUwNjJEWTB5WXVtU2VvdVpMSlJRV2xZN3hsNHpkTllCcmYwS0hEeVdrUEVqajh3VlJ5cUpOeG96NjdycVJqTjJpOGRMTThUMDZuay8weTJFMXd1NnVIcHo1OVRRT1o3aHJhMG9XUkRtcUd4WTVsVmFuRTJhTUhpUWo3NlV4RVZtU3A0TmQxZjVhb0MyRHZ0WG9UVm82UzN0b1NZVGtiNG1pVVd5eFljR0swZEtTSVpVckFPOVo0T0Nuak4yc1Q0NTVNd0tUNG1USzZxakI0VitYaGdzZGlHUzZYMVdPRkNNUWpSdktWWUdPL2ZMenJoOVd3MncxOVRXNzdDckJTcjgwU09oMFVMWW5PSE94MVdndlVERkJIVTI4SVdjQjNrcE05OVBabG9qNWZBR3NLRHFpZ0QySGJ4MWJra1NKUTF5b0hmS0tleEZ5VmdKRDRBMGhnTTZUNUZlTWIrR3Q4KzJETmJQN3UvMU1oeE9QcmxUZk9zZ0o0NldUQ0hmVmpTSzBQbXNLdmg5OCtmcmg3N3Z0RDMrL292ZUZTSVl1T3l0US9TQlRoeEVrMGFrZEFabE9kK2ZkU0JEazh0amRjNnRsbU5ZeEVCZjhseXIwQWxxaEs5eVdzY3RGb1NvRVgyUWhReHRRL1ZxS0JGK044ZWNtNG9zV3A0alZnMDNvZHgrYXZqU25veGIwTCtXNTBBMStKRVVGS1RIOTAza1lEbzloc2J1M3UvVCsvY3BMYkh3N1BUOWYxb2QvVnFlQ1Y3b29aVTNrVW5tZGlTWk1MbGlNbVBKUjhvaFluY0RrUFhsQVBkWDJHcU93aTJOZ2p1THBzbzZSaEl6REpMV1M1ZXo3R1VCY1lnbnFENGZvUGE4RUlQaHhEMEFRem9qMHV5aXZXOFMvUEJiL0paek5Yd1VwQnAwZ1hzdmhJMUtnV1dic2Roc1A3dS9lWWNiMGFuZzcxZFgrOVNtdWlpQzlvZWNjc3BxVTV5Y2pRbjNZaHFzem5rTWliK3o5UTRCa2MrWENXcU10SkJUcFJEZ0JNMXVNeDBickVqSGw3RXREV3NUR3BOVEd2NWxURUVyWkJiYVNpNHFWbHc3L1MyVXVhNS8vZEJWZHExbkJqRElnSlpSblN2RmpCWXdCVmhnQlI5OWJ1RG9mVkxyVlA3RzY5V3QzaVoxSi81WlB6SnNndVVQNktyWlZkVmN5VXFFaFY2TVVNWUdEVFo5MWRJT3B5azV3MmxQYStZcmQ4TUkybHV4YWtjZndkVnhGZmFSalJRb0JtWWVGSHNYWU8reG90Q0l2a0Z6Ly85Q2w0NDVDTmlSdWxnMlZnV29zQ3NVRWxPMVluYksrVjBteDFhOW5kNi9UV0J5dzFxUTFpMFJhK0N4S0tlU1NncHZNRytBWXdCM25zc1NlVHd0Q0d3M21pTGg1czVRdjlWWjVHQUV3dUh6MkxJdmJOT20xaVRCUjl4MlNVS0E5QTV1bnhjQUJMbUI4YjhXK0o4cDVuUHY3K2FUUHFTRU4yWkRyZXhPbURUUjlRcVNIWHNlbXE1dkNES3c0SE9KcmxDckR3WUkxSERoK3d4dVFTSWs2blJieUQrRVMyZFJyUmRJVXhXbnVlcUF0Z0Vhb0xrY0YzUVh1dk04M2VyWnNHN1Jvek9sK0VZOXNlU3dsQ1FuZkVXYUlYWlhJamNtUUFOcEkyMGNPSEQ2a24vTk9CbzJMeGJlM2JQeEZrL2JWTi94Q3d1NVZnbFUzbVpCcXNBT1cvSEYzUk5aUEV2a0JqcEk1VjNCaHY1OU9Kb2xBS1dqWWppZDVLTW55ZXFIL2J0Mk1DQUFBQWdHRDlXd3N5RWZ6MkJ5WEVhdStpZEtWU3Z6RjFra3RHd05JZmxPdWh4QlpsOFNobEtmblpBSjdDWk1MdEVGdEJBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3d3Jvb3QvaW1hZ2VzL1Nob3BfTWVudUhlYWRlci5wbmdcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2lkZW1lbnUuY29tcG9uZW50LmNzc1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9DbGllbnRBcHAvYXBwL2NvbXBvbmVudHMvc2hvcC9zaWRlbWVudS5jb21wb25lbnQuY3NzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubWFpbkRpdiB7XFxuICAgIHRleHQtYWxpZ246Y2VudGVyOyBcXG4gICAgd2lkdGg6MTAwJTtcXG59XFxuXFxuLm1lbnVIZWFkZXIge1xcbiAgICBwYWRkaW5nLXRvcDo1cHg7XFxufVxcblxcbi5tYWluTGlua3NEaXYge1xcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjsgXFxuICAgIG1heC13aWR0aDoyMjVweDsgXFxuICAgIG1hcmdpbjogMCBhdXRvO1xcbn1cXG5cXG4uZG90dGVkTGluZUNsYXNzIHtcXG4gICAgbWFyZ2luOjEwcHggMHB4IDEwcHggMTBweDtcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL0NsaWVudEFwcC9hcHAvY29tcG9uZW50cy9zaG9wL3NpZGVtZW51LmNvbXBvbmVudC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9